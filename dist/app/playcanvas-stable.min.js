/*

 PlayCanvas Engine v1.35.1 revision 3317bcf
 Copyright 2011-2020 PlayCanvas Ltd. All rights reserved.
*/
(function(m, Zc) {
    "object" === typeof exports && "undefined" !== typeof module ? Zc(exports) : "function" === typeof define && define.amd ? define(["exports"], Zc) : (m = "undefined" !== typeof globalThis ? globalThis : m || self,
    Zc(m.pc = {}))
}
)(this, function(m) {
    function Zc(a) {
        if (null === a)
            return "null";
        var b = typeof a;
        return "undefined" === b || "number" === b || "string" === b || "boolean" === b ? b : tn[Object.prototype.toString.call(a)]
    }
    function Gc(a, b) {
        var c;
        for (c in b) {
            var d = b[c];
            "object" == Zc(d) ? a[c] = Gc({}, d) : "array" == Zc(d) ? a[c] = Gc([], d) : a[c] = d
        }
        return a
    }
    function Xh(a) {
        return void 0 !== a
    }
    function M() {
        this._callbacks = {};
        this._callbackActive = {}
    }
    function Yh(a, b) {
        var c = a.length;
        b = b || 0;
        if (0 > b || b >= c)
            return null;
        var d = a.charCodeAt(b);
        return 1 < c && 55296 <= d && 56319 >= d && (a = a.charCodeAt(b + 1),
        56320 <= a && 57343 >= a) ? {
            code: 1024 * (d - 55296) + a - 56320 + 65536,
            long: !0
        } : {
            code: d,
            long: !1
        }
    }
    function $c(a, b, c) {
        return a ? (a = Yh(a)) ? (a = a.code,
        a >= b && a <= c) : !1 : !1
    }
    function L(a, b, c, d) {
        var e = a && a.length;
        3 === e || 4 === e ? (this.r = a[0],
        this.g = a[1],
        this.b = a[2],
        this.a = void 0 !== a[3] ? a[3] : 1) : (this.r = a || 0,
        this.g = b || 0,
        this.b = c || 0,
        this.a = void 0 !== d ? d : 1)
    }
    function Zh() {
        this._list = [];
        this._index = {}
    }
    function uk(a) {
        this._index = {};
        this._key = a || null
    }
    function ad(a) {
        M.call(this);
        this._index = {};
        this._list = [];
        this._parent = a
    }
    function $h() {
        this._isRunning = !1;
        this._b = this._a = 0
    }
    function qg(a) {
        a = a.match(/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/);
        this.scheme = a[2];
        this.authority = a[4];
        this.path = a[5];
        this.query = a[7];
        this.fragment = a[9];
        this.toString = function() {
            var b = "";
            this.scheme && (b += this.scheme + ":");
            this.authority && (b += "//" + this.authority);
            b += this.path;
            this.query && (b += "?" + this.query);
            this.fragment && (b += "#" + this.fragment);
            return b
        }
        ;
        this.getQuery = function() {
            var b, c = {};
            if (this.query) {
                var d = decodeURIComponent(this.query).split("&");
                d.forEach(function(e, f, g) {
                    b = e.split("=");
                    c[b[0]] = b[1]
                }, this)
            }
            return c
        }
        ;
        this.setQuery = function(b) {
            var c = "", d;
            for (d in b)
                b.hasOwnProperty(d) && ("" !== c && (c += "&"),
                c += encodeURIComponent(d) + "=" + encodeURIComponent(b[d]));
            this.query = c
        }
    }
    function da() {}
    function ai(a, b) {
        this._curve = a;
        this._left = -Infinity;
        this._right = Infinity;
        this._m1 = this._m0 = this._p1 = this._p0 = this._recip = 0;
        this._reset(b || 0)
    }
    function gb(a) {
        this.keys = [];
        this.type = 1;
        this.tension = .5;
        this._eval = new ai(this);
        if (a)
            for (var b = 0; b < a.length - 1; b += 2)
                this.keys.push([a[b], a[b + 1]]);
        this.sort()
    }
    function Cb() {
        var a;
        this.curves = [];
        this._type = 1;
        if (1 < arguments.length)
            for (a = 0; a < arguments.length; a++)
                this.curves.push(new gb(arguments[a]));
        else if (0 === arguments.length)
            this.curves.push(new gb);
        else {
            var b = arguments[0];
            if ("number" === typeof b)
                for (a = 0; a < b; a++)
                    this.curves.push(new gb);
            else
                for (a = 0; a < b.length; a++)
                    this.curves.push(new gb(b[a]))
        }
    }
    function xb() {
        var a = new Float32Array(9);
        a[0] = a[4] = a[8] = 1;
        this.data = a
    }
    function P(a, b) {
        a && 2 === a.length ? (this.x = a[0],
        this.y = a[1]) : (this.x = a || 0,
        this.y = b || 0)
    }
    function z(a, b, c) {
        a && 3 === a.length ? (this.x = a[0],
        this.y = a[1],
        this.z = a[2]) : (this.x = a || 0,
        this.y = b || 0,
        this.z = c || 0)
    }
    function X(a, b, c, d) {
        a && 4 === a.length ? (this.x = a[0],
        this.y = a[1],
        this.z = a[2],
        this.w = a[3]) : (this.x = a || 0,
        this.y = b || 0,
        this.z = c || 0,
        this.w = d || 0)
    }
    function K() {
        var a = new Float32Array(16);
        a[0] = a[5] = a[10] = a[15] = 1;
        this.data = a
    }
    function Y(a, b, c, d) {
        a && 4 === a.length ? (this.x = a[0],
        this.y = a[1],
        this.z = a[2],
        this.w = a[3]) : (this.x = void 0 === a ? 0 : a,
        this.y = void 0 === b ? 0 : b,
        this.z = void 0 === c ? 0 : c,
        this.w = void 0 === d ? 1 : d)
    }
    function oa(a, b) {
        this.center = a || new z(0,0,0);
        this.halfExtents = b || new z(.5,.5,.5);
        this._min = new z;
        this._max = new z
    }
    function Cd(a, b) {
        this.center = a || new z(0,0,0);
        this.radius = void 0 === b ? .5 : b
    }
    function rg() {
        this.planes = [];
        for (var a = 0; 6 > a; a++)
            this.planes[a] = []
    }
    function bd(a, b) {
        this.origin = a || new z(0,0,0);
        this.direction = b || new z(0,0,-1)
    }
    function bi(a, b) {
        this.halfExtents = b || new z(.5,.5,.5);
        a = a || vk.setIdentity();
        this._modelTransform = a.clone().invert();
        this._worldTransform = a.clone();
        this._aabb = new oa(new z,this.halfExtents)
    }
    function ci(a, b) {
        this.normal = b || new z(0,0,1);
        this.point = a || new z(0,0,0)
    }
    function ab(a, b, c, d, e) {
        this.usage = d || 0;
        this.format = b;
        this.numVertices = c;
        this.id = un++;
        this.numBytes = b.verticesByteSize ? b.verticesByteSize : b.size * c;
        a._vram.vb += this.numBytes;
        this.device = a;
        e ? this.setData(e) : this.storage = new ArrayBuffer(this.numBytes);
        this.device.buffers.push(this)
    }
    function qe(a) {
        for (var b = 0, c = 0, d = a.length; c < d; c++)
            b = (b << 5) - b + a.charCodeAt(c),
            b |= 0;
        return b
    }
    function Na(a, b, c) {
        var d;
        this.elements = [];
        this.hasTangents = this.hasColor = this.hasUv1 = this.hasUv0 = !1;
        this._defaultInstancingFormat = null;
        this.verticesByteSize = 0;
        this.vertexCount = c;
        this.interleaved = !c;
        this.size = b.reduce(function(h, l) {
            return h + 4 * Math.ceil(l.components * qf[l.type] / 4)
        }, 0);
        var e = 0;
        a = 0;
        for (d = b.length; a < d; a++) {
            var f = b[a];
            var g = f.components * qf[f.type];
            c && (e = N.roundUp(e, g));
            var k = {
                name: f.semantic,
                offset: c ? e : f.hasOwnProperty("offset") ? f.offset : e,
                stride: c ? g : f.hasOwnProperty("stride") ? f.stride : this.size,
                dataType: f.type,
                numComponents: f.components,
                normalize: void 0 === f.normalize ? !1 : f.normalize,
                size: g
            };
            this.elements.push(k);
            e = c ? e + g * c : e + 4 * Math.ceil(g / 4);
            "TEXCOORD0" === f.semantic ? this.hasUv0 = !0 : "TEXCOORD1" === f.semantic ? this.hasUv1 = !0 : "COLOR" === f.semantic ? this.hasColor = !0 : "TANGENT" === f.semantic && (this.hasTangents = !0)
        }
        c && (this.verticesByteSize = e);
        this.update()
    }
    function rf(a, b, c) {
        this.index = 0;
        this.numComponents = b.numComponents;
        this.array = c.interleaved ? new Dd[b.dataType](a,b.offset) : new Dd[b.dataType](a,b.offset,c.vertexCount * b.numComponents);
        this.stride = b.stride / this.array.constructor.BYTES_PER_ELEMENT;
        switch (b.numComponents) {
        case 1:
            this.set = vn;
            this.getToArray = wn;
            this.setFromArray = xn;
            break;
        case 2:
            this.set = yn;
            this.getToArray = zn;
            this.setFromArray = An;
            break;
        case 3:
            this.set = Bn;
            this.getToArray = Cn;
            this.setFromArray = Dn;
            break;
        case 4:
            this.set = En,
            this.getToArray = Fn,
            this.setFromArray = Gn
        }
    }
    function vn(a) {
        this.array[this.index] = a
    }
    function yn(a, b) {
        this.array[this.index] = a;
        this.array[this.index + 1] = b
    }
    function Bn(a, b, c) {
        this.array[this.index] = a;
        this.array[this.index + 1] = b;
        this.array[this.index + 2] = c
    }
    function En(a, b, c, d) {
        this.array[this.index] = a;
        this.array[this.index + 1] = b;
        this.array[this.index + 2] = c;
        this.array[this.index + 3] = d
    }
    function xn(a, b, c) {
        this.array[a] = b[c]
    }
    function An(a, b, c) {
        this.array[a] = b[c];
        this.array[a + 1] = b[c + 1]
    }
    function Dn(a, b, c) {
        this.array[a] = b[c];
        this.array[a + 1] = b[c + 1];
        this.array[a + 2] = b[c + 2]
    }
    function Gn(a, b, c) {
        this.array[a] = b[c];
        this.array[a + 1] = b[c + 1];
        this.array[a + 2] = b[c + 2];
        this.array[a + 3] = b[c + 3]
    }
    function wn(a, b, c) {
        b[c] = this.array[a]
    }
    function zn(a, b, c) {
        b[c] = this.array[a];
        b[c + 1] = this.array[a + 1]
    }
    function Cn(a, b, c) {
        b[c] = this.array[a];
        b[c + 1] = this.array[a + 1];
        b[c + 2] = this.array[a + 2]
    }
    function Fn(a, b, c) {
        b[c] = this.array[a];
        b[c + 1] = this.array[a + 1];
        b[c + 2] = this.array[a + 2];
        b[c + 3] = this.array[a + 3]
    }
    function Pb(a) {
        this.vertexBuffer = a;
        this.vertexFormatSize = a.getFormat().size;
        this.buffer = this.vertexBuffer.lock();
        this.accessors = [];
        this.element = {};
        a = this.vertexBuffer.getFormat();
        for (var b = 0; b < a.elements.length; b++) {
            var c = a.elements[b];
            this.accessors[b] = new rf(this.buffer,c,a);
            this.element[c.name] = this.accessors[b]
        }
    }
    function La(a, b, c, d, e, f) {
        if (null === Ed) {
            var g = new Na(a,[{
                semantic: "POSITION",
                components: 2,
                type: 6
            }]);
            Ed = new ab(a,g,4);
            g = new Pb(Ed);
            g.element.POSITION.set(-1, -1);
            g.next();
            g.element.POSITION.set(1, -1);
            g.next();
            g.element.POSITION.set(-1, 1);
            g.next();
            g.element.POSITION.set(1, 1);
            g.end()
        }
        g = a.renderTarget;
        a.setRenderTarget(b);
        a.updateBegin();
        if (d) {
            var k = d.x;
            var h = d.y;
            var l = d.z;
            var n = d.w
        } else
            l = b ? b.width : a.width,
            n = b ? b.height : a.height,
            h = k = 0;
        if (e) {
            var p = e.x;
            var q = e.y;
            var r = e.z;
            var t = e.w
        } else
            p = k,
            q = h,
            r = l,
            t = n;
        e = a.vx;
        d = a.vy;
        b = a.vw;
        var u = a.vh;
        a.setViewport(k, h, l, n);
        l = a.sx;
        k = a.sy;
        h = a.sw;
        n = a.sh;
        a.setScissor(p, q, r, t);
        p = a.getDepthTest();
        q = a.getDepthWrite();
        r = a.getCullMode();
        t = a.writeRed;
        var x = a.writeGreen
          , v = a.writeBlue
          , w = a.writeAlpha;
        a.setDepthTest(!1);
        a.setDepthWrite(!1);
        a.setCullMode(0);
        a.setColorWrite(!0, !0, !0, !0);
        f || a.setBlending(!1);
        a.setVertexBuffer(Ed, 0);
        a.setShader(c);
        a.draw(Hn);
        a.setDepthTest(p);
        a.setDepthWrite(q);
        a.setCullMode(r);
        a.setColorWrite(t, x, v, w);
        a.updateEnd();
        a.setRenderTarget(g);
        a.updateBegin();
        a.setViewport(e, d, b, u);
        a.setScissor(l, k, h, n)
    }
    function re(a, b) {
        this.device = a;
        this.definition = b;
        this.attributes = [];
        this.uniforms = [];
        this.samplers = [];
        this.failed = this.ready = !1;
        this.device.createShader(this)
    }
    function sg(a, b) {
        b || (b = F);
        return 1 === a || 2 === a ? b.gamma2_2PS ? b.gamma2_2PS : F.gamma2_2PS : 3 === a ? "#define HDR\n" + (b.gamma2_2PS ? b.gamma2_2PS : F.gamma2_2PS) : b.gamma1_0PS ? b.gamma1_0PS : F.gamma1_0PS
    }
    function tg(a, b) {
        b || (b = F);
        return 1 === a ? b.tonemappingFilmicPS ? b.tonemappingFilmicPS : F.tonemappingFilmicPS : 0 === a ? b.tonemappingLinearPS ? b.tonemappingLinearPS : F.tonemappingLinearPS : 2 === a ? b.tonemappingHejlPS ? b.tonemappingHejlPS : F.tonemappingHejlPS : 3 === a ? b.tonemappingAcesPS ? b.tonemappingAcesPS : F.tonemappingAcesPS : 4 === a ? b.tonemappingAces2PS ? b.tonemappingAces2PS : F.tonemappingAces2PS : b.tonemapingNonePS ? b.tonemapingNonePS : F.tonemappingNonePS
    }
    function di(a, b) {
        b || (b = F);
        return "linear" === a ? b.fogLinearPS ? b.fogLinearPS : F.fogLinearPS : "exp" === a ? b.fogExpPS ? b.fogExpPS : F.fogExpPS : "exp2" === a ? b.fogExp2PS ? b.fogExp2PS : F.fogExp2PS : b.fogNonePS ? b.fogNonePS : F.fogNonePS
    }
    function ei(a, b) {
        b || (b = F);
        return a.supportsBoneTextures ? b.skinTexVS : "#define BONE_LIMIT " + a.getBoneLimit() + "\n" + b.skinConstVS
    }
    function Fd(a) {
        var b = "precision " + a.precision + " float;\n";
        a.webgl2 && (b += "#ifdef GL2\nprecision " + a.precision + " sampler2DShadow;\n#endif\n");
        return b
    }
    function Gd(a) {
        return a.webgl2 ? "#version 300 es\n" : ""
    }
    function wk() {
        return "void main(void) {gl_FragColor = vec4(0.0);}"
    }
    function se() {
        return "void main(void)\n{\n"
    }
    function ug(a) {
        for (var b = {}, c = 0, d = a.indexOf("attribute"); 0 <= d && !(0 < d && "/" === a[d - 1]); ) {
            var e = a.indexOf(";", d)
              , f = a.lastIndexOf(" ", e);
            e = a.substr(f + 1, e - (f + 1));
            f = In[e];
            void 0 !== f ? b[e] = f : (b[e] = "ATTR" + c,
            c++);
            d = a.indexOf("attribute", d + 1)
        }
        return b
    }
    function Wa(a, b, c, d, e, f) {
        var g = a.programLib._cache
          , k = g[d];
        if (void 0 !== k)
            return k;
        c = Fd(a) + "\n" + (c || wk());
        k = ug(b);
        a.webgl2 && (b = Gd(a) + F.gles3VS + b,
        c = Gd(a) + F.gles3PS + c);
        g[d] = new re(a,{
            attributes: k,
            vshader: b,
            fshader: (f ? f : "") + c,
            useTransformFeedback: e
        });
        return g[d]
    }
    function V(a, b) {
        this.device = a;
        this.name = null;
        this._height = this._width = 4;
        this._depth = 1;
        this._format = 7;
        this.type = "default";
        this.fixCubemapSeams = this._volume = this._cubemap = !1;
        this._flipY = !0;
        this._premultiplyAlpha = !1;
        this._mipmaps = !0;
        this._minFilter = 5;
        this._anisotropy = this._magFilter = 1;
        this._addressW = this._addressV = this._addressU = 0;
        this._compareOnRead = !1;
        this._compareFunc = 1;
        void 0 !== b && (void 0 !== b.name && (this.name = b.name),
        this._width = void 0 !== b.width ? b.width : this._width,
        this._height = void 0 !== b.height ? b.height : this._height,
        this._format = void 0 !== b.format ? b.format : this._format,
        b.hasOwnProperty("type") ? this.type = b.type : b.hasOwnProperty("rgbm") ? this.type = b.rgbm ? "rgbm" : "default" : b.hasOwnProperty("swizzleGGGR") && (this.type = b.swizzleGGGR ? "swizzleGGGR" : "default"),
        this._mipmaps = void 0 !== b.mipmaps ? b.mipmaps : void 0 !== b.autoMipmap ? b.autoMipmap : this._mipmaps,
        this._levels = b.levels,
        this._cubemap = void 0 !== b.cubemap ? b.cubemap : this._cubemap,
        this.fixCubemapSeams = void 0 !== b.fixCubemapSeams ? b.fixCubemapSeams : this.fixCubemapSeams,
        this._minFilter = void 0 !== b.minFilter ? b.minFilter : this._minFilter,
        this._magFilter = void 0 !== b.magFilter ? b.magFilter : this._magFilter,
        this._anisotropy = void 0 !== b.anisotropy ? b.anisotropy : this._anisotropy,
        this._addressU = void 0 !== b.addressU ? b.addressU : this._addressU,
        this._addressV = void 0 !== b.addressV ? b.addressV : this._addressV,
        this._compareOnRead = void 0 !== b.compareOnRead ? b.compareOnRead : this._compareOnRead,
        this._compareFunc = void 0 !== b._compareFunc ? b._compareFunc : this._compareFunc,
        this._flipY = void 0 !== b.flipY ? b.flipY : this._flipY,
        this._premultiplyAlpha = void 0 !== b.premultiplyAlpha ? b.premultiplyAlpha : this._premultiplyAlpha,
        a.webgl2 && (this._depth = void 0 !== b.depth ? b.depth : this._depth,
        this._volume = void 0 !== b.volume ? b.volume : this._volume,
        this._addressW = void 0 !== b.addressW ? b.addressW : this._addressW));
        this._compressed = 8 === this._format || 9 === this._format || 10 === this._format || 21 <= this._format;
        this._invalid = !1;
        this._lockedLevel = -1;
        this._levels || (this._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null]);
        this.dirtyAll();
        this._gpuSize = 0
    }
    function dc(a, b, c, d, e) {
        this.usage = d || 0;
        this.format = b;
        this.numIndices = c;
        this.device = a;
        c = this.device.gl;
        if (0 === b) {
            var f = 1;
            this.glFormat = c.UNSIGNED_BYTE
        } else
            1 === b ? (f = 2,
            this.glFormat = c.UNSIGNED_SHORT) : 2 === b && (f = 4,
            this.glFormat = c.UNSIGNED_INT);
        this.bytesPerIndex = f;
        this.numBytes = this.numIndices * f;
        e ? this.setData(e) : this.storage = new ArrayBuffer(this.numBytes);
        a._vram.ib += this.numBytes;
        this.device.buffers.push(this)
    }
    function cd() {
        this.initDefaults()
    }
    function Jn(a, b, c, d) {
        this.data = a;
        this.componentCount = b;
        this.dataType = c;
        this.dataTypeNormalize = d
    }
    function rb(a) {
        this._refCount = 0;
        this.id = Kn++;
        this.device = a || ea.getApplication().graphicsDevice;
        this.vertexBuffer = null;
        this.indexBuffer = [null];
        this.primitive = [{
            type: 0,
            base: 0,
            count: 0
        }];
        this._geometryData = this.morph = this.skin = null;
        this._aabb = new oa;
        this.boneAabb = null
    }
    function va(a, b, c) {
        this._key = [0, 0];
        this._shader = [null, null, null];
        this.isStatic = !1;
        this._staticSource = this._staticLightList = null;
        this.node = a;
        this._mesh = b;
        b.incReference();
        this.material = c;
        this._shaderDefs = 65536;
        this._shaderDefs |= b.vertexBuffer.format.hasUv0 ? 4 : 0;
        this._shaderDefs |= b.vertexBuffer.format.hasUv1 ? 8 : 0;
        this._shaderDefs |= b.vertexBuffer.format.hasColor ? 16 : 0;
        this._shaderDefs |= b.vertexBuffer.format.hasTangents ? 512 : 0;
        this._lightHash = 0;
        this.visible = !0;
        this.layer = 15;
        this.renderStyle = 0;
        this.castShadow = !1;
        this._receiveShadow = !0;
        this._noDepthDrawGl1 = this._screenSpace = !1;
        this._updateAabb = this.pick = this.cull = !0;
        this._calculateSortDistance = this._updateAabbFunc = null;
        this.updateKey();
        this.instancingData = this._morphInstance = this._skinInstance = null;
        this.aabb = new oa;
        this._aabbVer = -1;
        this.visibleThisFrame = this.drawOrder = 0;
        this.isVisibleFunc = null;
        this.parameters = {};
        this.stencilBack = this.stencilFront = null;
        this.flipFaces = !1
    }
    function vg(a, b, c) {
        this._key = [];
        this._key[0] = (a & 15) << 27 | (3 === b ? 1 : 0) << 26 | 33554432;
        this.command = c
    }
    function Ln(a) {
        this.count = a;
        this.vertexBuffer = null
    }
    function Db(a, b) {
        this.device = b || ea.getApplication().graphicsDevice;
        this._targets = a;
        this.device.supportsMorphTargetTexturesCore && (this.device.extTextureHalfFloat && this.device.textureHalfFloatRenderable ? this._renderTextureFormat = Db.FORMAT_HALF_FLOAT : this.device.extTextureFloat && this.device.textureFloatRenderable && (this._renderTextureFormat = Db.FORMAT_FLOAT),
        this.device.extTextureHalfFloat && this.device.textureHalfFloatUpdatable ? this._textureFormat = Db.FORMAT_HALF_FLOAT : this.device.extTextureFloat && (this._textureFormat = Db.FORMAT_FLOAT),
        void 0 !== this._renderTextureFormat && void 0 !== this._textureFormat && (this._useTextureMorph = !0));
        this._init();
        this._updateMorphFlags();
        this._calculateAabb()
    }
    function sf(a) {
        this.morph = a;
        this.device = a.device;
        this.meshInstance = null;
        this._weights = [];
        for (var b = 0; b < a._targets.length; b++)
            this.setWeight(b, a._targets[b].defaultWeight);
        this._activeTargets = [];
        if (a.useTextureMorph) {
            this.shaderCache = {};
            this.maxSubmitCount = this.device.maxTextures;
            this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);
            b = function(c, d) {
                this[d] = a._createTexture(c, a._renderTextureFormat === Db.FORMAT_FLOAT ? 14 : 12);
                return new ra({
                    colorBuffer: this[d],
                    depth: !1
                })
            }
            .bind(this);
            a.morphPositions && (this.rtPositions = b("MorphRTPos", "texturePositions"));
            a.morphNormals && (this.rtNormals = b("MorphRTNrm", "textureNormals"));
            this._textureParams = new Float32Array([a.morphTextureWidth, a.morphTextureHeight, 1 / a.morphTextureWidth, 1 / a.morphTextureHeight]);
            for (b = 0; b < this.maxSubmitCount; b++)
                this["morphBlendTex" + b] = this.device.scope.resolve("morphBlendTex" + b);
            this.morphFactor = this.device.scope.resolve("morphFactor[0]");
            this.zeroTextures = !1
        } else
            this.maxSubmitCount = 8,
            this._shaderMorphWeights = new Float32Array(this.maxSubmitCount),
            this._shaderMorphWeightsA = new Float32Array(this._shaderMorphWeights.buffer,0,4),
            this._shaderMorphWeightsB = new Float32Array(this._shaderMorphWeights.buffer,16,4),
            this._activeVertexBuffers = Array(this.maxSubmitCount)
    }
    function Hc(a) {
        this._dirty = !0;
        a && this.initSkin(a)
    }
    function sb() {
        this.graph = null;
        this.meshInstances = [];
        this.skinInstances = [];
        this.morphInstances = [];
        this.cameras = [];
        this.lights = [];
        this._shadersVersion = 0;
        this._immutable = !1
    }
    function fi(a, b, c) {
        this.origMeshInstances = a;
        this._aabb = new oa;
        this.model = this.meshInstance = null;
        this.dynamic = b;
        this.batchGroupId = c;
        this.refCounter = 0
    }
    function bb(a, b, c, d, e) {
        this.dynamic = c;
        this.maxAabbSize = d;
        this.id = a;
        this.name = b;
        this.layers = void 0 === e ? [0] : e;
        this._sprite = this._ui = !1;
        this._obj = {
            model: [],
            element: [],
            sprite: []
        }
    }
    function Hd(a, b, c) {
        Hc.call(this);
        Hc.prototype.init.call(this, a, b.length);
        this.device = a;
        this.rootNode = c;
        this.bones = b
    }
    function Ia(a, b, c) {
        this.device = a;
        this.rootNode = b;
        this.scene = c;
        this._init = !1;
        this._batchGroups = {};
        this._batchGroupCounter = 0;
        this._batchList = [];
        this._dirtyGroups = []
    }
    function xk(a, b) {
        if (a && !b || !a && b)
            return !1;
        a = a.data;
        b = b.data;
        if (a === b)
            return !0;
        if (a instanceof Float32Array && b instanceof Float32Array) {
            if (a.length !== b.length)
                return !1;
            for (var c = 0; c < a.length; c++)
                if (a[c] !== b[c])
                    return !1;
            return !0
        }
        return !1
    }
    function Mn(a, b) {
        for (var c in a)
            if (a.hasOwnProperty(c) && !xk(a[c], b[c]))
                return !1;
        for (c in b)
            if (b.hasOwnProperty(c) && !xk(b[c], a[c]))
                return !1;
        return !0
    }
    function Nn(a, b) {
        var c;
        for (c = 0; c < a.length; c++)
            if (0 > b.indexOf(a[c]))
                return !1;
        for (c = 0; c < b.length; c++)
            if (0 > a.indexOf(b[c]))
                return !1;
        return !0
    }
    function gi(a) {
        a = a.node.worldTransform;
        a.getX(wg);
        a.getY(yk);
        a.getZ(zk);
        wg.cross(wg, yk);
        return 0 <= wg.dot(zk) ? 1 : -1
    }
    function pa() {
        this._aspectRatio = 16 / 9;
        this._aspectRatioMode = 0;
        this._calculateTransform = this._calculateProjection = null;
        this._clearColor = new L(.75,.75,.75,1);
        this._clearColorBuffer = !0;
        this._clearDepth = 1;
        this._clearDepthBuffer = !0;
        this._clearStencil = 0;
        this._clearStencilBuffer = !0;
        this._cullingMask = 4294967295;
        this._cullFaces = !0;
        this._farClip = 1E3;
        this._flipFaces = !1;
        this._fov = 45;
        this._frustumCulling = !0;
        this._horizontalFov = !1;
        this._layers = [0, 1, 2, 4, 3];
        this._nearClip = .1;
        this._node = null;
        this._orthoHeight = 10;
        this._projection = 0;
        this._rect = new X(0,0,1,1);
        this._renderTarget = null;
        this._scissorRect = new X(0,0,1,1);
        this._vrDisplay = null;
        this._projMat = new K;
        this._projMatDirty = !0;
        this._projMatSkybox = new K;
        this._viewMat = new K;
        this._viewMatDirty = !0;
        this._viewProjMat = new K;
        this._viewProjMatDirty = !0;
        this.frustum = new rg
    }
    function Z(a) {
        M.call(this);
        this.name = "string" === typeof a ? a : "Untitled";
        this.tags = new ad(this);
        this._labels = {};
        this.localPosition = new z(0,0,0);
        this.localRotation = new Y(0,0,0,1);
        this.localScale = new z(1,1,1);
        this.localEulerAngles = new z(0,0,0);
        this.position = new z(0,0,0);
        this.rotation = new Y(0,0,0,1);
        this.eulerAngles = new z(0,0,0);
        this._scale = null;
        this.localTransform = new K;
        this._dirtyLocal = !1;
        this._aabbVer = 0;
        this._frozen = !1;
        this.worldTransform = new K;
        this._dirtyWorld = !1;
        this.normalMatrix = new xb;
        this._dirtyNormal = !0;
        this._parent = this._forward = this._up = this._right = null;
        this._children = [];
        this._graphDepth = 0;
        this._enabled = !0;
        this.scaleCompensation = this._enabledInHierarchy = !1
    }
    function On(a, b) {
        return a.priority - b.priority
    }
    function Pn(a, b) {
        return b.key - a.key
    }
    function Ak() {
        this.list = [];
        this.length = 0;
        this.done = !1
    }
    function Bk() {
        this.opaqueMeshInstances = [];
        this.transparentMeshInstances = [];
        this.shadowCasters = [];
        this.visibleOpaque = [];
        this.visibleTransparent = []
    }
    function ma(a) {
        a = a || {};
        void 0 !== a.id ? (this.id = a.id,
        hi = Math.max(this.id + 1, hi)) : this.id = hi++;
        this.name = a.name;
        this._refCounter = (this._enabled = void 0 === a.enabled ? !0 : a.enabled) ? 1 : 0;
        this.opaqueSortMode = void 0 === a.opaqueSortMode ? 2 : a.opaqueSortMode;
        this.transparentSortMode = void 0 === a.transparentSortMode ? 3 : a.transparentSortMode;
        this.renderTarget = a.renderTarget;
        this.shaderPass = void 0 === a.shaderPass ? 0 : a.shaderPass;
        this.passThrough = void 0 === a.passThrough ? !1 : a.passThrough;
        this.overrideClear = void 0 === a.overrideClear ? !1 : a.overrideClear;
        this._clearColor = new L(0,0,0,1);
        a.clearColor && this._clearColor.copy(a.clearColor);
        this._clearColorBuffer = void 0 === a.clearColorBuffer ? !1 : a.clearColorBuffer;
        this._clearDepthBuffer = void 0 === a.clearDepthBuffer ? !1 : a.clearDepthBuffer;
        this._clearStencilBuffer = void 0 === a.clearStencilBuffer ? !1 : a.clearStencilBuffer;
        this._clearOptions = {
            color: [this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a],
            depth: 1,
            stencil: 0,
            flags: (this._clearColorBuffer ? 1 : 0) | (this._clearDepthBuffer ? 2 : 0) | (this._clearStencilBuffer ? 4 : 0)
        };
        this.onPreCull = a.onPreCull;
        this.onPreRender = a.onPreRender;
        this.onPreRenderOpaque = a.onPreRenderOpaque;
        this.onPreRenderTransparent = a.onPreRenderTransparent;
        this.onPostCull = a.onPostCull;
        this.onPostRender = a.onPostRender;
        this.onPostRenderOpaque = a.onPostRenderOpaque;
        this.onPostRenderTransparent = a.onPostRenderTransparent;
        this.onDrawCall = a.onDrawCall;
        this.onEnable = a.onEnable;
        this.onDisable = a.onDisable;
        if (this._enabled && this.onEnable)
            this.onEnable();
        this.instances = (this.layerReference = a.layerReference) ? a.layerReference.instances : new Bk;
        this.cullingMask = a.cullingMask ? a.cullingMask : 4294967295;
        this.opaqueMeshInstances = this.instances.opaqueMeshInstances;
        this.transparentMeshInstances = this.instances.transparentMeshInstances;
        this.shadowCasters = this.instances.shadowCasters;
        this.customCalculateSortValues = this.customSortCallback = null;
        this._lightComponents = [];
        this._lights = [];
        this._sortedLights = [[], [], []];
        this.cameras = [];
        this._dirtyCameras = this._dirtyLights = this._dirty = !1;
        this._staticLightHash = this._lightHash = this._cameraHash = 0;
        this._needsStaticPrepare = !0;
        this._staticPrepareDone = !1;
        this._shaderVersion = -1;
        this._version = 0;
        this._lightCube = null
    }
    function Qn(a, b) {
        if (0 !== b || a.webgl2) {
            if (3 === b)
                return a.extTextureFloatLinear ? 1 : 0;
            if (2 === b)
                return a.extTextureHalfFloatLinear ? 1 : 0
        } else
            return 0;
        return 1
    }
    function Ck(a, b, c, d) {
        var e = 3 === d ? 14 : 2 === d ? 12 : 4 === d || 0 === d && a.webgl2 ? 16 : 7
          , f = Qn(a, d);
        b = new V(a,{
            format: e,
            width: b,
            height: c,
            mipmaps: !1,
            minFilter: f,
            magFilter: f,
            addressU: 1,
            addressV: 1
        });
        b.name = "shadowmap";
        return 4 === d || 0 === d && a.webgl2 ? (b.compareOnRead = !0,
        b.compareFunc = 1,
        new ra({
            depthBuffer: b
        })) : new ra({
            colorBuffer: b,
            depth: !0
        })
    }
    function Dk(a, b) {
        a = new V(a,{
            format: 7,
            width: b,
            height: b,
            cubemap: !0,
            mipmaps: !1,
            minFilter: 0,
            magFilter: 0,
            addressU: 1,
            addressV: 1
        });
        a.name = "shadowcube";
        b = [];
        for (var c, d = 0; 6 > d; d++)
            c = new ra({
                colorBuffer: a,
                face: d,
                depth: !0
            }),
            b.push(c);
        return b
    }
    function Ek(a, b, c, d) {
        d || (d = 0);
        d = 1E4 * d + b;
        var e = Fk[c][d];
        e || (e = Ck(a, b, b, c ? c : 0),
        Fk[c][d] = e);
        return e
    }
    function Gk(a, b) {
        if (1 === b._type) {
            0 < b._shadowType && (b._shadowType = 0);
            if (b._cacheShadowMap) {
                var c = Hk[b._shadowResolution];
                c || (c = Dk(a, b._shadowResolution),
                Hk[b._shadowResolution] = c)
            } else
                c = Dk(a, b._shadowResolution);
            b._shadowCamera.renderTarget = c[0];
            b._shadowCubeMap = c
        } else
            c = b._cacheShadowMap ? Ek(a, b._shadowResolution, b._shadowType) : Ck(a, b._shadowResolution, b._shadowResolution, b._shadowType),
            b._shadowCamera.renderTarget = c;
        b._isCachedShadowMap = b._cacheShadowMap
    }
    function xg(a) {
        a = this.device = a;
        this._instancingTime = this._morphTime = this._skinTime = this._sortTime = this._cullTime = this._forwardTime = this._depthMapTime = this._shadowMapTime = this._shadowMapUpdates = this._materialSwitches = this._camerasRendered = this._skinDrawCalls = this._forwardDrawCalls = this._shadowDrawCalls = 0;
        this.library = a.getProgramLibrary();
        a = a.scope;
        this.projId = a.resolve("matrix_projection");
        this.projSkyboxId = a.resolve("matrix_projectionSkybox");
        this.viewId = a.resolve("matrix_view");
        this.viewId3 = a.resolve("matrix_view3");
        this.viewInvId = a.resolve("matrix_viewInverse");
        this.viewProjId = a.resolve("matrix_viewProjection");
        this.viewPos = new Float32Array(3);
        this.viewPosId = a.resolve("view_position");
        this.nearClipId = a.resolve("camera_near");
        this.farClipId = a.resolve("camera_far");
        this.cameraParamsId = a.resolve("camera_params");
        this.shadowMapLightRadiusId = a.resolve("light_radius");
        this.fogColorId = a.resolve("fog_color");
        this.fogStartId = a.resolve("fog_start");
        this.fogEndId = a.resolve("fog_end");
        this.fogDensityId = a.resolve("fog_density");
        this.modelMatrixId = a.resolve("matrix_model");
        this.normalMatrixId = a.resolve("matrix_normal");
        this.poseMatrixId = a.resolve("matrix_pose[0]");
        this.boneTextureId = a.resolve("texture_poseMap");
        this.boneTextureSizeId = a.resolve("texture_poseMapSize");
        this.morphWeightsA = a.resolve("morph_weights_a");
        this.morphWeightsB = a.resolve("morph_weights_b");
        this.morphPositionTex = a.resolve("morphPositionTex");
        this.morphNormalTex = a.resolve("morphNormalTex");
        this.morphTexParams = a.resolve("morph_tex_params");
        this.alphaTestId = a.resolve("alpha_ref");
        this.opacityMapId = a.resolve("texture_opacityMap");
        this.ambientId = a.resolve("light_globalAmbient");
        this.exposureId = a.resolve("exposure");
        this.skyboxIntensityId = a.resolve("skyboxIntensity");
        this.lightColorId = [];
        this.lightDir = [];
        this.lightDirId = [];
        this.lightShadowMapId = [];
        this.lightShadowMatrixId = [];
        this.lightShadowParamsId = [];
        this.lightShadowMatrixVsId = [];
        this.lightShadowParamsVsId = [];
        this.lightDirVs = [];
        this.lightDirVsId = [];
        this.lightRadiusId = [];
        this.lightPos = [];
        this.lightPosId = [];
        this.lightInAngleId = [];
        this.lightOutAngleId = [];
        this.lightPosVsId = [];
        this.lightCookieId = [];
        this.lightCookieIntId = [];
        this.lightCookieMatrixId = [];
        this.lightCookieOffsetId = [];
        this.depthMapId = a.resolve("uDepthMap");
        this.screenSizeId = a.resolve("uScreenSize");
        this._screenSize = new Float32Array(4);
        this.sourceId = a.resolve("source");
        this.pixelOffsetId = a.resolve("pixelOffset");
        this.weightId = a.resolve("weight[0]");
        this.blurVsmShaderCode = [F.blurVSMPS, "#define GAUSS\n" + F.blurVSMPS];
        this.blurPackedVsmShaderCode = ["#define PACKED\n" + this.blurVsmShaderCode[0], "#define PACKED\n" + this.blurVsmShaderCode[1]];
        this.blurVsmShader = [{}, {}];
        this.blurPackedVsmShader = [{}, {}];
        this.blurVsmWeights = {};
        this.polygonOffsetId = a.resolve("polygonOffset");
        this.polygonOffset = new Float32Array(2);
        this.fogColor = new Float32Array(3);
        this.ambientColor = new Float32Array(3);
        this.cameraParams = new Float32Array(4)
    }
    function yg(a, b) {
        a.data[0] = b.data[0];
        a.data[1] = b.data[1];
        a.data[2] = b.data[2];
        a.data[3] = b.data[4];
        a.data[4] = b.data[5];
        a.data[5] = b.data[6];
        a.data[6] = b.data[8];
        a.data[7] = b.data[9];
        a.data[8] = b.data[10]
    }
    function dd() {
        ka.call(this);
        this.color = new L(1,1,1,1);
        this.colorUniform = new Float32Array(4);
        this.colorMap = null;
        this.vertexColors = !1
    }
    function zg(a) {
        this.lineVertexFormat = new Na(a,[{
            semantic: "POSITION",
            components: 3,
            type: 6
        }, {
            semantic: "COLOR",
            components: 4,
            type: 1,
            normalize: !0
        }]);
        this.lineBatches = [];
        this.layers = [];
        this.layerToBatch = {};
        this.cubeWorldPos = this.cubeLocalPos = this.quadMesh = null;
        this.identityGraphNode = new Z
    }
    function Ik() {
        this.numLinesAllocated = 128;
        this.mesh = this.vbRam = this.vb = null;
        this.linesUsed = 0;
        this.layer = this.meshInstance = this.material = null
    }
    function xa() {
        M.call(this);
        this.layerList = [];
        this.subLayerList = [];
        this.subLayerEnabled = [];
        this._opaqueOrder = {};
        this._transparentOrder = {};
        this._dirtyCameras = this._dirtyLights = this._dirtyBlend = this._dirty = !1;
        this._meshInstances = [];
        this._lights = [];
        this.cameras = [];
        this._sortedLights = [[], [], []];
        this._lightShadowCasters = [];
        this._globalLightCameras = [];
        this._globalLightCameraIds = [];
        this._renderedRt = [];
        this._renderedByCam = [];
        this._renderedLayer = [];
        this._renderList = [];
        this._renderListCamera = []
    }
    function Ag(a, b, c, d) {
        if (a.enabled) {
            var e;
            if (a.model && a.model.model && a.model.enabled && (d && d.push(a),
            a.model.lightmapped && b)) {
                var f = !0
                  , g = a.model.model.meshInstances;
                for (e = 0; e < g.length; e++)
                    if (!g[e].mesh.vertexBuffer.format.hasUv1) {
                        f = !1;
                        break
                    }
                if (f) {
                    var k = [];
                    for (e = 0; e < g.length; e++) {
                        var h = !1;
                        for (f = 0; f < g.length; f++)
                            e !== f && g[e].mesh === g[f].mesh && (h = !0);
                        h ? (b.push(a),
                        c.push([g[e]])) : k.push(g[e])
                    }
                    0 < k.length && (b.push(a),
                    c.push(k))
                }
            }
            for (e = 0; e < a._children.length; e++)
                Ag(a._children[e], b, c, d)
        }
    }
    function ii(a, b, c, d, e) {
        this.device = a;
        this.root = b;
        this.scene = c;
        this.renderer = d;
        this.assets = e
    }
    function te(a) {
        return a - Math.floor(a)
    }
    function ji(a, b) {
        return a - b * Math.floor(a / b)
    }
    function Bg(a) {
        var b = te(a);
        a = te(255 * a);
        return [b - a / 255, a - a / 255]
    }
    function ki(a) {
        this._emitter = a
    }
    function Jk(a, b) {
        b.data[0] = a.data[0];
        b.data[1] = a.data[1];
        b.data[2] = a.data[2];
        b.data[3] = a.data[4];
        b.data[4] = a.data[5];
        b.data[5] = a.data[6];
        b.data[6] = a.data[8];
        b.data[7] = a.data[9];
        b.data[8] = a.data[10]
    }
    function Cg(a, b) {
        this._emitter = a;
        this.frameRandomUniform = new Float32Array(3);
        this.emitterPosUniform = new Float32Array(3);
        this.emitterScaleUniform = new Float32Array([1, 1, 1]);
        this.worldBoundsMulUniform = new Float32Array(3);
        this.worldBoundsAddUniform = new Float32Array(3);
        this.inBoundsSizeUniform = new Float32Array(3);
        this.inBoundsCenterUniform = new Float32Array(3);
        this.constantParticleTexIN = b.scope.resolve("particleTexIN");
        this.constantParticleTexOUT = b.scope.resolve("particleTexOUT");
        this.constantEmitterPos = b.scope.resolve("emitterPos");
        this.constantEmitterScale = b.scope.resolve("emitterScale");
        this.constantSpawnBounds = b.scope.resolve("spawnBounds");
        this.constantSpawnPosInnerRatio = b.scope.resolve("spawnPosInnerRatio");
        this.constantSpawnBoundsSphere = b.scope.resolve("spawnBoundsSphere");
        this.constantSpawnBoundsSphereInnerRatio = b.scope.resolve("spawnBoundsSphereInnerRatio");
        this.constantInitialVelocity = b.scope.resolve("initialVelocity");
        this.constantFrameRandom = b.scope.resolve("frameRandom");
        this.constantDelta = b.scope.resolve("delta");
        this.constantRate = b.scope.resolve("rate");
        this.constantRateDiv = b.scope.resolve("rateDiv");
        this.constantLifetime = b.scope.resolve("lifetime");
        this.constantGraphSampleSize = b.scope.resolve("graphSampleSize");
        this.constantGraphNumSamples = b.scope.resolve("graphNumSamples");
        this.constantInternalTex0 = b.scope.resolve("internalTex0");
        this.constantInternalTex1 = b.scope.resolve("internalTex1");
        this.constantInternalTex2 = b.scope.resolve("internalTex2");
        this.constantInternalTex3 = b.scope.resolve("internalTex3");
        this.constantEmitterMatrix = b.scope.resolve("emitterMatrix");
        this.constantEmitterMatrixInv = b.scope.resolve("emitterMatrixInv");
        this.constantNumParticles = b.scope.resolve("numParticles");
        this.constantNumParticlesPot = b.scope.resolve("numParticlesPot");
        this.constantLocalVelocityDivMult = b.scope.resolve("localVelocityDivMult");
        this.constantVelocityDivMult = b.scope.resolve("velocityDivMult");
        this.constantRotSpeedDivMult = b.scope.resolve("rotSpeedDivMult");
        this.constantSeed = b.scope.resolve("seed");
        this.constantStartAngle = b.scope.resolve("startAngle");
        this.constantStartAngle2 = b.scope.resolve("startAngle2");
        this.constantOutBoundsMul = b.scope.resolve("outBoundsMul");
        this.constantOutBoundsAdd = b.scope.resolve("outBoundsAdd");
        this.constantInBoundsSize = b.scope.resolve("inBoundsSize");
        this.constantInBoundsCenter = b.scope.resolve("inBoundsCenter");
        this.constantMaxVel = b.scope.resolve("maxVel");
        this.constantFaceTangent = b.scope.resolve("faceTangent");
        this.constantFaceBinorm = b.scope.resolve("faceBinorm")
    }
    function U(a, b) {
        Kk[a] = void 0 !== Dg[a] && null !== Dg[a] ? Dg[a] : b
    }
    function Lk(a, b) {
        for (var c = a.length / 3, d = Array(4 * c), e = 0; e < c; e++)
            d[4 * e] = a[3 * e],
            d[4 * e + 1] = a[3 * e + 1],
            d[4 * e + 2] = a[3 * e + 2],
            d[4 * e + 3] = (255 * b[3 * e] << 16 | 255 * b[3 * e + 1] << 8 | 255 * b[3 * e + 2]) / 16777216;
        return d
    }
    function Id(a, b) {
        var c, d, e = b.length, f = a.length / e;
        for (c = 0; c < f; c++)
            for (d = 0; d < e; d++)
                b[d] = Math.max(b[d], Math.abs(a[c * e + d]))
    }
    function Jd(a, b, c) {
        for (var d = new Float32Array(b.length), e = 0; e < b.length; e++)
            d[e] = b[e] - a[e];
        Id(d, c);
        a = c.length;
        var f = d.length / a;
        for (b = 0; b < f; b++)
            for (e = 0; e < a; e++)
                d[b * a + e] /= 0 === c[e] ? 1 : c[e],
                d[b * a + e] *= .5,
                d[b * a + e] += .5;
        return d
    }
    function Mk(a, b) {
        var c = b.length / 3, d = a.length / 3, e, f = new z, g = new z, k = new z, h = new z, l = new z, n = new z, p = [];
        for (e = 0; e < a.length; e++)
            p[e] = 0;
        for (e = 0; e < c; e++) {
            var q = b[3 * e];
            var r = b[3 * e + 1];
            var t = b[3 * e + 2];
            f.set(a[3 * q], a[3 * q + 1], a[3 * q + 2]);
            g.set(a[3 * r], a[3 * r + 1], a[3 * r + 2]);
            k.set(a[3 * t], a[3 * t + 1], a[3 * t + 2]);
            h.sub2(g, f);
            l.sub2(k, f);
            n.cross(h, l).normalize();
            p[3 * q] += n.x;
            p[3 * q + 1] += n.y;
            p[3 * q + 2] += n.z;
            p[3 * r] += n.x;
            p[3 * r + 1] += n.y;
            p[3 * r + 2] += n.z;
            p[3 * t] += n.x;
            p[3 * t + 1] += n.y;
            p[3 * t + 2] += n.z
        }
        for (e = 0; e < d; e++)
            a = p[3 * e],
            b = p[3 * e + 1],
            c = p[3 * e + 2],
            a = 1 / Math.sqrt(a * a + b * b + c * c),
            p[3 * e] *= a,
            p[3 * e + 1] *= a,
            p[3 * e + 2] *= a;
        return p
    }
    function Nk(a, b, c, d) {
        var e = d.length / 3, f = a.length / 3, g = new z, k = new z, h = new z, l = new z, n = new z, p = new P, q = new P, r = new P, t, u = new Float32Array(3 * f), x = new Float32Array(3 * f), v = [];
        for (t = 0; t < e; t++) {
            var w = d[3 * t];
            var y = d[3 * t + 1];
            var A = d[3 * t + 2];
            h.set(a[3 * w], a[3 * w + 1], a[3 * w + 2]);
            l.set(a[3 * y], a[3 * y + 1], a[3 * y + 2]);
            n.set(a[3 * A], a[3 * A + 1], a[3 * A + 2]);
            p.set(c[2 * w], c[2 * w + 1]);
            q.set(c[2 * y], c[2 * y + 1]);
            r.set(c[2 * A], c[2 * A + 1]);
            var B = l.x - h.x;
            var E = n.x - h.x;
            var C = l.y - h.y;
            var D = n.y - h.y;
            var G = l.z - h.z;
            var J = n.z - h.z;
            var R = q.x - p.x;
            var I = r.x - p.x;
            var T = q.y - p.y;
            var S = r.y - p.y;
            var ba = R * S - I * T;
            0 == ba ? (g.set(0, 1, 0),
            k.set(1, 0, 0)) : (ba = 1 / ba,
            g.set((S * B - T * E) * ba, (S * C - T * D) * ba, (S * G - T * J) * ba),
            k.set((R * E - I * B) * ba, (R * D - I * C) * ba, (R * J - I * G) * ba));
            u[3 * w] += g.x;
            u[3 * w + 1] += g.y;
            u[3 * w + 2] += g.z;
            u[3 * y] += g.x;
            u[3 * y + 1] += g.y;
            u[3 * y + 2] += g.z;
            u[3 * A] += g.x;
            u[3 * A + 1] += g.y;
            u[3 * A + 2] += g.z;
            x[3 * w] += k.x;
            x[3 * w + 1] += k.y;
            x[3 * w + 2] += k.z;
            x[3 * y] += k.x;
            x[3 * y + 1] += k.y;
            x[3 * y + 2] += k.z;
            x[3 * A] += k.x;
            x[3 * A + 1] += k.y;
            x[3 * A + 2] += k.z
        }
        T = new z;
        S = new z;
        a = new z;
        c = new z;
        for (t = 0; t < f; t++)
            a.set(b[3 * t], b[3 * t + 1], b[3 * t + 2]),
            T.set(u[3 * t], u[3 * t + 1], u[3 * t + 2]),
            S.set(x[3 * t], x[3 * t + 1], x[3 * t + 2]),
            d = a.dot(T),
            c.copy(a).scale(d),
            c.sub2(T, c).normalize(),
            v[4 * t] = c.x,
            v[4 * t + 1] = c.y,
            v[4 * t + 2] = c.z,
            c.cross(a, T),
            v[4 * t + 3] = 0 > c.dot(S) ? -1 : 1;
        return v
    }
    function Qb(a, b, c) {
        var d = c && void 0 !== c.normals ? c.normals : null
          , e = c && void 0 !== c.tangents ? c.tangents : null
          , f = c && void 0 !== c.colors ? c.colors : null
          , g = c && void 0 !== c.uvs ? c.uvs : null
          , k = c && void 0 !== c.uvs1 ? c.uvs1 : null
          , h = c && void 0 !== c.indices ? c.indices : null
          , l = c && void 0 !== c.blendIndices ? c.blendIndices : null
          , n = c && void 0 !== c.blendWeights ? c.blendWeights : null;
        c = [{
            semantic: "POSITION",
            components: 3,
            type: 6
        }];
        null !== d && c.push({
            semantic: "NORMAL",
            components: 3,
            type: 6
        });
        null !== e && c.push({
            semantic: "TANGENT",
            components: 4,
            type: 6
        });
        null !== f && c.push({
            semantic: "COLOR",
            components: 4,
            type: 1,
            normalize: !0
        });
        null !== g && c.push({
            semantic: "TEXCOORD0",
            components: 2,
            type: 6
        });
        null !== k && c.push({
            semantic: "TEXCOORD1",
            components: 2,
            type: 6
        });
        null !== l && c.push({
            semantic: "BLENDINDICES",
            components: 2,
            type: 1
        });
        null !== n && c.push({
            semantic: "BLENDWEIGHT",
            components: 2,
            type: 6
        });
        var p = new Na(a,c);
        c = b.length / 3;
        p = new ab(a,p,c);
        for (var q = new Pb(p), r = 0; r < c; r++)
            q.element.POSITION.set(b[3 * r], b[3 * r + 1], b[3 * r + 2]),
            null !== d && q.element.NORMAL.set(d[3 * r], d[3 * r + 1], d[3 * r + 2]),
            null !== e && q.element.TANGENT.set(e[4 * r], e[4 * r + 1], e[4 * r + 2], e[4 * r + 3]),
            null !== f && q.element.COLOR.set(f[4 * r], f[4 * r + 1], f[4 * r + 2], f[4 * r + 3]),
            null !== g && q.element.TEXCOORD0.set(g[2 * r], g[2 * r + 1]),
            null !== k && q.element.TEXCOORD1.set(k[2 * r], k[2 * r + 1]),
            null !== l && q.element.BLENDINDICES.set(l[2 * r], l[2 * r + 1]),
            null !== n && q.element.BLENDWEIGHT.set(n[2 * r], n[2 * r + 1]),
            q.next();
        q.end();
        d = null;
        if (e = null !== h)
            d = new dc(a,1,h.length),
            (new Uint16Array(d.lock())).set(h),
            d.unlock();
        f = new oa;
        f.compute(b);
        a = new rb(a);
        a.vertexBuffer = p;
        a.indexBuffer[0] = d;
        a.primitive[0].type = 4;
        a.primitive[0].base = 0;
        a.primitive[0].count = e ? h.length : c;
        a.primitive[0].indexed = e;
        a.aabb = f;
        return a
    }
    function Ok(a, b) {
        var c = b && void 0 !== b.tubeRadius ? b.tubeRadius : .2
          , d = b && void 0 !== b.ringRadius ? b.ringRadius : .3
          , e = b && void 0 !== b.segments ? b.segments : 30
          , f = b && void 0 !== b.sides ? b.sides : 20;
        b = b && void 0 !== b.calculateTangents ? b.calculateTangents : !1;
        var g, k, h = [], l = [], n = [], p = [];
        for (g = 0; g <= f; g++)
            for (k = 0; k <= e; k++) {
                var q = Math.cos(2 * Math.PI * k / e) * (d + c * Math.cos(2 * Math.PI * g / f));
                var r = Math.sin(2 * Math.PI * g / f) * c;
                var t = Math.sin(2 * Math.PI * k / e) * (d + c * Math.cos(2 * Math.PI * g / f));
                var u = Math.cos(2 * Math.PI * k / e) * Math.cos(2 * Math.PI * g / f);
                var x = Math.sin(2 * Math.PI * g / f);
                var v = Math.sin(2 * Math.PI * k / e) * Math.cos(2 * Math.PI * g / f);
                var w = g / f;
                var y = 1 - k / e;
                h.push(q, r, t);
                l.push(u, x, v);
                n.push(w, y);
                g < f && k < e && (q = g * (e + 1) + k,
                r = (g + 1) * (e + 1) + k,
                t = g * (e + 1) + (k + 1),
                u = (g + 1) * (e + 1) + (k + 1),
                p.push(q, r, t),
                p.push(r, u, t))
            }
        c = {
            normals: l,
            uvs: n,
            indices: p
        };
        b && (c.tangents = b(h, l, n, p));
        return Qb(a, h, c)
    }
    function li(a, b, c, d, e, f) {
        var g, k, h = new z, l = new z;
        var n = new z;
        var p = []
          , q = []
          , r = []
          , t = []
          , u = [];
        if (0 < c)
            for (g = 0; g <= d; g++)
                for (k = 0; k <= e; k++) {
                    var x = k / e * 2 * Math.PI - Math.PI;
                    var v = Math.sin(x);
                    x = Math.cos(x);
                    var w = new z(v * a,-c / 2,x * a);
                    var y = new z(v * b,c / 2,x * b);
                    h.lerp(w, y, g / d);
                    l.sub2(y, w).normalize();
                    v = new z(x,0,-v);
                    n.cross(v, l).normalize();
                    p.push(h.x, h.y, h.z);
                    q.push(n.x, n.y, n.z);
                    y = k / e;
                    w = g / d;
                    r.push(y, w);
                    v = w;
                    w = y;
                    y = v;
                    y /= 3;
                    y = .875 * y + .0625;
                    w = .875 * w + .0625;
                    t.push(y, w);
                    g < d && k < e && (v = g * (e + 1) + k,
                    x = g * (e + 1) + (k + 1),
                    y = (g + 1) * (e + 1) + k,
                    w = (g + 1) * (e + 1) + (k + 1),
                    u.push(v, x, y),
                    u.push(x, w, y))
                }
        if (f) {
            a = Math.floor(e / 2);
            g = c / 2;
            for (c = 0; c <= a; c++)
                for (x = c * Math.PI * .5 / a,
                v = Math.sin(x),
                x = Math.cos(x),
                h = 0; h <= e; h++)
                    f = 2 * h * Math.PI / e - Math.PI / 2,
                    y = Math.sin(f),
                    f = Math.cos(f),
                    f *= v,
                    k = x,
                    n = y * v,
                    y = 1 - h / e,
                    w = 1 - c / a,
                    p.push(f * b, k * b + g, n * b),
                    q.push(f, k, n),
                    r.push(y, w),
                    y /= 3,
                    w /= 3,
                    y = .875 * y + .0625,
                    w = .875 * w + .0625,
                    y += 1 / 3,
                    t.push(y, w);
            l = (d + 1) * (e + 1);
            for (c = 0; c < a; ++c)
                for (h = 0; h < e; ++h)
                    v = c * (e + 1) + h,
                    x = v + e + 1,
                    u.push(l + v + 1, l + x, l + v),
                    u.push(l + v + 1, l + x + 1, l + x);
            for (c = 0; c <= a; c++)
                for (x = .5 * Math.PI + c * Math.PI * .5 / a,
                v = Math.sin(x),
                x = Math.cos(x),
                h = 0; h <= e; h++)
                    f = 2 * h * Math.PI / e - Math.PI / 2,
                    y = Math.sin(f),
                    f = Math.cos(f),
                    f *= v,
                    k = x,
                    n = y * v,
                    y = 1 - h / e,
                    w = 1 - c / a,
                    p.push(f * b, k * b - g, n * b),
                    q.push(f, k, n),
                    r.push(y, w),
                    y /= 3,
                    w /= 3,
                    y = .875 * y + .0625,
                    w = .875 * w + .0625,
                    y += 2 / 3,
                    t.push(y, w);
            l = (d + 1) * (e + 1) + (e + 1) * (a + 1);
            for (c = 0; c < a; ++c)
                for (h = 0; h < e; ++h)
                    v = c * (e + 1) + h,
                    x = v + e + 1,
                    u.push(l + v + 1, l + x, l + v),
                    u.push(l + v + 1, l + x + 1, l + x)
        } else {
            l = (d + 1) * (e + 1);
            if (0 < a)
                for (g = 0; g < e; g++)
                    x = g / e * 2 * Math.PI,
                    f = Math.sin(x),
                    k = -c / 2,
                    n = Math.cos(x),
                    y = 1 - (f + 1) / 2,
                    w = (n + 1) / 2,
                    p.push(f * a, k, n * a),
                    q.push(0, -1, 0),
                    r.push(y, w),
                    y /= 3,
                    w /= 3,
                    y = .875 * y + .0625,
                    w = .875 * w + .0625,
                    y += 1 / 3,
                    t.push(y, w),
                    1 < g && u.push(l, l + g, l + g - 1);
            l += e;
            if (0 < b)
                for (g = 0; g < e; g++)
                    x = g / e * 2 * Math.PI,
                    f = Math.sin(x),
                    k = c / 2,
                    n = Math.cos(x),
                    y = 1 - (f + 1) / 2,
                    w = (n + 1) / 2,
                    p.push(f * b, k, n * b),
                    q.push(0, 1, 0),
                    r.push(y, w),
                    y /= 3,
                    w /= 3,
                    y = .875 * y + .0625,
                    w = .875 * w + .0625,
                    y += 2 / 3,
                    t.push(y, w),
                    1 < g && u.push(l, l + g - 1, l + g)
        }
        return {
            positions: p,
            normals: q,
            uvs: r,
            uvs1: t,
            indices: u
        }
    }
    function mi(a, b) {
        var c = b && (b.radius || b.baseRadius);
        c = void 0 !== c ? c : .5;
        var d = b && void 0 !== b.calculateTangents ? b.calculateTangents : !1;
        b = li(c, c, b && void 0 !== b.height ? b.height : 1, b && void 0 !== b.heightSegments ? b.heightSegments : 5, b && void 0 !== b.capSegments ? b.capSegments : 20, !1);
        d && (b.tangents = d(b.positions, b.normals, b.uvs, b.indices));
        return Qb(a, b.positions, b)
    }
    function ni(a, b) {
        var c = b && void 0 !== b.radius ? b.radius : .3
          , d = b && void 0 !== b.calculateTangents ? b.calculateTangents : !1;
        b = li(c, c, (b && void 0 !== b.height ? b.height : 1) - 2 * c, b && void 0 !== b.heightSegments ? b.heightSegments : 1, b && void 0 !== b.sides ? b.sides : 20, !0);
        d && (b.tangents = d(b.positions, b.normals, b.uvs, b.indices));
        return Qb(a, b.positions, b)
    }
    function oi(a, b) {
        var c = b && void 0 !== b.calculateTangents ? b.calculateTangents : !1;
        b = li(b && void 0 !== b.baseRadius ? b.baseRadius : .5, b && void 0 !== b.peakRadius ? b.peakRadius : 0, b && void 0 !== b.height ? b.height : 1, b && void 0 !== b.heightSegments ? b.heightSegments : 5, b && void 0 !== b.capSegments ? b.capSegments : 18, !1);
        c && (b.tangents = c(b.positions, b.normals, b.uvs, b.indices));
        return Qb(a, b.positions, b)
    }
    function pi(a, b) {
        var c = b && void 0 !== b.radius ? b.radius : .5
          , d = b && void 0 !== b.latitudeBands ? b.latitudeBands : 16
          , e = b && void 0 !== b.longitudeBands ? b.longitudeBands : 16;
        b = b && void 0 !== b.calculateTangents ? b.calculateTangents : !1;
        var f, g = [], k = [], h = [], l = [];
        for (f = 0; f <= d; f++) {
            var n = f * Math.PI / d;
            var p = Math.sin(n);
            var q = Math.cos(n);
            for (n = 0; n <= e; n++) {
                var r = 2 * n * Math.PI / e - Math.PI / 2;
                var t = Math.sin(r);
                r = Math.cos(r);
                r *= p;
                var u = q;
                t *= p;
                var x = 1 - n / e;
                var v = 1 - f / d;
                g.push(r * c, u * c, t * c);
                k.push(r, u, t);
                h.push(x, v)
            }
        }
        for (f = 0; f < d; ++f)
            for (n = 0; n < e; ++n)
                c = f * (e + 1) + n,
                p = c + e + 1,
                l.push(c + 1, p, c),
                l.push(c + 1, p + 1, p);
        d = {
            normals: k,
            uvs: h,
            uvs1: h,
            indices: l
        };
        b && (d.tangents = b(g, k, h, l));
        return Qb(a, g, d)
    }
    function qi(a, b) {
        var c = b && void 0 !== b.halfExtents ? b.halfExtents : new P(.5,.5)
          , d = b && void 0 !== b.widthSegments ? b.widthSegments : 5
          , e = b && void 0 !== b.lengthSegments ? b.lengthSegments : 5;
        b = b && void 0 !== b.calculateTangents ? b.calculateTangents : !1;
        var f, g, k = [], h = [], l = [], n = [], p = 0;
        for (f = 0; f <= d; f++)
            for (g = 0; g <= e; g++) {
                var q = -c.x + 2 * c.x * f / d;
                var r = -(-c.y + 2 * c.y * g / e);
                var t = f / d;
                var u = g / e;
                k.push(q, 0, r);
                h.push(0, 1, 0);
                l.push(t, u);
                f < d && g < e && (n.push(p + e + 1, p + 1, p),
                n.push(p + e + 1, p + e + 2, p + 1));
                p++
            }
        c = {
            normals: h,
            uvs: l,
            uvs1: l,
            indices: n
        };
        b && (c.tangents = b(k, h, l, n));
        return Qb(a, k, c)
    }
    function Eg(a, b) {
        var c = b && void 0 !== b.halfExtents ? b.halfExtents : new z(.5,.5,.5)
          , d = b && void 0 !== b.widthSegments ? b.widthSegments : 1
          , e = b && void 0 !== b.lengthSegments ? b.lengthSegments : 1
          , f = b && void 0 !== b.heightSegments ? b.heightSegments : 1;
        b = b && void 0 !== b.calculateTangents ? b.calculateTangents : !1;
        var g = [new z(-c.x,-c.y,c.z), new z(c.x,-c.y,c.z), new z(c.x,c.y,c.z), new z(-c.x,c.y,c.z), new z(c.x,-c.y,-c.z), new z(-c.x,-c.y,-c.z), new z(-c.x,c.y,-c.z), new z(c.x,c.y,-c.z)]
          , k = [[0, 1, 3], [4, 5, 7], [3, 2, 6], [1, 0, 4], [1, 4, 2], [5, 0, 6]]
          , h = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]]
          , l = []
          , n = []
          , p = []
          , q = []
          , r = []
          , t = 0;
        c = function(u, x, v) {
            var w, y;
            for (w = 0; w <= x; w++)
                for (y = 0; y <= v; y++) {
                    var A = new z;
                    var B = new z;
                    var E = new z
                      , C = new z;
                    A.lerp(g[k[u][0]], g[k[u][1]], w / x);
                    B.lerp(g[k[u][0]], g[k[u][2]], y / v);
                    E.sub2(B, g[k[u][0]]);
                    C.add2(A, E);
                    A = w / x;
                    B = y / v;
                    l.push(C.x, C.y, C.z);
                    n.push(h[u][0], h[u][1], h[u][2]);
                    p.push(A, B);
                    A /= 3;
                    B /= 3;
                    A = .875 * A + .0625;
                    B = .875 * B + .0625;
                    A += u % 3 / 3;
                    B += Math.floor(u / 3) / 3;
                    q.push(A, B);
                    w < x && y < v && (r.push(t + v + 1, t + 1, t),
                    r.push(t + v + 1, t + v + 2, t + 1));
                    t++
                }
        }
        ;
        c(0, d, f);
        c(1, d, f);
        c(2, d, e);
        c(3, d, e);
        c(4, e, f);
        c(5, e, f);
        d = {
            normals: n,
            uvs: p,
            uvs1: q,
            indices: r
        };
        b && (d.tangents = b(l, n, p, r));
        return Qb(a, l, d)
    }
    function sa() {
        M.call(this);
        this.root = null;
        this._gravity = new z(0,-9.8,0);
        this._layers = null;
        this._fog = "none";
        this.fogColor = new L(0,0,0);
        this.fogStart = 1;
        this.fogEnd = 1E3;
        this.fogDensity = 0;
        this.ambientLight = new L(0,0,0);
        this._toneMapping = this._gammaCorrection = 0;
        this.exposure = 1;
        this._skyboxPrefiltered = [null, null, null, null, null, null];
        this._firstUpdateSkybox = !0;
        this.skyboxModel = this._skyboxCubeMap = null;
        this._skyboxIntensity = 1;
        this._skyboxMip = 0;
        this.lightmapSizeMultiplier = 1;
        this.lightmapMaxResolution = 2048;
        this.lightmapMode = 1;
        this._stats = {
            meshInstances: 0,
            lights: 0,
            dynamicLights: 0,
            bakedLights: 0,
            lastStaticPrepareFullTime: 0,
            lastStaticPrepareSearchTime: 0,
            lastStaticPrepareWriteTime: 0,
            lastStaticPrepareTriAabbTime: 0,
            lastStaticPrepareCombineTime: 0,
            updateShadersTime: 0
        };
        this.updateSkybox = this.updateShaders = !0;
        this._shaderVersion = 0;
        this._statsUpdated = !1;
        this._models = [];
        this.defaultMaterial = new la;
        this.defaultMaterial.name = "Default Material";
        this.defaultMaterial.shadingModel = 1
    }
    function ue() {
        return "undefined" !== typeof Audio
    }
    function ed() {
        return !("undefined" === typeof AudioContext && "undefined" === typeof webkitAudioContext)
    }
    function ri(a) {
        this.position = new z;
        this.velocity = new z;
        this.orientation = new K;
        ed() && (this.listener = a.context.listener)
    }
    function ec(a) {
        M.call(this);
        if (ed() || a.forceWebAudioApi) {
            if ("undefined" !== typeof AudioContext ? this.context = new AudioContext : "undefined" !== typeof webkitAudioContext && (this.context = new webkitAudioContext),
            this.context) {
                var b = this.context;
                this.resumeContext = function() {
                    this.context.resume();
                    window.removeEventListener("mousedown", this.resumeContext);
                    window.removeEventListener("touchend", this.resumeContext)
                }
                .bind(this);
                window.addEventListener("mousedown", this.resumeContext);
                window.addEventListener("touchend", this.resumeContext);
                if (Ca.ios) {
                    var c = function() {
                        var d = b.createBuffer(1, 1, 44100)
                          , e = b.createBufferSource();
                        e.buffer = d;
                        e.connect(b.destination);
                        e.start(0);
                        e.disconnect();
                        window.removeEventListener("touchend", c)
                    };
                    window.addEventListener("touchend", c)
                }
            }
        } else
            console.warn("No support for 3D audio found");
        ue() || console.warn("No support for 2D audio found");
        this.listener = new ri(this);
        this._volume = 1;
        this.suspended = !1
    }
    function Fg(a, b, c, d) {
        this.time = a;
        this.position = b;
        this.rotation = c;
        this.scale = d
    }
    function Gg() {
        this._name = "";
        this._keys = []
    }
    function Rb() {
        this.name = "";
        this.duration = 0;
        this._nodes = [];
        this._nodeDict = {}
    }
    function tf(a) {
        2 === arguments.length && (a = arguments[1]);
        this.options = a;
        this.name = a.name;
        this.defaultWeight = a.defaultWeight || 0;
        this.aabb = a.aabb;
        this.aabb || (this.aabb = new oa,
        a.deltaPositions && this.aabb.compute(a.deltaPositions));
        this.deltaPositions = a.deltaPositions
    }
    function Hg(a, b, c) {
        this.device = a;
        this.inverseBindPose = b;
        this.boneNames = c
    }
    function uf() {}
    function fa(a, b) {
        Z.call(this, a);
        a instanceof ea && (b = a);
        this._batchHandle = null;
        this.c = {};
        this._app = b;
        if (!b && (this._app = ea.getApplication(),
        !this._app))
            throw Error("Couldn't find current application");
        this._guid = null;
        this._template = this._destroying = !1
    }
    function Pk(a, b, c, d) {
        var e;
        if (b instanceof fa) {
            var f = b.c, g;
            for (g in f) {
                var k = f[g]
                  , h = k.system.getPropertiesOfType("entity");
                var l = 0;
                for (e = h.length; l < e; l++) {
                    var n = h[l].name
                      , p = k[n];
                    a.findByGuid(p) && ((p = d[p].getGuid()) ? c.c[g][n] = p : console.warn("Could not find corresponding entity id when resolving duplicated entity references"))
                }
            }
            f.script && !c._app.useLegacyScriptAttributeCloning && c.script.resolveDuplicatedEntityReferenceProperties(f.script, d);
            b = b.children.filter(function(q) {
                return q instanceof fa
            });
            c = c.children.filter(function(q) {
                return q instanceof fa
            });
            l = 0;
            for (e = b.length; l < e; l++)
                Pk(a, b[l], c[l], d)
        }
    }
    function vf(a, b) {
        this._components = a;
        this._data = b
    }
    function Qk() {
        this._left = Infinity;
        this._right = -Infinity;
        this._t = this._p1 = this._p0 = this._recip = this._len = 0;
        this._hermite = {
            valid: !1,
            p0: 0,
            m0: 0,
            p1: 0,
            m1: 0
        }
    }
    function Ig(a, b, c, d) {
        this._paths = a;
        this._input = b;
        this._output = c;
        this._interpolation = d
    }
    function Kd(a, b, c, d, e) {
        this._name = a;
        this._duration = b;
        this._inputs = c;
        this._outputs = d;
        this._curves = e
    }
    function Rk(a) {
        this._name = a.name + "Snapshot";
        this._time = -1;
        this._cache = [];
        this._results = [];
        var b;
        for (b = 0; b < a._inputs.length; ++b)
            this._cache[b] = new Qk;
        var c = a._curves;
        a = a._outputs;
        for (b = 0; b < c.length; ++b) {
            for (var d = a[c[b]._output], e = [], f = 0; f < d._components; ++f)
                e[f] = 0;
            this._results[b] = e
        }
    }
    function wf(a, b, c, d, e) {
        this._name = a.name;
        this._track = a;
        this._snapshot = new Rk(a);
        this._playing = d;
        this._time = b;
        this._speed = c;
        this._loop = e;
        this._blendWeight = 1;
        this._blendOrder = 0
    }
    function Ic(a, b, c) {
        this._func = a;
        this._type = b;
        this._components = c
    }
    function uc() {}
    function xf(a) {
        var b = {}
          , c = function(d) {
            b[d.name] = {
                node: d,
                count: 0
            };
            for (var e = 0; e < d.children.length; ++e)
                c(d.children[e])
        };
        c(a);
        this.nodes = b;
        this.activeNodes = [];
        this.handlers = {
            localPosition: function(d) {
                var e = d.localPosition;
                return new Ic(function(f) {
                    e.set.apply(e, f)
                }
                ,"vector",3)
            },
            localRotation: function(d) {
                var e = d.localRotation;
                return new Ic(function(f) {
                    e.set.apply(e, f)
                }
                ,"quaternion",4)
            },
            localScale: function(d) {
                var e = d.localScale;
                return new Ic(function(f) {
                    e.set.apply(e, f)
                }
                ,"vector",3)
            },
            weights: function(d) {
                for (var e = d; e && e.constructor !== fa; )
                    e = e.parent;
                if (!(e && e.model && e.model.model && e.model.model.morphInstances))
                    return null;
                e = e.model.meshInstances;
                for (var f, g = 0; g < e.length; ++g)
                    if (e[g].node.name === d.name) {
                        f = e[g].morphInstance;
                        break
                    }
                return f ? new Ic(function(k) {
                    for (var h = 0; h < k.length; ++h)
                        f.setWeight(h, k[h])
                }
                ,"vector",f.morph._targets.length) : null
            },
            materialTexture: function(d, e) {
                for (var f = d; f && f.constructor !== fa; )
                    f = f.parent;
                if (!f || !f.model || !f.model.model)
                    return null;
                f = f.model.meshInstances;
                for (var g, k = 0; k < f.length; ++k)
                    if (f[k].node.name === d.name) {
                        g = f[k];
                        break
                    }
                if (!g)
                    return null;
                d = function(h) {
                    (h = this.animComponent.system.app.assets.get(h[0])) && h.resource && "texture" === h.type && (g.material[e] = h.resource,
                    g.material.update())
                }
                .bind(this);
                return new Ic(d,"vector",1)
            }
            .bind(this)
        };
        this.propertyLocator = new uf
    }
    function Ja(a) {
        this._binder = a;
        this._clips = [];
        this._inputs = [];
        this._outputs = [];
        this._targets = {}
    }
    function si() {}
    function Oa(a) {
        M.call(this);
        this.locale = Jg;
        this._translations = {};
        this._availableLangs = {};
        this._app = a;
        this._assets = [];
        this._parser = new si
    }
    function ti(a) {
        this.asset = a
    }
    function aa(a, b, c, d, e) {
        M.call(this);
        this._id = Rn--;
        this.name = a || "";
        this.type = b;
        this.tags = new ad(this);
        this._preload = !1;
        this.variants = new ti(this);
        this._file = null;
        this._data = d || {};
        this.options = e || {};
        this._resources = [];
        this._i18n = {};
        this.loading = this.loaded = !1;
        this.registry = null;
        c && (this.file = c)
    }
    function fd() {}
    function ui() {
        this.retryRequests = !1
    }
    function vi() {
        this.retryRequests = !1
    }
    function yf(a) {
        this._layers = [];
        this._parameters = {};
        var b;
        if (Array.isArray(a.layers))
            this._layers = a.layers;
        else
            for (var c in a.layers) {
                var d = a.layers[c]
                  , e = {
                    name: d.name,
                    states: [],
                    transitions: []
                };
                for (b = 0; b < d.states.length; b++)
                    e.states.push(a.states[d.states[b]]);
                for (b = 0; b < d.transitions.length; b++) {
                    var f = a.transitions[d.transitions[b]];
                    if (f.conditions && !Array.isArray(f.conditions)) {
                        for (var g = Object.keys(f.conditions), k = [], h = 0; h < g.length; h++) {
                            var l = f.conditions[g[h]];
                            l.parameterName && k.push(l)
                        }
                        f.conditions = k
                    }
                    Number.isInteger(f.from) && (f.from = a.states[f.from].name);
                    Number.isInteger(f.to) && (f.to = a.states[f.to].name);
                    e.transitions.push(f)
                }
                this._layers.push(e)
            }
        for (var n in a.parameters)
            b = a.parameters[n],
            this._parameters[b.name] = {
                type: b.type,
                value: b.value
            }
    }
    function wi() {
        this.retryRequests = !1
    }
    function Kg(a) {
        a instanceof Audio ? this.audio = a : this.buffer = a
    }
    function zf(a) {
        this.manager = a;
        this.retryRequests = !1
    }
    function xi() {
        this.retryRequests = !1
    }
    function Af(a) {
        this._blobUrls = {};
        for (var b = 0, c = a.length; b < c; b++)
            a[b].url && (this._blobUrls[a[b].name] = a[b].url)
    }
    function Sk(a) {
        function b(f) {
            this._fields = f
        }
        function c(f) {
            this._arrayBuffer = f || new ArrayBuffer(0);
            this._bufferView = new DataView(this._arrayBuffer);
            this._paxHeader = this._globalPaxHeader = null;
            this._bytesRead = 0
        }
        if ("undefined" !== typeof TextDecoder) {
            var d = new TextDecoder("utf-8");
            var e = new TextDecoder("windows-1252")
        } else
            console.warn("TextDecoder not supported - pc.Untar module will not work");
        b.parse = function(f, g, k) {
            for (var h = new Uint8Array(f,g,k), l = 0, n = []; l < k; ) {
                var p;
                for (p = l; p < k && 32 != h[p]; p++)
                    ;
                if (p >= k)
                    throw Error("Invalid PAX header data format.");
                var q = parseInt(d.decode(new Uint8Array(f,g + l,p - l)), 10);
                p = d.decode(new Uint8Array(f,g + p + 1,q - (p - l) - 2)).split("=");
                if (2 !== p.length)
                    throw Error("Invalid PAX header data format.");
                0 === p[1].length && (p[1] = null);
                n.push({
                    name: p[0],
                    value: p[1]
                });
                l += q
            }
            return new b(n)
        }
        ;
        b.prototype.applyHeader = function(f) {
            for (var g = 0; g < this._fields.length; g++) {
                var k = this._fields[g].name
                  , h = this._fields[g].value;
                "path" === k && (k = "name");
                null === h ? delete f[k] : f[k] = h
            }
        }
        ;
        a || (Tk = c);
        c.prototype._hasNext = function() {
            return this._bytesRead + 4 < this._arrayBuffer.byteLength && 0 !== this._bufferView.getUint32(this._bytesRead)
        }
        ;
        c.prototype._readNextFile = function() {
            var f = new DataView(this._arrayBuffer,this._bytesRead,512)
              , g = e.decode(f);
            this._bytesRead += 512;
            f = g.substr(0, 100).replace(/\0/g, "");
            var k = g.substr(257, 6)
              , h = parseInt(g.substr(124, 12), 8)
              , l = g.substr(156, 1)
              , n = this._bytesRead
              , p = null
              , q = !1;
            switch (l) {
            case "0":
            case "":
                q = !0;
                a || (p = new Blob([this._arrayBuffer.slice(this._bytesRead, this._bytesRead + h)]),
                p = URL.createObjectURL(p));
                break;
            case "g":
                this._globalPaxHeader = b.parse(this._arrayBuffer, this._bytesRead, h);
                break;
            case "x":
                this._paxHeader = b.parse(this._arrayBuffer, this._bytesRead, h)
            }
            this._bytesRead += h;
            l = h % 512;
            0 !== l && (this._bytesRead += 512 - l);
            if (!q)
                return null;
            -1 !== k.indexOf("ustar") && (g = g.substr(345, 155).replace(/\0/g, ""),
            0 < g.length && (f = g.trim() + f.trim()));
            f = {
                name: f,
                start: n,
                size: h,
                url: p
            };
            this._globalPaxHeader && this._globalPaxHeader.applyHeader(f);
            this._paxHeader && (this._paxHeader.applyHeader(f),
            this._paxHeader = null);
            return f
        }
        ;
        c.prototype.untar = function(f) {
            if (!d)
                return console.error("Cannot untar because TextDecoder interface is not available for this platform."),
                [];
            for (var g = []; this._hasNext(); ) {
                var k = this._readNextFile();
                k && (f && k.name && (k.name = f + k.name),
                g.push(k))
            }
            return g
        }
        ;
        a && (self.onmessage = function(f) {
            var g = f.data.id;
            try {
                var k = (new c(f.data.arrayBuffer)).untar(f.data.prefix);
                postMessage({
                    id: g,
                    files: k,
                    arrayBuffer: f.data.arrayBuffer
                }, [f.data.arrayBuffer])
            } catch (h) {
                postMessage({
                    id: g,
                    error: h.toString()
                })
            }
        }
        )
    }
    function Bf(a) {
        this._requestId = 0;
        this._pendingRequests = {};
        this._filenamePrefix = a;
        a = Worker;
        if (!yi) {
            var b = new Blob(["(" + Sk.toString() + ")(true)\n\n"],{
                type: "application/javascript"
            });
            yi = URL.createObjectURL(b)
        }
        this._worker = new a(yi);
        this._worker.addEventListener("message", this._onMessage.bind(this))
    }
    function zi(a) {
        this._assets = a;
        this._worker = null;
        this.retryRequests = !1
    }
    function Ai(a) {
        this.data = a;
        this.model = null;
        this.materials = [];
        this.textures = [];
        this.animations = [];
        this.registry = null
    }
    function Bi(a, b) {
        this._device = a;
        this._defaultMaterial = b
    }
    function Ci() {
        this.retryRequests = !1
    }
    function Di(a, b, c) {
        this._device = a;
        this._registry = b;
        this._loader = c
    }
    function Ei() {}
    function Lg(a, b) {
        this.type = b ? b.type || "msdf" : "msdf";
        this.em = 1;
        this.textures = a;
        this.intensity = 0;
        this._data = null;
        this.data = b
    }
    function Fi(a) {
        3 > a.version && (2 > a.version && (a.info.maps = a.info.maps || [{
            width: a.info.width,
            height: a.info.height
        }]),
        a.chars = Object.keys(a.chars || {}).reduce(function(b, c) {
            var d = a.chars[c];
            c = void 0 !== d.letter ? d.letter : vc.fromCodePoint(c);
            2 > a.version && (d.map = d.map || 0);
            b[c] = d;
            return b
        }, {}),
        a.version = 3);
        return a
    }
    function Gi(a) {
        this._loader = a;
        this.retryRequests = !1
    }
    function Eb(a, b) {
        M.call(this);
        this._assets = [];
        this._registry = b;
        this._loaded = !1;
        this._total = this._count = 0;
        this._failed = [];
        this._waitingAssets = [];
        if (a.length && a[0]instanceof aa)
            this._assets = a;
        else
            for (var c = 0; c < a.length; c++) {
                var d = b.get(a[c]);
                d ? this._assets.push(d) : (this._waitForAsset(a[c]),
                this._total++)
            }
    }
    function Mg(a, b) {
        this._node = a;
        this._data = b
    }
    function Ng(a, b) {
        this._app = a;
        this._isTemplate = b
    }
    function Hi(a) {
        this._app = a;
        this.retryRequests = !1
    }
    function Ii() {
        this.retryRequests = !1
    }
    function Ji() {
        this.retryRequests = !1
    }
    function wc(a, b, c, d, e) {
        this.propertyName = a;
        this.parent = b;
        this._scope = e;
        this._registry = c;
        this.asset = this.url = this.id = null;
        this._onAssetLoad = d.load;
        this._onAssetAdd = d.add;
        this._onAssetRemove = d.remove
    }
    function Cf() {
        this.valid = this.removeInvalid = !0;
        this.enumValidators = {
            occludeSpecular: this._createEnumValidator([0, 1, 2]),
            cull: this._createEnumValidator([0, 1, 2, 3]),
            blendType: this._createEnumValidator([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),
            shadingModel: this._createEnumValidator([0, 1])
        }
    }
    function ve() {
        this._validator = null
    }
    function Ki(a) {
        this._assets = a.assets;
        this._device = a.graphicsDevice;
        this._placeholderTextures = null;
        this._parser = new ve;
        this.retryRequests = !1
    }
    function Uk(a) {
        this._device = a;
        this._defaultMaterial = ea.getApplication().scene.defaultMaterial
    }
    function Sn() {
        this.index = 0;
        this.boneIndices = [0, 0, 0, 0]
    }
    function Vk() {
        this.indexCount = this.indexStart = this.vertexCount = this.vertexStart = this.partition = 0;
        this.boneIndices = [];
        this.vertices = [];
        this.indices = [];
        this.indexMap = {}
    }
    function Tn(a) {
        var b = a.vertices
          , c = a.skins
          , d = a.meshes
          , e = a.meshInstances;
        for (a = 0; a < d.length; a++)
            d[a].vertices = b[d[a].vertices],
            void 0 !== d[a].skin && (d[a].skin = c[d[a].skin]);
        for (a = 0; a < e.length; a++)
            e[a].mesh = d[e[a].mesh]
    }
    function Un(a) {
        var b = a.vertices
          , c = a.skins
          , d = a.meshes
          , e = a.meshInstances;
        for (a = 0; a < d.length; a++)
            d[a].vertices = b.indexOf(d[a].vertices),
            void 0 !== d[a].skin && (d[a].skin = c.indexOf(d[a].skin));
        for (a = 0; a < e.length; a++)
            e[a].mesh = d.indexOf(e[a].mesh)
    }
    function Wk(a, b, c) {
        var d, e;
        Tn(a);
        var f = a.vertices
          , g = a.skins
          , k = a.meshes
          , h = a.meshInstances
          , l = function(D) {
            var G = new Sn;
            G.index = D;
            return G
        };
        for (d = g.length - 1; 0 <= d; d--)
            if (g[d].boneNames.length > c) {
                var n = g.splice(d, 1)[0]
                  , p = [];
                for (e = 0; e < k.length; e++)
                    k[e].skin === n && p.push(k[e]);
                for (e = 0; e < p.length; e++) {
                    var q = k.indexOf(p[e]);
                    -1 !== q && k.splice(q, 1)
                }
                if (0 === p.length)
                    throw Error("partitionSkin: There should be at least one mesh that references a skin");
                var r = p[0].vertices;
                for (e = 1; e < p.length; e++)
                    if (p[e].vertices !== r)
                        throw Error("partitionSkin: All meshes that share a skin should also share the same vertex buffer");
                var t = []
                  , u = [];
                var x = [];
                var v = 0;
                for (e = 0; e < p.length; e++) {
                    var w = p[e];
                    for (var y = w.indices, A = w.base; A < w.base + w.count; ) {
                        q = y[A++];
                        u[0] = l(q);
                        x[0] = q;
                        q = y[A++];
                        u[1] = l(q);
                        x[1] = q;
                        q = y[A++];
                        u[2] = l(q);
                        x[2] = q;
                        for (var B = !1, E = v; E < t.length; E++)
                            if (q = t[E],
                            q.addPrimitive(u, x, r, c)) {
                                B = !0;
                                break
                            }
                        B || (q = new Vk,
                        q.originalMesh = w,
                        q.addPrimitive(u, x, r, c),
                        t.push(q))
                    }
                    v = t.length
                }
                w = [];
                p = [];
                for (e = 0; e < t.length; e++)
                    if (q = t[e],
                    q.vertices.length && q.indices.length) {
                        u = w.length;
                        x = q.vertices.length;
                        v = p.length;
                        y = q.indices.length;
                        q.partition = e;
                        q.vertexStart = u;
                        q.vertexCount = x;
                        q.indexStart = v;
                        q.indexCount = y;
                        A = 0;
                        for (B = u; A < x; )
                            w[B++] = q.vertices[A++];
                        A = 0;
                        for (B = v; A < y; )
                            p[B++] = q.indices[A++] + u
                    }
                u = [];
                for (e = 0; e < t.length; e++) {
                    q = t[e];
                    v = [];
                    y = [];
                    for (x = 0; x < q.boneIndices.length; x++)
                        v.push(n.inverseBindMatrices[q.boneIndices[x]]),
                        y.push(n.boneNames[q.boneIndices[x]]);
                    q = {
                        inverseBindMatrices: v,
                        boneNames: y
                    };
                    u.push(q);
                    g.push(q)
                }
                var C;
                n = {};
                for (C in r)
                    n[C] = {
                        components: r[C].components,
                        data: [],
                        type: r[C].type
                    };
                for (C in r)
                    if ("blendIndices" === C)
                        for (q = n[C].data,
                        e = 0; e < w.length; e++)
                            x = w[e].boneIndices,
                            q.push(x[0], x[1], x[2], x[3]);
                    else
                        for (e = r[C],
                        v = e.data,
                        y = e.components,
                        e = 0; e < w.length; e++)
                            for (q = w[e].index,
                            x = 0; x < y; x++)
                                n[C].data.push(v[q * y + x]);
                f[f.indexOf(r)] = n;
                for (e = 0; e < t.length; e++)
                    for (q = t[e],
                    w = {
                        aabb: {
                            min: [0, 0, 0],
                            max: [0, 0, 0]
                        },
                        vertices: n,
                        skin: u[e],
                        indices: p.splice(0, q.indexCount),
                        type: "triangles",
                        base: 0,
                        count: q.indexCount
                    },
                    k.push(w),
                    x = h.length - 1; 0 <= x; x--)
                        h[x].mesh === q.originalMesh && (h.push({
                            mesh: w,
                            node: h[x].node
                        }),
                        b && b.push({
                            material: b[x].material,
                            path: b[x].path
                        }));
                for (e = 0; e < t.length; e++)
                    for (q = t[e],
                    x = h.length - 1; 0 <= x; x--)
                        h[x].mesh === q.originalMesh && (h.splice(x, 1),
                        b && b.splice(x, 1))
            }
        Un(a)
    }
    function Xk(a) {
        this._device = a;
        this._defaultMaterial = ea.getApplication().scene.defaultMaterial
    }
    function Li(a, b) {
        this._device = a;
        this._parsers = [];
        this._defaultMaterial = b;
        this.retryRequests = !1;
        this.addParser(new Xk(this._device), function(c, d) {
            return ".json" === ca.getExtension(c)
        });
        this.addParser(new Uk(this._device), function(c, d) {
            return ".glb" === ca.getExtension(c)
        })
    }
    function Mi(a) {
        this._handlers = {};
        this._requests = {};
        this._cache = {};
        this._app = a
    }
    function Ni(a) {
        this._app = a;
        this.retryRequests = !1
    }
    function Oi(a) {
        this._app = a;
        this.retryRequests = !1
    }
    function tb(a) {
        this._app = a;
        this._scripts = {};
        this._cache = {}
    }
    function Pi() {
        this.retryRequests = !1
    }
    function Sa(a, b) {
        M.call(this);
        this._device = a;
        this._pixelsPerUnit = b && void 0 !== b.pixelsPerUnit ? b.pixelsPerUnit : 1;
        this._renderMode = b && void 0 !== b.renderMode ? b.renderMode : 0;
        this._atlas = b && void 0 !== b.atlas ? b.atlas : null;
        this._frameKeys = b && void 0 !== b.frameKeys ? b.frameKeys : null;
        this._meshes = [];
        this._meshesDirty = this._updatingProperties = !1;
        this._atlas && this._frameKeys && this._createMeshes()
    }
    function Qi(a, b) {
        this._assets = a;
        this._device = b;
        this.retryRequests = !1
    }
    function Ri(a) {
        this.resource && (this.resource.atlas = a.resource)
    }
    function Si(a) {
        this.registry.load(a)
    }
    function Og(a, b) {
        this._app = a;
        this._data = b;
        this._templateRoot = null
    }
    function Ti(a) {
        this._app = a
    }
    function Ui() {
        this.retryRequests = !1
    }
    function xc() {
        M.call(this);
        this._frames = this._texture = null
    }
    function Vi(a) {
        this._loader = a;
        this.retryRequests = !1
    }
    function Vn() {
        var a = {
            astc: 10,
            dxt: 2,
            etc2: 0,
            etc1: 0,
            pvr: 8,
            atc: 11,
            none: 14
        }
          , b = {
            astc: 10,
            dxt: 3,
            etc2: 1,
            etc1: 16,
            pvr: 9,
            atc: 12,
            none: 16
        }
          , c = {
            0: 21,
            1: 23,
            2: 8,
            3: 10,
            8: 26,
            9: 27,
            10: 28,
            11: 29,
            12: 30,
            13: 7,
            14: 3,
            16: 5
        }
          , d = "undefined" !== typeof performance
          , e = function(l, n, p, q, r) {
            var t = d ? performance.now() : 0
              , u = new l.BasisFile(new Uint8Array(q));
            l = u.getImageWidth(0, 0);
            q = u.getImageHeight(0, 0);
            var x = u.getNumImages()
              , v = u.getNumLevels(0)
              , w = !!u.getHasAlpha();
            if (!(l && q && x && v))
                throw u.close(),
                u.delete(),
                Error("Invalid image dimensions url=" + n + " width=" + l + " height=" + q + " images=" + x + " levels=" + v);
            p = w ? b[p] : a[p];
            if (8 === p || 9 === p)
                if (0 !== (l & l - 1) || l !== q)
                    p = 8 === p ? 14 : 13;
            r && r.unswizzleGGGR && (p = 13);
            if (!u.startTranscoding())
                throw u.close(),
                u.delete(),
                Error("Failed to start transcoding url=" + n);
            w = [];
            for (var y = 0; y < v; ++y) {
                var A = u.getImageTranscodedSizeInBytes(0, y, p)
                  , B = new Uint8Array(A);
                if (!u.transcodeImage(B, 0, y, p, 1, 0))
                    throw u.close(),
                    u.delete(),
                    Error("Failed to transcode image url=" + n);
                if (14 === p || 16 === p) {
                    var E = new Uint16Array(A / 2);
                    for (x = 0; x < A / 2; ++x)
                        E[x] = B[2 * x] + 256 * B[2 * x + 1];
                    B = E
                }
                w.push(B)
            }
            u.close();
            u.delete();
            if (r && r.unswizzleGGGR)
                for (p = 14,
                x = 0; x < w.length; ++x) {
                    r = x;
                    u = w[x];
                    for (v = 0; v < u.length; v += 4)
                        A = u[v + 3],
                        y = u[v + 1],
                        u[v + 0] = A,
                        A = 2 / 255 * A - 1,
                        y = 2 / 255 * y - 1,
                        u[v + 2] = Math.max(0, Math.min(255, Math.floor(127.5 * (Math.sqrt(1 - Math.min(1, A * A + y * y)) + 1)))),
                        u[v + 3] = 255;
                    v = new Uint16Array(u.length / 4);
                    for (y = 0; y < u.length; y += 4)
                        v[y / 4] = (u[y + 0] & 248) << 8 | (u[y + 1] & 252) << 3 | u[y + 2] >> 3;
                    w[r] = v
                }
            return {
                format: c[p],
                width: l + 3 & -4,
                height: q + 3 & -4,
                levels: w,
                cubemap: !1,
                mipmaps: !0,
                transcodeTime: d ? performance.now() - t : 0,
                url: n
            }
        }
          , f = null
          , g = []
          , k = function(l, n, p, q) {
            try {
                var r = e(f, l, n, p, q);
                r.levels = r.levels.map(function(t) {
                    return t.buffer
                });
                self.postMessage({
                    url: l,
                    data: r
                }, r.levels)
            } catch (t) {
                self.postMessage({
                    url: l.toString(),
                    err: t.toString()
                })
            }
        }
          , h = function(l) {
            var n = function(p, q) {
                WebAssembly.instantiate(l, p).then(function(r) {
                    q(r)
                });
                return {}
            };
            self.BASIS(l ? {
                instantiateWasm: n
            } : null).then(function(p) {
                f = p;
                f.initializeBasis();
                for (p = 0; p < g.length; ++p)
                    k(g[p].url, g[p].format, g[p].data, g[p].options);
                g = []
            })
        };
        self.onmessage = function(l) {
            l = l.data;
            switch (l.type) {
            case "init":
                h(l.module);
                break;
            case "transcode":
                f ? k(l.url, l.format, l.data, l.options) : g.push(l)
            }
        }
    }
    function Wi() {
        if (!Xi) {
            var a = ea.getApplication().graphicsDevice;
            Xi = a.extCompressedTextureASTC ? "astc" : a.extCompressedTextureS3TC ? "dxt" : a.extCompressedTextureETC ? "etc2" : a.extCompressedTextureETC1 ? "etc1" : a.extCompressedTexturePVRTC ? "pvr" : a.extCompressedTextureATC ? "atc" : "none"
        }
        return Xi
    }
    function Wn(a) {
        var b = a.data.url
          , c = a.data.err;
        a = a.data.data;
        var d = Df[b];
        if (d) {
            var e;
            if (c)
                for (e = 0; e < d.length; ++e)
                    d[e](c);
            else {
                a.levels = 3 === a.format || 5 === a.format ? a.levels.map(function(f) {
                    return new Uint16Array(f)
                }) : a.levels.map(function(f) {
                    return new Uint8Array(f)
                });
                for (e = 0; e < d.length; ++e)
                    d[e](null, a);
                delete Df[b]
            }
        } else
            console.error("internal logical error encountered in basis transcoder")
    }
    function Yk(a, b, c, d) {
        Df.hasOwnProperty(a) ? Df[a].push(c) : (Df[a] = [c],
        Ef.postMessage({
            type: "transcode",
            url: a,
            format: Wi(),
            data: b,
            options: d
        }, [b]))
    }
    function Yi(a, b, c) {
        a = ["/* basis.js */", a, "/* mappings */\nvar PIXELFORMAT_ETC1 = 21;\nvar PIXELFORMAT_ETC2_RGBA = 23;\nvar PIXELFORMAT_DXT1 = 8;\nvar PIXELFORMAT_DXT5 = 10;\nvar PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;\nvar PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;\nvar PIXELFORMAT_ASTC_4x4 = 28;\nvar PIXELFORMAT_ATC_RGB = 29;\nvar PIXELFORMAT_ATC_RGBA = 30;\nvar PIXELFORMAT_R8_G8_B8_A8 = 7;\nvar PIXELFORMAT_R5_G6_B5 = 3;\nvar PIXELFORMAT_R4_G4_B4_A4 = 5;\n\n/* worker */", "(" + Vn.toString() + ")()\n\n"].join("\n");
        a = new Blob([a],{
            type: "application/javascript"
        });
        a = URL.createObjectURL(a);
        Ef = new Worker(a);
        Ef.addEventListener("message", Wn);
        Ef.postMessage({
            type: "init",
            module: b
        });
        c && c();
        for (b = 0; b < Zi.length; ++b)
            c = Zi[b],
            Yk(c.url, c.data, c.callback, c.options)
    }
    function $i(a, b, c, d) {
        aj && console.warn("basis module is being downloaded more than once");
        aj = !0;
        if (Xn) {
            var e = null
              , f = null
              , g = function() {
                e && f && Yi(e, f, d)
            }
              , k = function() {
                wa.get(b, {
                    cache: !0,
                    responseType: "arraybuffer",
                    retry: !1
                }, function(h, l) {
                    l && WebAssembly.compile(l).then(function(n) {
                        f = n;
                        g()
                    })
                })
            };
            WebAssembly.compileStreaming ? WebAssembly.compileStreaming(fetch(b)).then(function(h) {
                f = h;
                g()
            }).catch(function(h) {
                console.error(h);
                console.warn("compileStreaming() failed for " + b + ", falling back to arraybuffer download...");
                k()
            }) : k();
            wa.get(a, {
                cache: !0,
                responseType: "text",
                retry: !1
            }, function(h, l) {
                e = l;
                g()
            })
        } else
            wa.get(c, {
                cache: !0,
                responseType: "text",
                retry: !1
            }, function(h, l) {
                l && Yi(l, null, d)
            })
    }
    function Zk(a) {
        if (Ff)
            $i(Ff.glueUrl, Ff.wasmUrl, Ff.fallbackUrl, a);
        else {
            var b = ((window.config ? window.config.wasmModules : window.PRELOAD_MODULES) || []).find(function(d) {
                return "BASIS" === d.moduleName
            });
            if (b) {
                var c = window.ASSET_PREFIX ? window.ASSET_PREFIX : "";
                $i(c + b.glueUrl, c + b.wasmUrl, c + b.fallbackUrl, a)
            }
        }
    }
    function $k(a, b, c, d) {
        Ef ? Yk(a, b, c, d) : (Zi.push({
            url: a,
            data: b,
            callback: c,
            options: d
        }),
        aj || Zk())
    }
    function bj(a, b) {
        this.retryRequests = !!b
    }
    function cj(a, b) {
        this.crossOrigin = a.prefix ? "anonymous" : null;
        this.retryRequests = !!b;
        this.useImageBitmap = !1
    }
    function dj(a, b) {
        this.retryRequests = !!b
    }
    function ej(a, b) {
        this.retryRequests = !!b
    }
    function al() {}
    function Pg(a, b, c) {
        this._device = a;
        this._assets = b;
        this._loader = c;
        this.imgParser = new cj(b,!1);
        this.parsers = {
            dds: new ej(b,!1),
            ktx: new dj(b,!1),
            basis: new bj(b,!1)
        }
    }
    function Ld(a) {
        M.call(this);
        this._loader = a;
        this._assets = [];
        this._cache = {};
        this._names = {};
        this._tags = new uk("_id");
        this._urls = {};
        this.prefix = null
    }
    function fj(a) {
        this._assets = a;
        this._bundleAssets = {};
        this._assetsInBundles = {};
        this._urlsInBundles = {};
        this._fileRequests = {};
        this._assets.on("add", this._onAssetAdded, this);
        this._assets.on("remove", this._onAssetRemoved, this)
    }
    function fc(a) {
        M.call(this);
        this.app = a;
        this._scripts = {};
        this._list = []
    }
    function Md(a, b) {
        M.call(this);
        var c = this;
        this._app = a;
        this._device = a.graphicsDevice;
        this.id = b.displayId;
        this._frameData = null;
        window.VRFrameData && (this._frameData = new window.VRFrameData);
        this.display = b;
        this._camera = null;
        this.sitToStandInv = new K;
        this.leftView = new K;
        this.leftProj = new K;
        this.leftViewInv = new K;
        this.leftPos = new z;
        this.rightView = new K;
        this.rightProj = new K;
        this.rightViewInv = new K;
        this.rightPos = new z;
        this.combinedPos = new z;
        this.combinedView = new K;
        this.combinedProj = new K;
        this.combinedViewInv = new K;
        this.combinedAspect = this.combinedFov = 0;
        this.presenting = !1;
        c._presentChange = function(d) {
            if ((d.display ? d.display : d.detail && d.detail.display ? d.detail.display : d.detail && d.detail.vrdisplay ? d.detail.vrdisplay : c.display) === c.display) {
                c.presenting = c.display && c.display.isPresenting;
                if (c.presenting) {
                    d = c.display.getEyeParameters("left");
                    var e = c.display.getEyeParameters("right");
                    c._app.graphicsDevice.setResolution(2 * Math.max(d.renderWidth, e.renderWidth), Math.max(d.renderHeight, e.renderHeight));
                    c._app._allowResize = !1
                } else
                    c._app.setCanvasResolution("AUTO"),
                    c._app._allowResize = !0;
                c.fire("beforepresentchange", c);
                c.fire("presentchange", c)
            }
        }
        ;
        window.addEventListener("vrdisplaypresentchange", c._presentChange, !1)
    }
    function gd(a) {
        M.call(this);
        var b = this;
        this.isSupported = gd.isSupported;
        this._index = {};
        this.displays = [];
        this.display = null;
        this._app = a;
        this._onDisplayConnect = this._onDisplayConnect.bind(this);
        this._onDisplayDisconnect = this._onDisplayDisconnect.bind(this);
        b._attach();
        this._getDisplays(function(c, d) {
            if (c)
                b.fire("error", c);
            else {
                for (c = 0; c < d.length; c++)
                    b._addDisplay(d[c]);
                b.fire("ready", b.displays)
            }
        })
    }
    function Jc(a, b, c) {
        M.call(this);
        this.manager = a;
        this._xrHitTestSource = b;
        this._transient = c
    }
    function Sb(a) {
        M.call(this);
        this.manager = a;
        this._supported = !(!window.XRSession || !window.XRSession.prototype.requestHitTestSource);
        this._session = null;
        this.sources = [];
        this._supported && (this.manager.on("start", this._onSessionStart, this),
        this.manager.on("end", this._onSessionEnd, this))
    }
    function Gf(a, b) {
        this._index = a;
        this._hand = b;
        this._hand._fingers.push(this);
        this._joints = [];
        this._tip = null
    }
    function Tb(a, b, c, d) {
        this._index = a;
        this._id = b;
        this._hand = c;
        this._hand._joints.push(this);
        this._hand._jointsById[b] = this;
        (this._finger = d || null) && this._finger._joints.push(this);
        if (this._wrist = b === XRHand.WRIST)
            this._hand._wrist = this;
        if (this._tip = this._finger && !!bl[b])
            this._hand._tips.push(this),
            this._finger && (this._finger._tip = this);
        this._radius = null;
        this._localTransform = new K;
        this._worldTransform = new K;
        this._localPosition = new z;
        this._localRotation = new Y;
        this._position = new z;
        this._rotation = new Y;
        this._dirtyLocal = !0
    }
    function gc(a) {
        M.call(this);
        var b = a._xrInputSource.hand;
        this._manager = a._manager;
        this._inputSource = a;
        this._tracking = !1;
        this._fingers = [];
        this._joints = [];
        this._jointsById = {};
        this._tips = [];
        this._wrist = null;
        b[XRHand.WRIST] && (this._wrist = new Tb(0,XRHand.WRIST,this,null));
        for (a = 0; a < Qg.length; a++)
            for (var c = new Gf(a,this), d = 0; d < Qg[a].length; d++) {
                var e = Qg[a][d];
                b[e] && new Tb(d,e,this,c)
            }
    }
    function ta(a, b) {
        M.call(this);
        this._id = ++Yn;
        this._manager = a;
        this._xrInputSource = b;
        this._ray = new bd;
        this._rayLocal = new bd;
        this._grip = !1;
        this._hand = null;
        b.hand && (this._hand = new gc(this));
        this._worldTransform = this._localTransform = null;
        this._position = new z;
        this._rotation = new Y;
        this._localRotation = this._localPosition = null;
        this._dirtyLocal = !0;
        this._selecting = !1;
        this._elementInput = !0;
        this._elementEntity = null;
        this._hitTestSources = []
    }
    function Fb(a) {
        M.call(this);
        var b = this;
        this.manager = a;
        this._session = null;
        this._inputSources = [];
        this._onInputSourcesChangeEvt = function(c) {
            b._onInputSourcesChange(c)
        }
        ;
        this.manager.on("start", this._onSessionStart, this);
        this.manager.on("end", this._onSessionEnd, this)
    }
    function hb(a) {
        M.call(this);
        this._manager = a;
        this._lightProbeRequested = this._available = this._supported = !1;
        this._lightProbe = null;
        this._intensity = 0;
        this._rotation = new Y;
        this._color = new L;
        this._sphericalHarmonics = new Float32Array(27);
        this._manager.on("start", this._onSessionStart, this);
        this._manager.on("end", this._onSessionEnd, this)
    }
    function Pa(a) {
        M.call(this);
        var b = this;
        this.app = a;
        this._supported = !!navigator.xr;
        this._available = {};
        this._available[cl] = !1;
        this._available[gj] = !1;
        this._available[Nd] = !1;
        this._referenceSpace = this._baseLayer = this._session = this._spaceType = this._type = null;
        this.input = new Fb(this);
        this.hitTest = new Sb(this);
        this.lightEstimation = new hb(this);
        this._camera = null;
        this.views = [];
        this.viewsPool = [];
        this._localPosition = new z;
        this._localRotation = new Y;
        this._depthNear = .1;
        this._depthFar = 1E3;
        this._height = this._width = 0;
        this._supported && (navigator.xr.addEventListener("devicechange", function() {
            b._deviceAvailabilityCheck()
        }),
        this._deviceAvailabilityCheck())
    }
    function O(a, b) {
        M.call(this);
        this.system = a;
        this.entity = b;
        this.system.schema && !this._accessorsBuilt && this.buildAccessors(this.system.schema);
        this.on("set", function(c, d, e) {
            this.fire("set_" + c, c, d, e)
        });
        this.on("set_enabled", this.onSetEnabled, this)
    }
    function H(a) {
        M.call(this);
        this.app = a;
        this.store = {};
        this.schema = []
    }
    function Zn(a, b) {
        if (!a)
            return a;
        switch (b) {
        case "rgb":
            return a instanceof L ? a.clone() : new L(a[0],a[1],a[2]);
        case "rgba":
            return a instanceof L ? a.clone() : new L(a[0],a[1],a[2],a[3]);
        case "vec2":
            return a instanceof P ? a.clone() : new P(a[0],a[1]);
        case "vec3":
            return a instanceof z ? a.clone() : new z(a[0],a[1],a[2]);
        case "vec4":
            return a instanceof X ? a.clone() : new X(a[0],a[1],a[2],a[3]);
        case "boolean":
        case "number":
        case "string":
            return a;
        case "entity":
            return a;
        default:
            throw Error("Could not convert unhandled type: " + b);
        }
    }
    function dl() {
        this._written = !1;
        this._name = "";
        this._keyFrames = [];
        this._quat = new Y;
        this._pos = new z;
        this._scale = new z;
        this._targetNode = null
    }
    function Ta(a) {
        function b(d) {
            var e = new dl;
            e._name = d.name;
            c._interpolatedKeys.push(e);
            c._interpolatedKeyDict[d.name] = e;
            for (e = c._currKeyIndices[d.name] = 0; e < d._children.length; e++)
                b(d._children[e])
        }
        this._animation = null;
        this._time = 0;
        this.looping = !0;
        this._interpolatedKeys = [];
        this._interpolatedKeyDict = {};
        this._currKeyIndices = {};
        this.graph = null;
        var c = this;
        b(a)
    }
    function hd(a, b) {
        O.call(this, a, b);
        this.animationsIndex = {};
        this.on("set_animations", this.onSetAnimations, this);
        this.on("set_assets", this.onSetAssets, this);
        this.on("set_loop", this.onSetLoop, this)
    }
    function $n() {
        this.assets = [];
        this.speed = 1;
        this.enabled = this.activate = this.loop = !0;
        this.animations = {};
        this.currAnim = this.prevAnim = this.model = null;
        this.blending = !1;
        this.blendSpeed = this.blend = 0;
        this.playing = !1;
        this.animEvaluator = this.toSkel = this.fromSkel = this.skeleton = null
    }
    function we(a) {
        H.call(this, a);
        this.id = "animation";
        this.ComponentType = hd;
        this.DataType = $n;
        this.schema = el;
        this.on("beforeremove", this.onBeforeRemove, this);
        this.on("update", this.onUpdate, this);
        H.bind("update", this.onUpdate, this)
    }
    function Ua(a, b) {
        this.animComponent = a;
        b ? xf.call(this, b) : this.propertyLocator = new uf
    }
    function Rg(a, b, c) {
        this._name = a;
        this._controller = b;
        this._component = c
    }
    function fl(a, b, c, d) {
        this._controller = a;
        this._name = b;
        this._animations = [];
        this._speed = c || 1;
        this._loop = void 0 === d ? !0 : d
    }
    function hj(a, b, c, d, e, f, g, k, h) {
        this._controller = a;
        this._from = b;
        this._to = c;
        this._time = d;
        this._priority = e;
        this._conditions = f || [];
        this._exitTime = g || null;
        this._transitionOffset = k || null;
        this._interruptionSource = h || "NONE"
    }
    function Sg(a, b, c, d, e) {
        this._animEvaluator = a;
        this._states = {};
        this._stateNames = [];
        for (a = 0; a < b.length; a++)
            this._states[b[a].name] = new fl(this,b[a].name,b[a].speed,b[a].loop),
            this._stateNames.push(b[a].name);
        this._transitions = c.map(function(f) {
            return new hj(this,f.from,f.to,f.time,f.priority,f.conditions,f.exitTime,f.transitionOffset,f.interruptionSource)
        }
        .bind(this));
        this._findTransitionsFromStateCache = {};
        this._findTransitionsBetweenStatesCache = {};
        this._parameters = d;
        this._previousStateName = null;
        this._activeStateName = "START";
        this._playing = !1;
        this._activate = e;
        this._totalTransitionTime = this._currTransitionTime = 1;
        this._isTransitioning = !1;
        this._transitionInterruptionSource = "NONE";
        this._transitionPreviousStates = [];
        this._timeInStateBefore = this._timeInState = 0
    }
    function id(a, b) {
        O.call(this, a, b)
    }
    function ao() {
        this.stateGraphAsset = null;
        this.animationAssets = {};
        this.speed = 1;
        this.enabled = this.activate = !0;
        this.playing = !1;
        this.stateGraph = null;
        this.layers = [];
        this.layerIndices = {};
        this.parameters = {}
    }
    function xe(a) {
        H.call(this, a);
        this.id = "anim";
        this.ComponentType = id;
        this.DataType = ao;
        this.schema = gl;
        this.on("beforeremove", this.onBeforeRemove, this);
        H.bind("animationUpdate", this.onAnimationUpdate, this)
    }
    function Od(a, b) {
        O.call(this, a, b)
    }
    function bo() {
        this.enabled = !0
    }
    function ye(a, b) {
        H.call(this, a);
        this.id = "audiolistener";
        this.ComponentType = Od;
        this.DataType = bo;
        this.schema = hl;
        this.manager = b;
        this.current = null;
        H.bind("update", this.onUpdate, this)
    }
    function Pd(a, b) {
        O.call(this, a, b);
        this.on("set_assets", this.onSetAssets, this);
        this.on("set_loop", this.onSetLoop, this);
        this.on("set_volume", this.onSetVolume, this);
        this.on("set_pitch", this.onSetPitch, this);
        this.on("set_minDistance", this.onSetMinDistance, this);
        this.on("set_maxDistance", this.onSetMaxDistance, this);
        this.on("set_rollOffFactor", this.onSetRollOffFactor, this);
        this.on("set_distanceModel", this.onSetDistanceModel, this);
        this.on("set_3d", this.onSet3d, this)
    }
    function co() {
        this.enabled = !0;
        this.assets = [];
        this.activate = !0;
        this.pitch = this.volume = 1;
        this.loop = !1;
        this["3d"] = !0;
        this.minDistance = 1;
        this.maxDistance = 1E4;
        this.rollOffFactor = 1;
        this.distanceModel = Hf;
        this.paused = !0;
        this.sources = {};
        this.channel = this.currentSource = null
    }
    function ze(a, b) {
        H.call(this, a);
        this.id = "audiosource";
        this.ComponentType = Pd;
        this.DataType = co;
        this.schema = il;
        this.manager = b;
        this.initialized = !1;
        H.bind("initialize", this.onInitialize, this);
        H.bind("update", this.onUpdate, this);
        this.on("remove", this.onRemove, this)
    }
    function Kc(a, b, c) {
        if (a && a instanceof O) {
            if (!b || "string" !== typeof b)
                throw Error("The propertyName argument is required and must be a string");
            if (c && "object" !== typeof c)
                throw Error("If provided, the eventConfig argument must be an object");
        } else
            throw Error("The parentComponent argument is required and must be a Component");
        this._parentComponent = a;
        this._entityPropertyName = b;
        this._entity = null;
        this._app = a.system.app;
        this._configureEventListeners(c || {}, {
            "entity#destroy": this._onEntityDestroy
        });
        this._toggleLifecycleListeners("on")
    }
    function Qd(a, b) {
        O.call(this, a, b);
        this._visualState = Ma.DEFAULT;
        this._isHovering = !1;
        this._hoveringCounter = 0;
        this._isPressed = !1;
        this._defaultTint = new L(1,1,1,1);
        this._defaultSpriteAsset = null;
        this._defaultSpriteFrame = 0;
        this._imageReference = new Kc(this,"imageEntity",{
            "element#gain": this._onImageElementGain,
            "element#lose": this._onImageElementLose,
            "element#set:color": this._onSetColor,
            "element#set:opacity": this._onSetOpacity,
            "element#set:spriteAsset": this._onSetSpriteAsset,
            "element#set:spriteFrame": this._onSetSpriteFrame
        });
        this._toggleLifecycleListeners("on", a)
    }
    function eo() {
        this.active = this.enabled = !0;
        this.imageEntity = null;
        this.hitPadding = new X;
        this.transitionMode = Tg;
        this.hoverTint = new L(.75,.75,.75);
        this.pressedTint = new L(.5,.5,.5);
        this.inactiveTint = new L(.25,.25,.25);
        this.fadeDuration = 0;
        this.hoverSpriteAsset = null;
        this.hoverSpriteFrame = 0;
        this.pressedSpriteAsset = null;
        this.pressedSpriteFrame = 0;
        this.inactiveSpriteAsset = null;
        this.inactiveSpriteFrame = 0
    }
    function Ae(a) {
        H.call(this, a);
        this.id = "button";
        this.ComponentType = Qd;
        this.DataType = eo;
        this.schema = ij;
        this.on("beforeremove", this._onRemoveComponent, this);
        H.bind("update", this.onUpdate, this)
    }
    function Ug(a, b) {
        var c = this;
        this.app = a;
        this.camera = b;
        this.effects = [];
        this.enabled = !1;
        this.depthTarget = null;
        this.renderTargetScale = 1;
        this.resizeTimeout = null;
        this.resizeLast = 0;
        this._resizeTimeoutCallback = function() {
            c.resizeRenderTargets()
        }
        ;
        b.on("set_rect", this.onCameraRectChanged, this);
        this._origStencilColorBuffer = this._origDepthColorBuffer = this._origClearColorBuffer = this._origOverrideClear = !1
    }
    function fo() {
        this.enabled = !0
    }
    function go() {
        this.enabled = !0;
        this.type = "box";
        this.halfExtents = new z(.5,.5,.5);
        this.radius = .5;
        this.axis = 1;
        this.height = 2;
        this.model = this.shape = this.asset = null;
        this.initialized = !1
    }
    function jj(a, b, c) {
        this.entity = b.entity;
        this.component = b;
        this.app = a;
        "undefined" === typeof Ammo || Lc || (Lc = new Ammo.btVector3,
        If = new Ammo.btQuaternion,
        Be = new Ammo.btTransform);
        this.initialize(c)
    }
    function kj() {
        this.list = []
    }
    function Rd(a) {
        this.func = void 0 === a.func ? 7 : a.func;
        this.ref = a.ref || 0;
        this.readMask = void 0 === a.readMask ? 255 : a.readMask;
        this.writeMask = void 0 === a.writeMask ? 255 : a.writeMask;
        this.fail = a.fail || 0;
        this.zfail = a.zfail || 0;
        this.zpass = a.zpass || 0
    }
    function yb(a, b, c) {
        this._entity = a;
        this._element = a.element;
        this.model = new sb;
        this.node = new Z;
        this.model.graph = this.node;
        this.mesh = b;
        this.meshInstance = new va(this.node,this.mesh,c);
        this.meshInstance.name = "ImageElement: " + a.name;
        this.meshInstance.castShadow = !1;
        this._meshDirty = this.meshInstance.receiveShadow = !1;
        this.model.meshInstances.push(this.meshInstance);
        this._entity.addChild(this.model.graph);
        this.model._entity = this._entity;
        this.unmaskMeshInstance = null
    }
    function cb(a) {
        this._element = a;
        this._entity = a.entity;
        this._system = a.system;
        this._sprite = this._spriteAsset = this._material = this._materialAsset = this._texture = this._textureAsset = null;
        this._spriteFrame = 0;
        this._pixelsPerUnit = null;
        this._rect = new X(0,0,1,1);
        this._mask = !1;
        this._maskRef = 0;
        this._outerScale = new P;
        this._outerScaleUniform = new Float32Array(2);
        this._innerOffset = new X;
        this._innerOffsetUniform = new Float32Array(4);
        this._atlasRect = new X;
        this._atlasRectUniform = new Float32Array(4);
        this._defaultMesh = this._createMesh();
        this._renderable = new yb(this._entity,this._defaultMesh,this._material);
        this._color = new L(1,1,1,1);
        this._colorUniform = new Float32Array([1, 1, 1]);
        this._renderable.setParameter("material_emissive", this._colorUniform);
        this._renderable.setParameter("material_opacity", 1);
        this._updateAabbFunc = this._updateAabb.bind(this);
        this._onScreenChange(this._element.screen);
        this._element.on("resize", this._onParentResizeOrPivotChange, this);
        this._element.on("set:pivot", this._onParentResizeOrPivotChange, this);
        this._element.on("screen:set:screenspace", this._onScreenSpaceChange, this);
        this._element.on("set:screen", this._onScreenChange, this);
        this._element.on("set:draworder", this._onDrawOrderChange, this);
        this._element.on("screen:set:resolution", this._onResolutionChange, this)
    }
    function Ga(a) {
        M.call(this);
        this._app = a;
        a.i18n.on("set:locale", this._onSetLocale, this);
        this._disableLocalization = this._autoLoad = !1;
        this._localizedAsset = this._defaultAsset = null
    }
    function jl(a) {
        this._symbols = a;
        this._last = this._index = 0;
        this._cur = 0 < this._symbols.length ? this._symbols[0] : null;
        this._buf = [];
        this._mode = "text";
        this._error = null
    }
    function kl(a, b) {
        for (var c in b)
            if (b.hasOwnProperty(c)) {
                var d = b[c];
                d instanceof Object ? (a.hasOwnProperty(c) || (a[c] = {}),
                kl(a[c], b[c])) : a[c] = d
            }
    }
    function ho(a) {
        if (0 === a.length)
            return null;
        for (var b = {}, c = 0; c < a.length; ++c) {
            var d = a[c]
              , e = {};
            e[d.name] = {
                value: d.value,
                attributes: d.attributes
            };
            kl(b, e)
        }
        return b
    }
    function io(a, b) {
        function c(l) {
            k = k.filter(function(n) {
                return void 0 === l.find(function(p) {
                    return p === n
                })
            })
        }
        function d(l) {
            for (var n = 0; n < l.length; ++n)
                k.push(l[n])
        }
        var e;
        if (0 === a.length)
            return null;
        var f = {};
        for (e = 0; e < a.length; ++e) {
            var g = a[e];
            f.hasOwnProperty(g.start) ? null === f[g.start].open ? f[g.start].open = [g] : f[g.start].open.push(g) : f[g.start] = {
                open: [g],
                close: null
            };
            f.hasOwnProperty(g.end) ? null === f[g.end].close ? f[g.end].close = [g] : f[g.end].close.push(g) : f[g.end] = {
                open: null,
                close: [g]
            }
        }
        var k = [];
        g = Object.keys(f).sort(function(l, n) {
            return l - n
        });
        a = [];
        for (e = 0; e < g.length; ++e) {
            var h = f[g[e]];
            null !== h.close && c(h.close);
            null !== h.open && d(h.open);
            a.push({
                start: g[e],
                tags: ho(k)
            })
        }
        f = [];
        g = null;
        for (e = 0; e < a.length; ++e) {
            for (h = a[e]; f.length < h.start; )
                f.push(g ? g.tags : null);
            g = h
        }
        for (; f.length < b; )
            f.push(null);
        return f
    }
    function jo(a) {
        var b = new ll(a)
          , c = []
          , d = [];
        if (!b.parse(c, d))
            return console.warn(b.error()),
            {
                symbols: a,
                tags: null
            };
        if (b = d.find(function(e) {
            return null === e.end
        }))
            return console.warn("Markup error: found unclosed tag='" + b.name + "'"),
            {
                symbols: a,
                tags: null
            };
        a = io(d, c.length);
        return {
            symbols: c,
            tags: a
        }
    }
    function ml() {}
    function ko() {
        this.quad = this.count = 0;
        this.lines = {};
        this.positions = [];
        this.normals = [];
        this.uvs = [];
        this.colors = [];
        this.indices = [];
        this.meshInstance = null
    }
    function na(a) {
        this._element = a;
        this._system = a.system;
        this._entity = a.entity;
        this._text = "";
        this._symbols = [];
        this._colorPalette = [];
        this._i18nKey = this._symbolColors = null;
        this._fontAsset = new Ga(this._system.app);
        this._fontAsset.disableLocalization = !0;
        this._fontAsset.on("load", this._onFontLoad, this);
        this._fontAsset.on("change", this._onFontChange, this);
        this._fontAsset.on("remove", this._onFontRemove, this);
        this._font = null;
        this._color = new L(1,1,1,1);
        this._colorUniform = new Float32Array(3);
        this._spacing = 1;
        this._fontSize = 32;
        this._fontMaxY = this._fontMinY = 0;
        this._maxFontSize = this._originalFontSize = 32;
        this._minFontSize = 8;
        this._autoFitHeight = this._autoFitWidth = !1;
        this._maxLines = -1;
        this._scaledLineHeight = this._lineHeight = 32;
        this._wrapLines = !1;
        this._drawOrder = 0;
        this._alignment = new P(.5,.5);
        this._autoHeight = this._autoWidth = !0;
        this.height = this.width = 0;
        this._node = new Z;
        this._model = new sb;
        this._model.graph = this._node;
        this._entity.addChild(this._node);
        this._meshInfo = [];
        this._material = null;
        this._aabbDirty = !0;
        this._aabb = new oa;
        this._noResize = !1;
        this._maskedMaterialSrc = this._currentMaterialType = null;
        this._rtl = this._unicodeConverter = this._rtlReorder = !1;
        this._outlineColor = new L(0,0,0,1);
        this._outlineColorUniform = new Float32Array(4);
        this._outlineThicknessScale = .2;
        this._outlineThickness = 0;
        this._shadowColor = new L(0,0,0,1);
        this._shadowColorUniform = new Float32Array(4);
        this._shadowOffsetScale = .005;
        this._shadowOffset = new P(0,0);
        this._shadowOffsetUniform = new Float32Array(2);
        this._enableMarkup = !1;
        this._onScreenChange(this._element.screen);
        a.on("resize", this._onParentResize, this);
        a.on("set:screen", this._onScreenChange, this);
        a.on("screen:set:screenspace", this._onScreenSpaceChange, this);
        a.on("set:draworder", this._onDrawOrderChange, this);
        a.on("set:pivot", this._onPivotChange, this);
        this._system.app.i18n.on("set:locale", this._onLocaleSet, this);
        this._system.app.i18n.on("data:add", this._onLocalizationData, this);
        this._system.app.i18n.on("data:remove", this._onLocalizationData, this);
        this._rangeEnd = this._rangeStart = 0
    }
    function ia(a, b) {
        O.call(this, a, b);
        this._beingInitialized = !1;
        this._anchor = new X;
        this._localAnchor = new X;
        this._pivot = new P;
        this._height = this._calculatedHeight = this._width = this._calculatedWidth = 32;
        this._margin = new X(0,0,-32,-32);
        this._modelTransform = new K;
        this._screenToWorld = new K;
        this._anchorTransform = new K;
        this._anchorDirty = !0;
        this._parentWorldTransform = new K;
        this._screenTransform = new K;
        this._screenCorners = [new z, new z, new z, new z];
        this._canvasCorners = [new P, new P, new P, new P];
        this._worldCorners = [new z, new z, new z, new z];
        this._worldCornersDirty = this._canvasCornersDirty = this._cornersDirty = !0;
        this.entity.on("insert", this._onInsert, this);
        this._patch();
        this.screen = null;
        this._type = nl;
        this._group = this._text = this._image = null;
        this._drawOrder = 0;
        this._useInput = !1;
        this._layers = [4];
        this._addedModels = [];
        this._batchGroupId = -1;
        this._offsetReadAt = 0;
        this._maskOffset = .5;
        this._maskedBy = null
    }
    function lo() {
        this.enabled = !0
    }
    function Ce(a) {
        H.call(this, a);
        this.id = "element";
        this.ComponentType = ia;
        this.DataType = lo;
        this.schema = ol;
        this._rtlReorder = this._unicodeConverter = null;
        this._defaultTexture = new V(a.graphicsDevice,{
            width: 1,
            height: 1,
            format: 7
        });
        this._defaultTexture.name = "element-system";
        a = this._defaultTexture.lock();
        var b = new Uint8Array(4);
        b[0] = 255;
        b[1] = 255;
        b[2] = 255;
        b[3] = 255;
        a.set(b);
        this._defaultTexture.unlock();
        this.defaultScreenSpaceBitmapTextMaterial = this.defaultScreenSpaceTextMaterial = this.defaultBitmapTextMaterial = this.defaultTextMaterial = this.defaultScreenSpaceImageMaskMaterial = this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImageMask9SlicedMaterial = this.defaultScreenSpaceImage9TiledMaterial = this.defaultScreenSpaceImage9SlicedMaterial = this.defaultScreenSpaceImageMaterial = this.defaultImage9TiledMaskMaterial = this.defaultImage9SlicedMaskMaterial = this.defaultImageMaskMaterial = this.defaultImage9TiledMaterial = this.defaultImage9SlicedMaterial = this.defaultImageMaterial = null;
        this.defaultImageMaterials = [];
        this.on("beforeremove", this.onRemoveComponent, this)
    }
    function Sd(a, b) {
        O.call(this, a, b);
        this._minHeight = this._minWidth = 0;
        this._maxHeight = this._maxWidth = null;
        this._fitHeightProportion = this._fitWidthProportion = 0;
        this._excludeFromLayout = !1
    }
    function Td(a) {
        var b = "_" + a;
        Object.defineProperty(Sd.prototype, a, {
            get: function() {
                return this[b]
            },
            set: function(c) {
                this[b] !== c && (this[b] = c,
                this.fire("resize"))
            }
        })
    }
    function mo() {
        this.enabled = !0
    }
    function lj() {}
    function pl(a) {
        function b(w) {
            w = w.entity.layoutchild;
            return !w || !w.enabled || !w.excludeFromLayout
        }
        function c(w, y, A) {
            switch (w) {
            case mj:
                return zb.NONE;
            case 1:
                return y < A ? zb.APPLY_STRETCHING : zb.NONE;
            case 2:
                return y >= A ? zb.APPLY_SHRINKING : zb.NONE;
            case 3:
                return y < A ? zb.APPLY_STRETCHING : y >= A ? zb.APPLY_SHRINKING : zb.NONE;
            default:
                throw Error("Unrecognized fitting mode: " + w);
            }
        }
        function d(w, y) {
            return l(w, y.size) + (w.length - 1) * u.spacing[y.axis]
        }
        function e(w, y, A) {
            var B = p(w, A.maxSize)
              , E = n(w, A.fittingProportion)
              , C = t(E, B);
            y = Gb[A.axis] - y;
            for (var D = 0; D < w.length; ++D) {
                var G = B[D]
                  , J = g(G, y, E, C)
                  , R = w[G][A.size] + J
                  , I = Math.min(R, w[G][A.maxSize]);
                w[G][A.size] = I;
                y -= J - Math.max(R - I, 0)
            }
        }
        function f(w, y, A) {
            var B = p(w, A.minSize, !0);
            var E = n(w, A.fittingProportion);
            if (1 === E.length)
                E = [1];
            else {
                for (var C = [], D = E.length, G = 0; G < D; ++G)
                    C.push((1 - E[G]) / (D - 1));
                E = C
            }
            C = t(E, B);
            y -= Gb[A.axis];
            for (D = 0; D < w.length; ++D) {
                G = B[D];
                var J = g(G, y, E, C)
                  , R = w[G][A.size] - J
                  , I = Math.max(R, w[G][A.minSize]);
                w[G][A.size] = I;
                y -= J - Math.max(I - R, 0)
            }
        }
        function g(w, y, A, B) {
            A = A[w];
            w = B[w];
            return 1E-5 > Math.abs(A) && 1E-5 > Math.abs(w) ? y : y * A / w
        }
        function k(w) {
            for (var y = [], A = 0; A < w.length; ++A) {
                var B = w[A]
                  , E = Math.max(h(B, "minWidth"), 0)
                  , C = Math.max(h(B, "minHeight"), 0)
                  , D = Math.max(h(B, "maxWidth"), E)
                  , G = Math.max(h(B, "maxHeight"), C);
                var J = h(B, "width");
                J = Math.min(Math.max(J, E), D);
                var R = h(B, "height");
                R = Math.min(Math.max(R, C), G);
                var I = h(B, "fitWidthProportion");
                B = h(B, "fitHeightProportion");
                y.push({
                    minWidth: E,
                    minHeight: C,
                    maxWidth: D,
                    maxHeight: G,
                    width: J,
                    height: R,
                    fitWidthProportion: I,
                    fitHeightProportion: B
                })
            }
            return y
        }
        function h(w, y) {
            var A = w.entity.layoutchild;
            return A && A.enabled && void 0 !== A[y] && null !== A[y] ? A[y] : void 0 !== w[y] ? w[y] : no[y]
        }
        function l(w, y) {
            return w.reduce(function(A, B) {
                return A + B[y]
            }, 0)
        }
        function n(w, y) {
            var A = l(w, y), B = [], E = w.length, C;
            if (0 === A)
                for (C = 0; C < E; ++C)
                    B.push(1 / E);
            else
                for (C = 0; C < E; ++C)
                    B.push(w[C][y] / A);
            return B
        }
        function p(w, y, A) {
            w.forEach(q);
            return w.slice().sort(function(B, E) {
                return A ? E[y] - B[y] : B[y] - E[y]
            }).map(r)
        }
        function q(w, y) {
            w.index = y
        }
        function r(w) {
            return w.index
        }
        function t(w, y) {
            var A = [];
            A[y[w.length - 1]] = w[y[w.length - 1]];
            for (var B = w.length - 2; 0 <= B; --B)
                A[y[B]] = A[y[B + 1]] + w[y[B]];
            return A
        }
        var u, x = ql[a], v = ql[oo[a]];
        return function(w, y) {
            w = w.filter(b);
            u = y;
            Gb.x = u.containerSize.x - u.padding.x - u.padding.z;
            Gb.y = u.containerSize.y - u.padding.y - u.padding.w;
            y = w;
            for (var A = 0; A < y.length; ++A) {
                var B = y[A]
                  , E = B.anchor;
                if (0 !== E.x || 0 !== E.y || 0 !== E.z || 0 !== E.w)
                    B.anchor = X.ZERO
            }
            if (u.wrap) {
                y = [[]];
                A = k(w);
                B = 0;
                E = 2 === u[x.fitting];
                for (var C = 0; C < w.length; ++C) {
                    0 < y[y.length - 1].length && (B += u.spacing[x.axis]);
                    var D = A[C][x.size];
                    B += D;
                    !E && B > Gb[x.axis] && 0 !== y[y.length - 1].length && (B = D,
                    y.push([]));
                    y[y.length - 1].push(w[C]);
                    E && B > Gb[x.axis] && C !== w.length - 1 && (B = 0,
                    y.push([]))
                }
                w = y
            } else
                w = [w];
            y = 0 === u.orientation && u.reverseX || 1 === u.orientation && u.reverseY;
            A = 0 === u.orientation && u.reverseY || 1 === u.orientation && u.reverseX;
            if (y)
                for (B = 0; B < w.length; ++B)
                    y && w[B].reverse();
            A && w.reverse();
            y = [];
            for (A = 0; A < w.length; ++A)
                B = k(w[A]),
                E = d(B, x),
                C = c(u[x.fitting], E, Gb[x.axis]),
                C === zb.APPLY_STRETCHING ? e(B, E, x) : C === zb.APPLY_SHRINKING && f(B, E, x),
                y.push(B);
            D = [];
            C = [];
            for (B = 0; B < w.length; ++B) {
                E = w[B];
                E.largestElement = null;
                E.largestSize = {
                    width: Number.NEGATIVE_INFINITY,
                    height: Number.NEGATIVE_INFINITY
                };
                for (A = 0; A < E.length; ++A) {
                    var G = y[B][A];
                    G[v.size] > E.largestSize[v.size] && (E.largestElement = E[A],
                    E.largestSize = G)
                }
                D.push(E.largestElement);
                C.push(E.largestSize)
            }
            A = d(C, v);
            B = c(u[v.fitting], A, Gb[v.axis]);
            B === zb.APPLY_STRETCHING ? e(C, A, v) : B === zb.APPLY_SHRINKING && f(C, A, v);
            for (B = 0; B < w.length; ++B)
                for (E = w[B],
                A = 0; A < E.length; ++A)
                    C = y[B][A],
                    D = 1 === w.length ? Gb[v.axis] : E.largestSize[v.size],
                    G = c(u[v.fitting], C[v.size], D),
                    G === zb.APPLY_STRETCHING ? C[v.size] = Math.min(D, C[v.maxSize]) : G === zb.APPLY_SHRINKING && (C[v.size] = Math.max(D, C[v.minSize]));
            a: {
                A = {};
                A[x.axis] = 0;
                A[v.axis] = 0;
                w[x.size] = Number.NEGATIVE_INFINITY;
                B = [];
                for (E = 0; E < w.length; ++E) {
                    C = w[E];
                    if (0 === C.length) {
                        A = void 0;
                        break a
                    }
                    D = [];
                    G = y[E];
                    for (var J = 0; J < C.length; ++J) {
                        var R = C[J]
                          , I = G[J];
                        A[v.axis] -= -I[v.size] * R.pivot[v.axis];
                        A[x.axis] -= -I[x.size] * R.pivot[x.axis];
                        D[J] = {};
                        D[J][x.axis] = A[x.axis];
                        D[J][v.axis] = A[v.axis];
                        A[v.axis] += -I[v.size] * R.pivot[v.axis];
                        A[x.axis] += I[x.size] * (1 - R.pivot[x.axis]) + u.spacing[x.axis]
                    }
                    C[x.size] = A[x.axis] - u.spacing[x.axis];
                    C[v.size] = C.largestSize[v.size];
                    w[x.size] = Math.max(w[x.size], C[x.size]);
                    A[x.axis] = 0;
                    A[v.axis] += C[v.size] + u.spacing[v.axis];
                    B.push(D)
                }
                w[v.size] = A[v.axis] - u.spacing[v.axis];
                A = B
            }
            B = A;
            E = u.alignment[x.axis];
            C = u.alignment[v.axis];
            D = u.padding[x.axis];
            G = u.padding[v.axis];
            for (J = 0; J < w.length; ++J) {
                R = w[J];
                I = y[J];
                for (var T = B[J], S = (Gb[x.axis] - R[x.size]) * E + D, ba = (Gb[v.axis] - w[v.size]) * C + G, ha = 0; ha < R.length; ++ha) {
                    var W = (R[v.size] - I[ha][v.size]) * u.alignment[v.axis];
                    T[ha][x.axis] += S;
                    T[ha][v.axis] += ba + W
                }
            }
            for (B = 0; B < w.length; ++B)
                for (E = w[B],
                C = y[B],
                D = A[B],
                G = 0; G < E.length; ++G)
                    J = E[G],
                    J[x.calculatedSize] = C[G][x.size],
                    J[v.calculatedSize] = C[G][v.size],
                    0 === u.orientation ? J.entity.setLocalPosition(D[G][x.axis], D[G][v.axis], J.entity.getLocalPosition().z) : J.entity.setLocalPosition(D[G][v.axis], D[G][x.axis], J.entity.getLocalPosition().z);
            y = w.width;
            w = w.height;
            return {
                bounds: new X((Gb.x - y) * u.alignment.x + u.padding.x,(Gb.y - w) * u.alignment.y + u.padding.y,y,w)
            }
        }
    }
    function jd(a, b) {
        O.call(this, a, b);
        this._orientation = 0;
        this._reverseX = !1;
        this._reverseY = !0;
        this._alignment = new P(0,1);
        this._padding = new X;
        this._spacing = new P;
        this._heightFitting = this._widthFitting = mj;
        this._wrap = !1;
        this._layoutCalculator = new lj;
        this._listenForReflowEvents(this.entity, "on");
        this.entity.children.forEach(function(c) {
            this._listenForReflowEvents(c, "on")
        }
        .bind(this));
        this.entity.on("childinsert", this._onChildInsert, this);
        this.entity.on("childremove", this._onChildRemove, this);
        a.app.systems.element.on("add", this._onElementOrLayoutComponentAdd, this);
        a.app.systems.element.on("beforeremove", this._onElementOrLayoutComponentRemove, this);
        a.app.systems.layoutchild.on("add", this._onElementOrLayoutComponentAdd, this);
        a.app.systems.layoutchild.on("beforeremove", this._onElementOrLayoutComponentRemove, this)
    }
    function po(a) {
        return a.element
    }
    function qo(a) {
        return a.enabled && a.element && a.element.enabled
    }
    function Mc(a) {
        var b = "_" + a;
        Object.defineProperty(jd.prototype, a, {
            get: function() {
                return this[b]
            },
            set: function(c) {
                this[b] !== c && (this[b] = c,
                this._scheduleReflow())
            }
        })
    }
    function ro() {
        this.enabled = !0
    }
    function De(a) {
        H.call(this, a);
        this.id = "layoutgroup";
        this.ComponentType = jd;
        this.DataType = ro;
        this.schema = rl;
        this._reflowQueue = [];
        this.on("beforeremove", this._onRemoveComponent, this);
        H.bind("postUpdate", this._onPostUpdate, this)
    }
    function kd(a, b) {
        O.call(this, a, b);
        this._cookieAssetId = this._cookieAsset = null;
        this._cookieAssetAdd = !1;
        this._cookieMatrix = null
    }
    function so() {
        for (var a = nj, b = to, c, d = 0; d < a.length; d++)
            c = b[d],
            this[a[d]] = c && c.clone ? c.clone() : c
    }
    function Ee(a) {
        H.call(this, a);
        this.id = "light";
        this.ComponentType = kd;
        this.DataType = so;
        this.on("beforeremove", this._onRemoveComponent, this)
    }
    function Ha(a, b) {
        O.call(this, a, b);
        this._type = "asset";
        this._model = this._asset = null;
        this._mapping = {};
        this._receiveShadows = this._castShadows = !0;
        this._materialAsset = null;
        this._material = a.defaultMaterial;
        this._castShadowsLightmap = !0;
        this._lightmapped = !1;
        this._lightmapSizeMultiplier = 1;
        this._isStatic = !1;
        this._layers = [0];
        this._batchGroupId = -1;
        this._area = null;
        this._assetOld = 0;
        this._materialEvents = null;
        this._clonedModel = this._dirtyMaterialAsset = this._dirtyModelAsset = !1;
        b.on("remove", this.onRemoveChild, this);
        b.on("insert", this.onInsertChild, this)
    }
    function uo() {
        this.enabled = !0
    }
    function Fe(a) {
        H.call(this, a);
        this.id = "model";
        this.ComponentType = Ha;
        this.DataType = uo;
        this.schema = sl;
        this.sphere = this.plane = this.cylinder = this.cone = this.capsule = this.box = null;
        this.defaultMaterial = a.scene.defaultMaterial;
        this.on("beforeremove", this.onRemove, this)
    }
    function vo() {
        this.rate = this.numParticles = 1;
        this.rate2 = null;
        this.startAngle = 0;
        this.startAngle2 = null;
        this.lifetime = 50;
        this.emitterExtents = new z;
        this.emitterExtentsInner = new z;
        this.initialVelocity = this.emitterShape = this.emitterRadiusInner = this.emitterRadius = 0;
        this.wrapBounds = new z;
        this.screenSpace = this.localSpace = !1;
        this.normalMapAsset = this.normalMap = this.colorMapAsset = this.colorMap = null;
        this.loop = !0;
        this.preWarm = !1;
        this.mode = this.sort = 0;
        this.scene = null;
        this.halfLambert = this.lighting = !1;
        this.intensity = 1;
        this.stretch = 0;
        this.alignToMotion = !1;
        this.depthSoftening = 0;
        this.mesh = this.meshAsset = null;
        this.noFog = this.depthWrite = !1;
        this.orientation = 0;
        this.particleNormal = new z(0,1,0);
        this.animTilesY = this.animTilesX = 1;
        this.animStartFrame = 0;
        this.animNumAnimations = this.animNumFrames = 1;
        this.animIndex = 0;
        this.randomizeAnimIndex = !1;
        this.animSpeed = 1;
        this.animLoop = !0;
        this.radialSpeedGraph2 = this.radialSpeedGraph = this.rotationSpeedGraph2 = this.rotationSpeedGraph = this.velocityGraph2 = this.velocityGraph = this.localVelocityGraph2 = this.localVelocityGraph = this.alphaGraph2 = this.alphaGraph = this.colorGraph2 = this.colorGraph = this.scaleGraph2 = this.scaleGraph = null;
        this.blendType = 2;
        this.model = null;
        this.enabled = !0;
        this.paused = !1;
        this.autoPlay = !0;
        this.layers = [0]
    }
    function Ge(a) {
        H.call(this, a);
        this.id = "particlesystem";
        this.ComponentType = ld;
        this.DataType = vo;
        this.schema = tl;
        this.propertyTypes = {
            emitterExtents: "vec3",
            emitterExtentsInner: "vec3",
            particleNormal: "vec3",
            wrapBounds: "vec3",
            localVelocityGraph: "curveset",
            localVelocityGraph2: "curveset",
            velocityGraph: "curveset",
            velocityGraph2: "curveset",
            colorGraph: "curveset",
            colorGraph2: "curveset",
            alphaGraph: "curve",
            alphaGraph2: "curve",
            rotationSpeedGraph: "curve",
            rotationSpeedGraph2: "curve",
            radialSpeedGraph: "curve",
            radialSpeedGraph2: "curve",
            scaleGraph: "curve",
            scaleGraph2: "curve"
        };
        this.on("beforeremove", this.onBeforeRemove, this);
        H.bind("update", this.onUpdate, this)
    }
    function Vg(a, b) {
        this._constructor = a;
        this._pool = [];
        this._count = 0;
        this._resize(b)
    }
    function hc(a, b) {
        O.call(this, a, b);
        "undefined" === typeof Ammo || Ub || (Ub = new Ammo.btTransform,
        ya = new Ammo.btVector3,
        Jf = new Ammo.btVector3,
        oj = new Ammo.btQuaternion,
        pj = new Ammo.btVector3(0,0,0));
        this.on("set_mass", this.onSetMass, this);
        this.on("set_linearDamping", this.onSetLinearDamping, this);
        this.on("set_angularDamping", this.onSetAngularDamping, this);
        this.on("set_linearFactor", this.onSetLinearFactor, this);
        this.on("set_angularFactor", this.onSetAngularFactor, this);
        this.on("set_friction", this.onSetFriction, this);
        this.on("set_restitution", this.onSetRestitution, this);
        this.on("set_type", this.onSetType, this);
        this.on("set_group", this.onSetGroupOrMask, this);
        this.on("set_mask", this.onSetGroupOrMask, this);
        this.on("set_body", this.onSetBody, this);
        this._linearVelocity = new z(0,0,0);
        this._angularVelocity = new z(0,0,0)
    }
    function wo() {
        this.enabled = !0;
        this.mass = 1;
        this.angularDamping = this.linearDamping = 0;
        this.linearFactor = new z(1,1,1);
        this.angularFactor = new z(1,1,1);
        this.friction = .5;
        this.restitution = 0;
        this.type = He;
        this.group = qj;
        this.mask = Wg;
        this.body = null;
        this.simulationEnabled = !1
    }
    function rj(a, b, c) {
        this.entity = a;
        this.point = b;
        this.normal = c
    }
    function ul(a, b, c) {
        0 === arguments.length ? (this.b = this.a = null,
        this.localPointA = new z,
        this.localPointB = new z,
        this.pointA = new z,
        this.pointB = new z,
        this.normal = new z) : (this.a = a,
        this.b = b,
        this.localPointA = c.localPoint,
        this.localPointB = c.localPointOther,
        this.pointA = c.point,
        this.pointB = c.pointOther,
        this.normal = c.normal)
    }
    function vl(a, b, c, d, e) {
        0 === arguments.length ? (this.localPoint = new z,
        this.localPointOther = new z,
        this.point = new z,
        this.pointOther = new z,
        this.normal = new z) : (this.localPoint = a,
        this.localPointOther = b,
        this.point = c,
        this.pointOther = d,
        this.normal = e)
    }
    function wl(a, b) {
        this.other = a;
        this.contacts = b
    }
    function Ud(a) {
        H.call(this, a);
        this.id = "rigidbody";
        this._stats = a.stats.frame;
        this.ComponentType = hc;
        this.DataType = wo;
        this.singleContactResultPool = this.contactResultPool = this.contactPointPool = null;
        this.schema = xl;
        this.maxSubSteps = 10;
        this.fixedTimeStep = 1 / 60;
        this.gravity = new z(0,-9.81,0);
        this._dynamic = [];
        this._kinematic = [];
        this._triggers = [];
        this._compounds = [];
        this.on("beforeremove", this.onBeforeRemove, this);
        this.on("remove", this.onRemove, this)
    }
    function Hb(a, b) {
        O.call(this, a, b);
        this._resolution = new P(640,320);
        this._referenceResolution = new P(640,320);
        this._scaleMode = Vd;
        this.scale = 1;
        this._scaleBlend = .5;
        this._priority = 0;
        this.cull = this._screenSpace = !1;
        this._screenMatrix = new K;
        a.app.graphicsDevice.on("resizecanvas", this._onResize, this)
    }
    function xo() {
        this.enabled = !0
    }
    function Ie(a) {
        H.call(this, a);
        this.id = "screen";
        this.ComponentType = Hb;
        this.DataType = xo;
        this.schema = yl;
        this.windowResolution = new P;
        this._drawOrderSyncQueue = new Zh;
        this.app.graphicsDevice.on("resizecanvas", this._onResize, this);
        H.bind("update", this._onUpdate, this);
        this.on("beforeremove", this.onRemoveComponent, this)
    }
    function Wd(a) {
        this.scriptType = a;
        this.index = {}
    }
    function db(a) {
        M.call(this);
        var b = this.constructor;
        this.app = a.app;
        this.entity = a.entity;
        this._enabled = "boolean" === typeof a.enabled ? a.enabled : !0;
        this._enabledOld = this.enabled;
        this.__destroyed = !1;
        this.__attributes = {};
        this.__attributesRaw = a.attributes || {};
        this.__scriptType = b;
        this.__executionOrder = -1
    }
    function Ib(a, b) {
        if (ub.legacy)
            return null;
        if (Ib.reservedScripts[a])
            throw Error("script name: '" + a + "' is reserved, please change script name");
        var c = function(d) {
            db.call(this, d)
        };
        c.prototype = Object.create(db.prototype);
        c.prototype.constructor = c;
        c.extend = db.extend;
        c.attributes = new Wd(c);
        zl(c, a, b);
        return c
    }
    function zl(a, b, c) {
        if (!a.legacy) {
            if ("function" !== typeof a)
                throw Error("script class: '" + a + "' must be a constructor function (i.e. class).");
            if (!(a.prototype instanceof db))
                throw Error("script class: '" + db.__getScriptName(a) + "' does not extend pc.ScriptType.");
            b = b || a.__name || db.__getScriptName(a);
            if (Ib.reservedScripts[b])
                throw Error("script name: '" + b + "' is reserved, please change script name");
            a.__name = b;
            (c ? c.scripts : ea.getApplication().scripts).add(a);
            tb._push(a)
        }
    }
    function ic(a) {
        this._sortBy = a.sortBy;
        this.items = [];
        this.length = 0;
        this.loopIndex = -1;
        this._sortHandler = this._doSort.bind(this)
    }
    function Xa(a, b) {
        O.call(this, a, b);
        this._scripts = [];
        this._updateList = new ic({
            sortBy: "__executionOrder"
        });
        this._postUpdateList = new ic({
            sortBy: "__executionOrder"
        });
        this._scriptsIndex = {};
        this._destroyedScripts = [];
        this._destroyed = !1;
        this._scriptsData = null;
        this._enabled = this._oldState = !0;
        this._isLoopingThroughScripts = this._beingEnabled = !1;
        this._executionOrder = -1;
        this.on("set_enabled", this._onSetEnabled, this)
    }
    function yo() {
        this.enabled = !0
    }
    function Je(a) {
        H.call(this, a);
        this.id = "script";
        this.ComponentType = Xa;
        this.DataType = yo;
        this._components = new ic({
            sortBy: "_executionOrder"
        });
        this._enabledComponents = new ic({
            sortBy: "_executionOrder"
        });
        this.preloading = !0;
        this.on("beforeremove", this._onBeforeRemove, this);
        H.bind("initialize", this._onInitialize, this);
        H.bind("postInitialize", this._onPostInitialize, this);
        H.bind("update", this._onUpdate, this);
        H.bind("postUpdate", this._onPostUpdate, this)
    }
    function Xd(a, b) {
        O.call(this, a, b);
        this.on("set_scripts", this.onSetScripts, this)
    }
    function zo() {
        this.scripts = [];
        this.enabled = !0;
        this.instances = {};
        this._instances = {};
        this.runInTools = !1;
        this.attributes = {};
        this.areScriptsLoaded = this.postInitialized = this.initialized = !1
    }
    function Nc(a, b) {
        M.call(this);
        if (!(a && a instanceof ia))
            throw Error("Element was null or not an ElementComponent");
        if (b && "x" !== b && "y" !== b)
            throw Error("Unrecognized axis: " + b);
        this._element = a;
        this._app = a.system.app;
        this._axis = b || null;
        this._enabled = !0;
        this._dragScale = new z;
        this._dragStartMousePosition = new z;
        this._dragStartHandlePosition = new z;
        this._deltaMousePosition = new z;
        this._deltaHandlePosition = new z;
        this._isDragging = !1;
        this._toggleLifecycleListeners("on")
    }
    function md(a, b) {
        O.call(this, a, b);
        this._viewportReference = new Kc(this,"viewportEntity",{
            "element#gain": this._onViewportElementGain,
            "element#resize": this._onSetContentOrViewportSize
        });
        this._contentReference = new Kc(this,"contentEntity",{
            "element#gain": this._onContentElementGain,
            "element#lose": this._onContentElementLose,
            "element#resize": this._onSetContentOrViewportSize
        });
        this._scrollbarUpdateFlags = {};
        this._scrollbarReferences = {};
        this._scrollbarReferences[0] = new Kc(this,"horizontalScrollbarEntity",{
            "scrollbar#set:value": this._onSetHorizontalScrollbarValue,
            "scrollbar#gain": this._onHorizontalScrollbarGain
        });
        this._scrollbarReferences[1] = new Kc(this,"verticalScrollbarEntity",{
            "scrollbar#set:value": this._onSetVerticalScrollbarValue,
            "scrollbar#gain": this._onVerticalScrollbarGain
        });
        this._prevContentSizes = {};
        this._prevContentSizes[0] = null;
        this._prevContentSizes[1] = null;
        this._scroll = new P;
        this._velocity = new z;
        this._dragStartPosition = new z;
        this._disabledContentInput = !1;
        this._disabledContentInputEntities = [];
        this._toggleLifecycleListeners("on", a);
        this._toggleElementListeners("on")
    }
    function Ao() {
        this.enabled = !0
    }
    function Yd(a, b) {
        O.call(this, a, b);
        this._app = a.app;
        this._handleReference = new Kc(this,"handleEntity",{
            "element#gain": this._onHandleElementGain,
            "element#lose": this._onHandleElementLose,
            "element#set:anchor": this._onSetHandleAlignment,
            "element#set:margin": this._onSetHandleAlignment,
            "element#set:pivot": this._onSetHandleAlignment
        });
        this._toggleLifecycleListeners("on")
    }
    function Bo() {
        this.enabled = !0
    }
    function Ke(a) {
        H.call(this, a);
        this.id = "scrollbar";
        this.ComponentType = Yd;
        this.DataType = Bo;
        this.schema = sj;
        this.on("beforeremove", this._onRemoveComponent, this)
    }
    function Qa(a, b, c) {
        M.call(this);
        this._component = a;
        this._assets = a.system.app.assets;
        this._manager = a.system.manager;
        this.name = b || "Untitled";
        c = c || {};
        this._volume = void 0 !== c.volume ? N.clamp(Number(c.volume) || 0, 0, 1) : 1;
        this._pitch = void 0 !== c.pitch ? Math.max(.01, Number(c.pitch) || 0) : 1;
        this._loop = !(void 0 === c.loop || !c.loop);
        this._duration = 0 < c.duration ? c.duration : null;
        this._startTime = Math.max(0, Number(c.startTime) || 0);
        this._overlap = !!c.overlap;
        this._autoPlay = !!c.autoPlay;
        this._lastNode = this._firstNode = null;
        this._asset = c.asset;
        this._asset instanceof aa && (this._asset = this._asset.id);
        this._onInstancePlayHandler = this._onInstancePlay.bind(this);
        this._onInstancePauseHandler = this._onInstancePause.bind(this);
        this._onInstanceResumeHandler = this._onInstanceResume.bind(this);
        this._onInstanceStopHandler = this._onInstanceStop.bind(this);
        this._onInstanceEndHandler = this._onInstanceEnd.bind(this);
        this.instances = []
    }
    function jc(a, b) {
        O.call(this, a, b);
        this._pitch = this._volume = 1;
        this._positional = !0;
        this._refDistance = 1;
        this._maxDistance = 1E4;
        this._rollOffFactor = 1;
        this._distanceModel = "linear";
        this._slots = {};
        this._playingBeforeDisable = {}
    }
    function Xg(a, b) {
        Object.defineProperty(jc.prototype, a, {
            get: function() {
                return this[b]
            },
            set: function(c) {
                this[b] = c;
                var d = this._slots, e;
                for (e in d) {
                    var f = d[e];
                    if (!f.overlap) {
                        f = f.instances;
                        for (var g = 0, k = f.length; g < k; g++)
                            f[g][a] = c
                    }
                }
            }
        })
    }
    function Al(a, b) {
        Object.defineProperty(jc.prototype, a, {
            get: function() {
                return this[b]
            },
            set: function(c) {
                this[b] = c;
                var d = this._slots, e;
                for (e in d) {
                    var f = d[e];
                    if (!f.overlap)
                        for (var g = f.instances, k = 0, h = g.length; k < h; k++)
                            g[k][a] = f[a] * c
                }
            }
        })
    }
    function Co() {
        this.enabled = !0
    }
    function vb(a, b) {
        M.call(this);
        this._component = a;
        this._frame = 0;
        this._spriteAsset = this._sprite = null;
        this.spriteAsset = b.spriteAsset;
        this.name = b.name;
        this.fps = b.fps || 0;
        this.loop = b.loop || !1;
        this._paused = this._playing = !1;
        this._time = 0
    }
    function Do() {
        this.enabled = !0
    }
    function Zd(a) {
        H.call(this, a);
        this.id = "sprite";
        this.ComponentType = Ba;
        this.DataType = Do;
        this.schema = Bl;
        this._default9SlicedMaterialTiledMode = this._default9SlicedMaterialSlicedMode = this._defaultMaterial = this._defaultTexture = null;
        H.bind("update", this.onUpdate, this);
        this.on("beforeremove", this.onBeforeRemove, this)
    }
    function nd(a, b) {
        O.call(this, a, b);
        this._oldState = !0;
        this._size = new z;
        this.on("set_enabled", this._onSetEnabled, this)
    }
    function Eo() {
        this.enabled = !0
    }
    function Fo(a) {
        this.frame = {
            fps: 0,
            ms: 0,
            dt: 0,
            updateStart: 0,
            updateTime: 0,
            renderStart: 0,
            renderTime: 0,
            physicsStart: 0,
            physicsTime: 0,
            cullTime: 0,
            sortTime: 0,
            skinTime: 0,
            morphTime: 0,
            instancingTime: 0,
            triangles: 0,
            otherPrimitives: 0,
            shaders: 0,
            materials: 0,
            cameras: 0,
            shadowMapUpdates: 0,
            shadowMapTime: 0,
            depthMapTime: 0,
            forwardTime: 0,
            _timeToCountFrames: 0,
            _fpsAccum: 0
        };
        this.drawCalls = {
            forward: 0,
            depth: 0,
            shadow: 0,
            immediate: 0,
            misc: 0,
            total: 0,
            skinned: 0,
            instanced: 0,
            removedByInstancing: 0
        };
        this.misc = {
            renderTargetCreationTime: 0
        };
        this.particles = {
            updatesPerFrame: 0,
            _updatesPerFrame: 0,
            frameTime: 0,
            _frameTime: 0
        };
        this.vram = a._vram;
        this.shaders = a._shaderStats;
        Object.defineProperty(this.vram, "totalUsed", {
            get: function() {
                return this.tex + this.vb + this.ib
            }
        });
        Object.defineProperty(this.vram, "geom", {
            get: function() {
                return this.vb + this.ib
            }
        });
        Object.defineProperty(this, "scene", {
            get: function() {
                return ea._currentApplication.scene._stats
            }
        });
        Object.defineProperty(this, "lightmapper", {
            get: function() {
                return ea._currentApplication.lightmapper._stats
            }
        });
        Object.defineProperty(this, "batcher", {
            get: function() {
                return ea._currentApplication.batcher._stats
            }
        })
    }
    function Cl(a, b) {
        this.name = a;
        this.url = b
    }
    function kc(a) {
        this._app = a;
        this._list = [];
        this._index = {};
        this._urlIndex = {}
    }
    function ea(a, b) {
        M.call(this);
        b = b || {};
        console.log("Powered by PlayCanvas 1.35.1 3317bcf");
        ea._applications[a.id] = this;
        ea._currentApplication = this;
        m.app = this;
        this._time = 0;
        this.timeScale = 1;
        this.maxDeltaTime = .1;
        this.frame = 0;
        this.autoRender = !0;
        this.renderNextFrame = !1;
        this.useLegacyScriptAttributeCloning = ub.legacy;
        this._librariesLoaded = !1;
        this._fillMode = Yg;
        this._resolutionMode = tj;
        this._allowResize = !0;
        this.context = this;
        b.graphicsDeviceOptions || (b.graphicsDeviceOptions = {});
        b.graphicsDeviceOptions.xrCompatible = !0;
        this.graphicsDevice = new ib(a,b.graphicsDeviceOptions);
        this.stats = new Fo(this.graphicsDevice);
        this._soundManager = new ec(b);
        this.loader = new Mi(this);
        this._entityIndex = {};
        this.scene = new sa;
        this.root = new fa(this);
        this.root._enabledInHierarchy = !0;
        this._enableList = [];
        this._enableList.size = 0;
        this.assets = new Ld(this.loader);
        b.assetPrefix && (this.assets.prefix = b.assetPrefix);
        this.bundles = new fj(this.assets);
        this.enableBundles = "undefined" !== typeof TextDecoder;
        this.scriptsOrder = b.scriptsOrder || [];
        this.scripts = new fc(this);
        this.i18n = new Oa(this);
        this.scenes = new kc(this);
        var c = this;
        this.defaultLayerWorld = new ma({
            name: "World",
            id: 0
        });
        this.graphicsDevice.webgl2 ? (this.defaultLayerDepth = new ma({
            enabled: !1,
            name: "Depth",
            id: 1,
            onEnable: function() {
                if (!this.renderTarget) {
                    var d = new V(c.graphicsDevice,{
                        format: 17,
                        width: c.graphicsDevice.width,
                        height: c.graphicsDevice.height
                    });
                    d.name = "rt-depth2";
                    d.minFilter = 0;
                    d.magFilter = 0;
                    d.addressU = 1;
                    d.addressV = 1;
                    this.renderTarget = new ra({
                        colorBuffer: null,
                        depthBuffer: d,
                        autoResolve: !1
                    });
                    c.graphicsDevice.scope.resolve("uDepthMap").setValue(d)
                }
            },
            onDisable: function() {
                this.renderTarget && (this.renderTarget._depthBuffer.destroy(),
                this.renderTarget.destroy(),
                this.renderTarget = null)
            },
            onPreRenderOpaque: function(d) {
                var e = c.graphicsDevice.gl;
                this.srcFbo = e.getParameter(e.FRAMEBUFFER_BINDING);
                this.renderTarget && this.renderTarget.width === c.graphicsDevice.width && this.renderTarget.height === c.graphicsDevice.height || (this.onDisable(),
                this.onEnable());
                this.oldClear = this.cameras[d].camera._clearOptions;
                this.cameras[d].camera._clearOptions = this.depthClearOptions
            },
            onPostRenderOpaque: function(d) {
                this.renderTarget && (this.cameras[d].camera._clearOptions = this.oldClear,
                d = c.graphicsDevice.gl,
                c.graphicsDevice.setRenderTarget(this.renderTarget),
                c.graphicsDevice.updateBegin(),
                d.bindFramebuffer(d.READ_FRAMEBUFFER, this.srcFbo),
                d.bindFramebuffer(d.DRAW_FRAMEBUFFER, this.renderTarget._glFrameBuffer),
                d.blitFramebuffer(0, 0, this.renderTarget.width, this.renderTarget.height, 0, 0, this.renderTarget.width, this.renderTarget.height, d.DEPTH_BUFFER_BIT, d.NEAREST))
            }
        }),
        this.defaultLayerDepth.depthClearOptions = {
            flags: 0
        }) : (this.defaultLayerDepth = new ma({
            enabled: !1,
            name: "Depth",
            id: 1,
            shaderPass: 2,
            onEnable: function() {
                if (!this.renderTarget) {
                    var d = new V(c.graphicsDevice,{
                        format: 7,
                        width: c.graphicsDevice.width,
                        height: c.graphicsDevice.height
                    });
                    d.name = "rt-depth1";
                    d.minFilter = 0;
                    d.magFilter = 0;
                    d.addressU = 1;
                    d.addressV = 1;
                    this.renderTarget = new ra(c.graphicsDevice,d,{
                        depth: !0,
                        stencil: c.graphicsDevice.supportsStencil
                    });
                    c.graphicsDevice.scope.resolve("uDepthMap").setValue(d)
                }
            },
            onDisable: function() {
                this.renderTarget && (this.renderTarget._colorBuffer.destroy(),
                this.renderTarget.destroy(),
                this.renderTarget = null)
            },
            onPostCull: function(d) {
                var e = this.instances.visibleOpaque[d]
                  , f = e.list
                  , g = 0
                  , k = c.scene.layers.layerList
                  , h = c.scene.layers.subLayerEnabled
                  , l = c.scene.layers.subLayerList
                  , n = c.defaultLayerWorld.renderTarget;
                d = this.cameras[d];
                for (var p, q, r, t, u = 0; u < k.length; u++) {
                    p = k[u];
                    if (p === this)
                        break;
                    if (p.renderTarget === n && p.enabled && h[u] && (q = p.cameras.indexOf(d),
                    !(0 > q)))
                        for (q = (r = l[u]) ? p.instances.visibleTransparent[q] : p.instances.visibleOpaque[q],
                        r = q.length,
                        q = q.list,
                        p = 0; p < r; p++)
                            t = q[p],
                            t.material && t.material.depthWrite && !t._noDepthDrawGl1 && (f[g] = t,
                            g++)
                }
                e.length = g
            },
            onPreRenderOpaque: function(d) {
                this.renderTarget && this.renderTarget.width === c.graphicsDevice.width && this.renderTarget.height === c.graphicsDevice.height || (this.onDisable(),
                this.onEnable());
                this.oldClear = this.cameras[d].camera._clearOptions;
                this.cameras[d].camera._clearOptions = this.rgbaDepthClearOptions
            },
            onDrawCall: function() {
                c.graphicsDevice.setColorWrite(!0, !0, !0, !0)
            },
            onPostRenderOpaque: function(d) {
                this.renderTarget && (this.cameras[d].camera._clearOptions = this.oldClear)
            }
        }),
        this.defaultLayerDepth.rgbaDepthClearOptions = {
            color: [254 / 255, 254 / 255, 254 / 255, 254 / 255],
            depth: 1,
            flags: 3
        });
        this.defaultLayerSkybox = new ma({
            enabled: !1,
            name: "Skybox",
            id: 2,
            opaqueSortMode: 0
        });
        this.defaultLayerUi = new ma({
            enabled: !0,
            name: "UI",
            id: 4,
            transparentSortMode: 1,
            passThrough: !1
        });
        this.defaultLayerImmediate = new ma({
            enabled: !0,
            name: "Immediate",
            id: 3,
            opaqueSortMode: 0,
            passThrough: !0
        });
        this.defaultLayerComposition = new xa;
        this.defaultLayerComposition.pushOpaque(this.defaultLayerWorld);
        this.defaultLayerComposition.pushOpaque(this.defaultLayerDepth);
        this.defaultLayerComposition.pushOpaque(this.defaultLayerSkybox);
        this.defaultLayerComposition.pushTransparent(this.defaultLayerWorld);
        this.defaultLayerComposition.pushOpaque(this.defaultLayerImmediate);
        this.defaultLayerComposition.pushTransparent(this.defaultLayerImmediate);
        this.defaultLayerComposition.pushTransparent(this.defaultLayerUi);
        this.scene.layers = this.defaultLayerComposition;
        this._immediateLayer = this.defaultLayerImmediate;
        this.scene.on("set:layers", function(d, e) {
            d = e.layerList;
            for (var f = 0; f < d.length; f++)
                switch (e = d[f],
                e.id) {
                case 1:
                    e.onEnable = c.defaultLayerDepth.onEnable;
                    e.onDisable = c.defaultLayerDepth.onDisable;
                    e.onPreRenderOpaque = c.defaultLayerDepth.onPreRenderOpaque;
                    e.onPostRenderOpaque = c.defaultLayerDepth.onPostRenderOpaque;
                    e.depthClearOptions = c.defaultLayerDepth.depthClearOptions;
                    e.rgbaDepthClearOptions = c.defaultLayerDepth.rgbaDepthClearOptions;
                    e.shaderPass = c.defaultLayerDepth.shaderPass;
                    e.onPostCull = c.defaultLayerDepth.onPostCull;
                    e.onDrawCall = c.defaultLayerDepth.onDrawCall;
                    break;
                case 4:
                    e.passThrough = c.defaultLayerUi.passThrough;
                    break;
                case 3:
                    e.passThrough = c.defaultLayerImmediate.passThrough
                }
        });
        this.renderer = new xg(this.graphicsDevice);
        this.renderer.scene = this.scene;
        this.lightmapper = new ii(this.graphicsDevice,this.root,this.scene,this.renderer,this.assets);
        this.once("prerender", this._firstBake, this);
        this.batcher = new Ia(this.graphicsDevice,this.root,this.scene);
        this.once("prerender", this._firstBatch, this);
        this.keyboard = b.keyboard || null;
        this.mouse = b.mouse || null;
        this.touch = b.touch || null;
        this.gamepads = b.gamepads || null;
        if (this.elementInput = b.elementInput || null)
            this.elementInput.app = this;
        this.vr = null;
        this.xr = new Pa(this);
        this.elementInput && this.elementInput.attachSelectEvents();
        this._inTools = !1;
        this._skyboxLast = 0;
        this._scriptPrefix = b.scriptPrefix || "";
        this.enableBundles && this.loader.addHandler("bundle", new zi(this.assets));
        this.loader.addHandler("animation", new ui);
        this.loader.addHandler("animclip", new vi);
        this.loader.addHandler("animstategraph", new wi);
        this.loader.addHandler("model", new Li(this.graphicsDevice,this.scene.defaultMaterial));
        this.loader.addHandler("material", new Ki(this));
        this.loader.addHandler("texture", new Pg(this.graphicsDevice,this.assets,this.loader));
        this.loader.addHandler("text", new Ui);
        this.loader.addHandler("json", new Ji);
        this.loader.addHandler("audio", new zf(this._soundManager));
        this.loader.addHandler("script", new tb(this));
        this.loader.addHandler("scene", new Ni(this));
        this.loader.addHandler("cubemap", new Di(this.graphicsDevice,this.assets,this.loader));
        this.loader.addHandler("html", new Ii);
        this.loader.addHandler("css", new Ci);
        this.loader.addHandler("shader", new Pi);
        this.loader.addHandler("hierarchy", new Hi(this));
        this.loader.addHandler("scenesettings", new Oi(this));
        this.loader.addHandler("folder", new Ei);
        this.loader.addHandler("font", new Gi(this.loader));
        this.loader.addHandler("binary", new xi);
        this.loader.addHandler("textureatlas", new Vi(this.loader));
        this.loader.addHandler("sprite", new Qi(this.assets,this.graphicsDevice));
        this.loader.addHandler("template", new Ti(this));
        this.loader.addHandler("container", new Bi(this.graphicsDevice,this.scene.defaultMaterial));
        this.systems = new kj;
        this.systems.add(new Ud(this));
        this.systems.add(new Le(this));
        this.systems.add(new we(this));
        this.systems.add(new xe(this));
        this.systems.add(new Fe(this));
        this.systems.add(new Me(this));
        this.systems.add(new Ee(this));
        ub.legacy ? this.systems.add(new Ne(this)) : this.systems.add(new Je(this));
        this.systems.add(new ze(this,this._soundManager));
        this.systems.add(new od(this,this._soundManager));
        this.systems.add(new ye(this,this._soundManager));
        this.systems.add(new Ge(this));
        this.systems.add(new Ie(this));
        this.systems.add(new Ce(this));
        this.systems.add(new Ae(this));
        this.systems.add(new Oe(this));
        this.systems.add(new Ke(this));
        this.systems.add(new Zd(this));
        this.systems.add(new De(this));
        this.systems.add(new Pe(this));
        this.systems.add(new Qe(this));
        this._visibilityChangeHandler = this.onVisibilityChange.bind(this);
        "undefined" !== typeof document && (void 0 !== document.hidden ? (this._hiddenAttr = "hidden",
        document.addEventListener("visibilitychange", this._visibilityChangeHandler, !1)) : void 0 !== document.mozHidden ? (this._hiddenAttr = "mozHidden",
        document.addEventListener("mozvisibilitychange", this._visibilityChangeHandler, !1)) : void 0 !== document.msHidden ? (this._hiddenAttr = "msHidden",
        document.addEventListener("msvisibilitychange", this._visibilityChangeHandler, !1)) : void 0 !== document.webkitHidden && (this._hiddenAttr = "webkitHidden",
        document.addEventListener("webkitvisibilitychange", this._visibilityChangeHandler, !1)));
        this.meshInstanceArray = [];
        this.tick = Go(this)
    }
    function ka() {
        this.name = "Untitled";
        this.id = Ho++;
        this._shader = null;
        this.variants = {};
        this.parameters = {};
        this.alphaTest = 0;
        this.blend = this.alphaToCoverage = !1;
        this.blendSrc = 1;
        this.blendEquation = this.blendDst = 0;
        this.separateAlphaBlend = !1;
        this.blendSrcAlpha = 1;
        this.blendAlphaEquation = this.blendDstAlpha = 0;
        this.cull = 1;
        this.depthWrite = this.depthTest = !0;
        this.stencilBack = this.stencilFront = null;
        this.slopeDepthBias = this.depthBias = 0;
        this.alphaWrite = this.blueWrite = this.greenWrite = this.redWrite = !0;
        this.meshInstances = [];
        this._shaderVersion = 0;
        this._scene = null;
        this._dirtyBlend = !1;
        this.dirty = !0
    }
    function Vb() {
        this._mapXForms = null
    }
    function la() {
        ka.call(this);
        this._assetReferences = {};
        this._validator = null;
        this.shaderOptBuilder = new Vb;
        this.reset()
    }
    function Jb(a) {
        this._device = a;
        this._cache = {};
        this._generators = {};
        this._precached = this._isClearingCache = !1;
        this._programsCollection = [];
        this._defaultStdMatOption = {};
        this._defaultStdMatOptionMin = {};
        var b = new la;
        b.shaderOptBuilder.updateRef(this._defaultStdMatOption, a, {}, b, null, [], 0, null, null);
        b.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, a, {}, b, null, [], 3, null, null)
    }
    function uj() {
        this.revision = this.globalId = 0
    }
    function Dl() {
        El++;
        this.version = new uj;
        this.version.globalId = El
    }
    function Zg(a) {
        this.name = a;
        this.value = null;
        this.versionObject = new Dl
    }
    function $g(a) {
        this.name = a;
        this.variables = {};
        this.namespaces = {}
    }
    function vj(a, b, c, d) {
        this.locationId = d;
        this.scopeId = a.scope.resolve(b);
        this.version = new uj;
        if ("[0]" === b.substr(b.length - 3))
            switch (c) {
            case 2:
                c = 17;
                break;
            case 3:
                c = 21;
                break;
            case 4:
                c = 22;
                break;
            case 5:
                c = 23
            }
        this.dataType = c;
        this.value = [null, null, null, null];
        this.array = []
    }
    function Fl(a, b) {
        var c = !0
          , d = a.createTexture();
        a.bindTexture(a.TEXTURE_2D, d);
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST);
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST);
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE);
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);
        a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, 2, 2, 0, a.RGBA, b, null);
        b = a.createFramebuffer();
        a.bindFramebuffer(a.FRAMEBUFFER, b);
        a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, d, 0);
        a.checkFramebufferStatus(a.FRAMEBUFFER) !== a.FRAMEBUFFER_COMPLETE && (c = !1);
        a.bindTexture(a.TEXTURE_2D, null);
        a.deleteTexture(d);
        a.bindFramebuffer(a.FRAMEBUFFER, null);
        a.deleteFramebuffer(b);
        return c
    }
    function ah(a, b, c) {
        var d = b._colorBuffer;
        if (7 == d.format) {
            var e = new Uint8Array(d.width * d.height * 4)
              , f = a.gl;
            a.setFramebuffer(b._glFrameBuffer);
            f.readPixels(0, 0, d.width, d.height, f.RGBA, f.UNSIGNED_BYTE, e);
            d._levels || (d._levels = []);
            d._levels[0] || (d._levels[0] = []);
            d._levels[0][c] = e
        }
    }
    function bh(a, b) {
        return Math.atan2(a * b, Math.sqrt(a * a + b * b + 1))
    }
    function Gl(a, b) {
        var c, d = a.width;
        if (7 != a.format)
            console.error("ERROR: SH: cubemap must be RGBA8");
        else {
            if (a._levels[0]) {
                if (!a._levels[0][0].length)
                    if (a._levels[0][0]instanceof HTMLImageElement) {
                        var e = ea.getApplication().graphicsDevice;
                        var f = e.gl;
                        var g = Wa(e, F.fullscreenQuadVS, F.fullscreenQuadPS, "fsQuadSimple")
                          , k = e.scope.resolve("source");
                        for (c = 0; 6 > c; c++) {
                            var h = a._levels[0][c]
                              , l = new V(e,{
                                cubemap: !1,
                                type: "default",
                                format: a.format,
                                width: d,
                                height: d,
                                mipmaps: !1
                            });
                            l.name = "prefiltered-cube";
                            l._levels[0] = h;
                            l.upload();
                            h = new V(e,{
                                cubemap: !1,
                                type: "default",
                                format: a.format,
                                width: d,
                                height: d,
                                mipmaps: !1
                            });
                            h.name = "prefiltered-cube";
                            h = new ra(e,h,{
                                depth: !1
                            });
                            k.setValue(l);
                            La(e, h, g);
                            var n = new Uint8Array(d * d * 4);
                            f.bindFramebuffer(f.FRAMEBUFFER, h._glFrameBuffer);
                            f.readPixels(0, 0, l.width, l.height, f.RGBA, f.UNSIGNED_BYTE, n);
                            a._levels[0][c] = n
                        }
                    } else {
                        console.error("ERROR: SH: cubemap must be composed of arrays or images");
                        return
                    }
                g = [];
                for (f = 0; f < d; f++)
                    for (e = 0; e < d; e++)
                        g[f * d + e] = (new z(e / (d - 1) * 2 - 1,f / (d - 1) * 2 - 1,1)).normalize();
                k = new Float32Array(27);
                for (c = h = 0; 6 > c; c++)
                    for (f = 0; f < d; f++)
                        for (e = 0; e < d; e++) {
                            l = f * d + e;
                            n = e;
                            var p = f;
                            var q = d;
                            var r = (2 * (n + .5) / q - 1) * (1 - 1 / q);
                            var t = (2 * (p + .5) / q - 1) * (1 - 1 / q);
                            var u = 1 / q;
                            var x = r - u;
                            var v = t - u;
                            r += u;
                            t += u;
                            x = bh(x, v) - bh(x, t) - bh(r, v) + bh(r, t);
                            if (0 === n && 0 === p || n === q - 1 && 0 === p || 0 === n && p === q - 1 || n === q - 1 && p === q - 1)
                                x /= 3;
                            else if (0 === n || 0 === p || n === q - 1 || p === q - 1)
                                x *= .5;
                            n = x;
                            p = 4 * n / 17;
                            q = 8 * n / 17;
                            x = 15 * n / 17;
                            v = 5 * n / 68;
                            t = 15 * n / 68;
                            u = g[l];
                            if (0 == c) {
                                var w = u.z;
                                var y = -u.y;
                                var A = -u.x
                            } else
                                1 == c ? (w = -u.z,
                                y = -u.y,
                                A = u.x) : 2 == c ? (w = u.x,
                                y = u.z,
                                A = u.y) : 3 == c ? (w = u.x,
                                y = -u.z,
                                A = -u.y) : 4 == c ? (w = u.x,
                                y = -u.y,
                                A = u.z) : 5 == c && (w = -u.x,
                                y = -u.y,
                                A = -u.z);
                            b || (w = -w);
                            r = a._levels[0][c][4 * l + 3] / 255;
                            for (u = 0; 3 > u; u++) {
                                var B = a._levels[0][c][4 * l + u] / 255;
                                "rgbm" === a.type ? (B *= 8 * r,
                                B *= B) : B = Math.pow(B, 2.2);
                                k[0 + u] += B * p;
                                k[3 + u] += B * q * w;
                                k[6 + u] += B * q * y;
                                k[9 + u] += B * q * A;
                                k[12 + u] += B * x * w * A;
                                k[15 + u] += B * x * A * y;
                                k[18 + u] += B * x * y * w;
                                k[21 + u] += B * v * (3 * A * A - 1);
                                k[24 + u] += B * t * (w * w - y * y);
                                h += n
                            }
                        }
                for (u = 0; u < k.length; u++)
                    k[u] *= 4 * Math.PI / h;
                return k
            }
            console.error("ERROR: SH: cubemap must be synced to CPU")
        }
    }
    function wj(a) {
        this.device = a;
        this.depthMap = this.shader = null;
        this.vertexBuffer = Hl(a);
        this.needsDepthBuffer = !1
    }
    function Hl(a) {
        var b = new Na(a,[{
            semantic: "POSITION",
            components: 2,
            type: 6
        }]);
        a = new ab(a,b,4);
        b = new Pb(a);
        b.element.POSITION.set(-1, -1);
        b.next();
        b.element.POSITION.set(1, -1);
        b.next();
        b.element.POSITION.set(-1, 1);
        b.next();
        b.element.POSITION.set(1, 1);
        b.end();
        return a
    }
    function Il(a, b, c, d, e) {
        var f = a.getRenderTarget();
        a.setRenderTarget(b);
        a.updateBegin();
        var g = null !== b ? b.width : a.width
          , k = null !== b ? b.height : a.height
          , h = 0
          , l = 0;
        e && (h = e.x * g,
        l = e.y * k,
        g *= e.z,
        k *= e.w);
        e = a.vx;
        b = a.vy;
        var n = a.vw
          , p = a.vh;
        a.setViewport(h, l, g, k);
        var q = a.sx
          , r = a.sy
          , t = a.sw
          , u = a.sh;
        a.setScissor(h, l, g, k);
        g = a.getBlending();
        k = a.getDepthTest();
        h = a.getDepthWrite();
        l = a.getCullMode();
        var x = a.writeRed
          , v = a.writeGreen
          , w = a.writeBlue
          , y = a.writeAlpha;
        a.setBlending(!1);
        a.setDepthTest(!1);
        a.setDepthWrite(!1);
        a.setCullMode(0);
        a.setColorWrite(!0, !0, !0, !0);
        a.setVertexBuffer(c, 0);
        a.setShader(d);
        a.draw(Io);
        a.setBlending(g);
        a.setDepthTest(k);
        a.setDepthWrite(h);
        a.setCullMode(l);
        a.setColorWrite(x, v, w, y);
        a.updateEnd();
        a.setRenderTarget(f);
        a.updateBegin();
        a.setViewport(e, b, n, p);
        a.setScissor(q, r, t, u)
    }
    function Kf(a, b) {
        b = b || 3;
        this.device = a.device;
        var c = this.device.gl;
        this._inputBuffer = a;
        3 === b && a.usage !== b && (c.bindBuffer(c.ARRAY_BUFFER, a.bufferId),
        c.bufferData(c.ARRAY_BUFFER, a.storage, c.DYNAMIC_COPY));
        this._outputBuffer = new ab(a.device,a.format,a.numVertices,b,a.storage)
    }
    function $d() {
        ka.call(this)
    }
    function pd(a, b, c) {
        a instanceof ib && (a = ea.getApplication());
        this.app = a;
        var d = this.device = a.graphicsDevice;
        this.library = d.getProgramLibrary();
        this.pickColor = new Float32Array(4);
        this.pickColor[3] = 1;
        this.scene = null;
        this.drawCalls = [];
        this.layerComp = this.layer = null;
        this.clearOptions = {
            color: [1, 1, 1, 1],
            depth: 1,
            flags: 3
        };
        var e = this;
        this._clearDepthOptions = {
            depth: 1,
            flags: 2
        };
        this.clearDepthCommand = new vg(0,0,function() {
            d.clear(e._clearDepthOptions)
        }
        );
        this.resize(b, c);
        this._ignoreOpacityFor = null
    }
    function Jl() {}
    function xj(a, b) {
        b ? (this.key = b.keyCode,
        this.element = b.target,
        this.event = b) : this.event = this.element = this.key = null
    }
    function yj(a) {
        ch.key = a.keyCode;
        ch.element = a.target;
        ch.event = a;
        return ch
    }
    function dh(a) {
        return "string" === typeof a ? a.toUpperCase().charCodeAt(0) : a
    }
    function jb(a, b) {
        M.call(this);
        b = b || {};
        this._element = null;
        this._keyDownHandler = this._handleKeyDown.bind(this);
        this._keyUpHandler = this._handleKeyUp.bind(this);
        this._keyPressHandler = this._handleKeyPress.bind(this);
        this._keymap = {};
        this._lastmap = {};
        a && this.attach(a);
        this.preventDefault = b.preventDefault || !1;
        this.stopPropagation = b.stopPropagation || !1
    }
    function qd(a, b) {
        var c = {
            x: 0,
            y: 0
        };
        if (b) {
            if (b instanceof qd)
                throw Error("Expected MouseEvent");
            c = a._getTargetCoords(b)
        } else
            b = {};
        if (c)
            this.x = c.x,
            this.y = c.y;
        else if (Kb.isPointerLocked())
            this.y = this.x = 0;
        else
            return;
        this.wheelDelta = 0;
        "wheel" === b.type && (0 < b.deltaY ? this.wheelDelta = 1 : 0 > b.deltaY && (this.wheelDelta = -1));
        Kb.isPointerLocked() ? (this.dx = b.movementX || b.webkitMovementX || b.mozMovementX || 0,
        this.dy = b.movementY || b.webkitMovementY || b.mozMovementY || 0) : (this.dx = this.x - a._lastX,
        this.dy = this.y - a._lastY);
        this.button = "mousedown" === b.type || "mouseup" === b.type ? b.button : -1;
        this.buttons = a._buttons.slice(0);
        this.element = b.target;
        this.ctrlKey = b.ctrlKey || !1;
        this.altKey = b.altKey || !1;
        this.shiftKey = b.shiftKey || !1;
        this.metaKey = b.metaKey || !1;
        this.event = b
    }
    function Kb(a) {
        M.call(this);
        this._lastY = this._lastX = 0;
        this._buttons = [!1, !1, !1];
        this._lastbuttons = [!1, !1, !1];
        this._upHandler = this._handleUp.bind(this);
        this._downHandler = this._handleDown.bind(this);
        this._moveHandler = this._handleMove.bind(this);
        this._wheelHandler = this._handleWheel.bind(this);
        this._contextMenuHandler = function(b) {
            b.preventDefault()
        }
        ;
        this._target = null;
        this._attached = !1;
        this.attach(a)
    }
    function kb(a, b) {
        b = b || {};
        this._keyboard = b.keyboard || null;
        this._mouse = b.mouse || null;
        this._gamepads = b.gamepads || null;
        this._element = null;
        this._actions = {};
        this._axes = {};
        this._axesValues = {};
        a && this.attach(a)
    }
    function Jo(a, b, c) {
        Re.sub2(b, a);
        eh.sub2(c[0], a);
        zj.sub2(c[1], a);
        Kl.sub2(c[2], a);
        fh.cross(Kl, Re);
        if (0 <= eh.dot(fh)) {
            if (0 > -zj.dot(fh))
                return !1;
            a = eh;
            if (0 > Ll.cross(Re, zj).dot(a))
                return !1
        } else {
            Aj.sub2(c[3], a);
            if (0 > Aj.dot(fh))
                return !1;
            a = Aj;
            if (0 > Ll.cross(Re, eh).dot(a))
                return !1
        }
        return 1E-8 > Re.sub2(c[0], c[2]).lengthSq() || 1E-8 > Re.sub2(c[1], c[3]).lengthSq() ? !1 : !0
    }
    function rd(a, b, c) {
        this.event = a;
        this.element = b;
        this.camera = c;
        this._stopPropagation = !1
    }
    function sd(a, b, c, d, e, f, g) {
        rd.call(this, a, b, c);
        this.x = d;
        this.y = e;
        this.ctrlKey = a.ctrlKey || !1;
        this.altKey = a.altKey || !1;
        this.shiftKey = a.shiftKey || !1;
        this.metaKey = a.metaKey || !1;
        this.button = a.button;
        Kb.isPointerLocked() ? (this.dx = a.movementX || a.webkitMovementX || a.mozMovementX || 0,
        this.dy = a.movementY || a.webkitMovementY || a.mozMovementY || 0) : (this.dx = d - f,
        this.dy = e - g);
        this.wheelDelta = 0;
        "wheel" === a.type && (0 < a.deltaY ? this.wheelDelta = 1 : 0 > a.deltaY && (this.wheelDelta = -1))
    }
    function Oc(a, b, c, d, e, f) {
        rd.call(this, a, b, c);
        this.touches = a.touches;
        this.changedTouches = a.changedTouches;
        this.x = d;
        this.y = e;
        this.touch = f
    }
    function lc(a, b, c, d) {
        rd.call(this, a, b, c);
        this.inputSource = d
    }
    function Lf(a, b) {
        this._app = null;
        this._attached = !1;
        this._target = null;
        this._enabled = !0;
        this._lastY = this._lastX = 0;
        this._upHandler = this._handleUp.bind(this);
        this._downHandler = this._handleDown.bind(this);
        this._moveHandler = this._handleMove.bind(this);
        this._wheelHandler = this._handleWheel.bind(this);
        this._touchstartHandler = this._handleTouchStart.bind(this);
        this._touchcancelHandler = this._touchendHandler = this._handleTouchEnd.bind(this);
        this._touchmoveHandler = this._handleTouchMove.bind(this);
        this._sortHandler = this._sortElements.bind(this);
        this._elements = [];
        this._pressedElement = this._hoveredElement = null;
        this._touchedElements = {};
        this._touchesForWhichTouchLeaveHasFired = {};
        this._selectedElements = {};
        this._selectedPressedElements = {};
        this._useMouse = !b || !1 !== b.useMouse;
        this._useTouch = !b || !1 !== b.useTouch;
        this._useXr = !b || !1 !== b.useXr;
        this._selectEventsAttached = !1;
        Ca.touch && (this._clickedEntities = {});
        this.attach(a)
    }
    function Bj() {
        this.gamepadsSupported = !!navigator.getGamepads || !!navigator.webkitGetGamepads;
        this.current = [];
        this.previous = [];
        this.deadZone = .25
    }
    function gh(a) {
        var b = Cj(a);
        this.id = a.identifier;
        this.x = b.x;
        this.y = b.y;
        this.target = a.target;
        this.touch = a
    }
    function ae(a, b) {
        this.element = b.target;
        this.event = b;
        this.touches = [];
        this.changedTouches = [];
        if (b) {
            var c = b.touches.length;
            for (a = 0; a < c; a++)
                this.touches.push(new gh(b.touches[a]));
            c = b.changedTouches.length;
            for (a = 0; a < c; a++)
                this.changedTouches.push(new gh(b.changedTouches[a]))
        }
    }
    function Se(a) {
        M.call(this);
        this._element = null;
        this._startHandler = this._handleTouchStart.bind(this);
        this._endHandler = this._handleTouchEnd.bind(this);
        this._moveHandler = this._handleTouchMove.bind(this);
        this._cancelHandler = this._handleTouchCancel.bind(this);
        this.attach(a)
    }
    function Cj(a) {
        for (var b = 0, c = 0, d = a.target; !(d instanceof HTMLElement); )
            d = d.parentNode;
        do
            b += d.offsetLeft - d.scrollLeft,
            c += d.offsetTop - d.scrollTop,
            d = d.offsetParent;
        while (d);return {
            x: a.pageX - b,
            y: a.pageY - c
        }
    }
    function wb(a, b) {
        M.call(this);
        this.type = "bitmap";
        this.app = a;
        this.intensity = 0;
        b = b || {};
        this.fontWeight = b.fontWeight || "normal";
        this.glyphSize = this.fontSize = parseInt(b.fontSize, 10);
        this.fontName = b.fontName || "Arial";
        this.color = b.color || new L(1,1,1);
        this.padding = b.padding || 0;
        a = 4096 < b.width ? 4096 : b.width || 512;
        var c = 4096 < b.height ? 4096 : b.height || 512;
        b = document.createElement("canvas");
        b.height = c;
        b.width = a;
        a = new V(this.app.graphicsDevice,{
            format: 7,
            autoMipmap: !0
        });
        a.name = "font";
        a.setSource(b);
        a.minFilter = 5;
        a.magFilter = 1;
        a.addressU = 1;
        a.addressV = 1;
        this.textures = [a];
        this.chars = "";
        this.data = {}
    }
    function Ml() {}
    function hh(a, b, c) {
        b = new V(b,{
            format: c,
            width: b.width,
            height: b.height
        });
        b.name = "posteffect-pass";
        b.minFilter = 0;
        b.magFilter = 0;
        b.addressU = 1;
        b.addressV = 1;
        Ka[a]._colorBuffer = b
    }
    function Nl(a) {
        a = a.match(Ko) || [];
        for (var b, c, d = [], e = 0; e < a.length; e++)
            b = a[e].search(Lo),
            c = a[e].search(Mo),
            b = a[e].substr(b, c - b),
            "uColorBuffer" !== b && d.push(b);
        return d
    }
    function Ol(a, b) {
        this.app = a;
        this.srcRenderTarget = b.srcRenderTarget;
        this.hdr = b.hdr;
        this.blending = b.blending;
        this.shader = b.shader;
        this.setup = b.setup;
        var c = this
          , d = a.graphicsDevice;
        this.layer = new ma({
            opaqueSortMode: 0,
            transparentSortMode: 0,
            passThrough: !0,
            name: b.name,
            onPostRender: function() {
                c.srcRenderTarget ? (Ab.x = c.srcRenderTarget.width,
                Ab.y = c.srcRenderTarget.height,
                Ab.z = 1 / c.srcRenderTarget.width,
                Ab.w = 1 / c.srcRenderTarget.height) : (Ab.x = d.width,
                Ab.y = d.height,
                Ab.z = 1 / d.width,
                Ab.w = 1 / d.height);
                Mf[0] = Ab.x;
                Mf[1] = Ab.y;
                Mf[2] = Ab.z;
                Mf[3] = Ab.w;
                Pl.setValue(Mf);
                if (this._postEffectCombined && 0 > this._postEffectCombined)
                    c.setup && c.setup(d, c, Ab, null, this.renderTarget);
                else {
                    var f = this._postEffectCombinedSrc ? this._postEffectCombinedSrc : c.srcRenderTarget ? c.srcRenderTarget : Ka[this._backbufferRtId];
                    1 < f._samples && f.resolve(!0, !1);
                    var g = f._colorBuffer;
                    g.magFilter = (this._postEffectCombinedShader ? this._postEffectCombinedBilinear : this.postEffectBilinear) ? 1 : 0;
                    Dj.setValue(g);
                    c.setup && c.setup(d, c, Ab, f, this.renderTarget);
                    (f = this._postEffectCombinedShader ? this._postEffectCombinedShader : this.shader) && La(d, this.renderTarget, f, null, null, c.blending);
                    if (!c.srcRenderTarget)
                        for (f = a.scene.layers.layerList,
                        g = 0; g < f.length && f[g] !== c.layer; g++)
                            if (f[g].renderTarget === Ka[0] || f[g].renderTarget === Ka[1])
                                f[g].renderTarget = null
                }
            }
        });
        this.layer._generateCameraHash();
        this.layer.isPostEffect = !0;
        this.layer.unmodifiedUvs = b.unmodifiedUvs;
        this.layer.postEffectBilinear = b.bilinear;
        this.layer.postEffect = this;
        this.layer.shader = b.shader;
        this.layer.renderTarget = b.destRenderTarget;
        if (!Dj) {
            Dj = d.scope.resolve("uColorBuffer");
            Pl = d.scope.resolve("uScreenSize");
            b = d.supportsMsaa ? 4 : 1;
            for (var e = 0; 2 > e; e++)
                Ka[e] = new ra({
                    depth: !0,
                    stencil: d.supportsStencil,
                    samples: b,
                    autoResolve: !1
                }),
                Ka[e].name = "backbuffer" + e;
            a.on("prerender", function() {
                var f = a.scene.layers.layerList, g, k = 0, h = 0;
                Ej = Fj = Nf = !1;
                var l = 7;
                if (a.scene.layers._dirty) {
                    var n = 0;
                    for (g = 0; g < f.length; g++) {
                        var p = !1;
                        var q;
                        if ((q = f[g].isPostEffect) && !(q = 0 === n) && (q = f[g].unmodifiedUvs && f[g].shader)) {
                            a: {
                                var r, t, u;
                                var x = f;
                                var v = mc;
                                var w = n
                                  , y = Nl(f[g].shader.definition.fshader);
                                if (0 !== y.length)
                                    for (u = 0; u < w; u++)
                                        for (t = 0; t < y.length; t++) {
                                            q = y[t];
                                            var A = Nl(x[v[u]].shader.definition.fshader);
                                            for (r = 0; r < A.length; r++)
                                                if (A[r] === q) {
                                                    q = !0;
                                                    break a
                                                }
                                        }
                                q = !1
                            }
                            q = !q
                        }
                        q ? (mc[n] = g,
                        n++,
                        g === f.length - 1 && (p = !0)) : 0 < n && (p = !0);
                        if (p) {
                            if (1 < n) {
                                q = "post_";
                                for (p = 0; p < n; p++)
                                    A = f[mc[p]],
                                    q += A.name ? A.name : A.id,
                                    p < n - 1 && (q += "_");
                                A = d.programLib._cache[q];
                                if (!A) {
                                    r = "vec4 shaderOutput;\n";
                                    t = "void main() {\n";
                                    u = [];
                                    for (p = 0; p < n; p++) {
                                        A = f[mc[p]].shader.definition.fshader + "\n";
                                        A = A.replace(No, "//").replace(Oo, "//").replace(Po, "//").replace(Qo, "shaderOutput");
                                        0 < p && (A = A.replace(Ro, "//").replace(So, "//").replace(To, "shaderOutput;//"));
                                        A = A.replace(Uo, "void main" + p);
                                        var B;
                                        y = A;
                                        v = u;
                                        var E = y.length;
                                        var C = 0
                                          , D = B = 0;
                                        w = "";
                                        for (x = 0; x < E; x++) {
                                            var G = y.charAt(x);
                                            "{" === G ? (0 === B && (C = x),
                                            B++) : "}" === G && (1 === B && (G = x,
                                            w += y.substr(D, C - D + 1),
                                            D = G),
                                            B--)
                                        }
                                        w += y.substr(D, y.length - D + 1);
                                        C = null;
                                        D = w.match(Vo) || [];
                                        for (x = 0; x < D.length; x++)
                                            for (y = D[x].split(","),
                                            E = 0; E < y.length; E++)
                                                B = y[E].replace(Wo, "").trim(),
                                                0 <= v.indexOf(B) ? (C || (C = []),
                                                C.push(B)) : v.push(B);
                                        w = w.match(Xo) || [];
                                        for (x = 0; x < w.length; x++)
                                            for (y = w[x].split(","),
                                            E = 0; E < y.length; E++)
                                                B = y[E].replace(Yo, "").trim(),
                                                B = v.indexOf(B),
                                                0 <= B && v.splice(B, 1);
                                        if (x = C)
                                            for (v = 0; v < x.length; v++)
                                                A = A.replace(new RegExp("\\b" + x[v] + "\\b","g"), x[v] + "NNNN" + p);
                                        r += A;
                                        t += "main" + p + "();\n"
                                    }
                                    t += "gl_FragColor = shaderOutput;\n}\n";
                                    A = Wa(d, F.fullscreenQuadVS, r + t, q)
                                }
                                for (p = 0; p < n; p++)
                                    f[mc[p]]._postEffectCombined = p === n - 1 ? 1 : -1;
                                f[mc[n - 1]]._postEffectCombinedShader = A;
                                f[mc[n - 1]]._postEffectCombinedBilinear = f[mc[0]].postEffectBilinear;
                                f[mc[n - 1]]._postEffectCombinedSrc = f[mc[0]].postEffect.srcRenderTarget
                            }
                            mc[0] = g;
                            n = 1
                        }
                    }
                }
                for (g = 0; g < f.length; g++) {
                    if (f[g].isPostEffect && (!f[g].postEffect.srcRenderTarget && !f[g]._postEffectCombined || !f[g].postEffect._postEffectCombinedSrc && 0 <= f[g]._postEffectCombined)) {
                        for (p = g - 1; p >= k; p--)
                            f[p].renderTarget || (f[p].renderTarget = Ka[h]);
                        f[g]._backbufferRtId = h;
                        k = g;
                        Nf = !0;
                        1 === h && (Fj = !0);
                        f[g].postEffect.hdr && (l = d.webgl2 && d.textureFloatRenderable ? 18 : d.extTextureHalfFloatLinear && d.textureHalfFloatRenderable ? 12 : 7);
                        f[g].postEffect.shader && !f[g].renderTarget && (h = 1 - h)
                    } else
                        f[g].isPostEffect || f[g].renderTarget || !Nf || (f[g].renderTarget = Ka[h]);
                    f[g].isPostEffect && !f[g].renderTarget && (Ej = !0)
                }
                if (Nf)
                    if (!Ka[0].colorBuffer)
                        hh(0, d, l);
                    else if (Ka[0].width !== d.width || Ka[0].height !== d.height || Ka[0]._colorBuffer._format !== l)
                        Ka[0].colorBuffer.destroy(),
                        Ka[0].destroy(),
                        hh(0, d, l);
                if (Fj)
                    if (!Ka[1].colorBuffer)
                        hh(1, d, l);
                    else if (Ka[1].width !== d.width || Ka[1].height !== d.height || Ka[1]._colorBuffer._format !== l)
                        Ka[1].colorBuffer.destroy(),
                        Ka[1].destroy(),
                        hh(1, d, l)
            }, this);
            a.on("postrender", function() {
                var f = a.graphicsDevice;
                if (Nf && !Ej) {
                    for (var g = a.scene.layers.layerList, k, h = g.length - 1; 0 <= h && (k = g[h].renderTarget,
                    k !== Ka[0] && k !== Ka[1]); h--)
                        ;
                    k && (1 < k._samples && k.resolve(!0, !1),
                    f.copyRenderTarget(k, null, !0, !1))
                }
            }, this)
        }
    }
    function Gj(a) {
        this.name = "UnsupportedBrowserError";
        this.message = a || ""
    }
    function Hj(a) {
        this.name = "ContextCreationError";
        this.message = a || ""
    }
    Array.prototype.find || Object.defineProperty(Array.prototype, "find", {
        value: function(a, b) {
            if (null == this)
                throw TypeError('"this" is null or not defined');
            var c = Object(this)
              , d = c.length >>> 0;
            if ("function" !== typeof a)
                throw TypeError("predicate must be a function");
            for (var e = 0; e < d; ) {
                var f = c[e];
                if (a.call(b, f, e, c))
                    return f;
                e++
            }
        },
        configurable: !0,
        writable: !0
    });
    Math.log2 = Math.log2 || function(a) {
        return Math.log(a) * Math.LOG2E
    }
    ;
    Math.sign || (Math.sign = function(a) {
        return (0 < a) - (0 > a) || +a
    }
    );
    "function" != typeof Object.assign && Object.defineProperty(Object, "assign", {
        value: function(a, b) {
            if (null == a)
                throw new TypeError("Cannot convert undefined or null to object");
            for (var c = Object(a), d = 1; d < arguments.length; d++) {
                var e = arguments[d];
                if (null != e)
                    for (var f in e)
                        Object.prototype.hasOwnProperty.call(e, f) && (c[f] = e[f])
            }
            return c
        },
        writable: !0,
        configurable: !0
    });
    (function() {
        if ("undefined" !== typeof navigator && "undefined" !== typeof document) {
            navigator.pointer = navigator.pointer || navigator.webkitPointer || navigator.mozPointer;
            var a = function() {
                var c = document.createEvent("CustomEvent");
                c.initCustomEvent("pointerlockchange", !0, !1, null);
                document.dispatchEvent(c)
            }
              , b = function() {
                var c = document.createEvent("CustomEvent");
                c.initCustomEvent("pointerlockerror", !0, !1, null);
                document.dispatchEvent(c)
            };
            document.addEventListener("webkitpointerlockchange", a, !1);
            document.addEventListener("webkitpointerlocklost", a, !1);
            document.addEventListener("mozpointerlockchange", a, !1);
            document.addEventListener("mozpointerlocklost", a, !1);
            document.addEventListener("webkitpointerlockerror", b, !1);
            document.addEventListener("mozpointerlockerror", b, !1);
            Element.prototype.requestPointerLock = Element.prototype.mozRequestPointerLock ? function() {
                this.mozRequestPointerLock()
            }
            : Element.prototype.requestPointerLock || Element.prototype.webkitRequestPointerLock || Element.prototype.mozRequestPointerLock;
            !Element.prototype.requestPointerLock && navigator.pointer && (Element.prototype.requestPointerLock = function() {
                document.pointerLockElement = this;
                navigator.pointer.lock(this, a, b)
            }
            );
            document.exitPointerLock = document.exitPointerLock || document.webkitExitPointerLock || document.mozExitPointerLock;
            document.exitPointerLock || (document.exitPointerLock = function() {
                navigator.pointer && (document.pointerLockElement = null,
                navigator.pointer.unlock())
            }
            )
        }
    }
    )();
    (function() {
        if ("undefined" !== typeof window) {
            for (var a = 0, b = ["ms", "moz", "webkit", "o"], c = 0; c < b.length && !window.requestAnimationFrame; ++c)
                window.requestAnimationFrame = window[b[c] + "RequestAnimationFrame"],
                window.cancelAnimationFrame = window[b[c] + "CancelAnimationFrame"] || window[b[c] + "CancelRequestAnimationFrame"];
            window.requestAnimationFrame || (window.requestAnimationFrame = function(d, e) {
                var f = (new Date).getTime()
                  , g = Math.max(0, 16 - (f - a));
                e = window.setTimeout(function() {
                    d(f + g)
                }, g);
                a = f + g;
                return e
            }
            );
            window.cancelAnimationFrame || (window.cancelAnimationFrame = function(d) {
                clearTimeout(d)
            }
            )
        }
    }
    )();
    String.prototype.endsWith || (String.prototype.endsWith = function(a, b) {
        if (void 0 === b || b > this.length)
            b = this.length;
        return this.substring(b - a.length, b) === a
    }
    );
    String.prototype.includes || (String.prototype.includes = function(a, b) {
        "number" !== typeof b && (b = 0);
        return b + a.length > this.length ? !1 : -1 !== this.indexOf(a, b)
    }
    );
    String.prototype.startsWith || (String.prototype.startsWith = function(a, b) {
        return this.substr(!b || 0 > b ? 0 : +b, a.length) === a
    }
    );
    (function() {
        function a(e) {
            var f = e.getError;
            e.getError = function() {
                do {
                    var g = f.apply(e);
                    g != e.NO_ERROR && (b[g] = !0)
                } while (g != e.NO_ERROR);for (g in b)
                    if (b[g])
                        return delete b[g],
                        parseInt(g);
                return e.NO_ERROR
            }
        }
        var b = {}
          , c = function g(f) {
            var k = f.gl;
            this.ext = f;
            this.isAlive = !0;
            this.hasBeenBound = !1;
            this.elementArrayBuffer = null;
            this.attribs = Array(f.maxVertexAttribs);
            for (f = 0; f < this.attribs.length; f++) {
                var h = new g.VertexAttrib(k);
                this.attribs[f] = h
            }
            this.maxAttrib = 0
        };
        c.VertexAttrib = function(f) {
            this.enabled = !1;
            this.buffer = null;
            this.size = 4;
            this.type = f.FLOAT;
            this.normalized = !1;
            this.stride = 16;
            this.offset = 0;
            this.cached = "";
            this.recache()
        }
        ;
        c.VertexAttrib.prototype.recache = function() {
            this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":")
        }
        ;
        var d = function(f) {
            var g = this;
            this.gl = f;
            a(f);
            var k = this.original = {
                getParameter: f.getParameter,
                enableVertexAttribArray: f.enableVertexAttribArray,
                disableVertexAttribArray: f.disableVertexAttribArray,
                bindBuffer: f.bindBuffer,
                getVertexAttrib: f.getVertexAttrib,
                vertexAttribPointer: f.vertexAttribPointer
            };
            f.getParameter = function(h) {
                return h == g.VERTEX_ARRAY_BINDING_OES ? g.currentVertexArrayObject == g.defaultVertexArrayObject ? null : g.currentVertexArrayObject : k.getParameter.apply(this, arguments)
            }
            ;
            f.enableVertexAttribArray = function(h) {
                var l = g.currentVertexArrayObject;
                l.maxAttrib = Math.max(l.maxAttrib, h);
                l.attribs[h].enabled = !0;
                return k.enableVertexAttribArray.apply(this, arguments)
            }
            ;
            f.disableVertexAttribArray = function(h) {
                var l = g.currentVertexArrayObject;
                l.maxAttrib = Math.max(l.maxAttrib, h);
                l.attribs[h].enabled = !1;
                return k.disableVertexAttribArray.apply(this, arguments)
            }
            ;
            f.bindBuffer = function(h, l) {
                switch (h) {
                case f.ARRAY_BUFFER:
                    g.currentArrayBuffer = l;
                    break;
                case f.ELEMENT_ARRAY_BUFFER:
                    g.currentVertexArrayObject.elementArrayBuffer = l
                }
                return k.bindBuffer.apply(this, arguments)
            }
            ;
            f.getVertexAttrib = function(h, l) {
                var n = g.currentVertexArrayObject.attribs[h];
                switch (l) {
                case f.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
                    return n.buffer;
                case f.VERTEX_ATTRIB_ARRAY_ENABLED:
                    return n.enabled;
                case f.VERTEX_ATTRIB_ARRAY_SIZE:
                    return n.size;
                case f.VERTEX_ATTRIB_ARRAY_STRIDE:
                    return n.stride;
                case f.VERTEX_ATTRIB_ARRAY_TYPE:
                    return n.type;
                case f.VERTEX_ATTRIB_ARRAY_NORMALIZED:
                    return n.normalized;
                default:
                    return k.getVertexAttrib.apply(this, arguments)
                }
            }
            ;
            f.vertexAttribPointer = function(h, l, n, p, q, r) {
                var t = g.currentVertexArrayObject;
                t.maxAttrib = Math.max(t.maxAttrib, h);
                t = t.attribs[h];
                t.buffer = g.currentArrayBuffer;
                t.size = l;
                t.type = n;
                t.normalized = p;
                t.stride = q;
                t.offset = r;
                t.recache();
                return k.vertexAttribPointer.apply(this, arguments)
            }
            ;
            f.instrumentExtension && f.instrumentExtension(this, "OES_vertex_array_object");
            f.canvas.addEventListener("webglcontextrestored", function() {
                window.console && window.console.log && window.console.log("OESVertexArrayObject emulation library context restored");
                g.reset_()
            }, !0);
            this.reset_()
        };
        d.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
        d.prototype.reset_ = function() {
            if (void 0 !== this.vertexArrayObjects)
                for (var f = 0; f < this.vertexArrayObjects.length; ++f)
                    this.vertexArrayObjects.isAlive = !1;
            f = this.gl;
            this.maxVertexAttribs = f.getParameter(f.MAX_VERTEX_ATTRIBS);
            this.defaultVertexArrayObject = new c(this);
            this.currentArrayBuffer = this.currentVertexArrayObject = null;
            this.vertexArrayObjects = [this.defaultVertexArrayObject];
            this.bindVertexArrayOES(null)
        }
        ;
        d.prototype.createVertexArrayOES = function() {
            var f = new c(this);
            this.vertexArrayObjects.push(f);
            return f
        }
        ;
        d.prototype.deleteVertexArrayOES = function(f) {
            f.isAlive = !1;
            this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(f), 1);
            this.currentVertexArrayObject == f && this.bindVertexArrayOES(null)
        }
        ;
        d.prototype.isVertexArrayOES = function(f) {
            return f && f instanceof c && f.hasBeenBound && f.ext == this ? !0 : !1
        }
        ;
        d.prototype.bindVertexArrayOES = function(f) {
            var g = this.gl;
            if (f && !f.isAlive)
                b[g.INVALID_OPERATION] = !0,
                window.console && window.console.error && window.console.error("bindVertexArrayOES: attempt to bind deleted arrayObject");
            else {
                var k = this.original
                  , h = this.currentVertexArrayObject;
                this.currentVertexArrayObject = f || this.defaultVertexArrayObject;
                this.currentVertexArrayObject.hasBeenBound = !0;
                f = this.currentVertexArrayObject;
                if (h != f) {
                    h && f.elementArrayBuffer == h.elementArrayBuffer || k.bindBuffer.call(g, g.ELEMENT_ARRAY_BUFFER, f.elementArrayBuffer);
                    for (var l = this.currentArrayBuffer, n = Math.max(h ? h.maxAttrib : 0, f.maxAttrib), p = 0; p <= n; p++) {
                        var q = f.attribs[p]
                          , r = h ? h.attribs[p] : null;
                        h && q.enabled == r.enabled || (q.enabled ? k.enableVertexAttribArray.call(g, p) : k.disableVertexAttribArray.call(g, p));
                        if (q.enabled) {
                            var t = !1;
                            h && q.buffer == r.buffer || (l != q.buffer && (k.bindBuffer.call(g, g.ARRAY_BUFFER, q.buffer),
                            l = q.buffer),
                            t = !0);
                            (t || q.cached != r.cached) && k.vertexAttribPointer.call(g, p, q.size, q.type, q.normalized, q.stride, q.offset)
                        }
                    }
                    this.currentArrayBuffer != l && k.bindBuffer.call(g, g.ARRAY_BUFFER, this.currentArrayBuffer)
                }
            }
        }
        ;
        window.setupVertexArrayObject = function(f) {
            if (f.getSupportedExtensions) {
                if (-1 != f.getSupportedExtensions().indexOf("OES_vertex_array_object"))
                    return
            } else if (f.getExtension && f.getExtension("OES_vertex_array_object"))
                return;
            if (f.getSupportedExtensions) {
                var g = f.getSupportedExtensions;
                f.getSupportedExtensions = function() {
                    var h = g.call(this) || [];
                    h.push("OES_vertex_array_object");
                    return h
                }
            }
            var k = f.getExtension;
            f.getExtension = function(h) {
                return "OES_vertex_array_object" == h ? (f.__OESVertexArrayObject || (f.__OESVertexArrayObject = new d(f)),
                f.__OESVertexArrayObject) : k ? k.call(this, h) : null
            }
        }
    }
    )();
    var tn = function() {
        for (var a = {}, b = "Array Object Function Date RegExp Float32Array".split(" "), c = 0; c < b.length; c++)
            a["[object " + b[c] + "]"] = b[c].toLowerCase();
        return a
    }()
      , Zo = function() {
        var a = null
          , b = null
          , c = null
          , d = null;
        return {
            display: function(e) {
                a || (a = document.createElement("table"),
                b = document.createElement("tr"),
                c = document.createElement("td"),
                d = document.createElement("td"),
                a.style.cssText = "position:absolute;font-family:sans-serif;font-size:12px;color:#cccccc",
                a.style.top = "0px",
                a.style.left = "0px",
                a.style.border = "thin solid #cccccc",
                document.body.appendChild(a));
                a.innerHTML = "";
                for (var f in e) {
                    var g = b.cloneNode()
                      , k = c.cloneNode()
                      , h = d.cloneNode();
                    k.textContent = f;
                    h.textContent = e[f];
                    g.appendChild(k);
                    g.appendChild(h);
                    a.appendChild(g)
                }
            }
        }
    }();
    Object.assign(M.prototype, {
        _addCallback: function(a, b, c, d) {
            a && "string" === typeof a && b && (this._callbacks[a] || (this._callbacks[a] = []),
            this._callbackActive[a] && this._callbackActive[a] === this._callbacks[a] && (this._callbackActive[a] = this._callbackActive[a].slice()),
            this._callbacks[a].push({
                callback: b,
                scope: c || this,
                once: d || !1
            }))
        },
        on: function(a, b, c) {
            this._addCallback(a, b, c, !1);
            return this
        },
        off: function(a, b, c) {
            if (a)
                this._callbackActive[a] && this._callbackActive[a] === this._callbacks[a] && (this._callbackActive[a] = this._callbackActive[a].slice());
            else
                for (var d in this._callbackActive)
                    this._callbacks[d] && this._callbacks[d] === this._callbackActive[d] && (this._callbackActive[d] = this._callbackActive[d].slice());
            if (a)
                if (b) {
                    a = this._callbacks[a];
                    if (!a)
                        return this;
                    d = a.length;
                    for (var e = 0; e < d; e++)
                        a[e].callback === b && (c && a[e].scope !== c || (a[e--] = a[--d]));
                    a.length = d
                } else
                    this._callbacks[a] && (this._callbacks[a] = []);
            else
                this._callbacks = {};
            return this
        },
        fire: function(a, b, c, d, e, f, g, k, h) {
            if (!a || !this._callbacks[a])
                return this;
            if (this._callbackActive[a]) {
                this._callbackActive[a] === this._callbacks[a] && (this._callbackActive[a] = this._callbackActive[a].slice());
                var l = this._callbacks[a].slice()
            } else
                this._callbackActive[a] = this._callbacks[a];
            for (var n = 0; (l || this._callbackActive[a]) && n < (l || this._callbackActive[a]).length; n++) {
                var p = (l || this._callbackActive[a])[n];
                p.callback.call(p.scope, b, c, d, e, f, g, k, h);
                p.once && (p = this._callbacks[a].indexOf(p),
                -1 !== p && (this._callbackActive[a] === this._callbacks[a] && (this._callbackActive[a] = this._callbackActive[a].slice()),
                this._callbacks[a].splice(p, 1)))
            }
            l || (this._callbackActive[a] = null);
            return this
        },
        once: function(a, b, c) {
            this._addCallback(a, b, c, !0);
            return this
        },
        hasEvent: function(a) {
            return this._callbacks[a] && 0 !== this._callbacks[a].length || !1
        }
    });
    var Of = {
        attach: function(a) {
            var b = Of;
            a._addCallback = b._addCallback;
            a.on = b.on;
            a.off = b.off;
            a.fire = b.fire;
            a.once = b.once;
            a.hasEvent = b.hasEvent;
            a._callbacks = {};
            a._callbackActive = {};
            return a
        },
        _addCallback: M.prototype._addCallback,
        on: M.prototype.on,
        off: M.prototype.off,
        fire: M.prototype.fire,
        once: M.prototype.once,
        hasEvent: M.prototype.hasEvent
    }
      , Ql = {
        create: function() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(a) {
                var b = 16 * Math.random() | 0;
                return ("x" == a ? b : b & 3 | 8).toString(16)
            })
        }
    }
      , ca = {
        delimiter: "/",
        join: function() {
            var a, b = arguments.length, c = arguments[0];
            for (a = 0; a < b - 1; ++a) {
                var d = arguments[a]
                  , e = arguments[a + 1];
                if (!Xh(d) || !Xh(e))
                    throw Error("undefined argument to pc.path.join");
                c = e[0] === ca.delimiter ? e : d && e && d[d.length - 1] !== ca.delimiter && e[0] !== ca.delimiter ? c + (ca.delimiter + e) : c + e
            }
            return c
        },
        normalize: function(a) {
            var b = a.startsWith(ca.delimiter)
              , c = a.endsWith(ca.delimiter);
            a = a.split("/");
            for (var d = [], e = 0; e < a.length; e++)
                "" !== a[e] && "." !== a[e] && (".." === a[e] && 0 < d.length ? d = d.slice(0, d.length - 2) : (0 < e && d.push(ca.delimiter),
                d.push(a[e])));
            a = d.join("");
            b || a[0] !== ca.delimiter || (a = a.slice(1));
            c && a[a.length - 1] !== ca.delimiter && (a += ca.delimiter);
            return a
        },
        split: function(a) {
            a = a.split(ca.delimiter);
            var b = a.slice(a.length - 1)[0];
            return [a.slice(0, a.length - 1).join(ca.delimiter), b]
        },
        getBasename: function(a) {
            return ca.split(a)[1]
        },
        getDirectory: function(a) {
            a = a.split(ca.delimiter);
            return a.slice(0, a.length - 1).join(ca.delimiter)
        },
        getExtension: function(a) {
            var b = a.split("?")[0].split(".").pop();
            return b !== a ? "." + b : ""
        },
        isRelativePath: function(a) {
            return "/" !== a.charAt(0) && null === a.match(/:\/\//)
        },
        extractPath: function(a) {
            var b = ""
              , c = a.split("/");
            if (1 < c.length)
                if (ca.isRelativePath(a))
                    if ("." === c[0])
                        for (a = 0; a < c.length - 1; ++a)
                            b += 0 === a ? c[a] : "/" + c[a];
                    else if (".." === c[0])
                        for (a = 0; a < c.length - 1; ++a)
                            b += 0 === a ? c[a] : "/" + c[a];
                    else
                        for (b = ".",
                        a = 0; a < c.length - 1; ++a)
                            b += "/" + c[a];
                else
                    for (a = 0; a < c.length - 1; ++a)
                        b += 0 === a ? c[a] : "/" + c[a];
            return b
        }
    }
      , Ca = {
        desktop: !1,
        mobile: !1,
        ios: !1,
        android: !1,
        windows: !1,
        xbox: !1,
        gamepads: !1,
        touch: !1,
        workers: !1,
        passiveEvents: !1
    };
    if ("undefined" !== typeof navigator) {
        var Pf = navigator.userAgent;
        /(windows|mac os|linux|cros)/i.test(Pf) && (Ca.desktop = !0);
        /xbox/i.test(Pf) && (Ca.xbox = !0);
        /(windows phone|iemobile|wpdesktop)/i.test(Pf) ? (Ca.desktop = !1,
        Ca.mobile = !0,
        Ca.windows = !0) : /android/i.test(Pf) ? (Ca.desktop = !1,
        Ca.mobile = !0,
        Ca.android = !0) : /ip([ao]d|hone)/i.test(Pf) && (Ca.desktop = !1,
        Ca.mobile = !0,
        Ca.ios = !0);
        "undefined" !== typeof window && (Ca.touch = "ontouchstart"in window || "maxTouchPoints"in navigator && 0 < navigator.maxTouchPoints);
        Ca.gamepads = "getGamepads"in navigator;
        Ca.workers = "undefined" !== typeof Worker;
        try {
            var Rl = Object.defineProperty({}, "passive", {
                get: function() {
                    Ca.passiveEvents = !0;
                    return !1
                }
            });
            window.addEventListener("testpassive", null, Rl);
            window.removeEventListener("testpassive", null, Rl)
        } catch (a) {}
    }
    var vc = {
        ASCII_LOWERCASE: "abcdefghijklmnopqrstuvwxyz",
        ASCII_UPPERCASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        ASCII_LETTERS: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
        format: function(a) {
            for (var b = 1; b < arguments.length; b++)
                a = a.replace("{" + (b - 1) + "}", arguments[b]);
            return a
        },
        toBool: function(a, b) {
            if ("true" === a)
                return !0;
            if (b) {
                if ("false" === a)
                    return !1;
                throw new TypeError("Not a boolean string");
            }
            return !1
        },
        getCodePoint: function(a, b) {
            return (a = Yh(a, b)) && a.code
        },
        getCodePoints: function(a) {
            if ("string" !== typeof a)
                throw new TypeError("Not a string");
            for (var b = 0, c = [], d; d = Yh(a, b); )
                c.push(d.code),
                b += d.long ? 2 : 1;
            return c
        },
        getSymbols: function(a) {
            if ("string" !== typeof a)
                throw new TypeError("Not a string");
            for (var b = 0, c = a.length, d = [], e = 0, f; b < c; ) {
                f = e;
                var g = a
                  , k = b + e;
                k === g.length - 1 ? e = 1 : $c(g[k], 55296, 56319) ? (e = g.substring(k, k + 2),
                g = g.substring(k + 2, k + 4),
                e = $c(g, 127995, 127999) || $c(e, 127462, 127487) && $c(g, 127462, 127487) ? 4 : $c(g, 65024, 65039) ? 3 : 2) : e = $c(g[k + 1], 65024, 65039) ? 2 : 1;
                e = f + e;
                f = a[b + e];
                $c(f, 8400, 8447) && (f = a[b + e++]);
                $c(f, 65024, 65039) && (f = a[b + e++]);
                f && 8205 === f.charCodeAt(0) ? e++ : (f = a.substring(b, b + e),
                d.push(f),
                b += e,
                e = 0)
            }
            return d
        },
        fromCodePoint: function() {
            for (var a = [], b, c, d = 0; d < arguments.length; ++d)
                b = Number(arguments[d]),
                c = b - 65536,
                b = 65535 < b ? [(c >> 10) + 55296, c % 1024 + 56320] : [b],
                a.push(String.fromCharCode.apply(null, b));
            return a.join("")
        }
    }
      , N = {
        DEG_TO_RAD: Math.PI / 180,
        RAD_TO_DEG: 180 / Math.PI,
        clamp: function(a, b, c) {
            return a >= c ? c : a <= b ? b : a
        },
        intToBytes24: function(a) {
            return [a >> 16 & 255, a >> 8 & 255, a & 255]
        },
        intToBytes32: function(a) {
            return [a >> 24 & 255, a >> 16 & 255, a >> 8 & 255, a & 255]
        },
        bytesToInt24: function(a, b, c) {
            a.length && (c = a[2],
            b = a[1],
            a = a[0]);
            return a << 16 | b << 8 | c
        },
        bytesToInt32: function(a, b, c, d) {
            a.length && (d = a[3],
            c = a[2],
            b = a[1],
            a = a[0]);
            return (a << 24 | b << 16 | c << 8 | d) >>> 32
        },
        lerp: function(a, b, c) {
            return a + (b - a) * N.clamp(c, 0, 1)
        },
        lerpAngle: function(a, b, c) {
            180 < b - a && (b -= 360);
            -180 > b - a && (b += 360);
            return N.lerp(a, b, N.clamp(c, 0, 1))
        },
        powerOfTwo: function(a) {
            return 0 !== a && !(a & a - 1)
        },
        nextPowerOfTwo: function(a) {
            a--;
            a |= a >> 1;
            a |= a >> 2;
            a |= a >> 4;
            a |= a >> 8;
            a |= a >> 16;
            a++;
            return a
        },
        random: function(a, b) {
            return Math.random() * (b - a) + a
        },
        smoothstep: function(a, b, c) {
            if (c <= a)
                return 0;
            if (c >= b)
                return 1;
            c = (c - a) / (b - a);
            return c * c * (3 - 2 * c)
        },
        smootherstep: function(a, b, c) {
            if (c <= a)
                return 0;
            if (c >= b)
                return 1;
            c = (c - a) / (b - a);
            return c * c * c * (c * (6 * c - 15) + 10)
        },
        roundUp: function(a, b) {
            return 0 === b ? a : Math.ceil(a / b) * b
        },
        float2Half: function() {
            var a = new Float32Array(1)
              , b = new Int32Array(a.buffer);
            return function(c) {
                a[0] = c;
                c = b[0];
                var d = c >> 16 & 32768
                  , e = c >> 12 & 2047
                  , f = c >> 23 & 255;
                return 103 > f ? d : 142 < f ? d | 31744 | ((255 == f ? 0 : 1) && c & 8388607) : 113 > f ? (e |= 2048,
                d | (e >> 114 - f) + (e >> 113 - f & 1)) : d = (d | f - 112 << 10 | e >> 1) + (e & 1)
            }
        }()
    };
    Object.assign(L.prototype, {
        clone: function() {
            return new L(this.r,this.g,this.b,this.a)
        },
        copy: function(a) {
            this.r = a.r;
            this.g = a.g;
            this.b = a.b;
            this.a = a.a;
            return this
        },
        equals: function(a) {
            return this.r === a.r && this.g === a.g && this.b === a.b && this.a === a.a
        },
        set: function(a, b, c, d) {
            this.r = a;
            this.g = b;
            this.b = c;
            this.a = void 0 === d ? 1 : d;
            return this
        },
        lerp: function(a, b, c) {
            this.r = a.r + c * (b.r - a.r);
            this.g = a.g + c * (b.g - a.g);
            this.b = a.b + c * (b.b - a.b);
            this.a = a.a + c * (b.a - a.a);
            return this
        },
        fromString: function(a) {
            var b = parseInt(a.replace("#", "0x"), 16);
            7 < a.length ? a = N.intToBytes32(b) : (a = N.intToBytes24(b),
            a[3] = 255);
            this.set(a[0] / 255, a[1] / 255, a[2] / 255, a[3] / 255);
            return this
        },
        toString: function(a) {
            var b = "#" + (16777216 + (Math.round(255 * this.r) << 16) + (Math.round(255 * this.g) << 8) + Math.round(255 * this.b)).toString(16).slice(1);
            !0 === a && (a = Math.round(255 * this.a).toString(16),
            b = this.a < 16 / 255 ? b + ("0" + a) : b + a);
            return b
        }
    });
    Object.defineProperties(L, {
        BLACK: {
            value: new L(0,0,0,1)
        },
        WHITE: {
            value: new L(1,1,1,1)
        },
        YELLOW: {
            value: new L(1,1,0,1)
        },
        RED: {
            value: new L(1,0,0,1)
        },
        MAGENTA: {
            value: new L(1,0,1,1)
        },
        GREEN: {
            value: new L(0,1,0,1)
        },
        GRAY: {
            value: new L(.5,.5,.5,1)
        },
        CYAN: {
            value: new L(0,1,1,1)
        },
        BLUE: {
            value: new L(0,0,1,1)
        }
    });
    Object.freeze(L.BLACK);
    Object.freeze(L.WHITE);
    Object.freeze(L.YELLOW);
    Object.freeze(L.RED);
    Object.freeze(L.MAGENTA);
    Object.freeze(L.GREEN);
    Object.freeze(L.GRAY);
    Object.freeze(L.CYAN);
    Object.freeze(L.BLUE);
    Object.assign(Zh.prototype, {
        push: function(a, b) {
            if (this._index[a])
                throw Error("Key already in index " + a);
            b = this._list.push(b) - 1;
            this._index[a] = b
        },
        has: function(a) {
            return void 0 !== this._index[a]
        },
        get: function(a) {
            a = this._index[a];
            return void 0 !== a ? this._list[a] : null
        },
        remove: function(a) {
            var b = this._index[a];
            if (void 0 !== b) {
                this._list.splice(b, 1);
                delete this._index[a];
                for (a in this._index) {
                    var c = this._index[a];
                    c > b && (this._index[a] = c - 1)
                }
                return !0
            }
            return !1
        },
        list: function() {
            return this._list
        },
        clear: function() {
            this._list.length = 0;
            for (var a in this._index)
                delete this._index[a]
        }
    });
    Object.assign(uk.prototype, {
        addItem: function(a) {
            for (var b = a.tags._list, c = 0; c < b.length; c++)
                this.add(b[c], a)
        },
        removeItem: function(a) {
            for (var b = a.tags._list, c = 0; c < b.length; c++)
                this.remove(b[c], a)
        },
        add: function(a, b) {
            this._index[a] && -1 !== this._index[a].list.indexOf(b) || (this._index[a] || (this._index[a] = {
                list: []
            },
            this._key && (this._index[a].keys = {})),
            this._index[a].list.push(b),
            this._key && (this._index[a].keys[b[this._key]] = b))
        },
        remove: function(a, b) {
            if (this._index[a] && (!this._key || this._index[a].keys[b[this._key]])) {
                var c = this._index[a].list.indexOf(b);
                -1 !== c && (this._index[a].list.splice(c, 1),
                this._key && delete this._index[a].keys[b[this._key]],
                0 === this._index[a].list.length && delete this._index[a])
            }
        },
        find: function(a) {
            var b = this, c = {}, d = [], e, f, g = function(n, p) {
                return b._index[n].list.length - b._index[p].list.length
            };
            for (e = 0; e < a.length; e++) {
                var k = a[e];
                if (k instanceof Array) {
                    if (0 === k.length)
                        continue;
                    if (1 === k.length)
                        k = k[0];
                    else {
                        var h = !1;
                        for (f = 0; f < k.length; f++)
                            if (!this._index[k[f]]) {
                                h = !0;
                                break
                            }
                        if (h)
                            continue;
                        k = k.slice(0).sort(g);
                        var l = k.slice(1);
                        1 === l.length && (l = l[0]);
                        for (f = 0; f < this._index[k[0]].list.length; f++)
                            h = this._index[k[0]].list[f],
                            (this._key ? !c[h[this._key]] : -1 === d.indexOf(h)) && h.tags.has(l) && (this._key && (c[h[this._key]] = !0),
                            d.push(h));
                        continue
                    }
                }
                if (k && "string" === typeof k && this._index[k])
                    for (f = 0; f < this._index[k].list.length; f++)
                        h = this._index[k].list[f],
                        this._key ? c[h[this._key]] || (c[h[this._key]] = !0,
                        d.push(h)) : -1 === d.indexOf(h) && d.push(h)
            }
            return d
        }
    });
    ad.prototype = Object.create(M.prototype);
    ad.prototype.constructor = ad;
    Object.assign(ad.prototype, {
        add: function() {
            var a = !1
              , b = this._processArguments(arguments, !0);
            if (!b.length)
                return a;
            for (var c = 0; c < b.length; c++)
                this._index[b[c]] || (a = !0,
                this._index[b[c]] = !0,
                this._list.push(b[c]),
                this.fire("add", b[c], this._parent));
            a && this.fire("change", this._parent);
            return a
        },
        remove: function() {
            var a = !1;
            if (!this._list.length)
                return a;
            var b = this._processArguments(arguments, !0);
            if (!b.length)
                return a;
            for (var c = 0; c < b.length; c++)
                this._index[b[c]] && (a = !0,
                delete this._index[b[c]],
                this._list.splice(this._list.indexOf(b[c]), 1),
                this.fire("remove", b[c], this._parent));
            a && this.fire("change", this._parent);
            return a
        },
        clear: function() {
            if (this._list.length) {
                var a = this._list.slice(0);
                this._list = [];
                this._index = {};
                for (var b = 0; b < a.length; b++)
                    this.fire("remove", a[b], this._parent);
                this.fire("change", this._parent)
            }
        },
        has: function() {
            return this._list.length ? this._has(this._processArguments(arguments)) : !1
        },
        _has: function(a) {
            if (!this._list.length || !a.length)
                return !1;
            for (var b = 0; b < a.length; b++)
                if (1 === a[b].length) {
                    if (this._index[a[b][0]])
                        return !0
                } else {
                    for (var c = !0, d = 0; d < a[b].length; d++)
                        if (!this._index[a[b][d]]) {
                            c = !1;
                            break
                        }
                    if (c)
                        return !0
                }
            return !1
        },
        list: function() {
            return this._list.slice(0)
        },
        _processArguments: function(a, b) {
            var c = []
              , d = [];
            if (!a || !a.length)
                return c;
            for (var e = 0; e < a.length; e++)
                if (a[e]instanceof Array) {
                    b || (d = []);
                    for (var f = 0; f < a[e].length; f++)
                        "string" === typeof a[e][f] && (b ? c.push(a[e][f]) : d.push(a[e][f]));
                    !b && d.length && c.push(d)
                } else
                    "string" === typeof a[e] && (b ? c.push(a[e]) : c.push([a[e]]));
            return c
        }
    });
    Object.defineProperty(ad.prototype, "size", {
        get: function() {
            return this._list.length
        }
    });
    var Lb = "undefined" !== typeof window && window.performance && window.performance.now && window.performance.timing ? function() {
        return window.performance.now()
    }
    : Date.now;
    Object.assign($h.prototype, {
        start: function() {
            this._isRunning = !0;
            this._a = Lb()
        },
        stop: function() {
            this._isRunning = !1;
            this._b = Lb()
        },
        getMilliseconds: function() {
            return this._b - this._a
        }
    });
    da.ContentType = {
        FORM_URLENCODED: "application/x-www-form-urlencoded",
        GIF: "image/gif",
        JPEG: "image/jpeg",
        DDS: "image/dds",
        JSON: "application/json",
        PNG: "image/png",
        TEXT: "text/plain",
        XML: "application/xml",
        WAV: "audio/x-wav",
        OGG: "audio/ogg",
        MP3: "audio/mpeg",
        MP4: "audio/mp4",
        AAC: "audio/aac",
        BIN: "application/octet-stream",
        BASIS: "image/basis",
        GLB: "model/gltf-binary"
    };
    da.ResponseType = {
        TEXT: "text",
        ARRAY_BUFFER: "arraybuffer",
        BLOB: "blob",
        DOCUMENT: "document",
        JSON: "json"
    };
    da.binaryExtensions = ".model .wav .ogg .mp3 .mp4 .m4a .aac .dds .basis .glb".split(" ");
    da.retryDelay = 100;
    Object.assign(da.prototype, {
        ContentType: da.ContentType,
        ResponseType: da.ResponseType,
        binaryExtensions: da.binaryExtensions,
        get: function(a, b, c) {
            "function" === typeof b && (c = b,
            b = {});
            return this.request("GET", a, b, c)
        },
        post: function(a, b, c, d) {
            "function" === typeof c && (d = c,
            c = {});
            c.postdata = b;
            return this.request("POST", a, c, d)
        },
        put: function(a, b, c, d) {
            "function" === typeof c && (d = c,
            c = {});
            c.postdata = b;
            return this.request("PUT", a, c, d)
        },
        del: function(a, b, c) {
            "function" === typeof b && (c = b,
            b = {});
            return this.request("DELETE", a, b, c)
        },
        request: function(a, b, c, d) {
            var e = !1;
            "function" === typeof c && (d = c,
            c = {});
            c.retry && (c = Object.assign({
                retries: 0,
                maxRetries: 5
            }, c));
            c.callback = d;
            null == c.async && (c.async = !0);
            null == c.headers && (c.headers = {});
            if (null != c.postdata)
                if (c.postdata instanceof Document)
                    var f = c.postdata;
                else if (c.postdata instanceof FormData)
                    f = c.postdata;
                else if (c.postdata instanceof Object)
                    switch (f = c.headers["Content-Type"],
                    void 0 === f && (c.headers["Content-Type"] = da.ContentType.FORM_URLENCODED,
                    f = c.headers["Content-Type"]),
                    f) {
                    case da.ContentType.FORM_URLENCODED:
                        f = "";
                        d = !0;
                        for (g in c.postdata)
                            c.postdata.hasOwnProperty(g) && (d ? d = !1 : f += "&",
                            f += escape(g) + "=" + escape(c.postdata[g]));
                        break;
                    default:
                    case da.ContentType.JSON:
                        null == f && (c.headers["Content-Type"] = da.ContentType.JSON),
                        f = JSON.stringify(c.postdata)
                    }
                else
                    f = c.postdata;
            if (!1 === c.cache) {
                d = Lb();
                var g = new qg(b);
                g.query = g.query ? g.query + "&ts=" + d : "ts=" + d;
                b = g.toString()
            }
            c.query && (g = new qg(b),
            d = Gc(g.getQuery(), c.query),
            g.setQuery(d),
            b = g.toString());
            var k = new XMLHttpRequest;
            k.open(a, b, c.async);
            k.withCredentials = void 0 !== c.withCredentials ? c.withCredentials : !1;
            k.responseType = c.responseType || this._guessResponseType(b);
            for (var h in c.headers)
                c.headers.hasOwnProperty(h) && k.setRequestHeader(h, c.headers[h]);
            k.onreadystatechange = function() {
                this._onReadyStateChange(a, b, c, k)
            }
            .bind(this);
            k.onerror = function() {
                this._onError(a, b, c, k);
                e = !0
            }
            .bind(this);
            try {
                k.send(f)
            } catch (l) {
                e || c.error(k.status, k, l)
            }
            return k
        },
        _guessResponseType: function(a) {
            a = new qg(a);
            a = ca.getExtension(a.path);
            return 0 <= da.binaryExtensions.indexOf(a) ? da.ResponseType.ARRAY_BUFFER : ".xml" === a ? da.ResponseType.DOCUMENT : da.ResponseType.TEXT
        },
        _isBinaryContentType: function(a) {
            return 0 <= [da.ContentType.MP4, da.ContentType.WAV, da.ContentType.OGG, da.ContentType.MP3, da.ContentType.BIN, da.ContentType.DDS, da.ContentType.BASIS, da.ContentType.GLB].indexOf(a) ? !0 : !1
        },
        _onReadyStateChange: function(a, b, c, d) {
            if (4 === d.readyState)
                switch (d.status) {
                case 0:
                    "/" != b[0] ? this._onSuccess(a, b, c, d) : this._onError(a, b, c, d);
                    break;
                case 200:
                case 201:
                case 206:
                case 304:
                    this._onSuccess(a, b, c, d);
                    break;
                default:
                    this._onError(a, b, c, d)
                }
        },
        _onSuccess: function(a, b, c, d) {
            if (a = d.getResponseHeader("Content-Type")) {
                var e = a.split(";");
                e = e[0].trim()
            }
            try {
                if (e === this.ContentType.JSON || b.split("?")[0].endsWith(".json"))
                    var f = JSON.parse(d.responseText);
                else
                    this._isBinaryContentType(e) ? f = d.response : (e && console.warn("responseType: " + d.responseType + " being served with Content-Type: " + e),
                    f = d.responseType === da.ResponseType.ARRAY_BUFFER ? d.response : d.responseType === da.ResponseType.BLOB || d.responseType === da.ResponseType.JSON ? d.response : d.responseType === da.ResponseType.DOCUMENT || e === this.ContentType.XML ? d.responseXML : d.responseText);
                c.callback(null, f)
            } catch (g) {
                c.callback(g)
            }
        },
        _onError: function(a, b, c, d) {
            if (!c.retrying)
                if (c.retry && c.retries < c.maxRetries) {
                    c.retries++;
                    c.retrying = !0;
                    var e = N.clamp(Math.pow(2, c.retries) * da.retryDelay, 0, c.maxRetryDelay || 5E3);
                    console.log(a + ": " + b + " - Error " + d.status + ". Retrying in " + e + " ms");
                    setTimeout(function() {
                        c.retrying = !1;
                        this.request(a, b, c, c.callback)
                    }
                    .bind(this), e)
                } else
                    c.callback(0 === d.status ? "Network error" : d.status, null)
        }
    });
    var wa = new da;
    Object.assign(ai.prototype, {
        evaluate: function(a, b) {
            (b || a < this._left || a >= this._right) && this._reset(a);
            b = this._curve.type;
            5 === b ? a = this._p0 : (a = 0 === this._recip ? 0 : (a - this._left) * this._recip,
            a = 0 === b ? N.lerp(this._p0, this._p1, a) : 1 === b ? N.lerp(this._p0, this._p1, a * a * (3 - 2 * a)) : this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, a));
            return a
        },
        _reset: function(a) {
            var b = this._curve.keys
              , c = b.length;
            if (c)
                if (a < b[0][0])
                    this._left = -Infinity,
                    this._right = b[0][0],
                    this._recip = 0,
                    this._p0 = this._p1 = b[0][1],
                    this._m0 = this._m1 = 0;
                else if (a >= b[c - 1][0])
                    this._left = b[c - 1][0],
                    this._right = Infinity,
                    this._recip = 0,
                    this._p0 = this._p1 = b[c - 1][1],
                    this._m0 = this._m1 = 0;
                else {
                    for (c = 0; a >= b[c + 1][0]; )
                        c++;
                    this._left = b[c][0];
                    this._right = b[c + 1][0];
                    a = 1 / (this._right - this._left);
                    this._recip = isFinite(a) ? a : 0;
                    this._p0 = b[c][1];
                    this._p1 = b[c + 1][1];
                    this._isHermite() && this._calcTangents(b, c)
                }
            else
                this._left = -Infinity,
                this._right = Infinity,
                this._p0 = this._p1 = this._m0 = this._m1 = this._recip = 0
        },
        _isHermite: function() {
            return 2 === this._curve.type || 3 === this._curve.type || 4 === this._curve.type
        },
        _calcTangents: function(a, b) {
            var c = a[b]
              , d = a[b + 1];
            var e = 0 === b ? [a[0][0] + (a[0][0] - a[1][0]), a[0][1] + (a[0][1] - a[1][1])] : a[b - 1];
            a = b == a.length - 2 ? [a[b + 1][0] + (a[b + 1][0] - a[b][0]), a[b + 1][1] + (a[b + 1][1] - a[b][1])] : a[b + 2];
            if (4 === this._curve.type) {
                b = 2 * (d[0] - c[0]) / (d[0] - e[0]);
                var f = 2 * (d[0] - c[0]) / (a[0] - c[0]);
                this._m0 = this._curve.tension * (isFinite(b) ? b : 0) * (d[1] - e[1]);
                this._m1 = this._curve.tension * (isFinite(f) ? f : 0) * (a[1] - c[1])
            } else
                f = (d[0] - c[0]) / (c[0] - e[0]),
                b = (d[0] - c[0]) / (a[0] - d[0]),
                e = c[1] + (e[1] - c[1]) * (isFinite(f) ? f : 0),
                a = d[1] + (a[1] - d[1]) * (isFinite(b) ? b : 0),
                b = 2 === this._curve.type ? .5 : this._curve.tension,
                this._m0 = b * (d[1] - e),
                this._m1 = b * (a - c[1])
        },
        _evaluateHermite: function(a, b, c, d, e) {
            var f = e * e
              , g = e + e
              , k = 1 - e;
            k *= k;
            return a * (1 + g) * k + c * e * k + b * f * (3 - g) + d * f * (e - 1)
        }
    });
    Object.assign(gb.prototype, {
        add: function(a, b) {
            for (var c = this.keys, d = c.length, e = 0; e < d && !(c[e][0] > a); e++)
                ;
            a = [a, b];
            this.keys.splice(e, 0, a);
            return a
        },
        get: function(a) {
            return this.keys[a]
        },
        sort: function() {
            this.keys.sort(function(a, b) {
                return a[0] - b[0]
            })
        },
        value: function(a) {
            return this._eval.evaluate(a, !0)
        },
        closest: function(a) {
            for (var b = this.keys, c = b.length, d = 2, e = null, f = 0; f < c; f++) {
                var g = Math.abs(a - b[f][0]);
                if (d >= g)
                    d = g,
                    e = b[f];
                else
                    break
            }
            return e
        },
        clone: function() {
            var a = new gb;
            a.keys = Gc(a.keys, this.keys);
            a.type = this.type;
            a.tension = this.tension;
            return a
        },
        quantize: function(a) {
            a = Math.max(a, 2);
            var b = new Float32Array(a)
              , c = 1 / (a - 1);
            b[0] = this._eval.evaluate(0, !0);
            for (var d = 1; d < a; d++)
                b[d] = this._eval.evaluate(c * d);
            return b
        },
        quantizeClamped: function(a, b, c) {
            a = this.quantize(a);
            for (var d = 0; d < a.length; ++d)
                a[d] = Math.min(c, Math.max(b, a[d]));
            return a
        }
    });
    Object.defineProperty(gb.prototype, "length", {
        get: function() {
            return this.keys.length
        }
    });
    Object.assign(Cb.prototype, {
        get: function(a) {
            return this.curves[a]
        },
        value: function(a, b) {
            var c = this.curves.length;
            b = b || [];
            b.length = c;
            for (var d = 0; d < c; d++)
                b[d] = this.curves[d].value(a);
            return b
        },
        clone: function() {
            var a = new Cb;
            a.curves = [];
            for (var b = 0; b < this.curves.length; b++)
                a.curves.push(this.curves[b].clone());
            a._type = this._type;
            return a
        },
        quantize: function(a) {
            a = Math.max(a, 2);
            for (var b = this.curves.length, c = new Float32Array(a * b), d = 1 / (a - 1), e = 0; e < b; e++)
                for (var f = new ai(this.curves[e]), g = 0; g < a; g++)
                    c[g * b + e] = f.evaluate(d * g);
            return c
        },
        quantizeClamped: function(a, b, c) {
            a = this.quantize(a);
            for (var d = 0; d < a.length; ++d)
                a[d] = Math.min(c, Math.max(b, a[d]));
            return a
        }
    });
    Object.defineProperty(Cb.prototype, "length", {
        get: function() {
            return this.curves.length
        }
    });
    Object.defineProperty(Cb.prototype, "type", {
        get: function() {
            return this._type
        },
        set: function(a) {
            this._type = a;
            for (var b = 0; b < this.curves.length; b++)
                this.curves[b].type = a
        }
    });
    Object.assign(xb.prototype, {
        clone: function() {
            return (new xb).copy(this)
        },
        copy: function(a) {
            a = a.data;
            var b = this.data;
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            b[6] = a[6];
            b[7] = a[7];
            b[8] = a[8];
            return this
        },
        set: function(a) {
            var b = this.data;
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            b[6] = a[6];
            b[7] = a[7];
            b[8] = a[8];
            return this
        },
        equals: function(a) {
            var b = this.data;
            a = a.data;
            return b[0] === a[0] && b[1] === a[1] && b[2] === a[2] && b[3] === a[3] && b[4] === a[4] && b[5] === a[5] && b[6] === a[6] && b[7] === a[7] && b[8] === a[8]
        },
        isIdentity: function() {
            var a = this.data;
            return 1 === a[0] && 0 === a[1] && 0 === a[2] && 0 === a[3] && 1 === a[4] && 0 === a[5] && 0 === a[6] && 0 === a[7] && 1 === a[8]
        },
        setIdentity: function() {
            var a = this.data;
            a[0] = 1;
            a[1] = 0;
            a[2] = 0;
            a[3] = 0;
            a[4] = 1;
            a[5] = 0;
            a[6] = 0;
            a[7] = 0;
            a[8] = 1;
            return this
        },
        toString: function() {
            for (var a = "[", b = 0; 9 > b; b++)
                a += this.data[b],
                a += 8 !== b ? ", " : "";
            return a + "]"
        },
        transpose: function() {
            var a = this.data;
            var b = a[1];
            a[1] = a[3];
            a[3] = b;
            b = a[2];
            a[2] = a[6];
            a[6] = b;
            b = a[5];
            a[5] = a[7];
            a[7] = b;
            return this
        }
    });
    Object.defineProperties(xb, {
        ZERO: {
            value: (new xb).set([0, 0, 0, 0, 0, 0, 0, 0, 0])
        },
        IDENTITY: {
            value: new xb
        }
    });
    Object.freeze(xb.ZERO);
    Object.freeze(xb.IDENTITY);
    Object.assign(P.prototype, {
        add: function(a) {
            this.x += a.x;
            this.y += a.y;
            return this
        },
        add2: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            return this
        },
        clone: function() {
            return (new P).copy(this)
        },
        copy: function(a) {
            this.x = a.x;
            this.y = a.y;
            return this
        },
        distance: function(a) {
            var b = this.x - a.x;
            a = this.y - a.y;
            return Math.sqrt(b * b + a * a)
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y
        },
        equals: function(a) {
            return this.x === a.x && this.y === a.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        lerp: function(a, b, c) {
            this.x = a.x + c * (b.x - a.x);
            this.y = a.y + c * (b.y - a.y);
            return this
        },
        mul: function(a) {
            this.x *= a.x;
            this.y *= a.y;
            return this
        },
        mul2: function(a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            return this
        },
        normalize: function() {
            var a = this.x * this.x + this.y * this.y;
            0 < a && (a = 1 / Math.sqrt(a),
            this.x *= a,
            this.y *= a);
            return this
        },
        scale: function(a) {
            this.x *= a;
            this.y *= a;
            return this
        },
        set: function(a, b) {
            this.x = a;
            this.y = b;
            return this
        },
        sub: function(a) {
            this.x -= a.x;
            this.y -= a.y;
            return this
        },
        sub2: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            return this
        },
        toString: function() {
            return "[" + this.x + ", " + this.y + "]"
        }
    });
    Object.defineProperties(P, {
        ZERO: {
            value: new P(0,0)
        },
        ONE: {
            value: new P(1,1)
        },
        UP: {
            value: new P(0,1)
        },
        DOWN: {
            value: new P(0,-1)
        },
        RIGHT: {
            value: new P(1,0)
        },
        LEFT: {
            value: new P(-1,0)
        }
    });
    Object.freeze(P.ZERO);
    Object.freeze(P.ONE);
    Object.freeze(P.UP);
    Object.freeze(P.DOWN);
    Object.freeze(P.RIGHT);
    Object.freeze(P.LEFT);
    Object.assign(z.prototype, {
        add: function(a) {
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
            return this
        },
        add2: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            return this
        },
        clone: function() {
            return (new z).copy(this)
        },
        copy: function(a) {
            this.x = a.x;
            this.y = a.y;
            this.z = a.z;
            return this
        },
        cross: function(a, b) {
            var c = a.x
              , d = a.y;
            a = a.z;
            var e = b.x
              , f = b.y;
            b = b.z;
            this.x = d * b - f * a;
            this.y = a * e - b * c;
            this.z = c * f - e * d;
            return this
        },
        distance: function(a) {
            var b = this.x - a.x
              , c = this.y - a.y;
            a = this.z - a.z;
            return Math.sqrt(b * b + c * c + a * a)
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y + this.z * a.z
        },
        equals: function(a) {
            return this.x === a.x && this.y === a.y && this.z === a.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        lerp: function(a, b, c) {
            this.x = a.x + c * (b.x - a.x);
            this.y = a.y + c * (b.y - a.y);
            this.z = a.z + c * (b.z - a.z);
            return this
        },
        mul: function(a) {
            this.x *= a.x;
            this.y *= a.y;
            this.z *= a.z;
            return this
        },
        mul2: function(a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;
            return this
        },
        normalize: function() {
            var a = this.x * this.x + this.y * this.y + this.z * this.z;
            0 < a && (a = 1 / Math.sqrt(a),
            this.x *= a,
            this.y *= a,
            this.z *= a);
            return this
        },
        project: function(a) {
            var b = (this.x * a.x + this.y * a.y + this.z * a.z) / (a.x * a.x + a.y * a.y + a.z * a.z);
            this.x = a.x * b;
            this.y = a.y * b;
            this.z = a.z * b;
            return this
        },
        scale: function(a) {
            this.x *= a;
            this.y *= a;
            this.z *= a;
            return this
        },
        set: function(a, b, c) {
            this.x = a;
            this.y = b;
            this.z = c;
            return this
        },
        sub: function(a) {
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
            return this
        },
        sub2: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            return this
        },
        toString: function() {
            return "[" + this.x + ", " + this.y + ", " + this.z + "]"
        }
    });
    Object.defineProperties(z, {
        ZERO: {
            value: new z(0,0,0)
        },
        ONE: {
            value: new z(1,1,1)
        },
        UP: {
            value: new z(0,1,0)
        },
        DOWN: {
            value: new z(0,-1,0)
        },
        RIGHT: {
            value: new z(1,0,0)
        },
        LEFT: {
            value: new z(-1,0,0)
        },
        FORWARD: {
            value: new z(0,0,-1)
        },
        BACK: {
            value: new z(0,0,1)
        }
    });
    Object.freeze(z.ZERO);
    Object.freeze(z.ONE);
    Object.freeze(z.UP);
    Object.freeze(z.DOWN);
    Object.freeze(z.RIGHT);
    Object.freeze(z.LEFT);
    Object.freeze(z.FORWARD);
    Object.freeze(z.BACK);
    Object.assign(X.prototype, {
        add: function(a) {
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
            this.w += a.w;
            return this
        },
        add2: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.w = a.w + b.w;
            return this
        },
        clone: function() {
            return (new X).copy(this)
        },
        copy: function(a) {
            this.x = a.x;
            this.y = a.y;
            this.z = a.z;
            this.w = a.w;
            return this
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
        },
        equals: function(a) {
            return this.x === a.x && this.y === a.y && this.z === a.z && this.w === a.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        lerp: function(a, b, c) {
            this.x = a.x + c * (b.x - a.x);
            this.y = a.y + c * (b.y - a.y);
            this.z = a.z + c * (b.z - a.z);
            this.w = a.w + c * (b.w - a.w);
            return this
        },
        mul: function(a) {
            this.x *= a.x;
            this.y *= a.y;
            this.z *= a.z;
            this.w *= a.w;
            return this
        },
        mul2: function(a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;
            this.w = a.w * b.w;
            return this
        },
        normalize: function() {
            var a = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            0 < a && (a = 1 / Math.sqrt(a),
            this.x *= a,
            this.y *= a,
            this.z *= a,
            this.w *= a);
            return this
        },
        scale: function(a) {
            this.x *= a;
            this.y *= a;
            this.z *= a;
            this.w *= a;
            return this
        },
        set: function(a, b, c, d) {
            this.x = a;
            this.y = b;
            this.z = c;
            this.w = d;
            return this
        },
        sub: function(a) {
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
            this.w -= a.w;
            return this
        },
        sub2: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.w = a.w - b.w;
            return this
        },
        toString: function() {
            return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]"
        }
    });
    Object.defineProperties(X, {
        ZERO: {
            value: new X(0,0,0,0)
        },
        ONE: {
            value: new X(1,1,1,1)
        }
    });
    Object.freeze(X.ZERO);
    Object.freeze(X.ONE);
    var Qf = new P;
    K._getPerspectiveHalfSize = function(a, b, c, d, e) {
        e ? (a.x = d * Math.tan(b * Math.PI / 360),
        a.y = a.x / c) : (a.y = d * Math.tan(b * Math.PI / 360),
        a.x = a.y * c)
    }
    ;
    Object.assign(K.prototype, {
        add2: function(a, b) {
            a = a.data;
            b = b.data;
            var c = this.data;
            c[0] = a[0] + b[0];
            c[1] = a[1] + b[1];
            c[2] = a[2] + b[2];
            c[3] = a[3] + b[3];
            c[4] = a[4] + b[4];
            c[5] = a[5] + b[5];
            c[6] = a[6] + b[6];
            c[7] = a[7] + b[7];
            c[8] = a[8] + b[8];
            c[9] = a[9] + b[9];
            c[10] = a[10] + b[10];
            c[11] = a[11] + b[11];
            c[12] = a[12] + b[12];
            c[13] = a[13] + b[13];
            c[14] = a[14] + b[14];
            c[15] = a[15] + b[15];
            return this
        },
        add: function(a) {
            return this.add2(this, a)
        },
        clone: function() {
            return (new K).copy(this)
        },
        copy: function(a) {
            a = a.data;
            var b = this.data;
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            b[6] = a[6];
            b[7] = a[7];
            b[8] = a[8];
            b[9] = a[9];
            b[10] = a[10];
            b[11] = a[11];
            b[12] = a[12];
            b[13] = a[13];
            b[14] = a[14];
            b[15] = a[15];
            return this
        },
        equals: function(a) {
            var b = this.data;
            a = a.data;
            return b[0] === a[0] && b[1] === a[1] && b[2] === a[2] && b[3] === a[3] && b[4] === a[4] && b[5] === a[5] && b[6] === a[6] && b[7] === a[7] && b[8] === a[8] && b[9] === a[9] && b[10] === a[10] && b[11] === a[11] && b[12] === a[12] && b[13] === a[13] && b[14] === a[14] && b[15] === a[15]
        },
        isIdentity: function() {
            var a = this.data;
            return 1 === a[0] && 0 === a[1] && 0 === a[2] && 0 === a[3] && 0 === a[4] && 1 === a[5] && 0 === a[6] && 0 === a[7] && 0 === a[8] && 0 === a[9] && 1 === a[10] && 0 === a[11] && 0 === a[12] && 0 === a[13] && 0 === a[14] && 1 === a[15]
        },
        mul2: function(a, b) {
            var c = a.data;
            var d = b.data
              , e = this.data;
            b = c[0];
            a = c[1];
            var f = c[2];
            var g = c[3];
            var k = c[4];
            var h = c[5];
            var l = c[6];
            var n = c[7];
            var p = c[8];
            var q = c[9];
            var r = c[10];
            var t = c[11];
            var u = c[12];
            var x = c[13];
            var v = c[14];
            c = c[15];
            var w = d[0];
            var y = d[1];
            var A = d[2];
            var B = d[3];
            e[0] = b * w + k * y + p * A + u * B;
            e[1] = a * w + h * y + q * A + x * B;
            e[2] = f * w + l * y + r * A + v * B;
            e[3] = g * w + n * y + t * A + c * B;
            w = d[4];
            y = d[5];
            A = d[6];
            B = d[7];
            e[4] = b * w + k * y + p * A + u * B;
            e[5] = a * w + h * y + q * A + x * B;
            e[6] = f * w + l * y + r * A + v * B;
            e[7] = g * w + n * y + t * A + c * B;
            w = d[8];
            y = d[9];
            A = d[10];
            B = d[11];
            e[8] = b * w + k * y + p * A + u * B;
            e[9] = a * w + h * y + q * A + x * B;
            e[10] = f * w + l * y + r * A + v * B;
            e[11] = g * w + n * y + t * A + c * B;
            w = d[12];
            y = d[13];
            A = d[14];
            B = d[15];
            e[12] = b * w + k * y + p * A + u * B;
            e[13] = a * w + h * y + q * A + x * B;
            e[14] = f * w + l * y + r * A + v * B;
            e[15] = g * w + n * y + t * A + c * B;
            return this
        },
        mulAffine2: function(a, b) {
            var c = a.data;
            var d = b.data
              , e = this.data;
            b = c[0];
            a = c[1];
            var f = c[2];
            var g = c[4];
            var k = c[5];
            var h = c[6];
            var l = c[8];
            var n = c[9];
            var p = c[10];
            var q = c[12];
            var r = c[13];
            c = c[14];
            var t = d[0];
            var u = d[1];
            var x = d[2];
            e[0] = b * t + g * u + l * x;
            e[1] = a * t + k * u + n * x;
            e[2] = f * t + h * u + p * x;
            e[3] = 0;
            t = d[4];
            u = d[5];
            x = d[6];
            e[4] = b * t + g * u + l * x;
            e[5] = a * t + k * u + n * x;
            e[6] = f * t + h * u + p * x;
            e[7] = 0;
            t = d[8];
            u = d[9];
            x = d[10];
            e[8] = b * t + g * u + l * x;
            e[9] = a * t + k * u + n * x;
            e[10] = f * t + h * u + p * x;
            e[11] = 0;
            t = d[12];
            u = d[13];
            x = d[14];
            e[12] = b * t + g * u + l * x + q;
            e[13] = a * t + k * u + n * x + r;
            e[14] = f * t + h * u + p * x + c;
            e[15] = 1;
            return this
        },
        mul: function(a) {
            return this.mul2(this, a)
        },
        transformPoint: function(a, b) {
            var c = this.data;
            var d = a.x;
            var e = a.y;
            a = a.z;
            b = void 0 === b ? new z : b;
            b.x = d * c[0] + e * c[4] + a * c[8] + c[12];
            b.y = d * c[1] + e * c[5] + a * c[9] + c[13];
            b.z = d * c[2] + e * c[6] + a * c[10] + c[14];
            return b
        },
        transformVector: function(a, b) {
            var c = this.data;
            var d = a.x;
            var e = a.y;
            a = a.z;
            b = void 0 === b ? new z : b;
            b.x = d * c[0] + e * c[4] + a * c[8];
            b.y = d * c[1] + e * c[5] + a * c[9];
            b.z = d * c[2] + e * c[6] + a * c[10];
            return b
        },
        transformVec4: function(a, b) {
            var c = this.data;
            var d = a.x;
            var e = a.y;
            var f = a.z;
            a = a.w;
            b = void 0 === b ? new X : b;
            b.x = d * c[0] + e * c[4] + f * c[8] + a * c[12];
            b.y = d * c[1] + e * c[5] + f * c[9] + a * c[13];
            b.z = d * c[2] + e * c[6] + f * c[10] + a * c[14];
            b.w = d * c[3] + e * c[7] + f * c[11] + a * c[15];
            return b
        },
        setLookAt: function() {
            var a = new z;
            var b = new z;
            var c = new z;
            return function(d, e, f) {
                c.sub2(d, e).normalize();
                b.copy(f).normalize();
                a.cross(b, c).normalize();
                b.cross(c, a);
                e = this.data;
                e[0] = a.x;
                e[1] = a.y;
                e[2] = a.z;
                e[3] = 0;
                e[4] = b.x;
                e[5] = b.y;
                e[6] = b.z;
                e[7] = 0;
                e[8] = c.x;
                e[9] = c.y;
                e[10] = c.z;
                e[11] = 0;
                e[12] = d.x;
                e[13] = d.y;
                e[14] = d.z;
                e[15] = 1;
                return this
            }
        }(),
        setFrustum: function(a, b, c, d, e, f) {
            var g = 2 * e;
            var k = b - a;
            var h = d - c;
            var l = f - e;
            var n = this.data;
            n[0] = g / k;
            n[1] = 0;
            n[2] = 0;
            n[3] = 0;
            n[4] = 0;
            n[5] = g / h;
            n[6] = 0;
            n[7] = 0;
            n[8] = (b + a) / k;
            n[9] = (d + c) / h;
            n[10] = (-f - e) / l;
            n[11] = -1;
            n[12] = 0;
            n[13] = 0;
            n[14] = -g * f / l;
            n[15] = 0;
            return this
        },
        setPerspective: function(a, b, c, d, e) {
            K._getPerspectiveHalfSize(Qf, a, b, c, e);
            return this.setFrustum(-Qf.x, Qf.x, -Qf.y, Qf.y, c, d)
        },
        setOrtho: function(a, b, c, d, e, f) {
            var g = this.data;
            g[0] = 2 / (b - a);
            g[1] = 0;
            g[2] = 0;
            g[3] = 0;
            g[4] = 0;
            g[5] = 2 / (d - c);
            g[6] = 0;
            g[7] = 0;
            g[8] = 0;
            g[9] = 0;
            g[10] = -2 / (f - e);
            g[11] = 0;
            g[12] = -(b + a) / (b - a);
            g[13] = -(d + c) / (d - c);
            g[14] = -(f + e) / (f - e);
            g[15] = 1;
            return this
        },
        setFromAxisAngle: function(a, b) {
            b *= N.DEG_TO_RAD;
            var c = a.x;
            var d = a.y;
            a = a.z;
            var e = Math.cos(b);
            b = Math.sin(b);
            var f = 1 - e;
            var g = f * c;
            var k = f * d;
            var h = this.data;
            h[0] = g * c + e;
            h[1] = g * d + b * a;
            h[2] = g * a - b * d;
            h[3] = 0;
            h[4] = g * d - b * a;
            h[5] = k * d + e;
            h[6] = k * a + b * c;
            h[7] = 0;
            h[8] = g * a + b * d;
            h[9] = k * a - c * b;
            h[10] = f * a * a + e;
            h[11] = 0;
            h[12] = 0;
            h[13] = 0;
            h[14] = 0;
            h[15] = 1;
            return this
        },
        setTranslate: function(a, b, c) {
            var d = this.data;
            d[0] = 1;
            d[1] = 0;
            d[2] = 0;
            d[3] = 0;
            d[4] = 0;
            d[5] = 1;
            d[6] = 0;
            d[7] = 0;
            d[8] = 0;
            d[9] = 0;
            d[10] = 1;
            d[11] = 0;
            d[12] = a;
            d[13] = b;
            d[14] = c;
            d[15] = 1;
            return this
        },
        setScale: function(a, b, c) {
            var d = this.data;
            d[0] = a;
            d[1] = 0;
            d[2] = 0;
            d[3] = 0;
            d[4] = 0;
            d[5] = b;
            d[6] = 0;
            d[7] = 0;
            d[8] = 0;
            d[9] = 0;
            d[10] = c;
            d[11] = 0;
            d[12] = 0;
            d[13] = 0;
            d[14] = 0;
            d[15] = 1;
            return this
        },
        invert: function() {
            var a = this.data;
            var b = a[0];
            var c = a[1];
            var d = a[2];
            var e = a[3];
            var f = a[4];
            var g = a[5];
            var k = a[6];
            var h = a[7];
            var l = a[8];
            var n = a[9];
            var p = a[10];
            var q = a[11];
            var r = a[12];
            var t = a[13];
            var u = a[14];
            var x = a[15];
            var v = b * g - c * f;
            var w = b * k - d * f;
            var y = b * h - e * f;
            var A = c * k - d * g;
            var B = c * h - e * g;
            var E = d * h - e * k;
            var C = l * t - n * r;
            var D = l * u - p * r;
            var G = l * x - q * r;
            var J = n * u - p * t;
            var R = n * x - q * t;
            var I = p * x - q * u;
            var T = v * I - w * R + y * J + A * G - B * D + E * C;
            0 === T ? this.setIdentity() : (T = 1 / T,
            a[0] = (g * I - k * R + h * J) * T,
            a[1] = (-c * I + d * R - e * J) * T,
            a[2] = (t * E - u * B + x * A) * T,
            a[3] = (-n * E + p * B - q * A) * T,
            a[4] = (-f * I + k * G - h * D) * T,
            a[5] = (b * I - d * G + e * D) * T,
            a[6] = (-r * E + u * y - x * w) * T,
            a[7] = (l * E - p * y + q * w) * T,
            a[8] = (f * R - g * G + h * C) * T,
            a[9] = (-b * R + c * G - e * C) * T,
            a[10] = (r * B - t * y + x * v) * T,
            a[11] = (-l * B + n * y - q * v) * T,
            a[12] = (-f * J + g * D - k * C) * T,
            a[13] = (b * J - c * D + d * C) * T,
            a[14] = (-r * A + t * w - u * v) * T,
            a[15] = (l * A - n * w + p * v) * T);
            return this
        },
        set: function(a) {
            var b = this.data;
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            b[6] = a[6];
            b[7] = a[7];
            b[8] = a[8];
            b[9] = a[9];
            b[10] = a[10];
            b[11] = a[11];
            b[12] = a[12];
            b[13] = a[13];
            b[14] = a[14];
            b[15] = a[15];
            return this
        },
        setIdentity: function() {
            var a = this.data;
            a[0] = 1;
            a[1] = 0;
            a[2] = 0;
            a[3] = 0;
            a[4] = 0;
            a[5] = 1;
            a[6] = 0;
            a[7] = 0;
            a[8] = 0;
            a[9] = 0;
            a[10] = 1;
            a[11] = 0;
            a[12] = 0;
            a[13] = 0;
            a[14] = 0;
            a[15] = 1;
            return this
        },
        setTRS: function(a, b, c) {
            var d = b.x;
            var e = b.y;
            var f = b.z;
            var g = b.w;
            b = c.x;
            var k = c.y;
            c = c.z;
            var h = d + d;
            var l = e + e;
            var n = f + f;
            var p = d * h;
            var q = d * l;
            d *= n;
            var r = e * l;
            e *= n;
            f *= n;
            h *= g;
            l *= g;
            g *= n;
            n = this.data;
            n[0] = (1 - (r + f)) * b;
            n[1] = (q + g) * b;
            n[2] = (d - l) * b;
            n[3] = 0;
            n[4] = (q - g) * k;
            n[5] = (1 - (p + f)) * k;
            n[6] = (e + h) * k;
            n[7] = 0;
            n[8] = (d + l) * c;
            n[9] = (e - h) * c;
            n[10] = (1 - (p + r)) * c;
            n[11] = 0;
            n[12] = a.x;
            n[13] = a.y;
            n[14] = a.z;
            n[15] = 1;
            return this
        },
        transpose: function() {
            var a = this.data;
            var b = a[1];
            a[1] = a[4];
            a[4] = b;
            b = a[2];
            a[2] = a[8];
            a[8] = b;
            b = a[3];
            a[3] = a[12];
            a[12] = b;
            b = a[6];
            a[6] = a[9];
            a[9] = b;
            b = a[7];
            a[7] = a[13];
            a[13] = b;
            b = a[11];
            a[11] = a[14];
            a[14] = b;
            return this
        },
        invertTo3x3: function(a) {
            var b = this.data;
            a = a.data;
            var c = b[0]
              , d = b[1]
              , e = b[2]
              , f = b[4]
              , g = b[5]
              , k = b[6]
              , h = b[8]
              , l = b[9]
              , n = b[10];
            b = n * g - k * l;
            var p = -n * f + k * h;
            var q = l * f - g * h;
            var r = c * b + d * p + e * q;
            if (0 === r)
                return this;
            r = 1 / r;
            a[0] = r * b;
            a[1] = r * (-n * d + e * l);
            a[2] = r * (k * d - e * g);
            a[3] = r * p;
            a[4] = r * (n * c - e * h);
            a[5] = r * (-k * c + e * f);
            a[6] = r * q;
            a[7] = r * (-l * c + d * h);
            a[8] = r * (g * c - d * f);
            return this
        },
        getTranslation: function(a) {
            a = void 0 === a ? new z : a;
            return a.set(this.data[12], this.data[13], this.data[14])
        },
        getX: function(a) {
            a = void 0 === a ? new z : a;
            return a.set(this.data[0], this.data[1], this.data[2])
        },
        getY: function(a) {
            a = void 0 === a ? new z : a;
            return a.set(this.data[4], this.data[5], this.data[6])
        },
        getZ: function(a) {
            a = void 0 === a ? new z : a;
            return a.set(this.data[8], this.data[9], this.data[10])
        },
        getScale: function() {
            var a = new z;
            var b = new z;
            var c = new z;
            return function(d) {
                d = void 0 === d ? new z : d;
                this.getX(a);
                this.getY(b);
                this.getZ(c);
                d.set(a.length(), b.length(), c.length());
                return d
            }
        }(),
        setFromEulerAngles: function(a, b, c) {
            a *= N.DEG_TO_RAD;
            b *= N.DEG_TO_RAD;
            c *= N.DEG_TO_RAD;
            var d = Math.sin(-a);
            a = Math.cos(-a);
            var e = Math.sin(-b);
            b = Math.cos(-b);
            var f = Math.sin(-c);
            c = Math.cos(-c);
            var g = this.data;
            g[0] = b * c;
            g[1] = -b * f;
            g[2] = e;
            g[3] = 0;
            g[4] = a * f + c * d * e;
            g[5] = a * c - d * e * f;
            g[6] = -b * d;
            g[7] = 0;
            g[8] = d * f - a * c * e;
            g[9] = c * d + a * e * f;
            g[10] = a * b;
            g[11] = 0;
            g[12] = 0;
            g[13] = 0;
            g[14] = 0;
            g[15] = 1;
            return this
        },
        getEulerAngles: function() {
            var a = new z;
            return function(b) {
                b = void 0 === b ? new z : b;
                this.getScale(a);
                var c = a.x;
                var d = a.y;
                var e = a.z;
                var f = this.data;
                var g = Math.asin(-f[2] / c);
                var k = .5 * Math.PI;
                g < k ? g > -k ? (d = Math.atan2(f[6] / d, f[10] / e),
                c = Math.atan2(f[1] / c, f[0] / c)) : (c = 0,
                d = -Math.atan2(f[4] / d, f[5] / d)) : (c = 0,
                d = Math.atan2(f[4] / d, f[5] / d));
                return b.set(d, g, c).scale(N.RAD_TO_DEG)
            }
        }(),
        toString: function() {
            var a;
            var b = "[";
            for (a = 0; 16 > a; a += 1)
                b += this.data[a],
                b += 15 !== a ? ", " : "";
            return b + "]"
        }
    });
    Object.defineProperties(K, {
        ZERO: {
            value: (new K).set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
        },
        IDENTITY: {
            value: new K
        }
    });
    Object.freeze(K.ZERO);
    Object.freeze(K.IDENTITY);
    Object.assign(Y.prototype, {
        clone: function() {
            return new Y(this.x,this.y,this.z,this.w)
        },
        conjugate: function() {
            this.x *= -1;
            this.y *= -1;
            this.z *= -1;
            return this
        },
        copy: function(a) {
            this.x = a.x;
            this.y = a.y;
            this.z = a.z;
            this.w = a.w;
            return this
        },
        equals: function(a) {
            return this.x === a.x && this.y === a.y && this.z === a.z && this.w === a.w
        },
        getAxisAngle: function(a) {
            var b = 2 * Math.acos(this.w)
              , c = Math.sin(b / 2);
            if (0 !== c) {
                if (a.x = this.x / c,
                a.y = this.y / c,
                a.z = this.z / c,
                0 > a.x || 0 > a.y || 0 > a.z)
                    a.x *= -1,
                    a.y *= -1,
                    a.z *= -1,
                    b *= -1
            } else
                a.x = 1,
                a.y = 0,
                a.z = 0;
            return b * N.RAD_TO_DEG
        },
        getEulerAngles: function(a) {
            a = void 0 === a ? new z : a;
            var b = this.x;
            var c = this.y;
            var d = this.z;
            var e = this.w;
            var f = 2 * (e * c - b * d);
            if (-.99999 >= f) {
                var g = 2 * Math.atan2(b, e);
                f = -Math.PI / 2;
                b = 0
            } else
                .99999 <= f ? (g = 2 * Math.atan2(b, e),
                f = Math.PI / 2,
                b = 0) : (g = Math.atan2(2 * (e * b + c * d), 1 - 2 * (b * b + c * c)),
                f = Math.asin(f),
                b = Math.atan2(2 * (e * d + b * c), 1 - 2 * (c * c + d * d)));
            return a.set(g, f, b).scale(N.RAD_TO_DEG)
        },
        invert: function() {
            return this.conjugate().normalize()
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        mul: function(a) {
            var b = this.x;
            var c = this.y;
            var d = this.z;
            var e = this.w;
            var f = a.x;
            var g = a.y;
            var k = a.z;
            a = a.w;
            this.x = e * f + b * a + c * k - d * g;
            this.y = e * g + c * a + d * f - b * k;
            this.z = e * k + d * a + b * g - c * f;
            this.w = e * a - b * f - c * g - d * k;
            return this
        },
        mul2: function(a, b) {
            var c = a.x;
            var d = a.y;
            var e = a.z;
            a = a.w;
            var f = b.x;
            var g = b.y;
            var k = b.z;
            b = b.w;
            this.x = a * f + c * b + d * k - e * g;
            this.y = a * g + d * b + e * f - c * k;
            this.z = a * k + e * b + c * g - d * f;
            this.w = a * b - c * f - d * g - e * k;
            return this
        },
        normalize: function() {
            var a = this.length();
            0 === a ? (this.x = this.y = this.z = 0,
            this.w = 1) : (a = 1 / a,
            this.x *= a,
            this.y *= a,
            this.z *= a,
            this.w *= a);
            return this
        },
        set: function(a, b, c, d) {
            this.x = a;
            this.y = b;
            this.z = c;
            this.w = d;
            return this
        },
        setFromAxisAngle: function(a, b) {
            b *= .5 * N.DEG_TO_RAD;
            var c = Math.sin(b);
            b = Math.cos(b);
            this.x = c * a.x;
            this.y = c * a.y;
            this.z = c * a.z;
            this.w = b;
            return this
        },
        setFromEulerAngles: function(a, b, c) {
            var d = .5 * N.DEG_TO_RAD;
            a *= d;
            b *= d;
            c *= d;
            d = Math.sin(a);
            a = Math.cos(a);
            var e = Math.sin(b);
            b = Math.cos(b);
            var f = Math.sin(c);
            c = Math.cos(c);
            this.x = d * b * c - a * e * f;
            this.y = a * e * c + d * b * f;
            this.z = a * b * f - d * e * c;
            this.w = a * b * c + d * e * f;
            return this
        },
        setFromMat4: function(a) {
            a = a.data;
            var b = a[0];
            var c = a[1];
            var d = a[2];
            var e = a[4];
            var f = a[5];
            var g = a[6];
            var k = a[8];
            var h = a[9];
            a = a[10];
            var l = b * b + c * c + d * d;
            if (0 === l)
                return this;
            l = 1 / Math.sqrt(l);
            var n = e * e + f * f + g * g;
            if (0 === n)
                return this;
            n = 1 / Math.sqrt(n);
            var p = k * k + h * h + a * a;
            if (0 === p)
                return this;
            p = 1 / Math.sqrt(p);
            b *= l;
            c *= l;
            d *= l;
            e *= n;
            f *= n;
            g *= n;
            k *= p;
            h *= p;
            a *= p;
            l = b + f + a;
            0 <= l ? (b = Math.sqrt(l + 1),
            this.w = .5 * b,
            b = .5 / b,
            this.x = (g - h) * b,
            this.y = (k - d) * b,
            this.z = (c - e) * b) : b > f ? b > a ? (b = Math.sqrt(b - (f + a) + 1),
            this.x = .5 * b,
            b = .5 / b,
            this.w = (g - h) * b,
            this.y = (c + e) * b,
            this.z = (d + k) * b) : (b = Math.sqrt(a - (b + f) + 1),
            this.z = .5 * b,
            b = .5 / b,
            this.w = (c - e) * b,
            this.x = (k + d) * b,
            this.y = (h + g) * b) : f > a ? (b = Math.sqrt(f - (a + b) + 1),
            this.y = .5 * b,
            b = .5 / b,
            this.w = (k - d) * b,
            this.z = (g + h) * b,
            this.x = (e + c) * b) : (b = Math.sqrt(a - (b + f) + 1),
            this.z = .5 * b,
            b = .5 / b,
            this.w = (c - e) * b,
            this.x = (k + d) * b,
            this.y = (h + g) * b);
            return this
        },
        slerp: function(a, b, c) {
            var d = a.x;
            var e = a.y;
            var f = a.z;
            a = a.w;
            var g = b.x;
            var k = b.y;
            var h = b.z;
            b = b.w;
            var l = a * b + d * g + e * k + f * h;
            0 > l && (b = -b,
            g = -g,
            k = -k,
            h = -h,
            l = -l);
            if (1 <= Math.abs(l))
                return this.w = a,
                this.x = d,
                this.y = e,
                this.z = f,
                this;
            var n = Math.acos(l)
              , p = Math.sqrt(1 - l * l);
            if (.001 > Math.abs(p))
                return this.w = .5 * a + .5 * b,
                this.x = .5 * d + .5 * g,
                this.y = .5 * e + .5 * k,
                this.z = .5 * f + .5 * h,
                this;
            l = Math.sin((1 - c) * n) / p;
            c = Math.sin(c * n) / p;
            this.w = a * l + b * c;
            this.x = d * l + g * c;
            this.y = e * l + k * c;
            this.z = f * l + h * c;
            return this
        },
        transformVector: function(a, b) {
            void 0 === b && (b = new z);
            var c = a.x
              , d = a.y
              , e = a.z;
            a = this.x;
            var f = this.y
              , g = this.z
              , k = this.w
              , h = k * c + f * e - g * d
              , l = k * d + g * c - a * e
              , n = k * e + a * d - f * c;
            c = -a * c - f * d - g * e;
            b.x = h * k + c * -a + l * -g - n * -f;
            b.y = l * k + c * -f + n * -a - h * -g;
            b.z = n * k + c * -g + h * -f - l * -a;
            return b
        },
        toString: function() {
            return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]"
        }
    });
    Object.defineProperties(Y, {
        ZERO: {
            value: new Y(0,0,0,0)
        },
        IDENTITY: {
            value: new Y(0,0,0,1)
        }
    });
    Object.freeze(Y.ZERO);
    Object.freeze(Y.IDENTITY);
    var yc = new z
      , Wb = new z
      , Rf = new z
      , Sf = new z
      , be = new z;
    Object.assign(oa.prototype, {
        add: function(a) {
            var b = this.center
              , c = b.x
              , d = b.y
              , e = b.z
              , f = this.halfExtents
              , g = f.x
              , k = f.y
              , h = f.z
              , l = c - g;
            c += g;
            g = d - k;
            d += k;
            k = e - h;
            e += h;
            h = a.center;
            var n = h.x
              , p = h.y;
            h = h.z;
            a = a.halfExtents;
            var q = a.x
              , r = a.y
              , t = a.z;
            a = n - q;
            n += q;
            q = p - r;
            p += r;
            r = h - t;
            h += t;
            a < l && (l = a);
            n > c && (c = n);
            q < g && (g = q);
            p > d && (d = p);
            r < k && (k = r);
            h > e && (e = h);
            b.x = .5 * (l + c);
            b.y = .5 * (g + d);
            b.z = .5 * (k + e);
            f.x = .5 * (c - l);
            f.y = .5 * (d - g);
            f.z = .5 * (e - k)
        },
        copy: function(a) {
            this.center.copy(a.center);
            this.halfExtents.copy(a.halfExtents);
            this.type = a.type
        },
        clone: function() {
            return new oa(this.center.clone(),this.halfExtents.clone())
        },
        intersects: function(a) {
            var b = this.getMax()
              , c = this.getMin()
              , d = a.getMax();
            a = a.getMin();
            return c.x <= d.x && b.x >= a.x && c.y <= d.y && b.y >= a.y && c.z <= d.z && b.z >= a.z
        },
        _intersectsRay: function(a, b) {
            var c = yc.copy(this.getMin()).sub(a.origin)
              , d = Wb.copy(this.getMax()).sub(a.origin)
              , e = a.direction;
            0 === e.x ? (c.x = 0 > c.x ? -Number.MAX_VALUE : Number.MAX_VALUE,
            d.x = 0 > d.x ? -Number.MAX_VALUE : Number.MAX_VALUE) : (c.x /= e.x,
            d.x /= e.x);
            0 === e.y ? (c.y = 0 > c.y ? -Number.MAX_VALUE : Number.MAX_VALUE,
            d.y = 0 > d.y ? -Number.MAX_VALUE : Number.MAX_VALUE) : (c.y /= e.y,
            d.y /= e.y);
            0 === e.z ? (c.z = 0 > c.z ? -Number.MAX_VALUE : Number.MAX_VALUE,
            d.z = 0 > d.z ? -Number.MAX_VALUE : Number.MAX_VALUE) : (c.z /= e.z,
            d.z /= e.z);
            e = Rf.set(Math.min(c.x, d.x), Math.min(c.y, d.y), Math.min(c.z, d.z));
            c = Sf.set(Math.max(c.x, d.x), Math.max(c.y, d.y), Math.max(c.z, d.z));
            d = Math.max(Math.max(e.x, e.y), e.z);
            (c = Math.min(Math.min(c.x, c.y), c.z) >= d && 0 <= d) && b.copy(a.direction).scale(d).add(a.origin);
            return c
        },
        _fastIntersectsRay: function(a) {
            var b = a.direction;
            yc.sub2(a.origin, this.center);
            Sf.set(Math.abs(yc.x), Math.abs(yc.y), Math.abs(yc.z));
            Rf.mul2(yc, b);
            if (Sf.x > this.halfExtents.x && 0 <= Rf.x || Sf.y > this.halfExtents.y && 0 <= Rf.y || Sf.z > this.halfExtents.z && 0 <= Rf.z)
                return !1;
            be.set(Math.abs(b.x), Math.abs(b.y), Math.abs(b.z));
            Wb.cross(b, yc);
            Wb.set(Math.abs(Wb.x), Math.abs(Wb.y), Math.abs(Wb.z));
            return Wb.x > this.halfExtents.y * be.z + this.halfExtents.z * be.y || Wb.y > this.halfExtents.x * be.z + this.halfExtents.z * be.x || Wb.z > this.halfExtents.x * be.y + this.halfExtents.y * be.x ? !1 : !0
        },
        intersectsRay: function(a, b) {
            return b ? this._intersectsRay(a, b) : this._fastIntersectsRay(a)
        },
        setMinMax: function(a, b) {
            this.center.add2(b, a).scale(.5);
            this.halfExtents.sub2(b, a).scale(.5)
        },
        getMin: function() {
            return this._min.copy(this.center).sub(this.halfExtents)
        },
        getMax: function() {
            return this._max.copy(this.center).add(this.halfExtents)
        },
        containsPoint: function(a) {
            var b = this.getMin()
              , c = this.getMax();
            return a.x < b.x || a.x > c.x || a.y < b.y || a.y > c.y || a.z < b.z || a.z > c.z ? !1 : !0
        },
        setFromTransformedAabb: function(a, b) {
            var c = a.center;
            a = a.halfExtents;
            b = b.data;
            var d = b[0]
              , e = b[4]
              , f = b[8]
              , g = b[1]
              , k = b[5]
              , h = b[9]
              , l = b[2]
              , n = b[6]
              , p = b[10];
            this.center.set(b[12] + d * c.x + e * c.y + f * c.z, b[13] + g * c.x + k * c.y + h * c.z, b[14] + l * c.x + n * c.y + p * c.z);
            this.halfExtents.set(Math.abs(d) * a.x + Math.abs(e) * a.y + Math.abs(f) * a.z, Math.abs(g) * a.x + Math.abs(k) * a.y + Math.abs(h) * a.z, Math.abs(l) * a.x + Math.abs(n) * a.y + Math.abs(p) * a.z)
        },
        compute: function(a, b) {
            b = void 0 === b ? a.length / 3 : b;
            if (0 < b) {
                for (var c = yc.set(a[0], a[1], a[2]), d = Wb.set(a[0], a[1], a[2]), e = 1; e < b; e++) {
                    var f = a[3 * e]
                      , g = a[3 * e + 1]
                      , k = a[3 * e + 2];
                    f < c.x && (c.x = f);
                    g < c.y && (c.y = g);
                    k < c.z && (c.z = k);
                    f > d.x && (d.x = f);
                    g > d.y && (d.y = g);
                    k > d.z && (d.z = k)
                }
                this.setMinMax(c, d)
            }
        },
        intersectsBoundingSphere: function(a) {
            return this._distanceToBoundingSphereSq(a) <= a.radius * a.radius ? !0 : !1
        },
        _distanceToBoundingSphereSq: function(a) {
            for (var b = this.getMin(), c = this.getMax(), d = 0, e = ["x", "y", "z"], f = 0; 3 > f; ++f) {
                var g = 0
                  , k = a.center[e[f]]
                  , h = b[e[f]]
                  , l = c[e[f]];
                k < h && (h -= k,
                g += h * h);
                k > l && (h = k - l,
                g += h * h);
                d += g
            }
            return d
        },
        _expand: function(a, b) {
            yc.add2(this.getMin(), a);
            Wb.add2(this.getMax(), b);
            this.setMinMax(yc, Wb)
        }
    });
    var td = new z
      , ih = new z
      , Te = new z
      , Sl = new z;
    Object.assign(Cd.prototype, {
        containsPoint: function(a) {
            a = td.sub2(a, this.center).lengthSq();
            var b = this.radius;
            return a < b * b
        },
        compute: function(a) {
            var b, c = a.length / 3;
            for (b = 0; b < c; b++)
                td.set(a[3 * b], a[3 * b + 1], a[3 * b + 2]),
                Te.addSelf(td),
                0 === b % 100 && (Te.scale(1 / c),
                ih.add(Te),
                Te.set(0, 0, 0));
            Te.scale(1 / c);
            ih.add(Te);
            this.center.copy(ih);
            var d = 0;
            for (b = 0; b < c; b++)
                td.set(a[3 * b], a[3 * b + 1], a[3 * b + 2]),
                Sl.sub2(td, this.center),
                d = Math.max(Sl.lengthSq(), d);
            this.radius = Math.sqrt(d)
        },
        intersectsRay: function(a, b) {
            var c = td.copy(a.origin).sub(this.center)
              , d = c.dot(ih.copy(a.direction).normalize());
            c = c.dot(c) - this.radius * this.radius;
            if (0 < c && 0 < d)
                return null;
            c = d * d - c;
            if (0 > c)
                return !1;
            d = Math.abs(-d - Math.sqrt(c));
            b && b.copy(a.direction).scale(d).add(a.origin);
            return !0
        },
        intersectsBoundingSphere: function(a) {
            td.sub2(a.center, this.center);
            a = a.radius + this.radius;
            return td.lengthSq() <= a * a ? !0 : !1
        }
    });
    Object.assign(rg.prototype, {
        setFromMat4: function(a) {
            a = a.data;
            var b = this.planes;
            var c = b[0];
            c[0] = a[3] - a[0];
            c[1] = a[7] - a[4];
            c[2] = a[11] - a[8];
            c[3] = a[15] - a[12];
            var d = Math.sqrt(c[0] * c[0] + c[1] * c[1] + c[2] * c[2]);
            c[0] /= d;
            c[1] /= d;
            c[2] /= d;
            c[3] /= d;
            c = b[1];
            c[0] = a[3] + a[0];
            c[1] = a[7] + a[4];
            c[2] = a[11] + a[8];
            c[3] = a[15] + a[12];
            d = Math.sqrt(c[0] * c[0] + c[1] * c[1] + c[2] * c[2]);
            c[0] /= d;
            c[1] /= d;
            c[2] /= d;
            c[3] /= d;
            c = b[2];
            c[0] = a[3] + a[1];
            c[1] = a[7] + a[5];
            c[2] = a[11] + a[9];
            c[3] = a[15] + a[13];
            d = Math.sqrt(c[0] * c[0] + c[1] * c[1] + c[2] * c[2]);
            c[0] /= d;
            c[1] /= d;
            c[2] /= d;
            c[3] /= d;
            c = b[3];
            c[0] = a[3] - a[1];
            c[1] = a[7] - a[5];
            c[2] = a[11] - a[9];
            c[3] = a[15] - a[13];
            d = Math.sqrt(c[0] * c[0] + c[1] * c[1] + c[2] * c[2]);
            c[0] /= d;
            c[1] /= d;
            c[2] /= d;
            c[3] /= d;
            c = b[4];
            c[0] = a[3] - a[2];
            c[1] = a[7] - a[6];
            c[2] = a[11] - a[10];
            c[3] = a[15] - a[14];
            d = Math.sqrt(c[0] * c[0] + c[1] * c[1] + c[2] * c[2]);
            c[0] /= d;
            c[1] /= d;
            c[2] /= d;
            c[3] /= d;
            c = b[5];
            c[0] = a[3] + a[2];
            c[1] = a[7] + a[6];
            c[2] = a[11] + a[10];
            c[3] = a[15] + a[14];
            d = Math.sqrt(c[0] * c[0] + c[1] * c[1] + c[2] * c[2]);
            c[0] /= d;
            c[1] /= d;
            c[2] /= d;
            c[3] /= d
        },
        containsPoint: function(a) {
            var b;
            for (b = 0; 6 > b; b++) {
                var c = this.planes[b];
                if (0 >= c[0] * a.x + c[1] * a.y + c[2] * a.z + c[3])
                    return !1
            }
            return !0
        },
        containsSphere: function(a) {
            var b = 0
              , c = a.radius;
            var d = a.center;
            a = d.x;
            var e = d.y
              , f = d.z
              , g = this.planes;
            for (d = 0; 6 > d; d++) {
                var k = g[d];
                k = k[0] * a + k[1] * e + k[2] * f + k[3];
                if (k <= -c)
                    return 0;
                k > c && b++
            }
            return 6 === b ? 2 : 1
        }
    });
    bd.prototype.set = function(a, b) {
        this.origin.copy(a);
        this.direction.copy(b);
        return this
    }
    ;
    var jh = new bd
      , Tl = new z
      , Ij = new Cd
      , vk = new K;
    Object.assign(bi.prototype, {
        intersectsRay: function(a, b) {
            this._modelTransform.transformPoint(a.origin, jh.origin);
            this._modelTransform.transformVector(a.direction, jh.direction);
            return b ? (a = this._aabb._intersectsRay(jh, b),
            vk.copy(this._modelTransform).invert().transformPoint(b, b),
            a) : this._aabb._fastIntersectsRay(jh)
        },
        containsPoint: function(a) {
            this._modelTransform.transformPoint(a, Tl);
            return this._aabb.containsPoint(Tl)
        },
        intersectsBoundingSphere: function(a) {
            this._modelTransform.transformPoint(a.center, Ij.center);
            Ij.radius = a.radius;
            return this._aabb.intersectsBoundingSphere(Ij) ? !0 : !1
        }
    });
    Object.defineProperty(bi.prototype, "worldTransform", {
        get: function() {
            return this._worldTransform
        },
        set: function(a) {
            this._worldTransform.copy(a);
            this._modelTransform.copy(a).invert()
        }
    });
    var $o = new z;
    Object.assign(ci.prototype, {
        intersectsLine: function(a, b, c) {
            var d = -this.normal.dot(this.point)
              , e = this.normal.dot(a) + d;
            d = this.normal.dot(b) + d;
            e /= e - d;
            (d = 0 <= e && 1 >= e) && c && c.lerp(a, b, e);
            return d
        },
        intersectsRay: function(a, b) {
            var c = $o.sub2(this.point, a.origin);
            c = this.normal.dot(c) / this.normal.dot(a.direction);
            var d = 0 <= c;
            d && b && b.copy(a.direction).scale(c).add(a.origin);
            return d
        }
    });
    var Dd = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array]
      , qf = [1, 1, 2, 2, 4, 4, 4]
      , Ul = [Uint8Array, Uint16Array, Uint32Array]
      , Jj = {
        POSITION: 0,
        NORMAL: 1,
        BLENDWEIGHT: 2,
        BLENDINDICES: 3,
        COLOR: 4,
        TEXCOORD0: 5,
        TEXCOORD1: 6,
        TEXCOORD2: 7,
        TEXCOORD3: 8,
        TEXCOORD4: 9,
        TEXCOORD5: 10,
        TEXCOORD6: 11,
        TEXCOORD7: 12,
        TANGENT: 13,
        ATTR0: 0,
        ATTR1: 1,
        ATTR2: 2,
        ATTR3: 3,
        ATTR4: 4,
        ATTR5: 5,
        ATTR6: 6,
        ATTR7: 7,
        ATTR8: 8,
        ATTR9: 9,
        ATTR10: 10,
        ATTR11: 11,
        ATTR12: 12,
        ATTR13: 13,
        ATTR14: 14,
        ATTR15: 15
    }
      , un = 0;
    Object.assign(ab.prototype, {
        destroy: function() {
            var a = this.device
              , b = a.buffers.indexOf(this);
            -1 !== b && a.buffers.splice(b, 1);
            this.bufferId && (b = a.gl,
            a.boundVao = null,
            b.bindVertexArray(null),
            b.deleteBuffer(this.bufferId),
            a._vram.vb -= this.storage.byteLength,
            this.bufferId = null)
        },
        getFormat: function() {
            return this.format
        },
        getUsage: function() {
            return this.usage
        },
        getNumVertices: function() {
            return this.numVertices
        },
        lock: function() {
            return this.storage
        },
        unlock: function() {
            var a = this.device.gl;
            this.bufferId || (this.bufferId = a.createBuffer());
            switch (this.usage) {
            case 0:
                var b = a.STATIC_DRAW;
                break;
            case 1:
                b = a.DYNAMIC_DRAW;
                break;
            case 2:
                b = a.STREAM_DRAW;
                break;
            case 3:
                b = this.device.webgl2 ? a.DYNAMIC_COPY : a.STATIC_DRAW
            }
            a.bindBuffer(a.ARRAY_BUFFER, this.bufferId);
            a.bufferData(a.ARRAY_BUFFER, this.storage, b)
        },
        setData: function(a) {
            if (a.byteLength !== this.numBytes)
                return console.error("VertexBuffer: wrong initial data size: expected " + this.numBytes + ", got " + a.byteLength),
                !1;
            this.storage = a;
            this.unlock();
            return !0
        }
    });
    Na.init = function(a) {
        this._defaultInstancingFormat = new Na(a,[{
            semantic: "TEXCOORD2",
            components: 4,
            type: 6
        }, {
            semantic: "TEXCOORD3",
            components: 4,
            type: 6
        }, {
            semantic: "TEXCOORD4",
            components: 4,
            type: 6
        }, {
            semantic: "TEXCOORD5",
            components: 4,
            type: 6
        }])
    }
    ;
    Object.defineProperty(Na, "defaultInstancingFormat", {
        get: function() {
            return function() {
                return this._defaultInstancingFormat
            }
        }()
    });
    Object.assign(Na.prototype, {
        update: function() {
            this._evaluateHash()
        },
        _evaluateHash: function() {
            var a = [], b = [], c, d = this.elements.length;
            for (c = 0; c < d; c++) {
                var e = this.elements[c];
                var f = e.name;
                f += e.dataType;
                f += e.numComponents;
                f += e.normalize;
                a.push(f);
                f += e.offset;
                f += e.stride;
                f += e.size;
                b.push(f)
            }
            a.sort();
            this.batchingHash = qe(a.join());
            this.renderingingHash = qe(b.join())
        }
    });
    rf.prototype.get = function(a) {
        return this.array[this.index + a]
    }
    ;
    rf.prototype.set = function(a, b, c, d) {}
    ;
    rf.prototype.setFromArray = function(a, b, c) {}
    ;
    rf.prototype.getToArray = function(a, b, c) {}
    ;
    Object.assign(Pb.prototype, {
        next: function(a) {
            void 0 === a && (a = 1);
            for (var b = 0, c = this.accessors, d = this.accessors.length; b < d; ) {
                var e = c[b++];
                e.index += a * e.stride
            }
        },
        end: function() {
            this.vertexBuffer.unlock()
        },
        writeData: function(a, b, c) {
            if (a = this.element[a]) {
                c > this.vertexBuffer.numVertices && (c = this.vertexBuffer.numVertices);
                var d, e = a.numComponents;
                if (this.vertexBuffer.getFormat().interleaved) {
                    var f = 0;
                    for (d = 0; d < c; d++)
                        a.setFromArray(f, b, d * e),
                        f += a.stride
                } else if (b.length > c * e)
                    if (c *= e,
                    ArrayBuffer.isView(b))
                        b = b.subarray(0, c),
                        a.array.set(b);
                    else
                        for (d = 0; d < c; d++)
                            a.array[d] = b[d];
                else
                    a.array.set(b)
            }
        },
        readData: function(a, b) {
            a = this.element[a];
            var c = 0;
            if (a) {
                c = this.vertexBuffer.numVertices;
                var d, e = a.numComponents;
                if (this.vertexBuffer.getFormat().interleaved) {
                    Array.isArray(b) && (b.length = 0);
                    var f = a.index = 0;
                    for (d = 0; d < c; d++)
                        a.getToArray(f, b, d * e),
                        f += a.stride
                } else if (ArrayBuffer.isView(b))
                    b.set(a.array);
                else
                    for (b.length = 0,
                    e *= c,
                    d = 0; d < e; d++)
                        b[d] = a.array[d]
            }
            return c
        }
    });
    var Ed = null
      , Hn = {
        type: 5,
        base: 0,
        count: 4,
        indexed: !1
    };
    Object.assign(re.prototype, {
        destroy: function() {
            this.device.destroyShader(this)
        }
    });
    var F = {
        alphaTestPS: "uniform float alpha_ref;\nvoid alphaTest(float a) {\n\tif (a < alpha_ref) discard;\n}\n",
        ambientConstantPS: "void addAmbient() {\n\tdDiffuseLight += light_globalAmbient;\n}\n",
        ambientPrefilteredCubePS: "#ifndef PMREM4\n#define PMREM4\nuniform samplerCube texture_prefilteredCubeMap4;\n#endif\nvoid addAmbient() {\n\tvec3 fixedReflDir = fixSeamsStatic(dNormalW, 1.0 - 1.0 / 4.0);\n\tfixedReflDir.x *= -1.0;\n\tdDiffuseLight += processEnvironment($DECODE(textureCube(texture_prefilteredCubeMap4, fixedReflDir)).rgb);\n}\n",
        ambientPrefilteredCubeLodPS: "#ifndef PMREM4\n#define PMREM4\n#extension GL_EXT_shader_texture_lod : enable\nuniform samplerCube texture_prefilteredCubeMap128;\n#endif\nvoid addAmbient() {\n\tvec3 fixedReflDir = fixSeamsStatic(dNormalW, 1.0 - 1.0 / 4.0);\n\tfixedReflDir.x *= -1.0;\n\tdDiffuseLight += processEnvironment($DECODE( textureCubeLodEXT(texture_prefilteredCubeMap128, fixedReflDir, 5.0) ).rgb);\n}\n",
        ambientSHPS: "uniform vec3 ambientSH[9];\nvoid addAmbient() {\n\tvec3 n = dNormalW;\n\tvec3 color =\n\t\tambientSH[0] +\n\t\tambientSH[1] * n.x +\n\t\tambientSH[2] * n.y +\n\t\tambientSH[3] * n.z +\n\t\tambientSH[4] * n.x * n.z +\n\t\tambientSH[5] * n.z * n.y +\n\t\tambientSH[6] * n.y * n.x +\n\t\tambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n\t\tambientSH[8] * (n.x * n.x - n.y * n.y);\n\tdDiffuseLight += processEnvironment(max(color, vec3(0.0)));\n}\n",
        aoPS: "#ifdef MAPTEXTURE\nuniform sampler2D texture_aoMap;\n#endif\nvoid applyAO() {\n\tdAo = 1.0;\n\t#ifdef MAPTEXTURE\n\tdAo *= texture2D(texture_aoMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAo *= saturate(vVertexColor.$VC);\n\t#endif\n\tdDiffuseLight *= dAo;\n}\n",
        aoSpecOccPS: "uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n\tfloat specPow = exp2(dGlossiness * 11.0);\n\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n\tspecOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n",
        aoSpecOccConstPS: "void occludeSpecular() {\n\tfloat specPow = exp2(dGlossiness * 11.0);\n\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n",
        aoSpecOccConstSimplePS: "void occludeSpecular() {\n\tfloat specOcc = dAo;\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n",
        aoSpecOccSimplePS: "uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n\tfloat specOcc = mix(1.0, dAo, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n",
        bakeDirLmEndPS: "\tvec4 dirLm = texture2D(texture_dirLightMap, vUv1);\n\tif (bakeDir > 0.5) {\n\t\tif (dAtten > 0.00001) {\n\t\t\tdirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\n\t\t\tdAtten = saturate(dAtten);\n\t\t\tgl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\n\t\t\tgl_FragColor.a = dirLm.w + dAtten;\n\t\t\tgl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\n\t\t} else {\n\t\t\tgl_FragColor = dirLm;\n\t\t}\n\t} else {\n\t\tgl_FragColor.rgb = dirLm.xyz;\n\t\tgl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\n\t}\n",
        bakeLmEndPS: "\tgl_FragColor.rgb = dDiffuseLight;\n\tgl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\n\tgl_FragColor.rgb /= 8.0;\n\tgl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\n\tgl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\n\tgl_FragColor.rgb /= gl_FragColor.a;\n",
        basePS: "uniform vec3 view_position;\nuniform vec3 light_globalAmbient;\nfloat square(float x) {\n\treturn x*x;\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x) {\n\treturn clamp(x, vec3(0.0), vec3(1.0));\n}\n",
        baseVS: "attribute vec3 vertex_position;\nattribute vec3 vertex_normal;\nattribute vec4 vertex_tangent;\nattribute vec2 vertex_texCoord0;\nattribute vec2 vertex_texCoord1;\nattribute vec4 vertex_color;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nvec3 dPositionW;\nmat4 dModelMatrix;\nmat3 dNormalMatrix;\nvec3 dLightPosW;\nvec3 dLightDirNormW;\nvec3 dNormalW;\n",
        baseNineSlicedPS: "#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n",
        baseNineSlicedVS: "#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n",
        baseNineSlicedTiledPS: "#define NINESLICED\n#define NINESLICETILED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n",
        biasConstPS: "#define SHADOWBIAS\nfloat getShadowBias(float resolution, float maxBias) {\n\treturn maxBias;\n}\n",
        blurVSMPS: "varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n#ifdef GAUSS\nuniform float weight[SAMPLES];\n#endif\n#ifdef PACKED\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\n#endif\nvoid main(void) {\n\tvec3 moments = vec3(0.0);\n\tvec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\n\tfor (int i=0; i<SAMPLES; i++) {\n\t\tvec4 c = texture2D(source, uv + pixelOffset * float(i));\n\t\t#ifdef PACKED\n\t\tc.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));\n\t\t#endif\n\t\t#ifdef GAUSS\n\t\tmoments += c.xyz * weight[i];\n\t\t#else\n\t\tmoments += c.xyz;\n\t\t#endif\n\t}\n\t#ifndef GAUSS\n\tmoments /= float(SAMPLES);\n\t#endif\n\t#ifdef PACKED\n\tgl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));\n\t#else\n\tgl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\n\t#endif\n}\n",
        clearCoatPS: "#ifdef MAPFLOAT\nuniform float material_clearCoat;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatMap;\n#endif\nvoid getClearCoat() {\n\tccSpecularity = 1.0;\n\t#ifdef MAPFLOAT\n\tccSpecularity *= material_clearCoat;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tccSpecularity *= texture2D(texture_clearCoatMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tccSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n}\n",
        clearCoatGlossPS: "#ifdef MAPFLOAT\nuniform float material_clearCoatGlossiness;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatGlossMap;\n#endif\nvoid getClearCoatGlossiness() {\n\tccGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tccGlossiness *= material_clearCoatGlossiness;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tccGlossiness *= texture2D(texture_clearCoatGlossMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tccGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\tccGlossiness += 0.0000001;\n}\n",
        clearCoatNormalPS: "#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatNormalMap;\nuniform float material_clearCoatBumpiness;\n#endif\nvoid getClearCoatNormal() {\n\t#ifdef MAPTEXTURE\n\tvec3 normalMap = unpackNormal(texture2D(texture_clearCoatNormalMap, $UV));\n\tnormalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness));\n\tccNormalW = dTBN * normalMap;\n\t#else\n\tccNormalW = normalize(dVertexNormalW);\n\t#endif\n\tccReflDirW = normalize(-reflect(dViewDirW, ccNormalW));\n}\n",
        combineClearCoatPS: "vec3 combineColorCC() {\n\treturn combineColor()+(ccSpecularLight*ccSpecularity+ccReflection.rgb*ccSpecularity*ccReflection.a);\n}\n",
        combineDiffusePS: "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight;\n}\n",
        combineDiffuseSpecularPS: "vec3 combineColor() {\n\treturn mix(dAlbedo * dDiffuseLight, dSpecularLight + dReflection.rgb * dReflection.a, dSpecularity);\n}\n",
        combineDiffuseSpecularNoConservePS: "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight + (dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity;\n}\n",
        combineDiffuseSpecularNoReflPS: "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity;\n}\n",
        combineDiffuseSpecularNoReflSeparateAmbientPS: "uniform vec3 material_ambient;\nvec3 combineColor() {\n\treturn (dDiffuseLight - light_globalAmbient) * dAlbedo + dSpecularLight * dSpecularity + material_ambient * light_globalAmbient;\n}\n",
        combineDiffuseSpecularOldPS: "vec3 combineColor() {\n\treturn mix(dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity, dReflection.rgb, dReflection.a);\n}\n",
        cookiePS: "vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\n\treturn mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\n}\n",
        cubeMapProjectBoxPS: "uniform vec3 envBoxMin, envBoxMax;\nvec3 cubeMapProject(vec3 nrdir) {\n\tvec3 rbmax = (envBoxMax - vPositionW) / nrdir;\n\tvec3 rbmin = (envBoxMin - vPositionW) / nrdir;\n\tvec3 rbminmax;\n\trbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\n\trbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\n\trbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\n\tfloat fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n\tvec3 posonbox = vPositionW + nrdir * fa;\n\tvec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\n\treturn posonbox - envBoxPos;\n}\n",
        cubeMapProjectNonePS: "vec3 cubeMapProject(vec3 dir) {\n\treturn dir;\n}\n",
        detailModesPS: "vec3 detailMode_mul(vec3 c1, vec3 c2) {\n\treturn c1 * c2;\n}\nvec3 detailMode_add(vec3 c1, vec3 c2) {\n\treturn c1 + c2;\n}\nvec3 detailMode_screen(vec3 c1, vec3 c2) {\n\treturn 1.0 - (1.0 - c1)*(1.0 - c2);\n}\nvec3 detailMode_overlay(vec3 c1, vec3 c2) {\n\treturn mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));\n}\nvec3 detailMode_min(vec3 c1, vec3 c2) {\n\treturn min(c1, c2);\n}\nvec3 detailMode_max(vec3 c1, vec3 c2) {\n\treturn max(c1, c2);\n}\n",
        diffusePS: "#ifdef MAPCOLOR\nuniform vec3 material_diffuse;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseMap;\n#endif\nvoid getAlbedo() {\n\tdAlbedo = vec3(1.0);\n\t#ifdef MAPCOLOR\n\tdAlbedo *= material_diffuse.rgb;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdAlbedo *= gammaCorrectInput(addAlbedoDetail(texture2D(texture_diffuseMap, $UV).$CH));\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n\t#endif\n}\n",
        diffuseDetailMapPS: "#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseDetailMap;\n#endif\nvec3 addAlbedoDetail(vec3 albedo) {\n\t#ifdef MAPTEXTURE\n\tvec3 albedoDetail = vec3(texture2D(texture_diffuseDetailMap, $UV).$CH);\n\treturn detailMode_$DETAILMODE(albedo, albedoDetail);\n\t#else\n\treturn albedo;\n\t#endif\n}\n",
        dilatePS: "varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nvoid main(void) {\n\tvec4 c = texture2D(source, vUv0);\n\tc = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);\n\tgl_FragColor = c;\n}\n",
        dpAtlasQuadPS: "varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec4 params;\nvoid main(void) {\n\tvec2 uv = vUv0;\n\tuv = uv * 2.0 - vec2(1.0);\n\tuv *= params.xy;\n\tuv = uv * 0.5 + 0.5;\n\tgl_FragColor = texture2D(source, uv);\n}\n",
        emissivePS: "#ifdef MAPCOLOR\nuniform vec3 material_emissive;\n#endif\n#ifdef MAPFLOAT\nuniform float material_emissiveIntensity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_emissiveMap;\n#endif\nvec3 getEmission() {\n\tvec3 emission = vec3(1.0);\n\t#ifdef MAPFLOAT\n\temission *= material_emissiveIntensity;\n\t#endif\n\t#ifdef MAPCOLOR\n\temission *= material_emissive;\n\t#endif\n\t#ifdef MAPTEXTURE\n\temission *= $texture2DSAMPLE(texture_emissiveMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\temission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n\t#endif\n\treturn emission;\n}\n",
        endPS: "\t#ifdef CLEARCOAT\n\tgl_FragColor.rgb = combineColorCC();\n\t#else\n\tgl_FragColor.rgb = combineColor();\n\t#endif\n\tgl_FragColor.rgb += getEmission();\n\tgl_FragColor.rgb = addFog(gl_FragColor.rgb);\n\t#ifndef HDR\n\tgl_FragColor.rgb = toneMap(gl_FragColor.rgb);\n\tgl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\n\t#endif\n",
        envConstPS: "vec3 processEnvironment(vec3 color) {\n\treturn color;\n}\n",
        envMultiplyPS: "uniform float skyboxIntensity;\nvec3 processEnvironment(vec3 color) {\n\treturn color * skyboxIntensity;\n}\n",
        extensionPS: "\n",
        extensionVS: "\n",
        falloffInvSquaredPS: "float getFalloffInvSquared(float lightRadius) {\n\tfloat sqrDist = dot(dLightDirW, dLightDirW);\n\tfloat falloff = 1.0 / (sqrDist + 1.0);\n\tfloat invRadius = 1.0 / lightRadius;\n\tfalloff *= 16.0;\n\tfalloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n\treturn falloff;\n}\n",
        falloffLinearPS: "float getFalloffLinear(float lightRadius) {\n\tfloat d = length(dLightDirW);\n\treturn max(((lightRadius - d) / lightRadius), 0.0);\n}\n",
        fixCubemapSeamsNonePS: "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n\treturn vec;\n}\nvec3 fixSeams(vec3 vec) {\n\treturn vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\treturn vec;\n}\n",
        fixCubemapSeamsStretchPS: "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n\tfloat scale = 1.0 - exp2(mipmapIndex) / 128.0;\n\tfloat M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n\tif (abs(vec.x) != M) vec.x *= scale;\n\tif (abs(vec.y) != M) vec.y *= scale;\n\tif (abs(vec.z) != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 fixSeams(vec3 vec) {\n\tfloat scale = 1.0 - 1.0 / 128.0;\n\tfloat M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n\tif (abs(vec.x) != M) vec.x *= scale;\n\tif (abs(vec.y) != M) vec.y *= scale;\n\tif (abs(vec.z) != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\tfloat scale = invRecMipSize;\n\tfloat M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n\tif (abs(vec.x) != M) vec.x *= scale;\n\tif (abs(vec.y) != M) vec.y *= scale;\n\tif (abs(vec.z) != M) vec.z *= scale;\n\treturn vec;\n}\n",
        fogExpPS: "uniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n",
        fogExp2PS: "uniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * depth * fog_density * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n",
        fogLinearPS: "uniform vec3 fog_color;\nuniform float fog_start;\nuniform float fog_end;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = (fog_end - depth) / (fog_end - fog_start);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\tfogFactor = gammaCorrectInput(fogFactor);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n",
        fogNonePS: "float dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\treturn color;\n}\n",
        fresnelSchlickPS: "\nuniform float material_fresnelFactor;\nvoid getFresnel() {\n\tfloat fresnel = 1.0 - max(dot(dNormalW, dViewDirW), 0.0);\n\tfloat fresnel2 = fresnel * fresnel;\n\tfresnel *= fresnel2 * fresnel2;\n\tfresnel *= dGlossiness * dGlossiness;\n\tdSpecularity = dSpecularity + (1.0 - dSpecularity) * fresnel;\n\t#ifdef CLEARCOAT\n\tfresnel = 1.0 - max(dot(ccNormalW, dViewDirW), 0.0);\n\tfresnel2 = fresnel * fresnel;\n\tfresnel *= fresnel2 * fresnel2;\n\tfresnel *= ccGlossiness * ccGlossiness;\n\tccSpecularity = ccSpecularity + (1.0 - ccSpecularity) * fresnel;\n\t#endif\n}\n",
        fullscreenQuadPS: "varying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n",
        fullscreenQuadVS: "attribute vec2 vertex_position;\nvarying vec2 vUv0;\nvoid main(void)\n{\n\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\tvUv0 = vertex_position.xy*0.5+0.5;\n}\n",
        gamma1_0PS: "vec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n\treturn texture2D(tex, uv);\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n\treturn texture2D(tex, uv, bias);\n}\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n\treturn textureCube(tex, uvw);\n}\nvec3 gammaCorrectOutput(vec3 color) {\n\treturn color;\n}\nvec3 gammaCorrectInput(vec3 color) {\n\treturn color;\n}\nfloat gammaCorrectInput(float color) {\n\treturn color;\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn color;\n}\n",
        gamma2_2PS: "vec3 gammaCorrectInput(vec3 color) {\n\treturn pow(color, vec3(2.2));\n}\nfloat gammaCorrectInput(float color) {\n\treturn pow(color, 2.2);\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn vec4(pow(color.rgb, vec3(2.2)), color.a);\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n\tvec4 rgba = texture2D(tex, uv);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n\tvec4 rgba = texture2D(tex, uv, bias);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n\tvec4 rgba = textureCube(tex, uvw);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec3 gammaCorrectOutput(vec3 color) {\n\t#ifdef HDR\n\treturn color;\n\t#else\n\tcolor += vec3(0.0000001);\n\treturn pow(color, vec3(0.45));\n\t#endif\n}\n",
        genParaboloidPS: "varying vec2 vUv0;\nuniform samplerCube source;\nuniform vec4 params;\nvoid main(void) {\n\tvec2 uv = vUv0;\n\tfloat side = uv.x < 0.5? 1.0 : -1.0;\n\tvec2 tc;\n\ttc.x = fract(uv.x * 2.0) * 2.0 - 1.0;\n\ttc.y = uv.y * 2.0 - 1.0;\n\tconst float scale = 1.1;\n\ttc *= scale;\n\tvec3 dir;\n\tdir.y = (dot(tc, tc) - 1.0) * side;\n\tdir.xz = tc * -2.0;\n\tdir.x *= -side * params.y;\n\tdir = fixSeams(dir, params.x);\n\tvec4 color = textureCube(source, dir, -100.0);\n\tgl_FragColor = color;\n}\n",
        gles3PS: "#define varying in\nout highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\n#define GL2\n",
        gles3VS: "#define attribute in\n#define varying out\n#define texture2D texture\n#define GL2\n#define VERTEXSHADER\n",
        glossPS: "#ifdef MAPFLOAT\nuniform float material_shininess;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_glossMap;\n#endif\nvoid getGlossiness() {\n\tdGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tdGlossiness *= material_shininess;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdGlossiness *= texture2D(texture_glossMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\tdGlossiness += 0.0000001;\n}\n",
        instancingVS: "attribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\n",
        lightDiffuseLambertPS: "float getLightDiffuse() {\n\treturn max(dot(dNormalW, -dLightDirNormW), 0.0);\n}\n",
        lightDirPointPS: "void getLightDirPoint(vec3 lightPosW) {\n\tdLightDirW = vPositionW - lightPosW;\n\tdLightDirNormW = normalize(dLightDirW);\n\tdLightPosW = lightPosW;\n}\n",
        lightmapDirPS: "uniform sampler2D texture_lightMap;\nuniform sampler2D texture_dirLightMap;\nvoid addLightMap() {\n\tvec3 color = $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n\tvec4 dir = texture2D(texture_dirLightMap, $UV);\n\tif (dot(dir.xyz,vec3(1.0)) < 0.00001) {\n\t\tdDiffuseLight += color;\n\t\treturn;\n\t}\n\tdLightDirNormW = normalize(dir.xyz * 2.0 - vec3(1.0));\n\tfloat vlight = saturate(dot(dLightDirNormW, -dVertexNormalW));\n\tfloat flight = saturate(dot(dLightDirNormW, -dNormalW));\n\tfloat nlight = (flight / max(vlight,0.01)) * 0.5;\n\tdDiffuseLight += color * nlight * 2.0;\n}\nvoid addDirLightMap() {\n\tvec4 dir = texture2D(texture_dirLightMap, $UV);\n\tif (dot(dir.xyz,vec3(1.0)) < 0.00001) return;\n\tvec3 color = $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n\tdLightDirNormW = normalize(dir.xyz * 2.0 - vec3(1.0));\n\tdSpecularLight += vec3(getLightSpecular()) * color;\n}\n",
        lightmapSinglePS: "#ifdef MAPTEXTURE\nuniform sampler2D texture_lightMap;\n#endif\nvoid addLightMap() {\n\tvec3 lm = vec3(1.0);\n\t#ifdef MAPTEXTURE\n\tlm *= $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tlm *= saturate(vVertexColor.$VC);\n\t#endif\n\tdDiffuseLight += lm;\n}\n",
        lightmapSingleVertPS: "void addLightMap() {\n\tdDiffuseLight += saturate(vVertexColor.$CH);\n}\n",
        lightSpecularAnisoGGXPS: "\nfloat calcLightSpecular(float tGlossiness, vec3 tNormalW) {\n\tfloat PI = 3.141592653589793;\n\tfloat roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\n\tfloat anisotropy = material_anisotropy * roughness;\n\tfloat at = max((roughness + anisotropy), roughness / 4.0);\n\tfloat ab = max((roughness - anisotropy), roughness / 4.0);\n\tvec3 h = normalize(normalize(-dLightDirNormW) + normalize(dViewDirW));\n\tfloat NoH = dot(tNormalW, h);\n\tfloat ToH = dot(dTBN[0], h);\n\tfloat BoH = dot(dTBN[1], h);\n\tfloat a2 = at * ab;\n\tvec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\n\tfloat v2 = dot(v, v);\n\tfloat w2 = a2 / v2;\n\tfloat D = a2 * w2 * w2 * (1.0 / PI);\n\tfloat ToV = dot(dTBN[0], dViewDirW);\n\tfloat BoV = dot(dTBN[1], dViewDirW);\n\tfloat ToL = dot(dTBN[0], -dLightDirNormW);\n\tfloat BoL = dot(dTBN[1], -dLightDirNormW);\n\tfloat NoV = dot(tNormalW, dViewDirW);\n\tfloat NoL = dot(tNormalW, -dLightDirNormW);\n\tfloat lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n\tfloat lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n\tfloat G = 0.5 / (lambdaV + lambdaL);\n\treturn D * G;\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dNormalW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccNormalW);\n}\n",
        lightSpecularBlinnPS: "\nfloat calcLightSpecular(float tGlossiness, vec3 tNormalW) {\n\tvec3 h = normalize( -dLightDirNormW + dViewDirW );\n\tfloat nh = max( dot( h, tNormalW ), 0.0 );\n\tfloat specPow = exp2(tGlossiness * 11.0);\n\tspecPow = antiAliasGlossiness(specPow);\n\tspecPow = max(specPow, 0.0001);\n\treturn pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dNormalW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccNormalW);\n}\n",
        lightSpecularPhongPS: "float calcLightSpecular(float tGlossiness, vec3 tReflDirW) {\n\tfloat specPow = tGlossiness;\n\tspecPow = antiAliasGlossiness(specPow);\n\treturn pow(max(dot(tReflDirW, -dLightDirNormW), 0.0), specPow + 0.0001);\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dReflDirW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccReflDirW);\n}\n",
        metalnessPS: "void processMetalness(float metalness) {\n\tconst float dielectricF0 = 0.04;\n\tdSpecularity = mix(vec3(dielectricF0), dAlbedo, metalness);\n\tdAlbedo *= 1.0 - metalness;\n}\n#ifdef MAPFLOAT\nuniform float material_metalness;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_metalnessMap;\n#endif\nvoid getSpecularity() {\n\tfloat metalness = 1.0;\n\t#ifdef MAPFLOAT\n\tmetalness *= material_metalness;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tmetalness *= texture2D(texture_metalnessMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tmetalness *= saturate(vVertexColor.$VC);\n\t#endif\n\tprocessMetalness(metalness);\n}\n",
        msdfPS: "uniform sampler2D texture_msdfMap;\n#ifdef GL_OES_standard_derivatives\n#define USE_FWIDTH\n#endif\n#ifdef GL2\n#define USE_FWIDTH\n#endif\nfloat median(float r, float g, float b) {\n\treturn max(min(r, g), min(max(r, g), b));\n}\nfloat map (float min, float max, float v) {\n\treturn (v - min) / (max - min);\n}\nuniform float font_sdfIntensity;\nuniform float font_pxrange;\nuniform float font_textureWidth;\nuniform vec4 outline_color;\nuniform float outline_thickness;\nuniform vec4 shadow_color;\nuniform vec2 shadow_offset;\nvec4 applyMsdf(vec4 color) {\n\tvec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n\tvec2 uvShdw = vUv0 - shadow_offset;\n\tvec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\n\tfloat sigDist = median(tsample.r, tsample.g, tsample.b);\n\tfloat sigDistShdw = median(ssample.r, ssample.g, ssample.b);\n\t#ifdef USE_FWIDTH\n\tvec2 w = fwidth(vUv0);\n\tfloat smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, 0.5);\n\t#else\n\tfloat font_size = 16.0;\n\tfloat smoothing = clamp(font_pxrange / font_size, 0.0, 0.5);\n\t#endif\n\tfloat mapMin = 0.05;\n\tfloat mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n\tfloat sigDistInner = map(mapMin, mapMax, sigDist);\n\tfloat sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\n\tsigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\n\tfloat center = 0.5;\n\tfloat inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\n\tfloat outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\n\tfloat shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\n\tvec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\n\ttcolor = mix(tcolor, color, inside);\n\tvec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\n\ttcolor = mix(scolor, tcolor, outline);\n\treturn tcolor;\n}\n",
        normalVS: "#ifdef MORPHING_TEXTURE_BASED_NORMAL\nuniform highp sampler2D morphNormalTex;\n#endif\nvec3 getNormal() {\n\t#ifdef SKIN\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\t#elif defined(INSTANCING)\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\t#else\n\tdNormalMatrix = matrix_normal;\n\t#endif\n\tvec3 tempNormal = vertex_normal;\n\t#ifdef MORPHING\n\t#ifdef MORPHING_NRM03\n\ttempNormal += morph_weights_a[0] * morph_nrm0;\n\ttempNormal += morph_weights_a[1] * morph_nrm1;\n\ttempNormal += morph_weights_a[2] * morph_nrm2;\n\ttempNormal += morph_weights_a[3] * morph_nrm3;\n\t#endif\n\t#ifdef MORPHING_NRM47\n\ttempNormal += morph_weights_b[0] * morph_nrm4;\n\ttempNormal += morph_weights_b[1] * morph_nrm5;\n\ttempNormal += morph_weights_b[2] * morph_nrm6;\n\ttempNormal += morph_weights_b[3] * morph_nrm7;\n\t#endif\n\t#endif\n\t#ifdef MORPHING_TEXTURE_BASED_NORMAL\n\tvec2 morphUV = getTextureMorphCoords();\n\tvec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;\n\ttempNormal += morphNormal;\n\t#endif\n\treturn normalize(dNormalMatrix * tempNormal);\n}\n",
        normalDetailMapPS: "#ifdef MAPTEXTURE\nuniform sampler2D texture_normalDetailMap;\nuniform float material_normalDetailMapBumpiness;\nvec3 blendNormals(vec3 n1, vec3 n2) {\n\tn1 += vec3(0, 0, 1);\n\tn2 *= vec3(-1, -1, 1);\n\treturn normalize(n1*dot(n1, n2)/n1.z - n2);\n}\n#endif\nvec3 addNormalDetail(vec3 normalMap) {\n\t#ifdef MAPTEXTURE\n\tvec3 normalDetailMap = unpackNormal(texture2D(texture_normalDetailMap, $UV));\n\tnormalDetailMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness));\n\treturn blendNormals(normalMap, normalDetailMap);\n\t#else\n\treturn normalMap;\n\t#endif\n}\n",
        normalInstancedVS: "vec3 getNormal() {\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n",
        normalMapPS: "uniform sampler2D texture_normalMap;\nuniform float material_bumpiness;\nvoid getNormal() {\n\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n\tnormalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness));\n\tdNormalMap = addNormalDetail(normalMap);\n\tdNormalW = dTBN * dNormalMap;\n}\n",
        normalMapFastPS: "uniform sampler2D texture_normalMap;\nvoid getNormal() {\n\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n\tdNormalMap = addNormalDetail(normalMap);\n\tdNormalW = dTBN * dNormalMap;\n}\n",
        normalSkinnedVS: "vec3 getNormal() {\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n",
        normalVertexPS: "void getNormal() {\n\tdNormalW = normalize(dVertexNormalW);\n}\n",
        normalXYPS: "vec3 unpackNormal(vec4 nmap) {\n\tvec3 normal;\n\tnormal.xy = nmap.wy * 2.0 - 1.0;\n\tnormal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n\treturn normal;\n}\n",
        normalXYZPS: "vec3 unpackNormal(vec4 nmap) {\n\treturn nmap.xyz * 2.0 - 1.0;\n}\n",
        opacityPS: "#ifdef MAPFLOAT\nuniform float material_opacity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_opacityMap;\n#endif\nvoid getOpacity() {\n\tdAlpha = 1.0;\n\t#ifdef MAPFLOAT\n\tdAlpha *= material_opacity;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdAlpha *= texture2D(texture_opacityMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);\n\t#endif\n}\n",
        outputAlphaPS: "gl_FragColor.a = dAlpha;\n",
        outputAlphaOpaquePS: "gl_FragColor.a = 1.0;\n",
        outputAlphaPremulPS: "gl_FragColor.rgb *= dAlpha;\ngl_FragColor.a = dAlpha;\n",
        outputCubemapPS: "varying vec2 vUv0;\nuniform samplerCube source;\nuniform vec4 params;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 encodeRGBM(vec4 color) {\n\tcolor.rgb = pow(color.rgb, vec3(0.5));\n\tcolor.rgb *= 1.0 / 8.0;\n\tcolor.a = saturate( max( max( color.r, color.g ), max( color.b, 1.0 / 255.0 ) ) );\n\tcolor.a = ceil(color.a * 255.0) / 255.0;\n\tcolor.rgb /= color.a;\n\treturn color;\n}\nvoid main(void) {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tfloat face = params.x;\n\tvec3 vec;\n\tif (face==0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face==1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face==2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face==3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face==4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\tgl_FragColor = textureCube(source, vec);\n\tif (params.w >= 2.0) gl_FragColor = encodeRGBM(gl_FragColor);\n}\n",
        outputTex2DPS: "varying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n",
        packDepthPS: "\nvec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\n",
        packDepthMaskPS: "vec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres.x = 0.0;\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\n",
        parallaxPS: "uniform sampler2D texture_heightMap;\nuniform float material_heightMapFactor;\nvoid getParallax() {\n\tfloat parallaxScale = material_heightMapFactor;\n\tfloat height = texture2D(texture_heightMap, $UV).$CH;\n\theight = height * parallaxScale - parallaxScale*0.5;\n\tvec3 viewDirT = dViewDirW * dTBN;\n\tviewDirT.z += 0.42;\n\tdUvOffset = height * (viewDirT.xy / viewDirT.z);\n}\n",
        particlePS: "varying vec4 texCoordsAlphaLife;\nuniform sampler2D colorMap;\nuniform sampler2D colorParam;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nuniform float softening;\nuniform float colorMult;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\tfloat depth = dot(rgbaDepth, bitShift);\n\treturn depth;\n}\n#endif\nvoid main(void) {\n\tvec4 tex  = texture2DSRGB(colorMap, texCoordsAlphaLife.xy);\n\tvec4 ramp = texture2DSRGB(colorParam, vec2(texCoordsAlphaLife.w, 0.0));\n\tramp.rgb *= colorMult;\n\tramp.a += texCoordsAlphaLife.z;\n\tvec3 rgb = tex.rgb * ramp.rgb;\n\tfloat a  = tex.a * ramp.a;\n",
        particleVS: "vec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc) {\n\treturn mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\n}\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex,tc);\n\tvec4 b = texture2D(tex,tc + graphSampleSize);\n\tfloat c = fract(tc.x*graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a, b, c);\n}\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\n\t#ifdef SCREEN_SPACE\n\t\tvec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;\n\t#else\n\t\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\t#endif\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY) {\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvec2 safeNormalize(vec2 v) {\n\tfloat l = length(v);\n\treturn (l > 1e-06) ? v / l : v;\n}\nvoid main(void) {\n\tvec3 meshLocalPos = particle_vertexData.xyz;\n\tfloat id = floor(particle_vertexData.w);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\tfloat uv = id / numParticlesPot;\n\treadInput(uv);\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy);\n\tfloat particleLifetime = lifetime;\n\tif (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\n\tvec2 quadXY = meshLocalPos.xy;\n\tfloat nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n\tvec3 paramDiv;\n\tvec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n\tfloat scale = params.y;\n\tfloat scaleDiv = paramDiv.x;\n\tfloat alphaDiv = paramDiv.z;\n\tscale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\n#ifndef USE_MESH\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#else\n\ttexCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#endif\n\tvec3 particlePos = inPos;\n\tvec3 particlePosMoved = vec3(0.0);\n\tmat2 rotMatrix;\n",
        particleAnimFrameClampVS: "\tfloat animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);\n",
        particleAnimFrameLoopVS: "\tfloat animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));\n",
        particleAnimTexVS: "\tfloat animationIndex;\n\tif (animTexIndexParams.y == 1.0) {\n\t\tanimationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);\n\t} else {\n\t\tanimationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);\n\t}\n\tfloat atlasX = (animationIndex + animFrame) * animTexTilesParams.x;\n\tfloat atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;\n\tatlasX = fract(atlasX);\n\ttexCoordsAlphaLife.xy *= animTexTilesParams.xy;\n\ttexCoordsAlphaLife.xy += vec2(atlasX, atlasY);\n",
        particleInputFloatPS: "void readInput(float uv) {\n\tvec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\n\tinPos = tex.xyz;\n\tinVel = tex2.xyz;\n\tinAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\n\tinShow = tex.w >= 0.0;\n\tinLife = tex2.w;\n}\n",
        particleInputRgba8PS: "\n#define PI2 6.283185307179586\nuniform vec3 inBoundsSize;\nuniform vec3 inBoundsCenter;\nuniform float maxVel;\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nfloat decodeFloatRGBA( vec4 rgba ) {\n  return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\nvoid readInput(float uv) {\n\tvec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\n\tvec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\n\tvec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\n\tinPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n\tinPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\n\tinVel = tex2.xyz;\n\tinVel = (inVel - vec3(0.5)) * maxVel;\n\tinAngle = decodeFloatRG(tex1.ba) * PI2;\n\tinShow = tex2.a > 0.5;\n\tinLife = decodeFloatRGBA(tex3);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\tinLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\n}\n",
        particleOutputFloatPS: "void writeOutput() {\n\tif (gl_FragCoord.y<1.0) {\n\t\tgl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\n\t} else {\n\t\tgl_FragColor = vec4(outVel, outLife);\n\t}\n}\n",
        particleOutputRgba8PS: "uniform vec3 outBoundsMul;\nuniform vec3 outBoundsAdd;\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\nvec4 encodeFloatRGBA( float v ) {\n\tvec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n\treturn enc;\n}\nvoid writeOutput() {\n\toutPos = outPos * outBoundsMul + outBoundsAdd;\n\toutAngle = fract(outAngle / PI2);\n\toutVel = (outVel / maxVel) + vec3(0.5);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\toutLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n\tif (gl_FragCoord.y < 1.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n\t} else if (gl_FragCoord.y < 2.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n\t} else if (gl_FragCoord.y < 3.0) {\n\t\tgl_FragColor = vec4(outVel, visMode*0.5+0.5);\n\t} else {\n\t\tgl_FragColor = encodeFloatRGBA(outLife);\n\t}\n}\n",
        particleUpdaterAABBPS: "uniform mat3 spawnBounds;\nuniform vec3 spawnPosInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tvec3 pos = inBounds - vec3(0.5);\n\tvec3 posAbs = abs(pos);\n\tvec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));\n\tvec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;\n\tpos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);\n\tpos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);\n\tpos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);\n#ifndef LOCAL_SPACE\n\treturn emitterPos + spawnBounds * pos;\n#else\n\treturn spawnBounds * pos;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity -= vec3(0, 0, initialVelocity);\n}\n",
        particleUpdaterEndPS: "\twriteOutput();\n}\n",
        particleUpdaterInitPS: "varying vec2 vUv0;\nuniform highp sampler2D particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform highp sampler2D internalTex3;\nuniform mat3 emitterMatrix, emitterMatrixInv;\nuniform vec3 emitterScale;\nuniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;\nuniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, radialSpeedDivMult, seed;\nuniform float startAngle, startAngle2;\nuniform float initialVelocity;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\nfloat visMode;\nvec3 outPos;\nvec3 outVel;\nfloat outAngle;\nbool outShow;\nfloat outLife;\n",
        particleUpdaterNoRespawnPS: "\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = -1.0;\n\t}\n",
        particleUpdaterOnStopPS: "\tvisMode = outLife < 0.0? -1.0: visMode;\n",
        particleUpdaterRespawnPS: "\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = 1.0;\n\t}\n\tvisMode = outLife < 0.0? 1.0: visMode;\n",
        particleUpdaterSpherePS: "uniform float spawnBoundsSphere;\nuniform float spawnBoundsSphereInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tfloat rnd4 = fract(rndFactor * 1000.0);\n\tvec3 norm = normalize(inBounds.xyz - vec3(0.5));\n\tfloat r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n#ifndef LOCAL_SPACE\n\treturn emitterPos + norm * r * spawnBoundsSphere;\n#else\n\treturn norm * r * spawnBoundsSphere;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\n}\n",
        particleUpdaterStartPS: "float saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nvec3 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex, tc);\n\tvec4 b = texture2D(tex, tc + graphSampleSize);\n\tfloat c = fract(tc.x * graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a.xyz, b.xyz, c);\n}\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash41(float p) {\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\nvoid main(void) {\n\tif (gl_FragCoord.x > numParticles) discard;\n\treadInput(vUv0.x);\n\tvisMode = inShow? 1.0 : -1.0;\n\tvec4 rndFactor = hash41(gl_FragCoord.x + seed);\n\tfloat particleRate = rate + rateDiv * rndFactor.x;\n\toutLife = inLife + delta;\n\tfloat nlife = clamp(outLife / lifetime, 0.0, 1.0);\n\tvec3 localVelocityDiv;\n\tvec3 velocityDiv;\n\tvec3 paramDiv;\n\tvec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);\n\tvec3 velocity =\t  tex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);\n\tvec3 params =\t\ttex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n\tfloat rotSpeed = params.x;\n\tfloat rotSpeedDiv = paramDiv.y;\n\tvec3 radialParams = tex1Dlod_lerp(internalTex3, vec2(nlife, 0), paramDiv);\n\tfloat radialSpeed = radialParams.x;\n\tfloat radialSpeedDiv = radialParams.y;\n\tbool respawn = inLife <= 0.0 || outLife >= lifetime;\n\tinPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;\n\tinAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;\n#ifndef LOCAL_SPACE\n\tvec3 radialVel = inPos - emitterPos;\n#else\n\tvec3 radialVel = inPos;\n#endif\n\tradialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);\n\tradialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;\n\tlocalVelocity +=\t(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\n\tvelocity +=\t\t (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\n\trotSpeed +=\t\t (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\n\taddInitialVelocity(localVelocity, rndFactor.xyz);\n#ifndef LOCAL_SPACE\n\toutVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;\n#else\n\toutVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;\n#endif\n\toutPos = inPos + outVel * delta;\n\toutAngle = inAngle + rotSpeed * delta;\n",
        particle_billboardVS: "\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = billboard(particlePos, quadXY);\n",
        particle_blendAddPS: "\tdBlendModeFogFactor = 0.0;\n\trgb *= saturate(gammaCorrectInput(max(a, 0.0)));\n\tif ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\n",
        particle_blendMultiplyPS: "\trgb = mix(vec3(1.0), rgb, vec3(a));\n\tif (rgb.r + rgb.g + rgb.b > 2.99) discard;\n",
        particle_blendNormalPS: "\tif (a < 0.01) discard;\n",
        particle_cpuVS: "attribute vec4 particle_vertexData;\nattribute vec4 particle_vertexData2;\nattribute vec4 particle_vertexData3;\nattribute float particle_vertexData4;\n#ifndef USE_MESH\n#define VDATA5TYPE vec2\n#else\n#define VDATA5TYPE vec4\n#endif\nattribute VDATA5TYPE particle_vertexData5;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\nuniform float numParticles;\nuniform float lifetime;\nuniform float stretch;\nuniform float seed;\nuniform vec3 wrapBounds, emitterScale, faceTangent, faceBinorm;\nuniform sampler2D texLifeAndSourcePosOUT;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform vec3 emitterPos;\nvarying vec4 texCoordsAlphaLife;\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\n{\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvoid main(void)\n{\n\tvec3 particlePos = particle_vertexData.xyz;\n\tvec3 inPos = particlePos;\n\tvec3 vertPos = particle_vertexData3.xyz;\n\tvec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);\n\tfloat id = floor(particle_vertexData4);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = normalize((mat3(matrix_view) * inVel).xy);\n\tvec2 quadXY = vertPos.xy;\n#ifndef USE_MESH\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\n#else\n\ttexCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);\n#endif\n\tmat2 rotMatrix;\n\tfloat inAngle = particle_vertexData2.x;\n\tvec3 particlePosMoved = vec3(0.0);\n\tvec3 meshLocalPos = particle_vertexData3.xyz;\n",
        particle_cpu_endVS: "\tlocalPos *= particle_vertexData2.y * emitterScale;\n\tlocalPos += particlePos;\n\tgl_Position = matrix_viewProjection * vec4(localPos, 1.0);\n",
        particle_customFaceVS: "\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = customFace(particlePos, quadXY);\n",
        particle_endPS: "\trgb = addFog(rgb);\n\trgb = toneMap(rgb);\n\trgb = gammaCorrectOutput(rgb);\n\tgl_FragColor = vec4(rgb, a);\n}\n",
        particle_endVS: "\tlocalPos *= scale * emitterScale;\n\tlocalPos += particlePos;\n\t#ifdef SCREEN_SPACE\n\tgl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);\n\t#else\n\tgl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\n\t#endif\n",
        particle_halflambertPS: "\tvec3 negNormal = normal*0.5+0.5;\n\tvec3 posNormal = -normal*0.5+0.5;\n\tnegNormal *= negNormal;\n\tposNormal *= posNormal;\n",
        particle_initVS: "attribute vec4 particle_vertexData;\n#ifdef USE_MESH\nattribute vec2 particle_uv;\n#endif\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform float numParticles, numParticlesPot;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nuniform float stretch;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale, emitterPos, faceTangent, faceBinorm;\nuniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;\nuniform sampler2D particleTexOUT, particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nvarying vec4 texCoordsAlphaLife;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\n",
        particle_lambertPS: "\tvec3 negNormal = max(normal, vec3(0.0));\n\tvec3 posNormal = max(-normal, vec3(0.0));\n",
        particle_lightingPS: "\tvec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\n\t\t\t\t\t\tnegNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\n\t\t\t\t\t\tnegNormal.z*lightCube[4] + posNormal.z*lightCube[5];\n\trgb *= light;\n",
        particle_localShiftVS: "\tparticlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;\n",
        particle_meshVS: "\tvec3 localPos = meshLocalPos;\n\tlocalPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\n\tlocalPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\n\tbillboard(particlePos, quadXY);\n",
        particle_normalVS: "\tNormal = normalize(localPos + matrix_viewInverse[2].xyz);\n",
        particle_normalMapPS: "\tvec3 normalMap = normalize(texture2D(normalMap, texCoordsAlphaLife.xy).xyz * 2.0 - 1.0);\n\tvec3 normal = ParticleMat * normalMap;\n",
        particle_pointAlongVS: "\tinAngle = atan(velocityV.x, velocityV.y);\n",
        particle_softPS: "\tfloat depth = getLinearScreenDepth();\n\tfloat particleDepth = vDepth;\n\tfloat depthDiff = saturate(abs(particleDepth - depth) * softening);\n\ta *= depthDiff;\n",
        particle_softVS: "\tvDepth = getLinearDepth(localPos);\n",
        particle_stretchVS: "\tvec3 moveDir = inVel * stretch;\n\tvec3 posPrev = particlePos - moveDir;\n\tposPrev += particlePosMoved;\n\tvec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\n\tfloat interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\n\tparticlePos = mix(particlePos, posPrev, interpolation);\n",
        particle_TBNVS: "\tmat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);\n\tParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\n",
        particle_wrapVS: "\tvec3 origParticlePos = particlePos;\n\tparticlePos -= matrix_model[3].xyz;\n\tparticlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\n\tparticlePos += matrix_model[3].xyz;\n\tparticlePosMoved = particlePos - origParticlePos;\n",
        precisionTestPS: "void main(void) {\n\tgl_FragColor = vec4(2147483648.0);\n}\n",
        precisionTest2PS: "uniform sampler2D source;\nvec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main(void) {\n\tfloat c = texture2D(source, vec2(0.0)).r;\n\tfloat diff = abs(c - 2147483648.0) / 2147483648.0;\n\tgl_FragColor = packFloat(diff);\n}\n",
        prefilterCubemapPS: "varying vec2 vUv0;\nuniform samplerCube source;\nuniform vec4 params;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nfloat rnd(vec2 uv) {\n\treturn fract(sin(dot(uv, vec2(12.9898, 78.233) * 2.0)) * 43758.5453);\n}\nconst float PI = 3.14159265358979;\nvec3 hemisphereSample_cos(vec2 uv, mat3 vecSpace, vec3 cubeDir, float gloss) {\n\tfloat phi = uv.y * 2.0 * PI;\n\tfloat cosTheta = sqrt(1.0 - uv.x);\n\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\tvec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\treturn normalize(mix(vecSpace * sampleDir, cubeDir, params.y));\n}\nvec3 hemisphereSample_phong(vec2 uv, mat3 vecSpace, vec3 cubeDir, float specPow) {\n\tfloat phi = uv.y * 2.0 * PI;\n\tfloat cosTheta = pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\n\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\tvec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\treturn vecSpace * sampleDir;\n}\nmat3 matrixFromVector(vec3 n) {\n\tfloat a = 1.0 / (1.0 + n.z);\n\tfloat b = -n.x * n.y * a;\n\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\treturn mat3(b1, b2, n);\n}\nvec4 encodeRGBM(vec3 color) {\n\tvec4 encoded;\n\tencoded.rgb = pow(color.rgb, vec3(0.5));\n\tencoded.rgb *= 1.0 / 8.0;\n\tencoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n\tencoded.a = ceil(encoded.a * 255.0) / 255.0;\n\tencoded.rgb /= encoded.a;\n\treturn encoded;\n}\nvoid main(void) {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tif (params.w==1.0 || params.w==3.0) {\n\t\tst = 2.0 * floor(gl_FragCoord.xy) / (params.z - 1.0) - 1.0;\n\t}\n\tfloat face = params.x;\n\tvec3 vec;\n\tif (face==0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face==1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face==2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face==3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face==4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\tmat3 vecSpace = matrixFromVector(normalize(vec));\n\tvec3 color = vec3(0.0);\n\tconst int samples = $NUMSAMPLES;\n\tvec3 vect;\n\tfor(int i=0; i<samples; i++) {\n\t\tfloat sini = sin(float(i));\n\t\tfloat cosi = cos(float(i));\n\t\tfloat rand = rnd(vec2(sini, cosi));\n\t\tvect = hemisphereSample_$METHOD(vec2(float(i) / float(samples), rand), vecSpace, vec, params.y);\n\t\tcolor += $textureCube(source, vect).rgb;\n\t}\n\tcolor /= float(samples);\n\tgl_FragColor = params.w < 2.0? vec4(color, 1.0) : encodeRGBM(color);\n}\n",
        reflDirPS: "void getReflDir() {\n\tdReflDirW = normalize(-reflect(dViewDirW, dNormalW));\n}\n",
        reflDirAnisoPS: "void getReflDir() {\n\tfloat roughness = sqrt(1.0 - min(dGlossiness, 1.0));\n\tfloat anisotropy = material_anisotropy * roughness;\n\tvec3 anisotropicDirection = anisotropy >= 0.0 ? dTBN[1] : dTBN[0];\n\tvec3 anisotropicTangent = cross(anisotropicDirection, dViewDirW);\n\tvec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);\n\tvec3 bentNormal = normalize(mix(normalize(dNormalW), normalize(anisotropicNormal), anisotropy));\n\tdReflDirW = reflect(-dViewDirW, bentNormal);\n}\n",
        reflectionCCPS: "#ifdef CLEARCOAT\nuniform float material_clearCoatReflectivity;\nvoid addReflectionCC() {\n\tccReflection += vec4(calcReflection(ccReflDirW, ccGlossiness), material_clearCoatReflectivity);\n}\n#endif\n",
        reflectionCubePS: "uniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 lookupVec = fixSeams(cubeMapProject(tReflDirW));\n\tlookupVec.x *= -1.0;\n\treturn $textureCubeSAMPLE(texture_cubeMap, lookupVec).rgb;\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n",
        reflectionDpAtlasPS: "uniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec2 getDpAtlasUv(vec2 uv, float mip) {\n\tvec4 rect;\n\tfloat sx = saturate(mip - 2.0);\n\trect.x = sx * 0.5;\n\tfloat t = mip - rect.x * 6.0;\n\tfloat i = 1.0 - rect.x;\n\trect.y = min(t * 0.5, 0.75) * i + rect.x;\n\tfloat st = saturate(t);\n\trect.z = (1.0 - st * 0.5) * i;\n\trect.w = rect.z * 0.5;\n\tfloat rcRectZ = 1.0 / rect.z;\n\tfloat scaleFactor = 0.00390625 * rcRectZ;\n\tvec2 scale = vec2(scaleFactor, scaleFactor * 2.0);\n\tuv = uv * (vec2(1.0) - scale) + scale * 0.5;\n\tuv = uv * rect.zw + rect.xy;\n\treturn uv;\n}\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 reflDir = normalize(cubeMapProject(tReflDirW));\n\tbool up = reflDir.y > 0.0;\n\tfloat scale = 0.90909090909090909090909090909091;\n\tvec3 reflDirWarp = reflDir.xzx * vec3(-0.25, 0.5, 0.25);\n\tfloat reflDirVer = abs(reflDir.y) + 1.0;\n\treflDirWarp /= reflDirVer;\n\treflDirWarp *= scale;\n\treflDirWarp = vec3(0.75, 0.5, 0.25) - reflDirWarp;\n\tvec2 tc = up? reflDirWarp.xy : reflDirWarp.zy;\n\tfloat bias = saturate(1.0 - tGlossiness) * 5.0;\n\tfloat mip = floor(bias);\n\tvec3 tex1 = $texture2DSAMPLE(texture_sphereMap, getDpAtlasUv(tc, mip)).rgb;\n\tmip = min(mip + 1.0, 5.0);\n\tvec3 tex2 = $texture2DSAMPLE(texture_sphereMap, getDpAtlasUv(tc, mip)).rgb;\n\ttex1 = mix(tex1, tex2, fract(bias));\n\ttex1 = processEnvironment(tex1);\n\treturn tex1;\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n",
        reflectionPrefilteredCubePS: "uniform samplerCube texture_prefilteredCubeMap128;\nuniform samplerCube texture_prefilteredCubeMap64;\nuniform samplerCube texture_prefilteredCubeMap32;\nuniform samplerCube texture_prefilteredCubeMap16;\nuniform samplerCube texture_prefilteredCubeMap8;\n#ifndef PMREM4\n#define PMREM4\nuniform samplerCube texture_prefilteredCubeMap4;\n#endif\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tfloat bias = saturate(1.0 - tGlossiness) * 5.0;\n\tint index1 = int(bias);\n\tint index2 = int(min(bias + 1.0, 7.0));\n\tvec3 fixedReflDir = fixSeams(cubeMapProject(tReflDirW), bias);\n\tfixedReflDir.x *= -1.0;\n\tvec4 cubes[6];\n\tcubes[0] = textureCube(texture_prefilteredCubeMap128, fixedReflDir);\n\tcubes[1] = textureCube(texture_prefilteredCubeMap64, fixedReflDir);\n\tcubes[2] = textureCube(texture_prefilteredCubeMap32, fixedReflDir);\n\tcubes[3] = textureCube(texture_prefilteredCubeMap16, fixedReflDir);\n\tcubes[4] = textureCube(texture_prefilteredCubeMap8, fixedReflDir);\n\tcubes[5] = textureCube(texture_prefilteredCubeMap4, fixedReflDir);\n\tvec4 cube[2];\n\tfor(int i = 0; i < 6; i++) {\n\t\tif (i == index1) {\n\t\t\tcube[0] = cubes[i];\n\t\t}\n\t\tif (i == index2) {\n\t\t\tcube[1] = cubes[i];\n\t\t}\n\t}\n\tvec4 cubeFinal = mix(cube[0], cube[1], fract(bias));\n\tvec3 refl = processEnvironment($DECODE(cubeFinal).rgb);\n\treturn refl;\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n",
        reflectionPrefilteredCubeLodPS: "#ifndef PMREM4\n#define PMREM4\n#extension GL_EXT_shader_texture_lod : enable\nuniform samplerCube texture_prefilteredCubeMap128;\n#endif\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tfloat bias = saturate(1.0 - tGlossiness) * 5.0;\n\tvec3 fixedReflDir = fixSeams(cubeMapProject(tReflDirW), bias);\n\tfixedReflDir.x *= -1.0;\n\tvec3 refl = processEnvironment($DECODE( textureCubeLodEXT(texture_prefilteredCubeMap128, fixedReflDir, bias) ).rgb);\n\treturn refl;\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n",
        reflectionSpherePS: "#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 reflDirV = (mat3(matrix_view) * tReflDirW).xyz;\n\tfloat m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\n\tvec2 sphereMapUv = reflDirV.xy / m + 0.5;\n\treturn $texture2DSAMPLE(texture_sphereMap, sphereMapUv).rgb;\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n",
        reflectionSphereLowPS: "uniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 reflDirV = vNormalV;\n\tvec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;\n\treturn $texture2DSAMPLE(texture_sphereMap, sphereMapUv).rgb;\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n",
        refractionPS: "uniform float material_refraction, material_refractionIndex;\nvec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {\n\tfloat vn = dot(viewVec, Normal);\n\tfloat k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n\tvec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;\n\treturn refrVec;\n}\nvoid addRefraction() {\n\tvec3 tmp = dReflDirW;\n\tvec4 tmp2 = dReflection;\n\tdReflection = vec4(0.0);\n\tdReflDirW = refract2(-dViewDirW, dNormalW, material_refractionIndex);\n\taddReflection();\n\tdDiffuseLight = mix(dDiffuseLight, dReflection.rgb * dAlbedo, material_refraction);\n\tdReflDirW = tmp;\n\tdReflection = tmp2;\n}\n",
        reprojectPS: "\nvarying vec2 vUv0;\nuniform sampler2D sourceTex;\nuniform samplerCube sourceCube;\nuniform vec4 params;\nfloat PI = 3.141592653589793;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 decodeLinear(vec4 source) {\n\treturn source.rgb;\n}\nvec4 encodeLinear(vec3 source) {\n\treturn vec4(source, 1.0);\n}\nvec3 decodeGamma(vec4 source) {\n\treturn pow(source.xyz, vec3(2.2));\n}\nvec4 encodeGamma(vec3 source) {\n\treturn vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);\n}\nvec3 decodeRGBM(vec4 rgbm) {\n\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\treturn color * color;\n}\nvec4 encodeRGBM(vec3 source) {\n\tvec4 result;\n\tresult.rgb = pow(source.rgb, vec3(0.5));\n\tresult.rgb *= 1.0 / 8.0;\n\tresult.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );\n\tresult.a = ceil(result.a * 255.0) / 255.0;\n\tresult.rgb /= result.a;\n\treturn result;\n}\nvec3 decodeRGBE(vec4 source) {\n\tif (source.a == 0.0) {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t} else {\n\t\treturn source.xyz * pow(2.0, source.w * 255.0 - 128.0);\n\t}\n}\nvec4 encodeRGBE(vec3 source) {\n\tfloat maxVal = max(source.x, max(source.y, source.z));\n\tif (maxVal < 1e-32) {\n\t\treturn vec4(0, 0, 0, 0);\n\t} else {\n\t\tfloat e = ceil(log2(maxVal));\n\t\treturn vec4(source / pow(2.0, e), (e + 128.0) / 255.0);\n\t}\n}\nvec2 toSpherical(vec3 dir) {\n\treturn vec2(atan(dir.z, dir.x) * -1.0, asin(dir.y));\n}\nvec3 fromSpherical(vec2 uv) {\n\treturn vec3(cos(uv.y) * cos(-uv.x),\n\t\t\t\tsin(uv.y),\n\t\t\t\tcos(uv.y) * sin(-uv.x));\n}\nvec4 sampleEquirect(vec2 sph) {\n\treturn texture2D(sourceTex, sph / vec2(PI * 2.0, PI) + 0.5);\n}\nvec4 sampleEquirect(vec3 dir) {\n\treturn sampleEquirect(toSpherical(dir));\n}\nvec4 sampleCubemap(vec3 dir) {\n\treturn textureCube(sourceCube, dir);\n}\nvec4 sampleCubemap(vec2 sph) {\n\treturn sampleCubemap(fromSpherical(sph));\n}\nvec3 getDirectionEquirect() {\n\treturn fromSpherical((vUv0 * 2.0 - 1.0) * vec2(PI, PI * 0.5));\n}\nvec3 getDirectionCubemap() {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tfloat face = params.x;\n\tvec3 vec;\n\tif (face==0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face==1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face==2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face==3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face==4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\treturn normalize(vec);\n}\nmat3 matrixFromVector(vec3 n) {\n\tfloat a = 1.0 / (1.0 + n.z);\n\tfloat b = -n.x * n.y * a;\n\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\treturn mat3(b1, b2, n);\n}\nfloat rnd(int i) {\n\tfloat sini = sin(float(i));\n\tfloat cosi = cos(float(i));\n\treturn fract(sin(dot(vec2(sini, cosi), vec2(12.9898, 78.233) * 2.0)) * 43758.5453);\n}\nvec3 hemisphereSamplePhong(vec2 uv, float specPow) {\n\tfloat phi = uv.y * 2.0 * PI;\n\tfloat cosTheta = pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\n\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\treturn vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n}\nvec4 reproject() {\n\tif (NUM_SAMPLES <= 1) {\n\t\treturn ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));\n\t} else {\n\t\tvec2 sph = toSpherical(TARGET_FUNC());\n\t\tvec2 sphu = dFdx(sph);\n\t\tvec2 sphv = dFdy(sph);\n\t\tconst float num = sqrt(float(NUM_SAMPLES));\n\t\tvec3 result = vec3(0.0);\n\t\tfor (float u=0.0; u<num; ++u) {\n\t\t\tfor (float v=0.0; v<num; ++v) {\n\t\t\t\tresult += DECODE_FUNC(SOURCE_FUNC(sph +\n\t\t\t\t\t\t\t\t\t\t\t\t  sphu * (u / num - 0.5) +\n\t\t\t\t\t\t\t\t\t\t\t\t  sphv * (v / num - 0.5)));\n\t\t\t}\n\t\t}\n\t\treturn ENCODE_FUNC(result / (num * num));\n\t}\n}\nvec4 prefilter() {\n\tvec3 vec = TARGET_FUNC();\n\tmat3 vecSpace = matrixFromVector(vec);\n\tvec3 result = vec3(0.0);\n\tfor (int i=0; i<NUM_SAMPLES; ++i) {\n\t\tvec2 uv = vec2(float(i) / float(NUM_SAMPLES), rnd(i));\n\t\tvec3 dir = vecSpace * hemisphereSamplePhong(uv, params.y);\n\t\tresult += DECODE_FUNC(SOURCE_FUNC(dir));\n\t}\n\treturn ENCODE_FUNC(result / float(NUM_SAMPLES));\n}\nvoid main(void) {\n\tgl_FragColor = (params.z == 0.0) ? reproject() : prefilter();\n}\n",
        rgbmPS: "vec3 decodeRGBM(vec4 rgbm) {\n\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\treturn color * color;\n}\nvec3 texture2DRGBM(sampler2D tex, vec2 uv) {\n\treturn decodeRGBM(texture2D(tex, uv));\n}\nvec3 textureCubeRGBM(samplerCube tex, vec3 uvw) {\n\treturn decodeRGBM(textureCube(tex, uvw));\n}\n",
        screenDepthPS: "uniform sampler2D uDepthMap;\n#ifndef SCREENSIZE\n#define SCREENSIZE\nuniform vec4 uScreenSize;\n#endif\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n#ifdef GL2\nfloat linearizeDepth(float z) {\n\tz = z * 2.0 - 1.0;\n\treturn 1.0 / (camera_params.z * z + camera_params.w);\n}\n#else\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n#endif\nfloat getLinearScreenDepth(vec2 uv) {\n\t#ifdef GL2\n\treturn linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y;\n\t#else\n\treturn unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y;\n\t#endif\n}\n#ifndef VERTEXSHADER\nfloat getLinearScreenDepth() {\n\tvec2 uv = gl_FragCoord.xy * uScreenSize.zw;\n\treturn getLinearScreenDepth(uv);\n}\n#endif\nfloat getLinearDepth(vec3 pos) {\n\treturn -(matrix_view * vec4(pos, 1.0)).z;\n}\n",
        shadowCommonPS: "void normalOffsetPointShadow(vec4 shadowParams) {\n\tfloat distScale = length(dLightDirW);\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\tvec3 dir = wPos - dLightPosW;\n\tdLightDirW = dir;\n}\n",
        shadowCoordPS: "void _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n\tdShadowCoord = (shadowMatrix * vec4(wPos, 1.0)).xyz;\n\tdShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n\t#ifdef SHADOWBIAS\n\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n}\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tprojPos.xy /= projPos.w;\n\tdShadowCoord.xy = projPos.xy;\n\tdShadowCoord.z = length(dLightDirW) * shadowParams.w;\n\t#ifdef SHADOWBIAS\n\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n}\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams) {\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0);\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n",
        shadowCoordVS: "void getLightDirPoint(vec3 lightPosW) {\n\tvec3 lightDirW = vPositionW - lightPosW;\n\tdLightDirNormW = normalize(lightDirW);\n\tdLightPosW = lightPosW;\n}\nvoid _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tvMainShadowUv = projPos;\n}\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tvMainShadowUv = projPos;\n}\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec3 shadowParams) {\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\n\tvec3 wPos = vPositionW + dNormalW * shadowParams.y * clamp(1.0 - dot(dNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n\tvec3 wPos = vPositionW + dNormalW * shadowParams.y * clamp(1.0 - dot(dNormalW, -dLightDirNormW), 0.0, 1.0);\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n",
        shadowCoordPerspZbufferPS: "void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tprojPos.xyz /= projPos.w;\n\tdShadowCoord = projPos.xyz;\n}\nvoid getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams) {\n\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, vPositionW);\n}\n",
        shadowEVSMPS: "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec3 moments = texture2D(tex, texCoords).xyz;\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n",
        shadowEVSMnPS: "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tfloat pixelSize = 1.0 / resolution;\n\ttexCoords -= vec2(pixelSize);\n\tvec3 s00 = texture2D(tex, texCoords).xyz;\n\tvec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\n\tvec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\n\tvec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\n\tvec2 fr = fract(texCoords * resolution);\n\tvec3 h0 = mix(s00, s10, fr.x);\n\tvec3 h1 = mix(s01, s11, fr.x);\n\tvec3 moments = mix(h0, h1, fr.y);\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n",
        shadowStandardPS: "vec3 lessThan2(vec3 a, vec3 b) {\n\treturn clamp((b - a)*1000.0, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n#ifdef GL2\nfloat _getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n\tfloat z = dShadowCoord.z;\n\tvec2 uv = dShadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat sum = 0.0;\n\tfloat uw0 = (3.0 - 2.0 * s);\n\tfloat uw1 = (1.0 + 2.0 * s);\n\tfloat u0 = (2.0 - s) / uw0 - 1.0;\n\tfloat u1 = s / uw1 + 1.0;\n\tfloat vw0 = (3.0 - 2.0 * t);\n\tfloat vw1 = (1.0 + 2.0 * t);\n\tfloat v0 = (2.0 - t) / vw0 - 1.0;\n\tfloat v1 = t / vw1 + 1.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n\tsum *= 1.0f / 16.0;\n\treturn sum;\n}\nfloat getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF3x3(sampler2DShadow shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n}\n#else\nfloat _xgetShadowPCF3x3(mat3 depthKernel, sampler2D shadowMap, vec3 shadowParams) {\n\tmat3 shadowKernel;\n\tvec3 shadowCoord = dShadowCoord;\n\tvec3 shadowZ = vec3(shadowCoord.z);\n\tshadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));\n\tvec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\treturn dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n\tvec3 shadowCoord = dShadowCoord;\n\tfloat xoffset = 1.0 / shadowParams.x;\n\tfloat dx0 = -xoffset;\n\tfloat dx1 = xoffset;\n\tmat3 depthKernel;\n\tdepthKernel[0][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));\n\tdepthKernel[0][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));\n\tdepthKernel[0][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));\n\tdepthKernel[1][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));\n\tdepthKernel[1][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy));\n\tdepthKernel[1][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));\n\tdepthKernel[2][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));\n\tdepthKernel[2][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));\n\tdepthKernel[2][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));\n\treturn _xgetShadowPCF3x3(depthKernel, shadowMap, shadowParams);\n}\nfloat getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF3x3(sampler2D shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n}\n#endif\nfloat _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {\n\tvec3 tc = normalize(dir);\n\tvec3 tcAbs = abs(tc);\n\tvec4 dirX = vec4(1,0,0, tc.x);\n\tvec4 dirY = vec4(0,1,0, tc.y);\n\tfloat majorAxisLength = tc.z;\n\tif ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {\n\t\tdirX = vec4(0,0,1, tc.z);\n\t\tdirY = vec4(0,1,0, tc.y);\n\t\tmajorAxisLength = tc.x;\n\t} else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {\n\t\tdirX = vec4(1,0,0, tc.x);\n\t\tdirY = vec4(0,0,1, tc.z);\n\t\tmajorAxisLength = tc.y;\n\t}\n\tfloat shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);\n\tvec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);\n\tvec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);\n\tvec3 dx0 = -xoffset;\n\tvec3 dy0 = -yoffset;\n\tvec3 dx1 = xoffset;\n\tvec3 dy1 = yoffset;\n\tmat3 shadowKernel;\n\tmat3 depthKernel;\n\tdepthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));\n\tdepthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));\n\tdepthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));\n\tdepthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));\n\tdepthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));\n\tdepthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));\n\tdepthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));\n\tdepthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));\n\tdepthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));\n\tvec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);\n\tshadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));\n\tvec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;\n\tvec2 fractionalCoord = fract( uv * shadowParams.x );\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\treturn 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat getShadowPointPCF3x3(samplerCube shadowMap, vec4 shadowParams) {\n\treturn _getShadowPoint(shadowMap, shadowParams, dLightDirW);\n}\n",
        shadowStandardGL2PS: "float _getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n\tfloat z = dShadowCoord.z;\n\tvec2 uv = dShadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat uw0 = (4.0 - 3.0 * s);\n\tfloat uw1 = 7.0;\n\tfloat uw2 = (1.0 + 3.0 * s);\n\tfloat u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n\tfloat u1 = (3.0 + s) / uw1;\n\tfloat u2 = s / uw2 + 2.0;\n\tfloat vw0 = (4.0 - 3.0 * t);\n\tfloat vw1 = 7.0;\n\tfloat vw2 = (1.0 + 3.0 * t);\n\tfloat v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n\tfloat v1 = (3.0 + t) / vw1;\n\tfloat v2 = t / vw2 + 2.0;\n\tfloat sum = 0.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tu2 = u2 * shadowMapSizeInv + base_uv.x;\n\tv2 = v2 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n\tsum += uw2 * vw0 * texture(shadowMap, vec3(u2, v0, z));\n\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n\tsum += uw2 * vw1 * texture(shadowMap, vec3(u2, v1, z));\n\tsum += uw0 * vw2 * texture(shadowMap, vec3(u0, v2, z));\n\tsum += uw1 * vw2 * texture(shadowMap, vec3(u1, v2, z));\n\tsum += uw2 * vw2 * texture(shadowMap, vec3(u2, v2, z));\n\tsum *= 1.0f / 144.0;\n\tsum = gammaCorrectInput(sum);\n\tsum = saturate(sum);\n\treturn sum;\n}\nfloat getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF5x5(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF5x5(sampler2DShadow shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF5x5(shadowMap, shadowParams.xyz);\n}\n",
        shadowStandardGL2VSPS: "float getShadowPCF5x5VS(sampler2DShadow shadowMap, vec3 shadowParams) {\n\tdShadowCoord = vMainShadowUv.xyz;\n\tdShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n\treturn _getShadowPCF5x5(shadowMap, shadowParams);\n}\n",
        shadowStandardVSPS: "#ifdef GL2\n#define SHADOW_SAMPLERVS sampler2DShadow\n#else\n#define SHADOW_SAMPLERVS sampler2D\n#endif\nfloat getShadowPCF3x3VS(SHADOW_SAMPLERVS shadowMap, vec3 shadowParams) {\n\tdShadowCoord = vMainShadowUv.xyz;\n\tdShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n\t#ifdef SHADOWBIAS\n\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n\treturn _getShadowPCF3x3(shadowMap, shadowParams);\n}\n",
        shadowVSM8PS: "float calculateVSM8(vec3 moments, float Z, float vsmBias) {\n\tfloat VSMBias = vsmBias;\n\tfloat depthScale = VSMBias * Z;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);\n}\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nfloat VSM8(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec4 c = texture2D(tex, texCoords);\n\tvec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);\n\treturn calculateVSM8(moments, Z, vsmBias);\n}\nfloat getShadowVSM8(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, 0.0);\n}\nfloat getShadowSpotVSM8(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);\n}\n",
        shadowVSMVSPS: "float getShadowVSM$VS(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\tdShadowCoord = vMainShadowUv.xyz;\n\tdShadowCoord.z += shadowParams.z;\n\tdShadowCoord.xyz /= vMainShadowUv.w;\n\tdShadowCoord.z = min(dShadowCoord.z, 1.0);\n\treturn $VSM(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\n",
        shadowVSM_commonPS: "float linstep(float a, float b, float v) {\n\treturn saturate((v - a) / (b - a));\n}\nfloat reduceLightBleeding(float pMax, float amount) {\n   return linstep(amount, 1.0, pMax);\n}\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\n\tfloat variance = moments.y - (moments.x * moments.x);\n\tvariance = max(variance, minVariance);\n\tfloat d = mean - moments.x;\n\tfloat pMax = variance / (variance + (d * d));\n\tpMax = reduceLightBleeding(pMax, lightBleedingReduction);\n\treturn (mean <= moments.x ? 1.0 : pMax);\n}\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\n\tZ = 2.0 * Z - 1.0;\n\tfloat warpedDepth = exp(exponent * Z);\n\tmoments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\n\tfloat VSMBias = vsmBias;\n\tfloat depthScale = VSMBias * exponent * warpedDepth;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\n}\n",
        skinBatchConstVS: "attribute float vertex_boneIndices;\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\nmat4 getBoneMatrix(const in float i) {\n\tvec4 v1 = matrix_pose[int(3.0 * i)];\n\tvec4 v2 = matrix_pose[int(3.0 * i + 1.0)];\n\tvec4 v3 = matrix_pose[int(3.0 * i + 2.0)];\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n",
        skinBatchTexVS: "attribute float vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nmat4 getBoneMatrix(const in float i) {\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tvec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tvec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tvec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n",
        skinConstVS: "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tv1 = matrix_pose[int(3.0 * i)];\n\tv2 = matrix_pose[int(3.0 * i + 1.0)];\n\tv3 = matrix_pose[int(3.0 * i + 2.0)];\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\tfloat one = dot(weights, vec4(1.0));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n",
        skinTexVS: "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tv1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tv2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tv3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\tfloat one = dot(weights, vec4(1.0));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n",
        skyboxPS: "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvoid main(void) {\n\tgl_FragColor = textureCube(texture_cubeMap, fixSeams(vViewDir));\n}\n",
        skyboxVS: "attribute vec3 aPosition;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat4 matrix_projectionSkybox;\nvarying vec3 vViewDir;\nvoid main(void) {\n\tmat4 view = matrix_view;\n\tview[3][0] = view[3][1] = view[3][2] = 0.0;\n\tgl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);\n\tgl_Position.z = gl_Position.w - 0.00001;\n\tvViewDir = aPosition;\n\tvViewDir.x *= -1.0;\n}\n",
        skyboxHDRPS: "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvoid main(void) {\n\tvec3 color = processEnvironment($textureCubeSAMPLE(texture_cubeMap, fixSeamsStatic(vViewDir, $FIXCONST)).rgb);\n\tcolor = toneMap(color);\n\tcolor = gammaCorrectOutput(color);\n\tgl_FragColor = vec4(color, 1.0);\n}\n",
        skyboxPrefilteredCubePS: "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvec3 fixSeamsStretch(vec3 vec, float mipmapIndex, float cubemapSize) {\n\tfloat scale = 1.0 - exp2(mipmapIndex) / cubemapSize;\n\tfloat M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n\tif (abs(vec.x) != M) vec.x *= scale;\n\tif (abs(vec.y) != M) vec.y *= scale;\n\tif (abs(vec.z) != M) vec.z *= scale;\n\treturn vec;\n}\nvoid main(void) {\n\tvec3 color = textureCubeRGBM(texture_cubeMap, fixSeamsStretch(vViewDir, 0.0, 128.0));\n\tcolor = toneMap(color);\n\tcolor = gammaCorrectOutput(color);\n\tgl_FragColor = vec4(color, 1.0);\n}\n",
        specularPS: "#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_specularMap;\n#endif\nvoid getSpecularity() {\n\tdSpecularity = vec3(1.0);\n\t#ifdef MAPCOLOR\n\tdSpecularity *= material_specular;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdSpecularity *= texture2D(texture_specularMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n}\n",
        specularAaNonePS: "float antiAliasGlossiness(float power) {\n\treturn power;\n}\n",
        specularAaToksvigPS: "float antiAliasGlossiness(float power) {\n\tfloat rlen = 1.0 / saturate(length(dNormalMap));\n\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n\treturn power * mix(1.0, toksvig, material_bumpiness);\n}\n",
        specularAaToksvigFastPS: "float antiAliasGlossiness(float power) {\n\tfloat rlen = 1.0 / saturate(length(dNormalMap));\n\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n\treturn power * toksvig;\n}\n",
        spotPS: "float getSpotEffect(vec3 lightSpotDirW, float lightInnerConeAngle, float lightOuterConeAngle) {\n\tfloat cosAngle = dot(dLightDirNormW, lightSpotDirW);\n\treturn smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\n}\n",
        startPS: "void main(void) {\n\tdDiffuseLight = vec3(0);\n\tdSpecularLight = vec3(0);\n\tdReflection = vec4(0);\n\tdSpecularity = vec3(0);\n\t#ifdef CLEARCOAT\n\tccSpecularLight = vec3(0);\n\tccReflection = vec4(0);\n\t#endif\n",
        startVS: "void main(void) {\n\tgl_Position = getPosition();\n",
        startNineSlicedPS: "\tnineSlicedUv = vUv0;\n",
        startNineSlicedTiledPS: "\tvec2 tileMask = step(vMask, vec2(0.99999));\n\tvec2 clampedUv = mix(innerOffset.xy*0.5, vec2(1.0) - innerOffset.zw*0.5, fract(vTiledUv));\n\tclampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\n\tnineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\n",
        storeEVSMPS: "float exponent = VSM_EXPONENT;\ndepth = 2.0 * depth - 1.0;\ndepth =  exp(exponent * depth);\ngl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\n",
        tangentBinormalVS: "vec3 getTangent() {\n\treturn normalize(dNormalMatrix * vertex_tangent.xyz);\n}\nvec3 getBinormal() {\n\treturn cross(vNormalW, vTangentW) * vertex_tangent.w;\n}\nvec3 getObjectSpaceUp() {\n\treturn normalize(dNormalMatrix * vec3(0, 1, 0));\n}\n",
        TBNPS: "void getTBN() {\n\tdTBN = mat3(normalize(dTangentW), normalize(dBinormalW), normalize(dVertexNormalW));\n}\n",
        TBNderivativePS: "\nvoid getTBN() {\n\tvec2 uv = $UV;\n\tvec3 dp1 = dFdx( vPositionW );\n\tvec3 dp2 = dFdy( vPositionW );\n\tvec2 duv1 = dFdx( uv );\n\tvec2 duv2 = dFdy( uv );\n\tvec3 dp2perp = cross( dp2, dVertexNormalW );\n\tvec3 dp1perp = cross( dVertexNormalW, dp1 );\n\tvec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n\tvec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\tfloat invmax = 1.0 / sqrt( max( dot(T,T), dot(B,B) ) );\n\tdTBN = mat3( T * invmax, B * invmax, dVertexNormalW );\n}\n",
        TBNfastPS: "void getTBN() {\n\tdTBN = mat3(dTangentW, dBinormalW, dVertexNormalW);\n}\n",
        TBNObjectSpacePS: "void getTBN() {\n\tvec3 B = cross(dVertexNormalW, vObjectSpaceUpW);\n\tvec3 T = cross(dVertexNormalW, B);\n\tif (dot(B,B)==0.0)\n\t{\n\t\tfloat major=max(max(dVertexNormalW.x, dVertexNormalW.y),dVertexNormalW.z);\n\t\tif (dVertexNormalW.x==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(0,1,0));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t\telse if (dVertexNormalW.y==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(0,0,1));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t\telse if (dVertexNormalW.z==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(1,0,0));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t}\n\tdTBN = mat3(normalize(T), normalize(B), normalize(dVertexNormalW));\n}\n",
        tonemappingAcesPS: "uniform float exposure;\nvec3 toneMap(vec3 color) {\n\tfloat tA = 2.51;\n\tfloat tB = 0.03;\n\tfloat tC = 2.43;\n\tfloat tD = 0.59;\n\tfloat tE = 0.14;\n\tvec3 x = color * exposure;\n\treturn (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\n}\n",
        tonemappingAces2PS: "uniform float exposure;\nconst mat3 ACESInputMat = mat3(\n\t0.59719, 0.35458, 0.04823,\n\t0.07600, 0.90834, 0.01566,\n\t0.02840, 0.13383, 0.83777\n);\nconst mat3 ACESOutputMat = mat3(\n\t 1.60475, -0.53108, -0.07367,\n\t-0.10208,  1.10813, -0.00605,\n\t-0.00327, -0.07276,  1.07602\n);\nvec3 RRTAndODTFit(vec3 v) {\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn a / b;\n}\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tcolor = color * ACESInputMat;\n\tcolor = RRTAndODTFit(color);\n\tcolor = color * ACESOutputMat;\n\tcolor = clamp(color, 0.0, 1.0);\n\treturn color;\n}\n",
        tonemappingFilmicPS: "const float A =  0.15;\nconst float B =  0.50;\nconst float C =  0.10;\nconst float D =  0.20;\nconst float E =  0.02;\nconst float F =  0.30;\nconst float W =  11.2;\nuniform float exposure;\nvec3 uncharted2Tonemap(vec3 x) {\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\nvec3 toneMap(vec3 color) {\n\tcolor = uncharted2Tonemap(color * exposure);\n\tvec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\n\tcolor = color * whiteScale;\n\treturn color;\n}\n",
        tonemappingHejlPS: "uniform float exposure;\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tconst float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\n\tconst float Scl = 1.25;\n\tvec3 h = max( vec3(0.0), color - vec3(0.004) );\n\treturn (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\n}\n",
        tonemappingLinearPS: "uniform float exposure;\nvec3 toneMap(vec3 color) {\n\treturn color * exposure;\n}\n",
        tonemappingNonePS: "vec3 toneMap(vec3 color) {\n\treturn color;\n}\n",
        transformVS: "#ifdef PIXELSNAP\nuniform vec4 uScreenSize;\n#endif\n#ifdef MORPHING\nuniform vec4 morph_weights_a;\nuniform vec4 morph_weights_b;\n#endif\n#ifdef MORPHING_TEXTURE_BASED\nuniform vec4 morph_tex_params;\nvec2 getTextureMorphCoords() {\n\tfloat vertexId = morph_vertex_id;\n\tvec2 textureSize = morph_tex_params.xy;\n\tvec2 invTextureSize = morph_tex_params.zw;\n\tfloat morphGridV = floor(vertexId * invTextureSize.x);\n\tfloat morphGridU = vertexId - (morphGridV * textureSize.x);\n\treturn (vec2(morphGridU, morphGridV) * invTextureSize) + (0.5 * invTextureSize);\n}\n#endif\n#ifdef MORPHING_TEXTURE_BASED_POSITION\nuniform highp sampler2D morphPositionTex;\n#endif\nmat4 getModelMatrix() {\n\t#ifdef DYNAMICBATCH\n\treturn getBoneMatrix(vertex_boneIndices);\n\t#elif defined(SKIN)\n\treturn matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n\t#elif defined(INSTANCING)\n\treturn mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n\t#else\n\treturn matrix_model;\n\t#endif\n}\nvec4 getPosition() {\n\tdModelMatrix = getModelMatrix();\n\tvec3 localPos = vertex_position;\n\t#ifdef NINESLICED\n\tlocalPos.xz *= outerScale;\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tlocalPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\tvTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0;\n\tlocalPos.xz *= -0.5;\n\tlocalPos = localPos.xzy;\n\t#endif\n\t#ifdef MORPHING\n\t#ifdef MORPHING_POS03\n\tlocalPos.xyz += morph_weights_a[0] * morph_pos0;\n\tlocalPos.xyz += morph_weights_a[1] * morph_pos1;\n\tlocalPos.xyz += morph_weights_a[2] * morph_pos2;\n\tlocalPos.xyz += morph_weights_a[3] * morph_pos3;\n\t#endif\n\t#ifdef MORPHING_POS47\n\tlocalPos.xyz += morph_weights_b[0] * morph_pos4;\n\tlocalPos.xyz += morph_weights_b[1] * morph_pos5;\n\tlocalPos.xyz += morph_weights_b[2] * morph_pos6;\n\tlocalPos.xyz += morph_weights_b[3] * morph_pos7;\n\t#endif\n\t#endif\n\t#ifdef MORPHING_TEXTURE_BASED_POSITION\n\tvec2 morphUV = getTextureMorphCoords();\n\tvec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;\n\tlocalPos += morphPos;\n\t#endif\n\tvec4 posW = dModelMatrix * vec4(localPos, 1.0);\n\t#ifdef SCREENSPACE\n\tposW.zw = vec2(0.0, 1.0);\n\t#endif\n\tdPositionW = posW.xyz;\n\tvec4 screenPos;\n\t#ifdef UV1LAYOUT\n\tscreenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n\t#else\n\t#ifdef SCREENSPACE\n\tscreenPos = posW;\n\t#else\n\tscreenPos = matrix_viewProjection * posW;\n\t#endif\n\t#ifdef PIXELSNAP\n\tscreenPos.xy = (screenPos.xy * 0.5) + 0.5;\n\tscreenPos.xy *= uScreenSize.xy;\n\tscreenPos.xy = floor(screenPos.xy);\n\tscreenPos.xy *= uScreenSize.zw;\n\tscreenPos.xy = (screenPos.xy * 2.0) - 1.0;\n\t#endif\n\t#endif\n\treturn screenPos;\n}\nvec3 getWorldPosition() {\n\treturn dPositionW;\n}\n",
        transformDeclVS: "attribute vec3 vertex_position;\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\nvec3 dPositionW;\nmat4 dModelMatrix;\n",
        uv0VS: "#ifdef NINESLICED\nvec2 getUv0() {\n\tvec2 uv = vertex_position.xz;\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tuv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\tuv = uv * -0.5 + 0.5;\n\tuv = uv * atlasRect.zw + atlasRect.xy;\n\tvMask = vertex_texCoord0.xy;\n\treturn uv;\n}\n#else\nvec2 getUv0() {\n\treturn vertex_texCoord0;\n}\n#endif\n",
        uv1VS: "vec2 getUv1() {\n\treturn vertex_texCoord1;\n}\n",
        viewDirPS: "void getViewDir() {\n\tdViewDirW = normalize(view_position - vPositionW);\n}\n",
        viewNormalVS: "#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nvec3 getViewNormal() {\n\treturn mat3(matrix_view) * vNormalW;\n}\n"
    }
      , In = {
        vertex_position: "POSITION",
        vertex_normal: "NORMAL",
        vertex_tangent: "TANGENT",
        vertex_texCoord0: "TEXCOORD0",
        vertex_texCoord1: "TEXCOORD1",
        vertex_texCoord2: "TEXCOORD2",
        vertex_texCoord3: "TEXCOORD3",
        vertex_texCoord4: "TEXCOORD4",
        vertex_texCoord5: "TEXCOORD5",
        vertex_texCoord6: "TEXCOORD6",
        vertex_texCoord7: "TEXCOORD7",
        vertex_color: "COLOR",
        vertex_boneIndices: "BLENDINDICES",
        vertex_boneWeights: "BLENDWEIGHT"
    };
    F.collectAttribs = ug;
    F.createShader = function(a, b, c, d) {
        b = F[b];
        c = Fd(a) + "\n" + F[c];
        var e = ug(b);
        a.webgl2 && (b = Gd(a) + F.gles3VS + b,
        c = Gd(a) + F.gles3PS + c);
        return new re(a,{
            attributes: e,
            vshader: b,
            fshader: c,
            useTransformFeedback: d
        })
    }
    ;
    F.createShaderFromCode = Wa;
    var Kj = function(a, b, c) {
        return "\n#ifdef MAPFLOAT\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
    }
      , Lj = function(a, b, c) {
        return "\n#ifdef MAPCOLOR\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
    }
      , ce = function(a, b, c) {
        return "\n#ifdef MAPTEXTURE\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
    }
      , Mj = function(a, b, c) {
        return "#undef MAPTEXTURECOLOR\n#ifdef MAPTEXTURE\n#ifdef MAPCOLOR\n#define MAPTEXTURECOLOR\n#endif\n#endif\n#ifdef MAPTEXTURECOLOR\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
    }
      , kh = function(a, b, c) {
        return "#undef MAPTEXTUREFLOAT\n#ifdef MAPTEXTURE\n#ifdef MAPFLOAT\n#define MAPTEXTUREFLOAT\n#endif\n#endif\n#ifdef MAPTEXTUREFLOAT\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
    }
      , de = function(a, b, c) {
        return "\n#ifdef MAPVERTEX\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
    }
      , Nj = function(a, b, c) {
        return "#undef MAPVERTEXCOLOR\n#ifdef MAPVERTEX\n#ifdef MAPCOLOR\n#define MAPVERTEXCOLOR\n#endif\n#endif\n#ifdef MAPVERTEXCOLOR\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
    }
      , lh = function(a, b, c) {
        return "#undef MAPVERTEXFLOAT\n#ifdef MAPVERTEX\n#ifdef MAPFLOAT\n#define MAPVERTEXFLOAT\n#endif\n#endif\n#ifdef MAPVERTEXFLOAT\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
    }
      , zc = []
      , Oj = {
        _oldChunkToNew: {
            aoTexPS: {
                n: "aoPS",
                f: ce
            },
            aoVertPS: {
                n: "aoPS",
                f: de
            },
            diffuseConstPS: {
                n: "diffusePS",
                f: Lj
            },
            diffuseTexPS: {
                n: "diffusePS",
                f: ce
            },
            diffuseTexConstPS: {
                n: "diffusePS",
                f: Mj
            },
            diffuseVertPS: {
                n: "diffusePS",
                f: de
            },
            diffuseVertConstPS: {
                n: "diffusePS",
                f: Nj
            },
            emissiveConstPS: {
                n: "emissivePS",
                f: Lj
            },
            emissiveTexPS: {
                n: "emissivePS",
                f: ce
            },
            emissiveTexConstPS: {
                n: "emissivePS",
                f: Mj
            },
            emissiveTexConstFloatPS: {
                n: "emissivePS",
                f: kh
            },
            emissiveVertPS: {
                n: "emissivePS",
                f: de
            },
            emissiveVertConstPS: {
                n: "emissivePS",
                f: Nj
            },
            emissiveVertConstFloatPS: {
                n: "emissivePS",
                f: lh
            },
            glossConstPS: {
                n: "glossPS",
                f: Kj
            },
            glossTexPS: {
                n: "glossPS",
                f: ce
            },
            glossTexConstPS: {
                n: "glossPS",
                f: kh
            },
            glossVertPS: {
                n: "glossPS",
                f: de
            },
            glossVertConstPS: {
                n: "glossPS",
                f: lh
            },
            metalnessConstPS: {
                n: "metalnessPS",
                f: Kj
            },
            metalnessTexPS: {
                n: "metalnessPS",
                f: ce
            },
            metalnessTexConstPS: {
                n: "metalnessPS",
                f: kh
            },
            metalnessVertPS: {
                n: "metalnessPS",
                f: de
            },
            metalnessVertConstPS: {
                n: "metalnessPS",
                f: lh
            },
            opacityConstPS: {
                n: "opacityPS",
                f: Kj
            },
            opacityTexPS: {
                n: "opacityPS",
                f: ce
            },
            opacityTexConstPS: {
                n: "opacityPS",
                f: kh
            },
            opacityVertPS: {
                n: "opacityPS",
                f: de
            },
            opacityVertConstPS: {
                n: "opacityPS",
                f: lh
            },
            specularConstPS: {
                n: "specularPS",
                f: Lj
            },
            specularTexPS: {
                n: "specularPS",
                f: ce
            },
            specularTexConstPS: {
                n: "specularPS",
                f: Mj
            },
            specularVertPS: {
                n: "specularPS",
                f: de
            },
            specularVertConstPS: {
                n: "specularPS",
                f: Nj
            },
            transformBatchSkinnedVS: {
                n: "transformVS",
                f: function(a, b, c) {
                    return "\n#ifdef DYNAMICBATCH\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
                }
            },
            transformInstancedVS: {
                n: "transformVS",
                f: function(a, b, c) {
                    return "\n#ifdef INSTANCING\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
                }
            },
            transformPixelSnapVS: {
                n: "transformVS",
                f: function(a, b, c) {
                    return "\n#ifdef PIXELSNAP\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
                }
            },
            transformScreenSpaceVS: {
                n: "transformVS",
                f: function(a, b, c) {
                    return "\n#ifdef SCREENSPACE\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
                }
            },
            transformScreenSpaceBatchSkinned: {
                n: "transformVS",
                f: function(a, b, c) {
                    return "#undef SCREENSPACEBATCH\n#ifdef SCREENSPACE\n#ifdef BATCH\n#define SCREENSPACEBATCH\n#endif\n#endif\n#ifdef SCREENSPACEBATCH\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
                }
            },
            transformSkinned: {
                n: "transformVS",
                f: function(a, b, c) {
                    return "\n#ifdef SKIN\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
                }
            },
            transformUv1: {
                n: "transformVS",
                f: function(a, b, c) {
                    return "\n#ifdef UV1LAYOUT\n" + a + "\n#else\n" + F[b] + "\n#endif\n"
                }
            }
        },
        optionsContext: {},
        optionsContextMin: {},
        generateKey: function(a) {
            var b = function(f) {
                var g = [], k;
                for (k in f)
                    f.hasOwnProperty(k) && "chunks" !== k && "lights" !== k && g.push(k);
                return g.sort()
            };
            if (a === this.optionsContextMin) {
                this.propsMin || (this.propsMin = b(a));
                var c = this.propsMin
            } else
                a === this.optionsContext ? (this.props || (this.props = b(a)),
                c = this.props) : c = b(a);
            b = "standard";
            var d;
            for (d = 0; d < c.length; d++)
                a[c[d]] && (b += c[d] + a[c[d]]);
            if (a.chunks) {
                c = [];
                for (var e in a.chunks)
                    a.chunks.hasOwnProperty(e) && c.push(e + a.chunks[e]);
                c.sort();
                b += c
            }
            if (a.lights)
                for (d = 0; d < a.lights.length; d++)
                    b += a.lights[d].key;
            return qe(b)
        },
        _correctChannel: function(a, b) {
            if (0 < zc[a]) {
                if (zc[a] < b.length)
                    return b.substring(0, zc[a]);
                if (zc[a] > b.length) {
                    var c = b.charAt(b.length - 1);
                    a = zc[a] - b.length;
                    for (var d = 0; d < a; d++)
                        b += c;
                    return b
                }
                return b
            }
        },
        _setMapTransform: function(a, b, c, d) {
            a[0] += "uniform vec4 texture_" + b + "MapTransform;\n";
            var e = c + 100 * d;
            a[3][e] || (a[1] += "varying vec2 vUV" + d + "_" + c + ";\n",
            a[2] += "   vUV" + d + "_" + c + " = uv" + d + " * texture_" + b + "MapTransform.xy + texture_" + b + "MapTransform.zw;\n",
            a[3][e] = !0);
            return a
        },
        _getUvSourceExpression: function(a, b, c) {
            var d = c[a];
            b = c[b];
            var e = 0 === c.pass || 1 === c.pass;
            e && 1 === c.nineSlicedMode ? d = "nineSlicedUv" : e && 2 === c.nineSlicedMode ? d = "nineSlicedUv, -1000.0" : (d = 0 === d ? "vUv" + b : "vUV" + b + "_" + d,
            c.heightMap && "heightMapTransform" !== a && (d += " + dUvOffset"));
            return d
        },
        _addMapDef: function(a, b) {
            var c = "\n#undef " + a + "\n";
            b && (c += " #define " + a + "\n");
            return c
        },
        _addMapDefs: function(a, b, c, d) {
            a = "" + this._addMapDef("MAPFLOAT", a);
            a += this._addMapDef("MAPCOLOR", b);
            a += this._addMapDef("MAPVERTEX", c);
            return a += this._addMapDef("MAPTEXTURE", d)
        },
        _addMap: function(a, b, c, d, e) {
            var f = a + "Map"
              , g = f + "Uv"
              , k = f + "Transform"
              , h = f + "Channel"
              , l = a + "VertexColorChannel"
              , n = c[a + "Tint"]
              , p = c[a + "VertexColor"];
            f = c[f];
            a = c[a + "Mode"];
            b = d[b];
            f && (g = this._getUvSourceExpression(k, g, c),
            b = b.replace(/\$UV/g, g).replace(/\$CH/g, c[h]),
            void 0 !== e && (b = b.replace(/\$texture2DSAMPLE/g, 0 === e ? "texture2DSRGB" : 1 === e ? "texture2DRGBM" : "texture2D")));
            p && (b = b.replace(/\$VC/g, c[l]));
            a && (b = b.replace(/\$DETAILMODE/g, a));
            b = this._addMapDefs(1 === n, 3 === n, p, f) + b;
            return b.replace(/\$/g, "")
        },
        _nonPointShadowMapProjection: function(a, b, c) {
            return !b._normalOffsetBias || b._isVsm ? 2 === b._type ? b._isPcf && (a.webgl2 || a.extStandardDerivatives) ? "\t   getShadowCoordPerspZbuffer" + c : "\t   getShadowCoordPersp" + c : "\t   getShadowCoordOrtho" + c : 2 === b._type ? b._isPcf && (a.webgl2 || a.extStandardDerivatives) ? "\t   getShadowCoordPerspZbufferNormalOffset" + c : "\t   getShadowCoordPerspNormalOffset" + c : "\t   getShadowCoordOrthoNormalOffset" + c
        },
        _addVaryingIfNeeded: function(a, b, c) {
            return 0 <= a.indexOf(c) ? "varying " + b + " " + c + ";\n" : ""
        },
        _vsAddTransformCode: function(a, b, c, d) {
            return a += c.transformVS
        },
        _vsAddBaseCode: function(a, b, c, d) {
            a += c.baseVS;
            if (1 === d.nineSlicedMode || 2 === d.nineSlicedMode)
                a += c.baseNineSlicedVS;
            return a
        },
        _fsAddBaseCode: function(a, b, c, d) {
            a += c.basePS;
            1 === d.nineSlicedMode ? a += c.baseNineSlicedPS : 2 === d.nineSlicedMode && (a += c.baseNineSlicedTiledPS);
            return a
        },
        _fsAddStartCode: function(a, b, c, d) {
            a += c.startPS;
            1 === d.nineSlicedMode ? a += c.startNineSlicedPS : 2 === d.nineSlicedMode && (a += c.startNineSlicedTiledPS);
            return a
        },
        createShaderDefinition: function(a, b) {
            var c = 0 < b.lights.length;
            b.dirLightMap && (c = !0,
            b.useSpecular = !0);
            0 === b.shadingModel ? (b.fresnelModel = 0,
            b.specularAntialias = !1,
            b.prefilteredCubemap = !1,
            b.dpAtlas = !1,
            b.ambientSH = !1) : b.fresnelModel = 0 === b.fresnelModel ? 2 : b.fresnelModel;
            var d = (b.cubeMap || b.prefilteredCubemap && b.useSpecular) && !b.sphereMap && !b.dpAtlas
              , e = b.sphereMap || d || b.dpAtlas
              , f = b.useTexCubeLod;
            b.cubeMap && (b.sphereMap = null);
            b.dpAtlas && (b.prefilteredCubemap = null);
            b.useSpecular || (b.specularMap = b.glossMap = null);
            var g = c || e || b.ambientSH || b.prefilteredCubemap || b.heightMap || b.enableGGXSpecular
              , k = 3 <= b.pass && 17 >= b.pass;
            this.options = b;
            var h = ""
              , l = ""
              , n = ""
              , p = F
              , q = {
                vertex_position: "POSITION"
            };
            if (b.chunks) {
                var r = {};
                for (A in p)
                    if (p.hasOwnProperty(A))
                        if (b.chunks[A]) {
                            var t = b.chunks[A];
                            0 <= t.indexOf("vertex_normal") && (q.vertex_normal = "NORMAL");
                            0 <= t.indexOf("vertex_tangent") && (q.vertex_tangent = "TANGENT");
                            0 <= t.indexOf("vertex_texCoord0") && (q.vertex_texCoord0 = "TEXCOORD0");
                            0 <= t.indexOf("vertex_texCoord1") && (q.vertex_texCoord1 = "TEXCOORD1");
                            0 <= t.indexOf("vertex_color") && (q.vertex_color = "COLOR");
                            0 <= t.indexOf("vertex_boneWeights") && (q.vertex_boneWeights = "BLENDWEIGHT");
                            0 <= t.indexOf("vertex_boneIndices") && (q.vertex_boneIndices = "BLENDINDICES");
                            r[A] = t
                        } else
                            r[A] = p[A];
                for (A in b.chunks)
                    (p = this._oldChunkToNew[A]) && (r[p.n] = p.f(b.chunks[A], p.n, A));
                p = r
            }
            h = this._vsAddBaseCode(h, a, p, b);
            r = -1;
            if (!b.noShadow && !b.twoSidedLighting) {
                for (t = 0; t < b.lights.length; t++) {
                    var u = b.lights[t]._type;
                    if (b.lights[t].castShadows && 0 === u) {
                        h += "uniform mat4 light" + t + "_shadowMatrixVS;\n";
                        h += "uniform vec3 light" + t + "_shadowParamsVS;\n";
                        h += "uniform vec3 light" + t + (0 === u ? "_directionVS" : "_positionVS") + ";\n";
                        r = t;
                        break
                    }
                }
                0 <= r && (h += p.shadowCoordVS)
            }
            l += "   vPositionW\t= getWorldPosition();\n";
            2 === b.pass && (h += "varying float vDepth;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n\n#endif\n",
            l += "\tvDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n");
            b.useInstancing && (q.instance_line1 = "TEXCOORD2",
            q.instance_line2 = "TEXCOORD3",
            q.instance_line3 = "TEXCOORD4",
            q.instance_line4 = "TEXCOORD5",
            h += p.instancingVS);
            g && (q.vertex_normal = "NORMAL",
            l += "   vNormalW\t= dNormalW = getNormal();\n",
            b.sphereMap && 16 >= a.fragmentUniformsCount && (h += p.viewNormalVS,
            l += "   vNormalV\t= getViewNormal();\n"),
            (b.heightMap || b.normalMap || b.enableGGXSpecular) && b.hasTangents ? (q.vertex_tangent = "TANGENT",
            h += p.tangentBinormalVS,
            l += "   vTangentW   = getTangent();\n   vBinormalW  = getBinormal();\n") : b.enableGGXSpecular && (h += p.tangentBinormalVS,
            l += "   vObjectSpaceUpW  = getObjectSpaceUp();\n"),
            0 <= r && (u = b.lights[r]._type,
            l = (0 === u ? l + ("   dLightDirNormW = light" + r + "_directionVS;\n") : l + ("   getLightDirPoint(light" + r + "_positionVS);\n")) + this._nonPointShadowMapProjection(a, b.lights[r], "(light" + r + "_shadowMatrixVS, light" + r + "_shadowParamsVS);\n")));
            u = [];
            var x = [];
            for (A in zc) {
                t = A + "Map";
                if (b[A + "VertexColor"]) {
                    var v = A + "VertexColorChannel";
                    b[v] = this._correctChannel(A, b[v])
                }
                if (b[t]) {
                    v = t + "Channel";
                    var w = t + "Transform";
                    var y = t + "Uv";
                    b[y] = Math.min(b[y], 1);
                    b[v] = this._correctChannel(A, b[v]);
                    y = b[y];
                    u[y] = !0;
                    x[y] = x[y] || b[t] && !b[w]
                }
            }
            b.forceUv1 && (u[1] = !0);
            for (t = 0; 2 > t; t++)
                u[t] && (q["vertex_texCoord" + t] = "TEXCOORD" + t,
                h += p["uv" + t + "VS"],
                l += "   vec2 uv" + t + " = getUv" + t + "();\n"),
                x[t] && (l += "   vUv" + t + " = uv" + t + ";\n");
            u = [h, n, l, []];
            for (A in zc)
                t = A + "Map",
                b[t] && (w = t + "Transform",
                b[w] && (y = t + "Uv",
                this._setMapTransform(u, A, b[w], b[y])));
            h = u[0];
            n = u[1];
            l = u[2];
            b.vertexColors && (q.vertex_color = "COLOR",
            l += "   vVertexColor = vertex_color;\n");
            if (b.useMorphPosition || b.useMorphNormal)
                b.useMorphTextureBased ? (h += "#define MORPHING_TEXTURE_BASED\n",
                b.useMorphPosition && (h += "#define MORPHING_TEXTURE_BASED_POSITION\n"),
                b.useMorphNormal && (h += "#define MORPHING_TEXTURE_BASED_NORMAL\n"),
                q.morph_vertex_id = "ATTR15",
                h += "attribute float morph_vertex_id;\n") : (h += "#define MORPHING\n",
                b.useMorphPosition ? (q.morph_pos0 = "ATTR8",
                q.morph_pos1 = "ATTR9",
                q.morph_pos2 = "ATTR10",
                q.morph_pos3 = "ATTR11",
                h += "#define MORPHING_POS03\nattribute vec3 morph_pos0;\nattribute vec3 morph_pos1;\nattribute vec3 morph_pos2;\nattribute vec3 morph_pos3;\n") : b.useMorphNormal && (q.morph_nrm0 = "ATTR8",
                q.morph_nrm1 = "ATTR9",
                q.morph_nrm2 = "ATTR10",
                q.morph_nrm3 = "ATTR11",
                h += "#define MORPHING_NRM03\nattribute vec3 morph_nrm0;\nattribute vec3 morph_nrm1;\nattribute vec3 morph_nrm2;\nattribute vec3 morph_nrm3;\n"),
                b.useMorphNormal ? (q.morph_nrm4 = "ATTR12",
                q.morph_nrm5 = "ATTR13",
                q.morph_nrm6 = "ATTR14",
                q.morph_nrm7 = "ATTR15",
                h += "#define MORPHING_NRM47\nattribute vec3 morph_nrm4;\nattribute vec3 morph_nrm5;\nattribute vec3 morph_nrm6;\nattribute vec3 morph_nrm7;\n") : (q.morph_pos4 = "ATTR12",
                q.morph_pos5 = "ATTR13",
                q.morph_pos6 = "ATTR14",
                q.morph_pos7 = "ATTR15",
                h += "#define MORPHING_POS47\nattribute vec3 morph_pos4;\nattribute vec3 morph_pos5;\nattribute vec3 morph_pos6;\nattribute vec3 morph_pos7;\n"));
            b.skin ? (q.vertex_boneWeights = "BLENDWEIGHT",
            q.vertex_boneIndices = "BLENDINDICES",
            h += ei(a, p),
            h += "#define SKIN\n") : b.useInstancing && (h += "#define INSTANCING\n");
            b.screenSpace && (h += "#define SCREENSPACE\n");
            b.pixelSnap && (h += "#define PIXELSNAP\n");
            h = this._vsAddTransformCode(h, a, p, b);
            g && (h += p.normalVS);
            h = h + "\n" + p.startVS;
            var A = h = h + l + "}";
            t = n;
            n = "" + this._addVaryingIfNeeded(h, "vec4", "vMainShadowUv");
            n += this._addVaryingIfNeeded(h, "vec4", "vVertexColor");
            n += this._addVaryingIfNeeded(h, "vec3", "vPositionW");
            n += this._addVaryingIfNeeded(h, "vec3", "vNormalV");
            n += this._addVaryingIfNeeded(h, "vec3", "vNormalW");
            n += this._addVaryingIfNeeded(h, "vec3", "vTangentW");
            n += this._addVaryingIfNeeded(h, "vec3", "vBinormalW");
            n += this._addVaryingIfNeeded(h, "vec3", "vObjectSpaceUpW");
            n += this._addVaryingIfNeeded(h, "vec2", "vUv0");
            n += this._addVaryingIfNeeded(h, "vec2", "vUv1");
            n += t;
            A = n + A;
            h = "";
            a.webgl2 ? (h = Gd(a),
            p.extensionVS && (h += p.extensionVS + "\n"),
            A = h + p.gles3VS + A) : (p.extensionVS && (h = p.extensionVS + "\n"),
            A = h + A);
            b.forceFragmentPrecision && "highp" != b.forceFragmentPrecision && "mediump" !== b.forceFragmentPrecision && "lowp" !== b.forceFragmentPrecision && (b.forceFragmentPrecision = null);
            b.forceFragmentPrecision && ("highp" === b.forceFragmentPrecision && "highp" !== a.maxPrecision && (b.forceFragmentPrecision = "mediump"),
            "mediump" === b.forceFragmentPrecision && "lowp" === a.maxPrecision && (b.forceFragmentPrecision = "lowp"));
            h = "";
            a.webgl2 && (h += Gd(a));
            a.extStandardDerivatives && !a.webgl2 && (h += "#extension GL_OES_standard_derivatives : enable\n\n");
            p.extensionPS && (h += p.extensionPS + "\n");
            a.webgl2 && (h += p.gles3PS);
            h += b.forceFragmentPrecision ? "precision " + b.forceFragmentPrecision + " float;\n\n" : Fd(a);
            if (18 === b.pass)
                return h = h + "uniform vec4 uColor;\n" + n,
                b.alphaTest && (h = h + "float dAlpha;\n" + this._addMap("opacity", "opacityPS", b, p),
                h += p.alphaTestPS),
                h += se(),
                b.alphaTest && (h += "   getOpacity();\n   alphaTest(dAlpha);\n"),
                {
                    attributes: q,
                    vshader: A,
                    fshader: h + "\tgl_FragColor = uColor;\n}\n"
                };
            if (2 === b.pass)
                return h = h + "varying float vDepth;\n" + n + p.packDepthPS,
                b.alphaTest && (h += "float dAlpha;\n",
                h += this._addMap("opacity", "opacityPS", b, p),
                h += p.alphaTestPS),
                h += se(),
                b.alphaTest && (h += "   getOpacity();\n",
                h += "   alphaTest(dAlpha);\n"),
                h += "\tgl_FragColor = packFloat(vDepth);\n",
                h += "}\n",
                {
                    attributes: q,
                    vshader: A,
                    fshader: h
                };
            if (k)
                return d = b.pass - 3,
                u = Math.floor(d / 5),
                d -= 5 * u,
                a.extStandardDerivatives && !a.webgl2 && (h += "uniform vec2 polygonOffset;\n"),
                3 === d ? h = a.textureFloatHighPrecision ? h + "#define VSM_EXPONENT 15.0\n\n" : h + "#define VSM_EXPONENT 5.54\n\n" : 2 === d && (h += "#define VSM_EXPONENT 5.54\n\n"),
                0 !== u && (h += "uniform vec3 view_position;\n",
                h += "uniform float light_radius;\n"),
                h += n,
                b.alphaTest && (h += "float dAlpha;\n",
                h += this._addMap("opacity", "opacityPS", b, p),
                h += p.alphaTestPS),
                0 !== d || a.webgl2 && 1 !== u ? 1 === d && (h += "vec2 encodeFloatRG( float v ) {\n",
                h += "\tvec2 enc = vec2(1.0, 255.0) * v;\n",
                h += "\tenc = fract(enc);\n",
                h += "\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n",
                h += "\treturn enc;\n",
                h += "}\n\n") : h += p.packDepthPS,
                h += se(),
                b.alphaTest && (h += "   getOpacity();\n",
                h += "   alphaTest(dAlpha);\n"),
                h = 1 === u || (1 === d || 2 === d || 3 === d) && 0 !== u ? h + "   float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n" : h + "   float depth = gl_FragCoord.z;\n",
                0 !== d || a.webgl2 && 1 !== u ? h = 0 === d || 4 === d ? h + "   gl_FragColor = vec4(1.0);\n" : 1 === d ? h + "   gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n" : h + p.storeEVSMPS : (a.extStandardDerivatives && !a.webgl2 && (h += "   float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\n",
                h += "   depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\n"),
                h += "   gl_FragColor = packFloat(depth);\n"),
                h += "}\n",
                {
                    attributes: q,
                    vshader: A,
                    fshader: h
                };
            if (b.customFragmentShader)
                return a = h + b.customFragmentShader,
                {
                    attributes: q,
                    vshader: A,
                    fshader: a,
                    tag: 1
                };
            h = this._fsAddBaseCode(h + n, a, p, b);
            b.detailModes && (h += p.detailModesPS);
            n = h;
            h = "";
            0 < b.clearCoat && (h += "#define CLEARCOAT\n");
            x = 0;
            w = [];
            v = y = !1;
            for (t = 0; t < b.lights.length; t++)
                if (l = b.lights[t],
                u = l._type,
                h += "uniform vec3 light" + t + "_color;\n",
                0 === u ? h += "uniform vec3 light" + t + "_direction;\n" : (h += "uniform vec3 light" + t + "_position;\n",
                h += "uniform float light" + t + "_radius;\n",
                2 === u && (h += "uniform vec3 light" + t + "_direction;\n",
                h += "uniform float light" + t + "_innerConeAngle;\n",
                h += "uniform float light" + t + "_outerConeAngle;\n")),
                l.castShadows && !b.noShadow && (h += "uniform mat4 light" + t + "_shadowMatrix;\n",
                h = 0 !== u ? h + ("uniform vec4 light" + t + "_shadowParams;\n") : h + ("uniform vec3 light" + t + "_shadowParams;\n"),
                h = 1 === u ? h + ("uniform samplerCube light" + t + "_shadowMap;\n") : l._isPcf && a.webgl2 ? h + ("uniform sampler2DShadow light" + t + "_shadowMap;\n") : h + ("uniform sampler2D light" + t + "_shadowMap;\n"),
                x++,
                w[l._shadowType] = !0,
                l._isVsm && (y = !0),
                l._isPcf && (a.webgl2 || a.extStandardDerivatives) && 2 === u && (v = !0)),
                l._cookie)
                    if (l._cookie._cubemap)
                        1 === u && (h += "uniform samplerCube light" + t + "_cookie;\n",
                        h += "uniform float light" + t + "_cookieIntensity;\n",
                        !l.castShadows || b.noShadow) && (h += "uniform mat4 light" + t + "_shadowMatrix;\n");
                    else if (2 === u) {
                        h += "uniform sampler2D light" + t + "_cookie;\n";
                        h += "uniform float light" + t + "_cookieIntensity;\n";
                        if (!l.castShadows || b.noShadow)
                            h += "uniform mat4 light" + t + "_shadowMatrix;\n";
                        l._cookieTransform && (h += "uniform vec4 light" + t + "_cookieMatrix;\n",
                        h += "uniform vec2 light" + t + "_cookieOffset;\n")
                    }
            h += "\n";
            k = !b.hasTangents && a.extStandardDerivatives ? p.TBNderivativePS : b.fastTbn ? p.TBNfastPS : p.TBNPS;
            g && (b.normalMap || b.clearCoatNormalMap) && (h += b.packedNormal ? p.normalXYPS : p.normalXYZPS,
            b.hasTangents || (t = this._getUvSourceExpression("normalMapTransform", "normalMapUv", b),
            k = k.replace(/\$UV/g, t)),
            h += k);
            g && (b.normalMap ? (b.normalDetail && (h += this._addMap("normalDetail", "normalDetailMapPS", b, p)),
            t = this._getUvSourceExpression("normalMapTransform", "normalMapUv", b),
            h = b.normalizeNormalMap ? h + p.normalMapPS.replace(/\$UV/g, t) : h + p.normalMapFastPS.replace(/\$UV/g, t)) : (h += p.normalVertexPS,
            b.enableGGXSpecular && (h += p.TBNObjectSpacePS)));
            h += sg(b.gamma, p);
            h += tg(b.toneMap, p);
            h += di(b.fog, p);
            b.useRgbm && (h += p.rgbmPS);
            if (d || b.prefilteredCubemap)
                h += b.fixSeams ? p.fixCubemapSeamsStretchPS : p.fixCubemapSeamsNonePS;
            g && (h += 0 < b.cubeMapProjection ? p.cubeMapProjectBoxPS : p.cubeMapProjectNonePS,
            h += b.skyboxIntensity ? p.envMultiplyPS : p.envConstPS);
            b.diffuseDetail && (h += this._addMap("diffuseDetail", "diffuseDetailMapPS", b, p));
            h += this._addMap("diffuse", "diffusePS", b, p);
            if (3 !== b.blendType || b.alphaTest || b.alphaToCoverage)
                h += this._addMap("opacity", "opacityPS", b, p);
            h += this._addMap("emissive", "emissivePS", b, p, b.emissiveFormat);
            b.useSpecular && (c || e) && (h = b.specularAntialias && b.normalMap ? b.normalizeNormalMap && g ? h + p.specularAaToksvigPS : h + p.specularAaToksvigFastPS : h + p.specularAaNonePS,
            t = b.useMetalness ? "metalness" : "specular",
            h += this._addMap(t, t + "PS", b, p),
            h += this._addMap("gloss", "glossPS", b, p),
            2 === b.fresnelModel && (h += p.fresnelSchlickPS));
            0 < b.clearCoat && (h += this._addMap("clearCoat", "clearCoatPS", b, p),
            h += this._addMap("clearCoatGloss", "clearCoatGlossPS", b, p),
            h += this._addMap("clearCoatNormal", "clearCoatNormalPS", b, p));
            b.heightMap && (b.normalMap || (t = this._getUvSourceExpression("heightMapTransform", "heightMapUv", b),
            b.hasTangents || (k = k.replace(/\$UV/g, t)),
            h += k),
            h += this._addMap("height", "parallaxPS", b, p));
            if (k = b.aoMap || b.aoVertexColor)
                h += this._addMap("ao", "aoPS", b, p),
                b.occludeSpecular && (h = 1 === b.occludeSpecular ? h + (b.occludeSpecularFloat ? p.aoSpecOccSimplePS : p.aoSpecOccConstSimplePS) : h + (b.occludeSpecularFloat ? p.aoSpecOccPS : p.aoSpecOccConstPS));
            t = b.rgbmReflection ? "decodeRGBM" : b.hdrReflection ? "" : "gammaCorrectInput";
            b.sphereMap ? (t = 16 < a.fragmentUniformsCount ? p.reflectionSpherePS : p.reflectionSphereLowPS,
            t = t.replace(/\$texture2DSAMPLE/g, b.rgbmReflection ? "texture2DRGBM" : b.hdrReflection ? "texture2D" : "texture2DSRGB"),
            h += t) : d ? h = b.prefilteredCubemap ? f ? h + p.reflectionPrefilteredCubeLodPS.replace(/\$DECODE/g, t) : h + p.reflectionPrefilteredCubePS.replace(/\$DECODE/g, t) : h + p.reflectionCubePS.replace(/\$textureCubeSAMPLE/g, b.rgbmReflection ? "textureCubeRGBM" : b.hdrReflection ? "textureCube" : "textureCubeSRGB") : b.dpAtlas && (h += p.reflectionDpAtlasPS.replace(/\$texture2DSAMPLE/g, b.rgbmReflection ? "texture2DRGBM" : b.hdrReflection ? "texture2D" : "texture2DSRGB"));
            if (d || b.sphereMap || b.dpAtlas)
                0 < b.clearCoat && (h += p.reflectionCCPS),
                b.refraction && (h += p.refractionPS);
            0 < x && (w[0] && (h += p.shadowStandardPS),
            w[4] && (h += p.shadowStandardGL2PS),
            y && (h += p.shadowVSM_commonPS,
            w[1] && (h += p.shadowVSM8PS),
            w[2] && (h += a.extTextureHalfFloatLinear ? p.shadowEVSMPS.replace(/\$/g, "16") : p.shadowEVSMnPS.replace(/\$/g, "16")),
            w[3] && (h += a.extTextureFloatLinear ? p.shadowEVSMPS.replace(/\$/g, "32") : p.shadowEVSMnPS.replace(/\$/g, "32"))),
            a.webgl2 || a.extStandardDerivatives || (h += p.biasConstPS),
            h += p.shadowCoordPS + p.shadowCommonPS,
            v && (h += p.shadowCoordPerspZbufferPS),
            0 <= r && (w[0] && (h += p.shadowStandardVSPS),
            w[4] && (h += p.shadowStandardGL2VSPS),
            y && (w[1] && (h += p.shadowVSMVSPS.replace(/\$VSM/g, "VSM8").replace(/\$/g, "8")),
            w[2] && (h += p.shadowVSMVSPS.replace(/\$VSM/g, "VSM16").replace(/\$/g, "16")),
            w[3] && (h += p.shadowVSMVSPS.replace(/\$VSM/g, "VSM32").replace(/\$/g, "32")))));
            b.enableGGXSpecular && (h += "uniform float material_anisotropy;\n");
            c && (h += p.lightDiffuseLambertPS);
            t = !1;
            b.useSpecular ? (c && (h += 0 === b.shadingModel ? p.lightSpecularPhongPS : b.enableGGXSpecular ? p.lightSpecularAnisoGGXPS : p.lightSpecularBlinnPS),
            b.sphereMap || d || b.dpAtlas || 0 < b.fresnelModel ? h = 0 < b.fresnelModel ? b.conserveEnergy ? h + p.combineDiffuseSpecularPS : h + p.combineDiffuseSpecularNoConservePS : h + p.combineDiffuseSpecularOldPS : b.diffuseMap ? h += p.combineDiffuseSpecularNoReflPS : (h += p.combineDiffuseSpecularNoReflSeparateAmbientPS,
            t = !0)) : h += p.combineDiffusePS;
            0 < b.clearCoat && (h += p.combineClearCoatPS);
            u = !0;
            if (b.lightMap || b.lightVertexColor)
                h += this._addMap("light", b.dirLightMap ? "lightmapDirPS" : "lightmapSinglePS", b, p, b.lightMapFormat),
                u = b.lightMapWithoutAmbient;
            u && (l = b.rgbmAmbient ? "decodeRGBM" : b.hdrAmbient ? "" : "gammaCorrectInput",
            h = b.ambientSH ? h + p.ambientSHPS : b.prefilteredCubemap ? f ? h + p.ambientPrefilteredCubeLodPS.replace(/\$DECODE/g, l) : h + p.ambientPrefilteredCubePS.replace(/\$DECODE/g, l) : h + p.ambientConstantPS);
            b.ambientTint && !t && (h += "uniform vec3 material_ambient;\n");
            b.alphaTest && (h += p.alphaTestPS);
            b.msdf && (h += p.msdfPS);
            g && (h += p.viewDirPS,
            b.useSpecular && (h += b.enableGGXSpecular ? p.reflDirAnisoPS : p.reflDirPS));
            v = y = w = x = f = !1;
            h = this._fsAddStartCode(h, a, p, b);
            g && (h = b.twoSidedLighting ? h + "   dVertexNormalW = gl_FrontFacing ? vNormalW : -vNormalW;\n" : h + "   dVertexNormalW = vNormalW;\n",
            (b.heightMap || b.normalMap) && b.hasTangents && (b.twoSidedLighting ? (h += "   dTangentW = gl_FrontFacing ? vTangentW : -vTangentW;\n",
            h += "   dBinormalW = gl_FrontFacing ? vBinormalW : -vBinormalW;\n") : (h += "   dTangentW = vTangentW;\n",
            h += "   dBinormalW = vBinormalW;\n")));
            l = !1;
            3 !== b.blendType || b.alphaTest || b.alphaToCoverage ? b.heightMap && b.opacityMap ? l = !0 : (h += "   getOpacity();\n",
            b.alphaTest && (h += "   alphaTest(dAlpha);\n")) : h += "   dAlpha = 1.0;\n";
            var B = !1;
            if (g) {
                h += "   getViewDir();\n";
                if (b.heightMap || b.normalMap || b.clearCoatNormalMap || b.enableGGXSpecular)
                    h += "   getTBN();\n";
                b.heightMap && (h += "   getParallax();\n");
                l && (h += "   getOpacity();\n",
                b.alphaTest && (h += "   alphaTest(dAlpha);\n"));
                h += "   getNormal();\n";
                b.useSpecular && (b.enableGGXSpecular && (h += "   getGlossiness();\n",
                B = !0),
                h += "   getReflDir();\n")
            }
            h += "   getAlbedo();\n";
            0 < b.clearCoat && (h += "   getClearCoat();\n",
            h += "   getClearCoatGlossiness();\n",
            h += "   getClearCoatNormal();\n");
            if (c && b.useSpecular || e)
                h += "   getSpecularity();\n",
                B || (h += "   getGlossiness();\n"),
                0 < b.fresnelModel && (h += "   getFresnel();\n");
            u && (h += "   addAmbient();\n");
            b.ambientTint && !t && (h += "   dDiffuseLight *= material_ambient;\n");
            k && !b.occludeDirect && (h += "\tapplyAO();\n");
            if (b.lightMap || b.lightVertexColor)
                h += "   addLightMap();\n";
            if (c || e) {
                if (d || b.sphereMap || b.dpAtlas)
                    0 < b.clearCoat && (h += "   addReflectionCC();\n"),
                    h += "   addReflection();\n";
                b.dirLightMap && (h += "   addDirLightMap();\n");
                for (t = 0; t < b.lights.length; t++) {
                    l = b.lights[t];
                    u = l._type;
                    e = !1;
                    0 === u ? (h += "   dLightDirNormW = light" + t + "_direction;\n",
                    h += "   dAtten = 1.0;\n") : (l._cookie && (2 !== u || l._cookie._cubemap ? 1 === u && l._cookie._cubemap && (e = v = !0) : e = v = !0),
                    h += "   getLightDirPoint(light" + t + "_position);\n",
                    f = !0,
                    e && (h = 2 === u ? h + ("   dAtten3 = getCookie2D" + (l._cookieFalloff ? "" : "Clip") + (l._cookieTransform ? "Xform" : "") + "(light" + t + "_cookie, light" + t + "_shadowMatrix, light" + t + "_cookieIntensity" + (l._cookieTransform ? ", light" + t + "_cookieMatrix, light" + t + "_cookieOffset" : "") + ")." + l._cookieChannel + ";\n") : h + ("   dAtten3 = getCookieCube(light" + t + "_cookie, light" + t + "_shadowMatrix, light" + t + "_cookieIntensity)." + l._cookieChannel + ";\n")),
                    0 === l._falloffMode ? (h += "   dAtten = getFalloffLinear(light" + t + "_radius);\n",
                    x = !0) : (h += "   dAtten = getFalloffInvSquared(light" + t + "_radius);\n",
                    w = !0),
                    h += "   if (dAtten > 0.00001) {\n",
                    2 !== u || e && !l._cookieFalloff || (h += "\t   dAtten *= getSpotEffect(light" + t + "_direction, light" + t + "_innerConeAngle, light" + t + "_outerConeAngle);\n",
                    y = !0));
                    h += "\t   dAtten *= getLightDiffuse();\n";
                    if (l.castShadows && !b.noShadow) {
                        if (1 === l._shadowType) {
                            g = "VSM8";
                            var E = "0.0"
                        } else
                            2 === l._shadowType ? (g = "VSM16",
                            E = "5.54") : 3 === l._shadowType ? (g = "VSM32",
                            E = a.textureFloatHighPrecision ? "15.0" : "5.54") : g = 4 === l._shadowType ? "PCF5x5" : "PCF3x3";
                        null !== g && (1 === u ? (c = "(light" + t + "_shadowMap, light" + t + "_shadowParams);\n",
                        l._normalOffsetBias && (h += "\t   normalOffsetPointShadow(light" + t + "_shadowParams);\n"),
                        h += "\t   dAtten *= getShadowPoint" + g + c) : (r === t ? g += "VS" : (c = "(light" + t + "_shadowMatrix, light" + t + "_shadowParams);\n",
                        h += this._nonPointShadowMapProjection(a, b.lights[t], c)),
                        2 === u && (g = "Spot" + g),
                        h += "\t   dAtten *= getShadow" + g + "(light" + t + "_shadowMap, light" + t + "_shadowParams" + (l._isVsm ? ", " + E : "") + ");\n"))
                    }
                    h += "\t   dDiffuseLight += dAtten * light" + t + "_color" + (e ? " * dAtten3" : "") + ";\n";
                    0 < b.clearCoat && (h += "\t   ccSpecularLight += getLightSpecularCC() * dAtten * light" + t + "_color" + (e ? " * dAtten3" : "") + ";\n");
                    b.useSpecular && (h += "\t   dAtten *= getLightSpecular();\n",
                    h += "\t   dSpecularLight += dAtten * light" + t + "_color" + (e ? " * dAtten3" : "") + ";\n");
                    0 !== u && (h += "   }\n");
                    h += "\n"
                }
                (d || b.sphereMap || b.dpAtlas) && b.refraction && (h += "   addRefraction();\n")
            }
            h += "\n";
            k && (b.occludeDirect && (h += "\tapplyAO();\n"),
            b.occludeSpecular && (h += "\toccludeSpecular();\n"));
            h += p.endPS;
            h = 2 === b.blendType || 6 === b.blendType || b.alphaToCoverage ? h + p.outputAlphaPS : 4 === b.blendType ? h + p.outputAlphaPremulPS : h + p.outputAlphaOpaquePS;
            b.msdf && (h += "   gl_FragColor = applyMsdf(gl_FragColor);\n");
            h += "\n";
            h += "}\n";
            f && (h = p.lightDirPointPS + h);
            x && (h = p.falloffLinearPS + h);
            w && (h = p.falloffInvSquaredPS + h);
            y && (h = p.spotPS + h);
            v && (h = p.cookiePS + h);
            a = "";
            h.includes("dReflection") && (a += "vec4 dReflection;\n");
            h.includes("dTBN") && (a += "mat3 dTBN;\n");
            h.includes("dAlbedo") && (a += "vec3 dAlbedo;\n");
            h.includes("dEmission") && (a += "vec3 dEmission;\n");
            h.includes("dNormalW") && (a += "vec3 dNormalW;\n");
            h.includes("dVertexNormalW") && (a += "vec3 dVertexNormalW;\n");
            h.includes("dTangentW") && (a += "vec3 dTangentW;\n");
            h.includes("dBinormalW") && (a += "vec3 dBinormalW;\n");
            h.includes("dViewDirW") && (a += "vec3 dViewDirW;\n");
            h.includes("dReflDirW") && (a += "vec3 dReflDirW;\n");
            h.includes("dDiffuseLight") && (a += "vec3 dDiffuseLight;\n");
            h.includes("dSpecularLight") && (a += "vec3 dSpecularLight;\n");
            h.includes("dLightDirNormW") && (a += "vec3 dLightDirNormW;\n");
            h.includes("dLightDirW") && (a += "vec3 dLightDirW;\n");
            h.includes("dLightPosW") && (a += "vec3 dLightPosW;\n");
            h.includes("dShadowCoord") && (a += "vec3 dShadowCoord;\n");
            h.includes("dNormalMap") && (a += "vec3 dNormalMap;\n");
            h.includes("dSpecularity") && (a += "vec3 dSpecularity;\n");
            h.includes("dUvOffset") && (a += "vec2 dUvOffset;\n");
            h.includes("dGlossiness") && (a += "float dGlossiness;\n");
            h.includes("dAlpha") && (a += "float dAlpha;\n");
            h.includes("dAtten") && (a += "float dAtten;\n");
            h.includes("dAtten3") && (a += "vec3 dAtten3;\n");
            h.includes("dAo") && (a += "float dAo;\n");
            h.includes("dMsdf") && (a += "vec4 dMsdf;\n");
            h.includes("ccReflection") && (a += "vec4 ccReflection;\n");
            h.includes("ccNormalW") && (a += "vec3 ccNormalW;\n");
            h.includes("ccReflDirW") && (a += "vec3 ccReflDirW;\n");
            h.includes("ccSpecularLight") && (a += "vec3 ccSpecularLight;\n");
            h.includes("ccSpecularity") && (a += "float ccSpecularity;\n");
            h.includes("ccGlossiness") && (a += "float ccGlossiness;\n");
            a = h = n + a + h;
            return {
                attributes: q,
                vshader: A,
                fshader: a,
                tag: 1
            }
        }
    }
      , mh = {
        begin: se,
        dummyFragmentCode: wk,
        end: function() {
            return "}\n"
        },
        fogCode: di,
        gammaCode: sg,
        precisionCode: Fd,
        skinCode: ei,
        tonemapCode: tg,
        versionCode: Gd,
        basic: {
            generateKey: function(a) {
                var b = "basic";
                a.fog && (b += "_fog");
                a.alphaTest && (b += "_atst");
                a.vertexColors && (b += "_vcol");
                a.diffuseMap && (b += "_diff");
                return b += "_" + a.pass
            },
            createShaderDefinition: function(a, b) {
                var c = {
                    vertex_position: "POSITION"
                };
                b.skin && (c.vertex_boneWeights = "BLENDWEIGHT",
                c.vertex_boneIndices = "BLENDINDICES");
                b.vertexColors && (c.vertex_color = "COLOR");
                b.diffuseMap && (c.vertex_texCoord0 = "TEXCOORD0");
                var d = "" + F.transformDeclVS;
                b.skin ? (d += ei(a),
                d += F.transformSkinnedVS) : d += F.transformVS;
                b.vertexColors && (d += "attribute vec4 vertex_color;\nvarying vec4 vColor;\n");
                b.diffuseMap && (d += "attribute vec2 vertex_texCoord0;\nvarying vec2 vUv0;\n");
                2 === b.pass && (d += "varying float vDepth;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n\n#endif\n");
                d += se();
                d += "   gl_Position = getPosition();\n";
                2 === b.pass && (d += "\tvDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;\n");
                b.vertexColors && (d += "\tvColor = vertex_color;\n");
                b.diffuseMap && (d += "\tvUv0 = vertex_texCoord0;\n");
                var e = d + "}\n";
                d = Fd(a);
                d = b.vertexColors ? d + "varying vec4 vColor;\n" : d + "uniform vec4 uColor;\n";
                b.diffuseMap && (d += "varying vec2 vUv0;\nuniform sampler2D texture_diffuseMap;\n");
                b.fog && (d += di(b.fog));
                b.alphatest && (d += F.alphaTestPS);
                2 === b.pass && (d = d + "varying float vDepth;\n" + F.packDepthPS);
                d += se();
                d = b.vertexColors ? d + "\tgl_FragColor = vColor;\n" : d + "\tgl_FragColor = uColor;\n";
                b.diffuseMap && (d += "\tgl_FragColor *= texture2D(texture_diffuseMap, vUv0);\n");
                b.alphatest && (d += "   alphaTest(gl_FragColor.a);\n");
                18 !== b.pass && (2 === b.pass ? d += "\tgl_FragColor = packFloat(vDepth);\n" : b.fog && (d += "   glFragColor.rgb = addFog(gl_FragColor.rgb);\n"));
                return {
                    attributes: c,
                    vshader: e,
                    fshader: d + "}\n"
                }
            }
        },
        particle: {
            generateKey: function(a) {
                var b = "particle", c;
                for (c in a)
                    a.hasOwnProperty(c) && (b += a[c]);
                return b
            },
            _animTex: function(a) {
                a = "" + (a.animTexLoop ? F.particleAnimFrameLoopVS : F.particleAnimFrameClampVS);
                return a += F.particleAnimTexVS
            },
            createShaderDefinition: function(a, b) {
                var c = ""
                  , d = Fd(a) + "\n";
                a.webgl2 && (c += "#define GL2\n",
                d += "#define GL2\n");
                c += "#define VERTEXSHADER\n";
                b.mesh && (c += "#define USE_MESH\n");
                b.localSpace && (c += "#define LOCAL_SPACE\n");
                b.screenSpace && (c += "#define SCREEN_SPACE\n");
                b.animTex && (c += "\nuniform vec2 animTexTilesParams;\n");
                b.animTex && (c += "\nuniform vec4 animTexParams;\n");
                b.animTex && (c += "\nuniform vec2 animTexIndexParams;\n");
                2 == b.normal && (c += "\nvarying mat3 ParticleMat;\n");
                1 == b.normal && (c += "\nvarying vec3 Normal;\n");
                b.soft && (c += "\nvarying float vDepth;\n");
                a = b.customFace ? F.particle_customFaceVS : F.particle_billboardVS;
                b.useCpu ? (0 < b.soft && (c += F.screenDepthPS),
                c += F.particle_cpuVS,
                b.localSpace && (c += F.particle_localShiftVS),
                b.animTex && (c += this._animTex(b)),
                b.alignToMotion && (c += F.particle_pointAlongVS),
                c += b.mesh ? F.particle_meshVS : a,
                1 == b.normal && (c += F.particle_normalVS),
                2 == b.normal && (c += F.particle_TBNVS),
                0 < b.stretch && (c += F.particle_stretchVS),
                c += F.particle_cpu_endVS) : (c += F.particle_initVS,
                c += b.pack8 ? F.particleInputRgba8PS : F.particleInputFloatPS,
                0 < b.soft && (c += F.screenDepthPS),
                c += F.particleVS,
                b.localSpace && (c += F.particle_localShiftVS),
                b.animTex && (c += this._animTex(b)),
                b.wrap && (c += F.particle_wrapVS),
                b.alignToMotion && (c += F.particle_pointAlongVS),
                c += b.mesh ? F.particle_meshVS : a,
                1 == b.normal && (c += F.particle_normalVS),
                2 == b.normal && (c += F.particle_TBNVS),
                0 < b.stretch && (c += F.particle_stretchVS),
                c += F.particle_endVS);
                0 < b.soft && (c += F.particle_softVS);
                c += "}\n";
                0 < b.normal && (1 == b.normal ? d += "\nvarying vec3 Normal;\n" : 2 == b.normal && (d += "\nvarying mat3 ParticleMat;\n"),
                d += "\nuniform vec3 lightCube[6];\n");
                b.soft && (d += "\nvarying float vDepth;\n");
                0 === b.normal && "none" === b.fog && (b.srgb = !1);
                d += sg(b.gamma);
                d += tg(b.toneMap);
                d = "linear" === b.fog ? d + F.fogLinearPS : "exp" === b.fog ? d + F.fogExpPS : "exp2" === b.fog ? d + F.fogExp2PS : d + F.fogNonePS;
                2 == b.normal && (d += "\nuniform sampler2D normalMap;\n");
                0 < b.soft && (d += F.screenDepthPS);
                d += F.particlePS;
                0 < b.soft && (d += F.particle_softPS);
                1 == b.normal && (d += "\nvec3 normal = Normal;\n");
                2 == b.normal && (d += F.particle_normalMapPS);
                0 < b.normal && (d += b.halflambert ? F.particle_halflambertPS : F.particle_lambertPS);
                0 < b.normal && (d += F.particle_lightingPS);
                2 == b.blend ? d += F.particle_blendNormalPS : 1 == b.blend ? d += F.particle_blendAddPS : 5 == b.blend && (d += F.particle_blendMultiplyPS);
                d += F.particle_endPS;
                return {
                    attributes: ug(c),
                    vshader: c,
                    fshader: d
                }
            }
        },
        skybox: {
            generateKey: function(a) {
                return "skybox" + a.rgbm + " " + a.hdr + " " + a.fixSeams + a.toneMapping + a.gamma + a.useIntensity + a.mip
            },
            createShaderDefinition: function(a, b) {
                a = Fd(a);
                a += b.mip ? F.fixCubemapSeamsStretchPS : F.fixCubemapSeamsNonePS;
                a += b.useIntensity ? F.envMultiplyPS : F.envConstPS;
                a += sg(b.gamma);
                a += tg(b.toneMapping);
                a += F.rgbmPS;
                a += F.skyboxHDRPS.replace(/\$textureCubeSAMPLE/g, b.rgbm ? "textureCubeRGBM" : b.hdr ? "textureCube" : "textureCubeSRGB").replace(/\$FIXCONST/g, 1 - 1 / [128, 64, 32, 16, 8, 4, 2][b.mip] + "");
                return {
                    attributes: {
                        aPosition: "POSITION"
                    },
                    vshader: F.skyboxVS,
                    fshader: a
                }
            }
        },
        standard: Oj
    };
    Object.defineProperties(V.prototype, {
        minFilter: {
            get: function() {
                return this._minFilter
            },
            set: function(a) {
                this._minFilter !== a && (this._minFilter = a,
                this._parameterFlags |= 1)
            }
        },
        magFilter: {
            get: function() {
                return this._magFilter
            },
            set: function(a) {
                this._magFilter !== a && (this._magFilter = a,
                this._parameterFlags |= 2)
            }
        },
        addressU: {
            get: function() {
                return this._addressU
            },
            set: function(a) {
                this._addressU !== a && (this._addressU = a,
                this._parameterFlags |= 4)
            }
        },
        addressV: {
            get: function() {
                return this._addressV
            },
            set: function(a) {
                this._addressV !== a && (this._addressV = a,
                this._parameterFlags |= 8)
            }
        },
        addressW: {
            get: function() {
                return this._addressW
            },
            set: function(a) {
                this.device.webgl2 && this._volume && a !== this._addressW && (this._addressW = a,
                this._parameterFlags |= 16)
            }
        },
        compareOnRead: {
            get: function() {
                return this._compareOnRead
            },
            set: function(a) {
                this._compareOnRead !== a && (this._compareOnRead = a,
                this._parameterFlags |= 32)
            }
        },
        compareFunc: {
            get: function() {
                return this._compareFunc
            },
            set: function(a) {
                this._compareFunc !== a && (this._compareFunc = a,
                this._parameterFlags |= 64)
            }
        },
        anisotropy: {
            get: function() {
                return this._anisotropy
            },
            set: function(a) {
                this._anisotropy !== a && (this._anisotropy = a,
                this._parameterFlags |= 128)
            }
        },
        autoMipmap: {
            get: function() {
                return this._mipmaps
            },
            set: function(a) {
                this._mipmaps = a
            }
        },
        mipmaps: {
            get: function() {
                return this._mipmaps
            },
            set: function(a) {
                this._mipmaps !== a && (this._mipmaps = a,
                this._minFilterDirty = !0,
                a && (this._needsMipmapsUpload = !0))
            }
        },
        width: {
            get: function() {
                return this._width
            }
        },
        height: {
            get: function() {
                return this._height
            }
        },
        depth: {
            get: function() {
                return this._depth
            }
        },
        format: {
            get: function() {
                return this._format
            }
        },
        cubemap: {
            get: function() {
                return this._cubemap
            }
        },
        gpuSize: {
            get: function() {
                return V.calcGpuSize(this._width, this._height, this._depth, this._format, this.pot && this._mipmaps && !(this._compressed && 1 === this._levels.length), this._cubemap)
            }
        },
        volume: {
            get: function() {
                return this._volume
            }
        },
        flipY: {
            get: function() {
                return this._flipY
            },
            set: function(a) {
                this._flipY !== a && (this._flipY = a,
                this._needsUpload = !0)
            }
        },
        premultiplyAlpha: {
            get: function() {
                return this._premultiplyAlpha
            },
            set: function(a) {
                this._premultiplyAlpha !== a && (this._premultiplyAlpha = a,
                this._needsUpload = !0)
            }
        },
        pot: {
            get: function() {
                return N.powerOfTwo(this._width) && N.powerOfTwo(this._height)
            }
        }
    });
    var nh = null
      , eb = null;
    Object.assign(V, {
        calcGpuSize: function(a, b, c, d, e, f) {
            nh || (nh = [1, 1, 2, 2, 2, 2, 4, 4, , , , 8, 8, 16, 16, 4, 4, 4, 4, 4, 4]);
            eb || (eb = [],
            eb[21] = 8,
            eb[22] = 8,
            eb[24] = 8,
            eb[25] = 8,
            eb[26] = 8,
            eb[27] = 8,
            eb[8] = 8,
            eb[29] = 8,
            eb[23] = 16,
            eb[9] = 16,
            eb[10] = 16,
            eb[28] = 16,
            eb[30] = 16);
            for (var g = nh.hasOwnProperty(d) ? nh[d] : 0, k = eb.hasOwnProperty(d) ? eb[d] : 0, h = 0; ; ) {
                if (0 < g)
                    h += a * b * c * g;
                else {
                    var l = Math.floor((a + 3) / 4)
                      , n = Math.floor((b + 3) / 4)
                      , p = Math.floor((c + 3) / 4);
                    if (24 === d || 25 === d)
                        l = Math.floor(l / 2, 1);
                    h += l * n * p * k
                }
                if (!e || 1 === a && 1 === b && 1 === c)
                    break;
                a = Math.max(Math.floor(a / 2), 1);
                b = Math.max(Math.floor(b / 2), 1);
                c = Math.max(Math.floor(c / 2), 1)
            }
            return h * (f ? 6 : 1)
        }
    });
    Object.assign(V.prototype, {
        destroy: function() {
            this.device && this.device.destroyTexture(this);
            this._levels = this.device = null
        },
        dirtyAll: function() {
            this._levelsUpdated = this._cubemap ? [[!0, !0, !0, !0, !0, !0]] : [!0];
            this._needsUpload = !0;
            this._needsMipmapsUpload = this._mipmaps;
            this._mipmapsUploaded = !1;
            this._parameterFlags = 255
        },
        lock: function(a) {
            a = a || {
                level: 0,
                face: 0,
                mode: 2
            };
            void 0 === a.level && (a.level = 0);
            void 0 === a.face && (a.face = 0);
            void 0 === a.mode && (a.mode = 2);
            this._lockedLevel = a.level;
            if (null === this._levels[a.level])
                switch (this._format) {
                case 0:
                case 1:
                    this._levels[a.level] = new Uint8Array(this._width * this._height * this._depth);
                    break;
                case 2:
                    this._levels[a.level] = new Uint8Array(this._width * this._height * this._depth * 2);
                    break;
                case 3:
                case 4:
                case 5:
                    this._levels[a.level] = new Uint16Array(this._width * this._height * this._depth);
                    break;
                case 6:
                    this._levels[a.level] = new Uint8Array(this._width * this._height * this._depth * 3);
                    break;
                case 7:
                    this._levels[a.level] = new Uint8Array(this._width * this._height * this._depth * 4);
                    break;
                case 8:
                    this._levels[a.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 8 * this._depth);
                    break;
                case 9:
                case 10:
                    this._levels[a.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 16 * this._depth);
                    break;
                case 11:
                    this._levels[a.level] = new Uint16Array(this._width * this._height * this._depth * 3);
                    break;
                case 13:
                    this._levels[a.level] = new Float32Array(this._width * this._height * this._depth * 3);
                    break;
                case 12:
                    this._levels[a.level] = new Uint16Array(this._width * this._height * this._depth * 4);
                    break;
                case 14:
                    this._levels[a.level] = new Float32Array(this._width * this._height * this._depth * 4)
                }
            return this._levels[a.level]
        },
        setSource: function(a, b) {
            var c, d = !1;
            b = b || 0;
            if (this._cubemap) {
                if (a[0]) {
                    var e = a[0].width || 0;
                    var f = a[0].height || 0;
                    for (c = 0; 6 > c; c++) {
                        var g = a[c];
                        if (!g || g.width !== e || g.height !== f || !this.device._isBrowserInterface(g)) {
                            d = !0;
                            break
                        }
                    }
                } else
                    d = !0;
                if (!d)
                    for (c = 0; 6 > c; c++)
                        this._levels[b][c] !== a[c] && (this._levelsUpdated[b][c] = !0)
            } else
                this.device._isBrowserInterface(a) || (d = !0),
                d || (a !== this._levels[b] && (this._levelsUpdated[b] = !0),
                e = a.width,
                f = a.height);
            if (d)
                if (this._height = this._width = 4,
                this._cubemap)
                    for (c = 0; 6 > c; c++)
                        this._levels[b][c] = null,
                        this._levelsUpdated[b][c] = !0;
                else
                    this._levels[b] = null,
                    this._levelsUpdated[b] = !0;
            else
                0 === b && (this._width = e,
                this._height = f),
                this._levels[b] = a;
            this._invalid === d && d || (this._invalid = d,
            this.upload())
        },
        getSource: function(a) {
            return this._levels[a || 0]
        },
        unlock: function() {
            this.upload();
            this._lockedLevel = -1
        },
        upload: function() {
            this._needsUpload = !0;
            this._needsMipmapsUpload = this._mipmaps
        },
        getDds: function() {
            7 !== this.format && console.error("This format is not implemented yet");
            for (var a = 128, b = 0, c, d; this._levels[b]; ) {
                if (this.cubemap)
                    for (d = 0; 6 > d; d++) {
                        if (!this._levels[b][d]) {
                            console.error("No level data for mip " + b + ", face " + d);
                            return
                        }
                        c = this._levels[b][d].length;
                        if (!c) {
                            console.error("No byte array for mip " + b + ", face " + d);
                            return
                        }
                        a += c
                    }
                else {
                    c = this._levels[b].length;
                    if (!c) {
                        console.error("No byte array for mip " + b);
                        return
                    }
                    a += c
                }
                a += this._levels[b].length;
                b++
            }
            a = new ArrayBuffer(a);
            d = new Uint32Array(a,0,32);
            b = 528391;
            1 < this._levels.length && (b |= 131072);
            c = 4096;
            1 < this._levels.length && (c |= 4194304);
            if (1 < this._levels.length || this.cubemap)
                c |= 8;
            var e = this.cubemap ? 65024 : 0;
            d[0] = 542327876;
            d[1] = 124;
            d[2] = b;
            d[3] = this.height;
            d[4] = this.width;
            d[5] = this.width * this.height * 4;
            d[6] = 0;
            d[7] = this._levels.length;
            for (b = 0; 11 > b; b++)
                d[8 + b] = 0;
            d[19] = 32;
            d[20] = 65;
            d[21] = 0;
            d[22] = 32;
            d[23] = 16711680;
            d[24] = 65280;
            d[25] = 255;
            d[26] = 4278190080;
            d[27] = c;
            d[28] = e;
            d[29] = 0;
            d[30] = 0;
            d[31] = 0;
            e = 128;
            if (this.cubemap)
                for (d = 0; 6 > d; d++)
                    for (b = 0; b < this._levels.length; b++) {
                        var f = this._levels[b][d];
                        var g = new Uint8Array(a,e,f.length);
                        for (c = 0; c < f.length; c++)
                            g[c] = f[c];
                        e += f.length
                    }
            else
                for (b = 0; b < this._levels.length; b++) {
                    f = this._levels[b];
                    g = new Uint8Array(a,e,f.length);
                    for (c = 0; c < f.length; c++)
                        g[c] = f[c];
                    e += f.length
                }
            return a
        }
    });
    Object.assign(dc.prototype, {
        destroy: function() {
            var a = this.device
              , b = a.buffers.indexOf(this);
            -1 !== b && a.buffers.splice(b, 1);
            this.bufferId && (this.device.gl.deleteBuffer(this.bufferId),
            this.device._vram.ib -= this.storage.byteLength,
            this.bufferId = null,
            this.device.indexBuffer === this && (this.device.indexBuffer = null))
        },
        getFormat: function() {
            return this.format
        },
        getNumIndices: function() {
            return this.numIndices
        },
        lock: function() {
            return this.storage
        },
        unlock: function() {
            var a = this.device.gl;
            this.bufferId || (this.bufferId = a.createBuffer());
            switch (this.usage) {
            case 0:
                var b = a.STATIC_DRAW;
                break;
            case 1:
                b = a.DYNAMIC_DRAW;
                break;
            case 2:
                b = a.STREAM_DRAW;
                break;
            case 3:
                b = this.device.webgl2 ? a.DYNAMIC_COPY : a.STATIC_DRAW
            }
            a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.bufferId);
            a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.storage, b)
        },
        setData: function(a) {
            if (a.byteLength !== this.numBytes)
                return !1;
            this.storage = a;
            this.unlock();
            return !0
        },
        _lockTypedArray: function() {
            var a = this.lock();
            return 2 === this.format ? new Uint32Array(a) : 1 === this.format ? new Uint16Array(a) : new Uint8Array(a)
        },
        writeData: function(a, b) {
            var c = this._lockTypedArray();
            if (a.length > b)
                if (ArrayBuffer.isView(a))
                    a = a.subarray(0, b),
                    c.set(a);
                else {
                    var d;
                    for (d = 0; d < b; d++)
                        c[d] = a[d]
                }
            else
                c.set(a);
            this.unlock()
        },
        readData: function(a) {
            var b = this._lockTypedArray()
              , c = this.numIndices;
            if (ArrayBuffer.isView(a))
                a.set(b);
            else {
                a.length = 0;
                var d;
                for (d = 0; d < c; d++)
                    a[d] = b[d]
            }
            return c
        }
    });
    var Kn = 0;
    Object.assign(cd.prototype, {
        initDefaults: function() {
            this.recreate = !1;
            this.indexCount = this.vertexCount = this.maxIndices = this.maxVertices = this.indicesUsage = this.verticesUsage = 0;
            this.indexStreamUpdated = this.vertexStreamsUpdated = !1;
            this.vertexStreamDictionary = {};
            this.indices = null
        },
        _validateVertexCount: function(a, b) {},
        _changeVertexCount: function(a, b) {
            this.vertexCount ? this._validateVertexCount(a, b) : this.vertexCount = a
        }
    });
    Object.defineProperties(cd, {
        DEFAULT_COMPONENTS_POSITION: {
            value: 3
        },
        DEFAULT_COMPONENTS_NORMAL: {
            value: 3
        },
        DEFAULT_COMPONENTS_UV: {
            value: 2
        },
        DEFAULT_COMPONENTS_COLORS: {
            value: 4
        }
    });
    Object.defineProperties(rb.prototype, {
        aabb: {
            get: function() {
                return this._aabb
            },
            set: function(a) {
                this._aabb = a
            }
        },
        refCount: {
            get: function() {
                return this._refCount
            }
        }
    });
    Object.assign(rb.prototype, {
        incReference: function() {
            this._refCount++
        },
        decReference: function() {
            this._refCount--
        },
        destroy: function() {
            this.vertexBuffer && (this.vertexBuffer.destroy(),
            this.vertexBuffer = null);
            var a, b;
            for (a = 0; a < this.indexBuffer.length; a++)
                (b = this.indexBuffer[a]) && b.destroy();
            this.indexBuffer.length = 0;
            this._geometryData = null
        },
        _initBoneAabbs: function(a) {
            this.boneAabb = [];
            this.boneUsed = [];
            var b = this.vertexBuffer.numVertices, c, d, e = [], f = [], g = this.boneUsed, k = this.skin.boneNames.length, h, l, n;
            for (c = 0; c < k; c++)
                e[c] = new z(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),
                f[c] = new z(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);
            var p = new Pb(this.vertexBuffer)
              , q = p.element.POSITION
              , r = p.element.BLENDWEIGHT
              , t = p.element.BLENDINDICES;
            for (c = 0; c < b; c++) {
                for (d = 0; 4 > d; d++) {
                    var u = r.array[r.index + d];
                    if (0 < u) {
                        var x = t.array[t.index + d];
                        g[x] = !0;
                        var v = q.array[q.index];
                        var w = q.array[q.index + 1];
                        var y = q.array[q.index + 2];
                        u = f[x];
                        x = e[x];
                        x.x > v && (x.x = v);
                        x.y > w && (x.y = w);
                        x.z > y && (x.z = y);
                        u.x < v && (u.x = v);
                        u.y < w && (u.y = w);
                        u.z < y && (u.z = y);
                        if (a) {
                            v = h = v;
                            w = l = w;
                            var A = n = y;
                            for (y = 0; y < a.length; y++) {
                                var B = a[y];
                                var E = B.deltaPositions[3 * c];
                                var C = B.deltaPositions[3 * c + 1];
                                B = B.deltaPositions[3 * c + 2];
                                0 > E ? v += E : h += E;
                                0 > C ? w += C : l += C;
                                0 > B ? A += B : n += B
                            }
                            x.x > v && (x.x = v);
                            x.y > w && (x.y = w);
                            x.z > A && (x.z = A);
                            u.x < h && (u.x = h);
                            u.y < l && (u.y = l);
                            u.z < n && (u.z = n)
                        }
                    }
                }
                p.next()
            }
            for (c = 0; c < k; c++)
                a = new oa,
                a.setMinMax(e[c], f[c]),
                this.boneAabb.push(a)
        },
        _initGeometryData: function() {
            this._geometryData || (this._geometryData = new cd,
            this.vertexBuffer && (this._geometryData.vertexCount = this.vertexBuffer.numVertices,
            this._geometryData.maxVertices = this.vertexBuffer.numVertices),
            0 < this.indexBuffer.length && this.indexBuffer[0] && (this._geometryData.indexCount = this.indexBuffer[0].numIndices,
            this._geometryData.maxIndices = this.indexBuffer[0].numIndices))
        },
        clear: function(a, b, c, d) {
            this._initGeometryData();
            this._geometryData.initDefaults();
            this._geometryData.recreate = !0;
            this._geometryData.maxVertices = c || 0;
            this._geometryData.maxIndices = d || 0;
            this._geometryData.verticesUsage = a ? 0 : 1;
            this._geometryData.indicesUsage = b ? 0 : 1
        },
        setVertexStream: function(a, b, c, d, e, f) {
            this._initGeometryData();
            this._geometryData._changeVertexCount(d || b.length / c, a);
            this._geometryData.vertexStreamsUpdated = !0;
            this._geometryData.vertexStreamDictionary[a] = new Jn(b,c,e || 6,f || !1)
        },
        getVertexStream: function(a, b) {
            var c = 0
              , d = !1;
            if (this._geometryData) {
                var e = this._geometryData.vertexStreamDictionary[a];
                e && (d = !0,
                c = this._geometryData.vertexCount,
                ArrayBuffer.isView(b) ? b.set(e.data) : (b.length = 0,
                b.push(e.data)))
            }
            d || this.vertexBuffer && (c = (new Pb(this.vertexBuffer)).readData(a, b));
            return c
        },
        setPositions: function(a, b, c) {
            this.setVertexStream("POSITION", a, b || cd.DEFAULT_COMPONENTS_POSITION, c, 6, !1)
        },
        setNormals: function(a, b, c) {
            this.setVertexStream("NORMAL", a, b || cd.DEFAULT_COMPONENTS_NORMAL, c, 6, !1)
        },
        setUvs: function(a, b, c, d) {
            this.setVertexStream("TEXCOORD" + a, b, c || cd.DEFAULT_COMPONENTS_UV, d, 6, !1)
        },
        setColors: function(a, b, c) {
            this.setVertexStream("COLOR", a, b || cd.DEFAULT_COMPONENTS_COLORS, c, 6, !1)
        },
        setColors32: function(a, b) {
            this.setVertexStream("COLOR", a, cd.DEFAULT_COMPONENTS_COLORS, b, 1, !0)
        },
        setIndices: function(a, b) {
            this._initGeometryData();
            this._geometryData.indexStreamUpdated = !0;
            this._geometryData.indices = a;
            this._geometryData.indexCount = b || a.length
        },
        getPositions: function(a) {
            return this.getVertexStream("POSITION", a)
        },
        getNormals: function(a) {
            return this.getVertexStream("NORMAL", a)
        },
        getUvs: function(a, b) {
            return this.getVertexStream("TEXCOORD" + a, b)
        },
        getColors: function(a) {
            return this.getVertexStream("COLOR", a)
        },
        getIndices: function(a) {
            var b = 0;
            if (this._geometryData && this._geometryData.indices) {
                var c = this._geometryData.indices;
                b = this._geometryData.indexCount;
                ArrayBuffer.isView(a) ? a.set(c) : (a.length = 0,
                a.push(c))
            } else
                0 < this.indexBuffer.length && this.indexBuffer[0] && (b = this.indexBuffer[0].readData(a));
            return b
        },
        update: function(a, b) {
            this._geometryData && ((b || void 0 === b) && (b = this._geometryData.vertexStreamDictionary.POSITION) && 3 == b.componentCount && this._aabb.compute(b.data, this._geometryData.vertexCount),
            b = this._geometryData.recreate,
            this._geometryData.vertexCount > this._geometryData.maxVertices && (b = !0,
            this._geometryData.maxVertices = this._geometryData.vertexCount),
            b && this.vertexBuffer && (this.vertexBuffer.destroy(),
            this.vertexBuffer = null),
            b = this._geometryData.recreate,
            this._geometryData.indexCount > this._geometryData.maxIndices && (b = !0,
            this._geometryData.maxIndices = this._geometryData.indexCount),
            b && 0 < this.indexBuffer.length && this.indexBuffer[0] && (this.indexBuffer[0].destroy(),
            this.indexBuffer[0] = null),
            this._geometryData.vertexStreamsUpdated && this._updateVertexBuffer(),
            this._geometryData.indexStreamUpdated && this._updateIndexBuffer(),
            this.primitive[0].type = void 0 === a ? 4 : a,
            0 < this.indexBuffer.length && this.indexBuffer[0] ? this._geometryData.indexStreamUpdated && (this.primitive[0].count = this._geometryData.indexCount,
            this.primitive[0].indexed = !0) : this._geometryData.vertexStreamsUpdated && (this.primitive[0].count = this._geometryData.vertexCount,
            this.primitive[0].indexed = !1),
            this._geometryData.vertexCount = 0,
            this._geometryData.indexCount = 0,
            this._geometryData.vertexStreamsUpdated = !1,
            this._geometryData.indexStreamUpdated = !1,
            this._geometryData.recreate = !1)
        },
        _buildVertexFormat: function(a) {
            var b = [], c;
            for (c in this._geometryData.vertexStreamDictionary) {
                var d = this._geometryData.vertexStreamDictionary[c];
                b.push({
                    semantic: c,
                    components: d.componentCount,
                    type: d.dataType,
                    normalize: d.dataTypeNormalize
                })
            }
            return new Na(this.device,b,a)
        },
        _updateVertexBuffer: function() {
            if (!this.vertexBuffer) {
                var a = this._geometryData.maxVertices
                  , b = this._buildVertexFormat(a);
                this.vertexBuffer = new ab(this.device,b,a,this._geometryData.verticesUsage)
            }
            a = new Pb(this.vertexBuffer);
            b = this._geometryData.vertexCount;
            for (var c in this._geometryData.vertexStreamDictionary)
                a.writeData(c, this._geometryData.vertexStreamDictionary[c].data, b),
                delete this._geometryData.vertexStreamDictionary[c];
            a.end()
        },
        _updateIndexBuffer: function() {
            if (0 >= this.indexBuffer.length || !this.indexBuffer[0])
                this.indexBuffer[0] = new dc(this.device,65535 < this._geometryData.maxVertices ? 2 : 1,this._geometryData.maxIndices,this._geometryData.indicesUsage);
            var a = this._geometryData.indices;
            a && (this.indexBuffer[0].writeData(a, this._geometryData.indexCount),
            this._geometryData.indices = null)
        },
        generateWireframe: function() {
            var a = function(r) {
                switch (r.format) {
                case 0:
                    return new Uint8Array(r.storage);
                case 1:
                    return new Uint16Array(r.storage);
                case 2:
                    return new Uint32Array(r.storage);
                default:
                    return null
                }
            }
              , b = [];
            if (0 < this.indexBuffer.length && this.indexBuffer[0]) {
                var c = [[0, 1], [1, 2], [2, 0]];
                for (var d = this.primitive[0].base, e = this.primitive[0].count, f = this.indexBuffer[0], g = a(f), k = {}, h = d; h < d + e; h += 3)
                    for (var l = 0; 3 > l; l++) {
                        var n = g[h + c[l][0]]
                          , p = g[h + c[l][1]]
                          , q = n > p ? p << 16 | n : n << 16 | p;
                        void 0 === k[q] && (k[q] = 0,
                        b.push(n, p))
                    }
                c = f.format
            } else {
                for (c = 0; c < this.vertexBuffer.numVertices; c += 3)
                    b.push(c, c + 1, c + 1, c + 2, c + 2, c);
                c = 65535 < b.length ? 2 : 1
            }
            c = new dc(this.vertexBuffer.device,c,b.length);
            a(c).set(b);
            c.unlock();
            this.primitive[1] = {
                type: 1,
                base: 0,
                count: b.length,
                indexed: !0
            };
            this.indexBuffer[1] = c
        }
    });
    var Ac = new oa
      , oh = new oa
      , Pj = new Cd;
    Object.defineProperty(va.prototype, "mesh", {
        get: function() {
            return this._mesh
        },
        set: function(a) {
            this._mesh && this._mesh.decReference();
            (this._mesh = a) && a.incReference()
        }
    });
    Object.defineProperty(va.prototype, "aabb", {
        get: function() {
            var a;
            if (!this._updateAabb)
                return this._aabb;
            if (this._updateAabbFunc)
                return this._updateAabbFunc(this._aabb);
            if (this.skinInstance) {
                this.mesh.boneAabb || this.mesh._initBoneAabbs(this._morphInstance ? this._morphInstance.morph._targets : null);
                var b = this.mesh.boneUsed
                  , c = this.node.getWorldTransform()
                  , d = !0;
                for (a = 0; a < this.mesh.boneAabb.length; a++)
                    b[a] && (oh.setFromTransformedAabb(this.mesh.boneAabb[a], this.skinInstance.matrices[a]),
                    d ? (d = !1,
                    Ac.center.copy(oh.center),
                    Ac.halfExtents.copy(oh.halfExtents)) : Ac.add(oh));
                this._aabb.setFromTransformedAabb(Ac, c)
            } else
                this.node._aabbVer !== this._aabbVer && (this.mesh ? (Ac.center.copy(this.mesh.aabb.center),
                Ac.halfExtents.copy(this.mesh.aabb.halfExtents)) : (Ac.center.set(0, 0, 0),
                Ac.halfExtents.set(0, 0, 0)),
                this.mesh && this.mesh.morph && Ac._expand(this.mesh.morph.aabb.getMin(), this.mesh.morph.aabb.getMax()),
                this._aabb.setFromTransformedAabb(Ac, this.node.getWorldTransform()),
                this._aabbVer = this.node._aabbVer);
            return this._aabb
        },
        set: function(a) {
            this._aabb = a
        }
    });
    Object.defineProperty(va.prototype, "material", {
        get: function() {
            return this._material
        },
        set: function(a) {
            var b;
            for (b = 0; b < this._shader.length; b++)
                this._shader[b] = null;
            if (this._material) {
                var c = this._material.meshInstances;
                b = c.indexOf(this);
                -1 !== b && c.splice(b, 1)
            }
            b = this._material;
            if (this._material = a)
                this._material.meshInstances.push(this),
                this.updateKey(),
                (b && 3 !== b.blendType) !== (3 !== this._material.blendType) && (a = this._material._scene,
                !a && b && b._scene && (a = b._scene),
                a ? a.layers._dirtyBlend = !0 : this._material._dirtyBlend = !0)
        }
    });
    Object.defineProperty(va.prototype, "layer", {
        get: function() {
            return this._layer
        },
        set: function(a) {
            this._layer = a;
            this.updateKey()
        }
    });
    Object.defineProperty(va.prototype, "calculateSortDistance", {
        get: function() {
            return this._calculateSortDistance
        },
        set: function(a) {
            this._calculateSortDistance = a
        }
    });
    Object.defineProperty(va.prototype, "receiveShadow", {
        get: function() {
            return this._receiveShadow
        },
        set: function(a) {
            this._shaderDefs = (this._receiveShadow = a) ? this._shaderDefs & -2 : this._shaderDefs | 1;
            this._shader[0] = null;
            this._shader[1] = null
        }
    });
    Object.defineProperty(va.prototype, "skinInstance", {
        get: function() {
            return this._skinInstance
        },
        set: function(a) {
            this._shaderDefs = (this._skinInstance = a) ? this._shaderDefs | 2 : this._shaderDefs & -3;
            for (a = 0; a < this._shader.length; a++)
                this._shader[a] = null
        }
    });
    Object.defineProperty(va.prototype, "morphInstance", {
        get: function() {
            return this._morphInstance
        },
        set: function(a) {
            if (this._morphInstance = a)
                this._morphInstance.meshInstance = this;
            this._shaderDefs = a && a.morph.useTextureMorph ? this._shaderDefs | 4096 : this._shaderDefs & -4097;
            this._shaderDefs = a && a.morph.morphPositions ? this._shaderDefs | 1024 : this._shaderDefs & -1025;
            this._shaderDefs = a && a.morph.morphNormals ? this._shaderDefs | 2048 : this._shaderDefs & -2049;
            for (a = 0; a < this._shader.length; a++)
                this._shader[a] = null
        }
    });
    Object.defineProperty(va.prototype, "screenSpace", {
        get: function() {
            return this._screenSpace
        },
        set: function(a) {
            this._shaderDefs = (this._screenSpace = a) ? this._shaderDefs | 256 : this._shaderDefs & -257;
            this._shader[0] = null
        }
    });
    Object.defineProperty(va.prototype, "key", {
        get: function() {
            return this._key[0]
        },
        set: function(a) {
            this._key[0] = a
        }
    });
    Object.defineProperty(va.prototype, "mask", {
        get: function() {
            return this._shaderDefs >> 16
        },
        set: function(a) {
            this._shaderDefs = this._shaderDefs & 65535 | a << 16;
            this._shader[0] = null;
            this._shader[1] = null
        }
    });
    Object.defineProperty(va.prototype, "instancingCount", {
        get: function() {
            return this.instancingData ? this.instancingData.count : 0
        },
        set: function(a) {
            this.instancingData && (this.instancingData.count = a)
        }
    });
    Object.assign(va.prototype, {
        syncAabb: function() {},
        _isVisible: function(a) {
            if (this.visible) {
                if (this.isVisibleFunc)
                    return this.isVisibleFunc(a);
                var b = this.aabb.center;
                this._aabb._radiusVer !== this._aabbVer && (this._aabb._radius = this._aabb.halfExtents.length(),
                this._aabb._radiusVer = this._aabbVer);
                Pj.radius = this._aabb._radius;
                Pj.center = b;
                return a.frustum.containsSphere(Pj)
            }
            return !1
        },
        updateKey: function() {
            var a = this.material;
            this._key[0] = (this.layer & 15) << 27 | (3 === (a.alphaToCoverage || a.alphaTest ? 2 : a.blendType) ? 1 : 0) << 26 | 0 | (a.id & 33554431) << 0
        },
        setInstancing: function(a) {
            a ? (this.instancingData = new Ln(a.numVertices),
            this.instancingData.vertexBuffer = a,
            a.instancing = !0,
            this.cull = !1) : (this.instancingData = null,
            this.cull = !0)
        },
        clearParameters: function() {
            this.parameters = {}
        },
        getParameters: function() {
            return this.parameters
        },
        getParameter: function(a) {
            return this.parameters[a]
        },
        setParameter: function(a, b, c) {
            void 0 === c && (c = -524285);
            if (void 0 === b && "object" === typeof a) {
                b = a;
                if (b.length) {
                    for (a = 0; a < b.length; a++)
                        this.setParameter(b[a]);
                    return
                }
                a = b.name;
                b = b.value
            }
            var d = this.parameters[a];
            d ? (d.data = b,
            d.passFlags = c) : this.parameters[a] = {
                scopeId: null,
                data: b,
                passFlags: c
            }
        },
        deleteParameter: function(a) {
            this.parameters[a] && delete this.parameters[a]
        },
        setParameters: function(a, b) {
            var c = this.parameters, d;
            for (d in c) {
                var e = c[d];
                e.passFlags & b && (e.scopeId || (e.scopeId = a.scope.resolve(d)),
                e.scopeId.setValue(e.data))
            }
        }
    });
    Object.defineProperty(vg.prototype, "key", {
        get: function() {
            return this._key[0]
        },
        set: function(a) {
            this._key[0] = a
        }
    });
    Object.defineProperties(Db, {
        FORMAT_FLOAT: {
            value: 0
        },
        FORMAT_HALF_FLOAT: {
            value: 1
        }
    });
    Object.defineProperties(Db.prototype, {
        morphPositions: {
            get: function() {
                return this._morphPositions
            }
        },
        morphNormals: {
            get: function() {
                return this._morphNormals
            }
        },
        maxActiveTargets: {
            get: function() {
                return this._useTextureMorph ? this._targets.length : this._morphPositions && this._morphNormals ? 4 : 8
            }
        },
        useTextureMorph: {
            get: function() {
                return this._useTextureMorph
            }
        }
    });
    Object.assign(Db.prototype, {
        _init: function() {
            this._useTextureMorph && (this._useTextureMorph = this._initTextureBased());
            var a;
            if (!this._useTextureMorph)
                for (a = 0; a < this._targets.length; a++)
                    this._targets[a]._initVertexBuffers(this.device);
            for (a = 0; a < this._targets.length; a++)
                this._targets[a]._postInit()
        },
        _initTextureBased: function() {
            var a, b = [], c = [];
            for (a = 0; a < this._targets.length; a++) {
                var d = this._targets[a];
                d.options.deltaPositions && (b.push(d.options.deltaPositions),
                c.push({
                    target: d,
                    name: "texturePositions"
                }));
                d.options.deltaNormals && (b.push(d.options.deltaNormals),
                c.push({
                    target: d,
                    name: "textureNormals"
                }))
            }
            var e = []
              , f = []
              , g = 1
              , k = b[0].length;
            for (d = 0; d < k; d += 3) {
                var h = !1;
                for (a = 0; a < b.length; a++) {
                    var l = b[a];
                    if (0 !== l[d] || 0 !== l[d + 1] || 0 !== l[d + 2]) {
                        h = !0;
                        break
                    }
                }
                h ? (e.push(g),
                f.push(d / 3),
                g++) : e.push(0)
            }
            a = Math.min(this.device.maxTextureSize, 4096);
            d = Math.ceil(Math.sqrt(g));
            d = Math.min(d, a);
            l = Math.ceil(g / d);
            if (l > a)
                return !1;
            this.morphTextureWidth = d;
            this.morphTextureHeight = l;
            g = !1;
            h = 3;
            k = N.float2Half;
            this._textureFormat === Db.FORMAT_HALF_FLOAT && (g = !0,
            h = 4);
            a = this.morphTextureWidth * this.morphTextureHeight * h;
            var n = g ? new Uint16Array(a) : new Float32Array(a);
            for (a = 0; a < b.length; a++) {
                l = b[a];
                for (d = 0; d < f.length; d++) {
                    var p = f[d];
                    g ? (n[d * h + h] = k(l[3 * p]),
                    n[d * h + h + 1] = k(l[3 * p + 1]),
                    n[d * h + h + 2] = k(l[3 * p + 2])) : (n[d * h + h] = l[3 * p],
                    n[d * h + h + 1] = l[3 * p + 1],
                    n[d * h + h + 2] = l[3 * p + 2])
                }
                d = c[a].target;
                d._setTexture(c[a].name, this._createTexture("MorphTarget", this._textureFormat === Db.FORMAT_FLOAT ? 13 : 12, n))
            }
            this.vertexBufferIds = new ab(this.device,new Na(this.device,[{
                semantic: "ATTR15",
                components: 1,
                type: 6
            }]),e.length,0,new Float32Array(e));
            return !0
        },
        destroy: function() {
            this.vertexBufferIds && (this.vertexBufferIds.destroy(),
            this.vertexBufferIds = null);
            for (var a = 0; a < this._targets.length; a++)
                this._targets[a].destroy();
            this._targets.length = 0
        },
        getTarget: function(a) {
            return this._targets[a]
        },
        _updateMorphFlags: function() {
            this._morphNormals = this._morphPositions = !1;
            for (var a, b = 0; b < this._targets.length; b++)
                a = this._targets[b],
                a.morphPositions && (this._morphPositions = !0),
                a.morphNormals && (this._morphNormals = !0)
        },
        _calculateAabb: function() {
            this.aabb = new oa(new z(0,0,0),new z(0,0,0));
            for (var a, b = 0; b < this._targets.length; b++)
                a = this._targets[b],
                this.aabb._expand(a.aabb.getMin(), a.aabb.getMax())
        },
        _createTexture: function(a, b, c) {
            b = new V(this.device,{
                width: this.morphTextureWidth,
                height: this.morphTextureHeight,
                format: b,
                cubemap: !1,
                mipmaps: !1,
                minFilter: 0,
                magFilter: 0,
                addressU: 1,
                addressV: 1
            });
            b.name = a;
            c && (b.lock().set(c),
            b.unlock());
            return b
        }
    });
    Object.assign(sf.prototype, {
        destroy: function() {
            this.shader = this.meshInstance = null;
            this.morph && (this.morph.destroy(),
            this.morph = null);
            this.rtPositions && (this.rtPositions.destroy(),
            this.rtPositions = null);
            this.texturePositions && (this.texturePositions.destroy(),
            this.texturePositions = null);
            this.rtNormals && (this.rtNormals.destroy(),
            this.rtNormals = null);
            this.textureNormals && (this.textureNormals.destroy(),
            this.textureNormals = null)
        },
        getWeight: function(a) {
            return this._weights[a]
        },
        setWeight: function(a, b) {
            this._weights[a] = b;
            this._dirty = !0
        },
        _getFragmentShader: function(a) {
            var b, c = "";
            0 < a && (c += "varying vec2 uv0;\nuniform highp float morphFactor[" + a + "];\n");
            for (b = 0; b < a; b++)
                c += "uniform highp sampler2D morphBlendTex" + b + ";\n";
            c += "void main (void) {\n\thighp vec4 color = vec4(0, 0, 0, 1);\n";
            for (b = 0; b < a; b++)
                c += "\tcolor.xyz += morphFactor[" + b + "] * texture2D(morphBlendTex" + b + ", uv0).xyz;\n";
            return c + "\tgl_FragColor = color;\n}\n"
        },
        _getShader: function(a) {
            var b = this.shaderCache[a];
            b || (b = this._getFragmentShader(a),
            b = Wa(this.device, "attribute vec2 vertex_position;\nvarying vec2 uv0;\nvoid main(void) {\n\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\tuv0 = vertex_position.xy * 0.5 + 0.5;\n}\n", b, "textureMorph" + a),
            this.shaderCache[a] = b);
            return b
        },
        _updateTextureRenderTarget: function(a, b) {
            for (var c = this.device, d = function(n, p) {
                this.morphFactor.setValue(this._shaderMorphWeights);
                c.setBlending(p);
                p && (c.setBlendFunction(1, 1),
                c.setBlendEquation(0));
                n = this._getShader(n);
                La(c, a, n, void 0, void 0, p)
            }
            .bind(this), e = 0, f = !1, g = this._activeTargets.length, k = 0; k < g; k++) {
                var h = this._activeTargets[k]
                  , l = h.target[b];
                l && (this["morphBlendTex" + e].setValue(l),
                this._shaderMorphWeights[e] = h.weight,
                e++,
                e >= this.maxSubmitCount && (d(e, f),
                e = 0,
                f = !0))
            }
            (0 < e || 0 === g && !this.zeroTextures) && d(e, f)
        },
        _updateTextureMorph: function() {
            if (0 < this._activeTargets.length || !this.zeroTextures)
                this._updateTextureRenderTarget(this.rtPositions, "texturePositions"),
                this._updateTextureRenderTarget(this.rtNormals, "textureNormals"),
                this.zeroTextures = 0 === this._activeTargets.length
        },
        _updateVertexMorph: function() {
            var a, b = this.maxSubmitCount;
            for (a = 0; a < b; a++)
                this._shaderMorphWeights[a] = 0,
                this._activeVertexBuffers[a] = null;
            b = 0;
            var c = this.morph.morphPositions ? 4 : 0;
            for (a = 0; a < this._activeTargets.length; a++) {
                var d = this._activeTargets[a].target;
                d._vertexBufferPositions && (this._activeVertexBuffers[b] = d._vertexBufferPositions,
                this._shaderMorphWeights[b] = this._activeTargets[a].weight,
                b++);
                d._vertexBufferNormals && (this._activeVertexBuffers[c] = d._vertexBufferNormals,
                this._shaderMorphWeights[c] = this._activeTargets[a].weight,
                c++)
            }
        },
        update: function() {
            this._dirty = !1;
            var a = this.morph._targets, b = 0, c;
            for (c = 0; c < a.length; c++) {
                var d = Math.abs(this.getWeight(c));
                if (1E-5 < d) {
                    this._activeTargets.length <= b && (this._activeTargets[b] = {});
                    var e = this._activeTargets[b++];
                    e.absWeight = d;
                    e.weight = this.getWeight(c);
                    e.target = a[c]
                }
            }
            this._activeTargets.length = b;
            a = this.morph.maxActiveTargets;
            this._activeTargets.length > a && (this._activeTargets.sort(function(f, g) {
                return f.absWeight < g.absWeight ? 1 : g.absWeight < f.absWeight ? -1 : 0
            }),
            this._activeTargets.length = a);
            this.morph.useTextureMorph ? this._updateTextureMorph() : this._updateVertexMorph()
        }
    });
    var Vl = new K;
    Object.assign(Hc.prototype, {
        init: function(a, b) {
            if (a.supportsBoneTextures) {
                b *= 3;
                var c = Math.ceil(Math.sqrt(b));
                c = N.roundUp(c, 3);
                this.boneTexture = new V(a,{
                    width: c,
                    height: Math.ceil(b / c),
                    format: 14,
                    mipmaps: !1,
                    minFilter: 0,
                    magFilter: 0
                });
                this.boneTexture.name = "skin";
                this.matrixPalette = this.boneTexture.lock()
            } else
                this.matrixPalette = new Float32Array(12 * b)
        },
        initSkin: function(a) {
            this.skin = a;
            this.bones = [];
            var b = a.inverseBindPose.length;
            this.init(a.device, b);
            this.matrices = [];
            for (a = 0; a < b; a++)
                this.matrices[a] = new K
        },
        uploadBones: function(a) {
            a.supportsBoneTextures && (this.boneTexture.lock(),
            this.boneTexture.unlock())
        },
        updateMatrices: function(a) {
            Vl.copy(a.getWorldTransform()).invert();
            for (a = this.bones.length - 1; 0 <= a; a--)
                this.matrices[a].mulAffine2(Vl, this.bones[a].getWorldTransform()),
                this.matrices[a].mulAffine2(this.matrices[a], this.skin.inverseBindPose[a])
        },
        updateMatrixPalette: function() {
            for (var a, b = this.matrixPalette, c, d = this.bones.length, e = 0; e < d; e++)
                a = this.matrices[e].data,
                c = 12 * e,
                b[c] = a[0],
                b[c + 1] = a[4],
                b[c + 2] = a[8],
                b[c + 3] = a[12],
                b[c + 4] = a[1],
                b[c + 5] = a[5],
                b[c + 6] = a[9],
                b[c + 7] = a[13],
                b[c + 8] = a[2],
                b[c + 9] = a[6],
                b[c + 10] = a[10],
                b[c + 11] = a[14];
            this.uploadBones(this.skin.device)
        }
    });
    Object.assign(sb.prototype, {
        getGraph: function() {
            return this.graph
        },
        setGraph: function(a) {
            this.graph = a
        },
        getCameras: function() {
            return this.cameras
        },
        setCameras: function(a) {
            this.cameras = a
        },
        getLights: function() {
            return this.lights
        },
        setLights: function(a) {
            this.lights = a
        },
        getMaterials: function() {
            var a, b = [];
            for (a = 0; a < this.meshInstances.length; a++) {
                var c = this.meshInstances[a];
                -1 === b.indexOf(c.material) && b.push(c.material)
            }
            return b
        },
        clone: function() {
            var a, b, c = [], d = [], e = function(r) {
                var t = r.clone();
                c.push(r);
                d.push(t);
                for (var u = 0; u < r._children.length; u++)
                    t.addChild(e(r._children[u]));
                return t
            }, f = e(this.graph), g = [], k = [], h = [];
            for (a = 0; a < this.skinInstances.length; a++) {
                var l = this.skinInstances[a].skin
                  , n = new Hc(l)
                  , p = [];
                for (b = 0; b < l.boneNames.length; b++) {
                    var q = f.findByName(l.boneNames[b]);
                    p.push(q)
                }
                n.bones = p;
                k.push(n)
            }
            for (a = 0; a < this.morphInstances.length; a++)
                b = new sf(this.morphInstances[a].morph),
                h.push(b);
            for (a = 0; a < this.meshInstances.length; a++)
                b = this.meshInstances[a],
                l = c.indexOf(b.node),
                l = new va(d[l],b.mesh,b.material),
                b.skinInstance && (n = this.skinInstances.indexOf(b.skinInstance),
                l.skinInstance = k[n]),
                b.morphInstance && (b = this.morphInstances.indexOf(b.morphInstance),
                l.morphInstance = h[b]),
                g.push(l);
            a = new sb;
            a.graph = f;
            a.meshInstances = g;
            a.skinInstances = k;
            a.morphInstances = h;
            a.getGraph().syncHierarchy();
            return a
        },
        destroy: function() {
            for (var a = this.meshInstances, b, c, d = 0; d < a.length; d++) {
                b = a[d];
                if (c = b.mesh)
                    b.mesh = null,
                    1 > c.refCount && c.destroy();
                (c = b.skinInstance) && (c = c.boneTexture) && c.destroy();
                b.skinInstance = null;
                (c = b.morphInstance) && c.destroy();
                b.morphInstance = null;
                b.material = null
            }
        },
        generateWireframe: function() {
            var a, b = [];
            for (a = 0; a < this.meshInstances.length; a++) {
                var c = this.meshInstances[a].mesh;
                -1 === b.indexOf(c) && b.push(c)
            }
            for (a = 0; a < b.length; ++a)
                c = b[a],
                c.primitive[1] || c.generateWireframe()
        }
    });
    bb.MODEL = "model";
    bb.ELEMENT = "element";
    bb.SPRITE = "sprite";
    Hd.prototype = Object.create(Hd.prototype);
    Hd.prototype.constructor = Hd;
    Object.assign(Hd.prototype, {
        updateMatrices: function(a) {},
        updateMatrixPalette: function() {
            for (var a, b = this.matrixPalette, c, d = this.bones.length, e = 0; e < d; e++)
                a = this.bones[e].getWorldTransform().data,
                c = 12 * e,
                b[c] = a[0],
                b[c + 1] = a[4],
                b[c + 2] = a[8],
                b[c + 3] = a[12],
                b[c + 4] = a[1],
                b[c + 5] = a[5],
                b[c + 6] = a[9],
                b[c + 7] = a[13],
                b[c + 8] = a[2],
                b[c + 9] = a[6],
                b[c + 10] = a[10],
                b[c + 11] = a[14];
            Hc.prototype.uploadBones.call(this, this.device)
        }
    });
    Ia.prototype.destroyManager = function() {
        this.scene = this.rootNode = this.device = null;
        this._batchGroups = {};
        this._batchList = [];
        this._dirtyGroups = []
    }
    ;
    Ia.prototype.addGroup = function(a, b, c, d, e) {
        void 0 === d && (d = this._batchGroupCounter,
        this._batchGroupCounter++);
        if (!this._batchGroups[d])
            return this._batchGroups[d] = a = new bb(d,a,b,c,e)
    }
    ;
    Ia.prototype.removeGroup = function(a) {
        if (this._batchGroups[a]) {
            for (var b = [], c = 0; c < this._batchList.length; c++)
                this._batchList[c].batchGroupId !== a ? b.push(this._batchList[c]) : this.destroy(this._batchList[c]);
            this._batchList = b;
            this._removeModelsFromBatchGroup(this.rootNode, a);
            delete this._batchGroups[a]
        }
    }
    ;
    Ia.prototype.markGroupDirty = function(a) {
        0 > this._dirtyGroups.indexOf(a) && this._dirtyGroups.push(a)
    }
    ;
    Ia.prototype.getGroupByName = function(a) {
        var b = this._batchGroups, c;
        for (c in b)
            if (b.hasOwnProperty(c) && b[c].name === a)
                return b[c];
        return null
    }
    ;
    Ia.prototype.getBatches = function(a) {
        for (var b = [], c = this._batchList.length, d = 0; d < c; d++) {
            var e = this._batchList[d];
            e.batchGroupId === a && b.push(e)
        }
        return b
    }
    ;
    Ia.prototype._removeModelsFromBatchGroup = function(a, b) {
        if (a.enabled) {
            a.model && a.model.batchGroupId === b && (a.model.batchGroupId = -1);
            a.element && a.element.batchGroupId === b && (a.element.batchGroupId = -1);
            a.sprite && a.sprite.batchGroupId === b && (a.sprite.batchGroupId = -1);
            for (var c = 0; c < a._children.length; c++)
                this._removeModelsFromBatchGroup(a._children[c], b)
        }
    }
    ;
    Ia.prototype.insert = function(a, b, c) {
        var d = this._batchGroups[b];
        d && 0 > d._obj[a].indexOf(c) && (d._obj[a].push(c),
        this.markGroupDirty(b))
    }
    ;
    Ia.prototype.remove = function(a, b, c) {
        var d = this._batchGroups[b];
        d && (c = d._obj[a].indexOf(c),
        0 <= c && (d._obj[a].splice(c, 1),
        this.markGroupDirty(b)))
    }
    ;
    Ia.prototype._extractModel = function(a, b, c, d) {
        if (!a.model || !a.model.model)
            return b;
        if (a.model.isStatic) {
            d = this.scene.drawCalls;
            var e = a.model.meshInstances;
            for (c = 0; c < d.length; c++)
                d[c]._staticSource && (0 > e.indexOf(d[c]._staticSource) || b.push(d[c]));
            for (c = 0; c < e.length; c++)
                0 <= d.indexOf(e[c]) && b.push(e[c])
        } else
            b = d[a.model.batchGroupId] = b.concat(a.model.meshInstances);
        a.model.removeModelFromLayers();
        return b
    }
    ;
    Ia.prototype._extractElement = function(a, b, c) {
        if (a.element) {
            var d = !1;
            a.element._text && 0 < a.element._text._model.meshInstances.length ? (b.push(a.element._text._model.meshInstances[0]),
            a.element.removeModelFromLayers(a.element._text._model),
            d = !0) : a.element._image && (b.push(a.element._image._renderable.meshInstance),
            a.element.removeModelFromLayers(a.element._image._renderable.model),
            a.element._image._renderable.unmaskMeshInstance && (b.push(a.element._image._renderable.unmaskMeshInstance),
            a.element._image._renderable.unmaskMeshInstance.stencilFront && a.element._image._renderable.unmaskMeshInstance.stencilBack || (a.element._dirtifyMask(),
            a.element._onPrerender())),
            d = !0);
            d && (c._ui = !0)
        }
    }
    ;
    Ia.prototype._collectAndRemoveModels = function(a, b) {
        for (var c, d, e, f = 0; f < b.length; f++)
            if (c = b[f],
            d = this._batchGroups[c]) {
                (e = a[c]) || (e = a[c] = []);
                for (c = 0; c < d._obj.model.length; c++)
                    e = this._extractModel(d._obj.model[c], e, d, a);
                for (c = 0; c < d._obj.element.length; c++)
                    this._extractElement(d._obj.element[c], e, d);
                for (var g = 0; g < d._obj.sprite.length; g++)
                    c = d._obj.sprite[g],
                    c.sprite && c.sprite._meshInstance && (d.dynamic || 0 === c.sprite.sprite._renderMode) && (e.push(c.sprite._meshInstance),
                    c.sprite.removeModelFromLayers(),
                    d._sprite = !0,
                    c.sprite._batchGroup = d)
            }
    }
    ;
    Ia.prototype.generate = function(a) {
        var b, c = {};
        a || (a = Object.keys(this._batchGroups));
        var d = [];
        for (b = 0; b < this._batchList.length; b++)
            0 > a.indexOf(this._batchList[b].batchGroupId) ? d.push(this._batchList[b]) : this.destroy(this._batchList[b]);
        this._batchList = d;
        this._collectAndRemoveModels(c, a);
        if (a === this._dirtyGroups)
            this._dirtyGroups.length = 0;
        else {
            d = [];
            for (b = 0; b < this._dirtyGroups.length; b++)
                0 > a.indexOf(this._dirtyGroups[b]) && d.push(this._dirtyGroups[b]);
            this._dirtyGroups = d
        }
        var e, f;
        for (f in c)
            if (c.hasOwnProperty(f) && (b = c[f],
            a = this._batchGroups[f])) {
                var g = this.prepare(b, a.dynamic, a.maxAabbSize, a._ui || a._sprite);
                for (b = 0; b < g.length; b++)
                    if (e = this.create(g[b], a.dynamic, parseInt(f, 10)))
                        for (d = 0; d < a.layers.length; d++) {
                            var k = this.scene.layers.getLayerById(a.layers[d]);
                            k && k.addMeshInstances(e.model.meshInstances)
                        }
            }
    }
    ;
    var wg = new z
      , yk = new z
      , zk = new z;
    Ia.prototype.prepare = function(a, b, c, d) {
        if (0 === a.length)
            return [];
        void 0 === c && (c = Number.POSITIVE_INFINITY);
        c *= .5;
        var e = this.device.supportsBoneTextures ? 1024 : this.device.boneLimit, f = this.device.extUintElement ? 4294967295 : 65535, g = new oa, k = new oa, h = null, l, n = [], p, q = 0;
        d && a.sort(function(I, T) {
            return I.drawOrder - T.drawOrder
        });
        for (var r = a, t, u = d ? function(I) {
            h ? h.add(I.aabb) : h = I.aabb.clone();
            t.push(I)
        }
        : function(I) {
            t.push(I)
        }
        ; 0 < r.length; ) {
            n[q] = [r[0]];
            t = [];
            a = r[0].material;
            var x = r[0].layer;
            var v = r[0]._shaderDefs;
            var w = r[0].parameters;
            var y = r[0].stencilFront;
            var A = r[0]._staticLightList;
            var B = r[0].mesh.vertexBuffer.getNumVertices();
            var E = r[0].drawOrder;
            g.copy(r[0].aabb);
            var C = gi(r[0]);
            var D = r[0].mesh.vertexBuffer.format.batchingHash;
            var G = r[0].mesh.primitive[0].indexed;
            h = null;
            for (p = 1; p < r.length; p++) {
                var J = r[p];
                if (b && n[q].length >= e) {
                    t = t.concat(r.slice(p));
                    break
                }
                if (a !== J.material || x !== J.layer || D !== J.mesh.vertexBuffer.format.batchingHash || G !== J.mesh.primitive[0].indexed || v !== J._shaderDefs || B + J.mesh.vertexBuffer.getNumVertices() > f)
                    u(J);
                else if (k.copy(g),
                k.add(J.aabb),
                k.halfExtents.x > c || k.halfExtents.y > c || k.halfExtents.z > c)
                    u(J);
                else if (!y || (l = J.stencilFront) && y.func == l.func && y.zpass == l.zpass)
                    if (C != gi(J))
                        u(J);
                    else if (Mn(w, J.parameters)) {
                        var R = J._staticLightList;
                        if (A && R) {
                            if (!Nn(A, R)) {
                                u(J);
                                continue
                            }
                        } else if (A || R) {
                            u(J);
                            continue
                        }
                        d && h && h.intersects(J.aabb) && J.drawOrder !== E ? u(J) : (g.add(J.aabb),
                        B += J.mesh.vertexBuffer.getNumVertices(),
                        n[q].push(J))
                    } else
                        u(J);
                else
                    u(J)
            }
            q++;
            r = t
        }
        return n
    }
    ;
    Ia.prototype.create = function(a, b, c) {
        this._init || (this.transformVS = "#define BONE_LIMIT " + this.device.getBoneLimit() + "\n#define DYNAMICBATCH\n" + F.transformVS,
        this.skinTexVS = F.skinBatchTexVS,
        this.skinConstVS = F.skinBatchConstVS,
        this.vertexFormats = {},
        this._init = !0);
        var d, e, f = null, g = null, k = 0, h = 0, l = null;
        for (d = 0; d < a.length; d++)
            if (a[d].visible) {
                var n = a[d].mesh;
                var p = n.vertexBuffer.numVertices;
                k += p;
                h += n.primitive[0].indexed ? n.primitive[0].count : 6 == n.primitive[0].type && 4 === n.primitive[0].count ? 6 : 0;
                if (!f) {
                    g = a[d].material;
                    f = {};
                    p = n.vertexBuffer.format.elements;
                    for (e = 0; e < p.length; e++) {
                        var q = p[e].name;
                        f[q] = {
                            numComponents: p[e].numComponents,
                            dataType: p[e].dataType,
                            normalize: p[e].normalize,
                            count: 0
                        }
                    }
                    b && (f.BLENDINDICES = {
                        numComponents: 1,
                        dataType: 6,
                        normalize: !1,
                        count: 0
                    })
                }
            }
        if (f) {
            l = new fi(a,b,c);
            this._batchList.push(l);
            var r = 0, t = 0, u, x = new z;
            h = new (65535 >= k ? Uint16Array : Uint32Array)(h);
            for (q in f) {
                var v = f[q];
                v.typeArrayType = Dd[v.dataType];
                v.elementByteSize = qf[v.dataType];
                v.buffer = new v.typeArrayType(k * v.numComponents)
            }
            for (d = 0; d < a.length; d++)
                if (a[d].visible) {
                    n = a[d].mesh;
                    p = n.vertexBuffer.numVertices;
                    b || (u = a[d].node.getWorldTransform());
                    for (q in f)
                        if ("BLENDINDICES" !== q) {
                            v = f[q];
                            k = new v.typeArrayType(v.buffer.buffer,v.elementByteSize * v.count);
                            var w = n.getVertexStream(q, k) * v.numComponents;
                            v.count += w;
                            if (!b && 3 <= v.numComponents && ("POSITION" == q || "NORMAL" == q || "TANGENT" == q))
                                for (u.transformFunction = "POSITION" == q ? K.prototype.transformPoint : K.prototype.transformVector,
                                e = 0; e < w; e += v.numComponents)
                                    x.set(k[e], k[e + 1], k[e + 2]),
                                    u.transformFunction(x, x),
                                    k[e] = x.x,
                                    k[e + 1] = x.y,
                                    k[e + 2] = x.z
                        }
                    if (b)
                        for (v = f.BLENDINDICES,
                        e = 0; e < p; e++)
                            v.buffer[v.count++] = d;
                    if (n.primitive[0].indexed)
                        v = n.primitive[0].base,
                        k = n.primitive[0].count,
                        e = n.indexBuffer[0].getFormat(),
                        n = new Ul[e](n.indexBuffer[0].storage);
                    else if (6 == n.primitive[0].type && 4 === n.primitive[0].count)
                        v = 0,
                        k = 6,
                        n = [0, 1, 3, 2, 3, 1];
                    else
                        continue;
                    for (e = 0; e < k; e++)
                        h[e + t] = n[v + e] + r;
                    t += k;
                    r += p
                }
            n = new rb(this.device);
            for (q in f)
                v = f[q],
                n.setVertexStream(q, v.buffer, v.numComponents, void 0, v.dataType, v.normalize);
            0 < h.length && n.setIndices(h);
            n.update(4, !1);
            b && (g = g.clone(),
            g.chunks.transformVS = this.transformVS,
            g.chunks.skinTexVS = this.skinTexVS,
            g.chunks.skinConstVS = this.skinConstVS,
            g.update());
            a = new va(this.rootNode,n,g);
            a.castShadow = l.origMeshInstances[0].castShadow;
            a.parameters = l.origMeshInstances[0].parameters;
            a.isStatic = l.origMeshInstances[0].isStatic;
            a.layer = l.origMeshInstances[0].layer;
            a._staticLightList = l.origMeshInstances[0]._staticLightList;
            a._shaderDefs = l.origMeshInstances[0]._shaderDefs;
            a.cull = l.origMeshInstances[0].cull;
            (d = this._batchGroups[c]) && d._ui && (a.cull = !1);
            if (b) {
                b = [];
                for (d = 0; d < l.origMeshInstances.length; d++)
                    b.push(l.origMeshInstances[d].node);
                a.skinInstance = new Hd(this.device,b,this.rootNode)
            }
            a._updateAabb = !1;
            a.drawOrder = l.origMeshInstances[0].drawOrder;
            a.stencilFront = l.origMeshInstances[0].stencilFront;
            a.stencilBack = l.origMeshInstances[0].stencilBack;
            a.flipFaces = 0 > gi(l.origMeshInstances[0]);
            l.meshInstance = a;
            this.update(l);
            b = new sb;
            b.meshInstances = [l.meshInstance];
            b.castShadows = l.origMeshInstances[0].castShadows;
            l.model = b
        }
        return l
    }
    ;
    Ia.prototype.update = function(a) {
        a._aabb.copy(a.origMeshInstances[0].aabb);
        for (var b = 1; b < a.origMeshInstances.length; b++)
            a._aabb.add(a.origMeshInstances[b].aabb);
        a.meshInstance.aabb = a._aabb;
        a._aabb._radiusVer = -1;
        a.meshInstance._aabbVer = 0
    }
    ;
    Ia.prototype.updateAll = function() {
        0 < this._dirtyGroups.length && this.generate(this._dirtyGroups);
        for (var a = 0; a < this._batchList.length; a++)
            this._batchList[a].dynamic && this.update(this._batchList[a])
    }
    ;
    Ia.prototype.clone = function(a, b) {
        var c = new fi(b,a.dynamic,a.batchGroupId);
        this._batchList.push(c);
        for (var d = [], e = 0; e < b.length; e++)
            d.push(b[e].node);
        c.meshInstance = new va(a.meshInstance.node,a.meshInstance.mesh,a.meshInstance.material);
        c.meshInstance._updateAabb = !1;
        c.meshInstance.parameters = b[0].parameters;
        c.meshInstance.isStatic = b[0].isStatic;
        c.meshInstance.cull = b[0].cull;
        c.meshInstance.layer = b[0].layer;
        c.meshInstance._staticLightList = b[0]._staticLightList;
        a.dynamic && (c.meshInstance.skinInstance = new Hd(this.device,d,this.rootNode));
        c.meshInstance.castShadow = a.meshInstance.castShadow;
        c.meshInstance._shader = a.meshInstance._shader;
        b = new sb;
        b.meshInstances = [c.meshInstance];
        b.castShadows = a.origMeshInstances[0].castShadows;
        c.model = b;
        return c
    }
    ;
    Ia.prototype.destroy = function(a) {
        a.refCounter = 0;
        if (a.model) {
            for (var b = this._batchGroups[a.batchGroupId].layers, c = 0; c < b.length; c++) {
                var d = this.scene.layers.getLayerById(b[c]);
                d && d.removeMeshInstances(a.model.meshInstances)
            }
            a.model.destroy()
        }
    }
    ;
    Ia.prototype.decrement = function(a) {
        a.refCounter--;
        0 === a.refCounter && this.destroy(a)
    }
    ;
    var Ue = new z
      , ee = new z
      , Wl = new z
      , Xl = new K;
    Object.defineProperty(pa.prototype, "aspectRatio", {
        get: function() {
            return this._aspectRatio
        },
        set: function(a) {
            this._aspectRatio !== a && (this._aspectRatio = a,
            this._projMatDirty = !0)
        }
    });
    Object.defineProperty(pa.prototype, "aspectRatioMode", {
        get: function() {
            return this._aspectRatioMode
        },
        set: function(a) {
            this._aspectRatioMode !== a && (this._aspectRatioMode = a,
            this._projMatDirty = !0)
        }
    });
    Object.defineProperty(pa.prototype, "calculateProjection", {
        get: function() {
            return this._calculateProjection
        },
        set: function(a) {
            this._calculateProjection = a;
            this._projMatDirty = !0
        }
    });
    Object.defineProperty(pa.prototype, "calculateTransform", {
        get: function() {
            return this._calculateTransform
        },
        set: function(a) {
            this._calculateTransform = a
        }
    });
    Object.defineProperty(pa.prototype, "clearColor", {
        get: function() {
            return this._clearColor
        },
        set: function(a) {
            this._clearColor.copy(a)
        }
    });
    Object.defineProperty(pa.prototype, "clearColorBuffer", {
        get: function() {
            return this._clearColorBuffer
        },
        set: function(a) {
            this._clearColorBuffer = a
        }
    });
    Object.defineProperty(pa.prototype, "clearDepth", {
        get: function() {
            return this._clearDepth
        },
        set: function(a) {
            this._clearDepth = a
        }
    });
    Object.defineProperty(pa.prototype, "clearDepthBuffer", {
        get: function() {
            return this._clearDepthBuffer
        },
        set: function(a) {
            this._clearDepthBuffer = a
        }
    });
    Object.defineProperty(pa.prototype, "clearStencil", {
        get: function() {
            return this._clearStencil
        },
        set: function(a) {
            this._clearStencil = a
        }
    });
    Object.defineProperty(pa.prototype, "clearStencilBuffer", {
        get: function() {
            return this._clearStencilBuffer
        },
        set: function(a) {
            this._clearStencilBuffer = a
        }
    });
    Object.defineProperty(pa.prototype, "cullingMask", {
        get: function() {
            return this._cullingMask
        },
        set: function(a) {
            this._cullingMask = a
        }
    });
    Object.defineProperty(pa.prototype, "cullFaces", {
        get: function() {
            return this._cullFaces
        },
        set: function(a) {
            this._cullFaces = a
        }
    });
    Object.defineProperty(pa.prototype, "farClip", {
        get: function() {
            return this._farClip
        },
        set: function(a) {
            this._farClip !== a && (this._farClip = a,
            this._projMatDirty = !0)
        }
    });
    Object.defineProperty(pa.prototype, "flipFaces", {
        get: function() {
            return this._flipFaces
        },
        set: function(a) {
            this._flipFaces = a
        }
    });
    Object.defineProperty(pa.prototype, "fov", {
        get: function() {
            return this._fov
        },
        set: function(a) {
            this._fov !== a && (this._fov = a,
            this._projMatDirty = !0)
        }
    });
    Object.defineProperty(pa.prototype, "frustumCulling", {
        get: function() {
            return this._frustumCulling
        },
        set: function(a) {
            this._frustumCulling = a
        }
    });
    Object.defineProperty(pa.prototype, "horizontalFov", {
        get: function() {
            return this._horizontalFov
        },
        set: function(a) {
            this._horizontalFov !== a && (this._horizontalFov = a,
            this._projMatDirty = !0)
        }
    });
    Object.defineProperty(pa.prototype, "layers", {
        get: function() {
            return this._layers
        },
        set: function(a) {
            this._layers = a.slice(0)
        }
    });
    Object.defineProperty(pa.prototype, "nearClip", {
        get: function() {
            return this._nearClip
        },
        set: function(a) {
            this._nearClip !== a && (this._nearClip = a,
            this._projMatDirty = !0)
        }
    });
    Object.defineProperty(pa.prototype, "node", {
        get: function() {
            return this._node
        },
        set: function(a) {
            this._node = a
        }
    });
    Object.defineProperty(pa.prototype, "orthoHeight", {
        get: function() {
            return this._orthoHeight
        },
        set: function(a) {
            this._orthoHeight !== a && (this._orthoHeight = a,
            this._projMatDirty = !0)
        }
    });
    Object.defineProperty(pa.prototype, "projection", {
        get: function() {
            return this._projection
        },
        set: function(a) {
            this._projection !== a && (this._projection = a,
            this._projMatDirty = !0)
        }
    });
    Object.defineProperty(pa.prototype, "projectionMatrix", {
        get: function() {
            this._evaluateProjectionMatrix();
            return this._projMat
        }
    });
    Object.defineProperty(pa.prototype, "rect", {
        get: function() {
            return this._rect
        },
        set: function(a) {
            this._rect.copy(a)
        }
    });
    Object.defineProperty(pa.prototype, "renderTarget", {
        get: function() {
            return this._renderTarget
        },
        set: function(a) {
            this._renderTarget = a
        }
    });
    Object.defineProperty(pa.prototype, "scissorRect", {
        get: function() {
            return this._scissorRect
        },
        set: function(a) {
            this._scissorRect.copy(a)
        }
    });
    Object.defineProperty(pa.prototype, "viewMatrix", {
        get: function() {
            if (this._viewMatDirty) {
                var a = this._node.getWorldTransform();
                this._viewMat.copy(a).invert();
                this._viewMatDirty = !1
            }
            return this._viewMat
        }
    });
    Object.defineProperty(pa.prototype, "vrDisplay", {
        get: function() {
            return this._vrDisplay
        },
        set: function(a) {
            if (this._vrDisplay = a)
                a._camera = this
        }
    });
    Object.assign(pa.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.aspectRatio = a.aspectRatio;
            this.aspectRatioMode = a.aspectRatioMode;
            this.calculateProjection = a.calculateProjection;
            this.calculateTransform = a.calculateTransform;
            this.clearColor = a.clearColor;
            this.clearColorBuffer = a.clearColorBuffer;
            this.clearDepth = a.clearDepth;
            this.clearDepthBuffer = a.clearDepthBuffer;
            this.clearStencil = a.clearStencil;
            this.clearStencilBuffer = a.clearStencilBuffer;
            this.cullFaces = a.cullFaces;
            this.cullingMask = a.cullingMask;
            this.farClip = a.farClip;
            this.flipFaces = a.flipFaces;
            this.fov = a.fov;
            this.frustumCulling = a.frustumCulling;
            this.horizontalFov = a.horizontalFov;
            this.layers = a.layers;
            this.nearClip = a.nearClip;
            this.orthoHeight = a.orthoHeight;
            this.projection = a.projection;
            this.rect = a.rect;
            this.renderTarget = a.renderTarget;
            this.scissorRect = a.scissorRect;
            this.vrDisplay = a.vrDisplay
        },
        _updateViewProjMat: function() {
            if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty)
                this._viewProjMat.mul2(this.projectionMatrix, this.viewMatrix),
                this._viewProjMatDirty = !1
        },
        worldToScreen: function(a, b, c, d) {
            void 0 === d && (d = new z);
            this._updateViewProjMat();
            this._viewProjMat.transformPoint(a, d);
            var e = this._viewProjMat.data;
            a = a.x * e[3] + a.y * e[7] + a.z * e[11] + 1 * e[15];
            d.x = .5 * (d.x / a + 1) * b;
            d.y = .5 * (1 - d.y / a) * c;
            return d
        },
        screenToWorld: function(a, b, c, d, e, f) {
            void 0 === f && (f = new z);
            Ue.set(a / d, (e - b) / e, c / (this._farClip - this._nearClip));
            Ue.scale(2);
            Ue.sub(z.ONE);
            0 === this._projection ? (K._getPerspectiveHalfSize(ee, this._fov, this._aspectRatio, this._nearClip, this._horizontalFov),
            ee.x *= Ue.x,
            ee.y *= Ue.y,
            a = this._node.getWorldTransform(),
            ee.z = -this._nearClip,
            a.transformPoint(ee, Wl),
            a = this._node.getPosition(),
            f.sub2(Wl, a),
            f.normalize(),
            f.scale(c),
            f.add(a)) : (this._updateViewProjMat(),
            Xl.copy(this._viewProjMat).invert(),
            Xl.transformPoint(Ue, f));
            return f
        },
        _evaluateProjectionMatrix: function() {
            if (this._projMatDirty) {
                if (0 === this._projection)
                    this._projMat.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip, this._horizontalFov),
                    this._projMatSkybox.copy(this._projMat);
                else {
                    var a = this._orthoHeight
                      , b = a * this._aspectRatio;
                    this._projMat.setOrtho(-b, b, -a, a, this._nearClip, this._farClip);
                    this._projMatSkybox.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip)
                }
                this._projMatDirty = !1
            }
        },
        getProjectionMatrixSkybox: function() {
            this._evaluateProjectionMatrix();
            return this._projMatSkybox
        }
    });
    var Yl = new K
      , Qj = new z
      , Zl = new Y
      , Rj = new Y
      , $l = new z
      , am = new z
      , ap = new K
      , bp = new Y;
    Z.prototype = Object.create(M.prototype);
    Z.prototype.constructor = Z;
    Object.defineProperty(Z.prototype, "right", {
        get: function() {
            this._right || (this._right = new z);
            return this.getWorldTransform().getX(this._right).normalize()
        }
    });
    Object.defineProperty(Z.prototype, "up", {
        get: function() {
            this._up || (this._up = new z);
            return this.getWorldTransform().getY(this._up).normalize()
        }
    });
    Object.defineProperty(Z.prototype, "forward", {
        get: function() {
            this._forward || (this._forward = new z);
            return this.getWorldTransform().getZ(this._forward).normalize().scale(-1)
        }
    });
    Object.defineProperty(Z.prototype, "enabled", {
        get: function() {
            return this._enabled && this._enabledInHierarchy
        },
        set: function(a) {
            this._enabled !== a && (this._enabled = a,
            this._parent && !this._parent.enabled || this._notifyHierarchyStateChanged(this, a))
        }
    });
    Object.defineProperty(Z.prototype, "parent", {
        get: function() {
            return this._parent
        }
    });
    Object.defineProperty(Z.prototype, "path", {
        get: function() {
            var a = this._parent;
            if (a) {
                for (var b = this.name; a && a._parent; )
                    b = a.name + "/" + b,
                    a = a._parent;
                return b
            }
            return ""
        }
    });
    Object.defineProperty(Z.prototype, "root", {
        get: function() {
            var a = this._parent;
            if (!a)
                return this;
            for (; a._parent; )
                a = a._parent;
            return a
        }
    });
    Object.defineProperty(Z.prototype, "children", {
        get: function() {
            return this._children
        }
    });
    Object.defineProperty(Z.prototype, "graphDepth", {
        get: function() {
            return this._graphDepth
        }
    });
    Object.assign(Z.prototype, {
        _notifyHierarchyStateChanged: function(a, b) {
            a._onHierarchyStateChanged(b);
            a = a._children;
            for (var c = 0, d = a.length; c < d; c++)
                a[c]._enabled && this._notifyHierarchyStateChanged(a[c], b)
        },
        _onHierarchyStateChanged: function(a) {
            (this._enabledInHierarchy = a) && !this._frozen && this._unfreezeParentToRoot()
        },
        _cloneInternal: function(a) {
            a.name = this.name;
            for (var b = this.tags._list, c = 0; c < b.length; c++)
                a.tags.add(b[c]);
            a._labels = Object.assign({}, this._labels);
            a.localPosition.copy(this.localPosition);
            a.localRotation.copy(this.localRotation);
            a.localScale.copy(this.localScale);
            a.localEulerAngles.copy(this.localEulerAngles);
            a.position.copy(this.position);
            a.rotation.copy(this.rotation);
            a.eulerAngles.copy(this.eulerAngles);
            a.localTransform.copy(this.localTransform);
            a._dirtyLocal = this._dirtyLocal;
            a.worldTransform.copy(this.worldTransform);
            a._dirtyWorld = this._dirtyWorld;
            a._dirtyNormal = this._dirtyNormal;
            a._aabbVer = this._aabbVer + 1;
            a._enabled = this._enabled;
            a.scaleCompensation = this.scaleCompensation;
            a._enabledInHierarchy = !1
        },
        clone: function() {
            var a = new Z;
            this._cloneInternal(a);
            return a
        },
        find: function(a, b) {
            var c = [], d = this._children.length, e;
            if (a instanceof Function)
                for ((b = a(this)) && c.push(this),
                e = 0; e < d; e++) {
                    var f = this._children[e].find(a);
                    f.length && (c = c.concat(f))
                }
            else
                for (this[a] && (e = this[a]instanceof Function ? this[a]() : this[a],
                e === b && c.push(this)),
                e = 0; e < d; ++e)
                    f = this._children[e].find(a, b),
                    f.length && (c = c.concat(f));
            return c
        },
        findOne: function(a, b) {
            var c, d = this._children.length, e;
            if (a instanceof Function) {
                if (e = a(this))
                    return this;
                for (c = 0; c < d; c++)
                    if (e = this._children[c].findOne(a))
                        return e
            } else {
                if (this[a] && (c = this[a]instanceof Function ? this[a]() : this[a],
                c === b))
                    return this;
                for (c = 0; c < d; c++)
                    if (e = this._children[c].findOne(a, b),
                    null !== e)
                        return e
            }
            return null
        },
        findByTag: function() {
            var a = this.tags._processArguments(arguments);
            return this._findByTag(a)
        },
        _findByTag: function(a) {
            var b = [], c, d = this._children.length;
            for (c = 0; c < d; c++) {
                this._children[c].tags._has(a) && b.push(this._children[c]);
                var e = this._children[c]._findByTag(a);
                e.length && (b = b.concat(e))
            }
            return b
        },
        findByName: function(a) {
            if (this.name === a)
                return this;
            for (var b = 0; b < this._children.length; b++) {
                var c = this._children[b].findByName(a);
                if (null !== c)
                    return c
            }
            return null
        },
        findByPath: function(a) {
            a = a.split("/");
            for (var b = this, c = null, d = 0, e = a.length; d < e && b; d++) {
                var f = a[d];
                c = null;
                b = b._children;
                for (var g = 0, k = b.length; g < k; g++)
                    if (b[g].name == f) {
                        c = b[g];
                        break
                    }
                b = c
            }
            return c
        },
        forEach: function(a, b) {
            a.call(b, this);
            for (var c = this._children, d = 0; d < c.length; d++)
                c[d].forEach(a, b)
        },
        isDescendantOf: function(a) {
            for (var b = this._parent; b; ) {
                if (b === a)
                    return !0;
                b = b._parent
            }
            return !1
        },
        isAncestorOf: function(a) {
            return a.isDescendantOf(this)
        },
        getEulerAngles: function() {
            this.getWorldTransform().getEulerAngles(this.eulerAngles);
            return this.eulerAngles
        },
        getLocalEulerAngles: function() {
            this.localRotation.getEulerAngles(this.localEulerAngles);
            return this.localEulerAngles
        },
        getLocalPosition: function() {
            return this.localPosition
        },
        getLocalRotation: function() {
            return this.localRotation
        },
        getLocalScale: function() {
            return this.localScale
        },
        getLocalTransform: function() {
            this._dirtyLocal && (this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale),
            this._dirtyLocal = !1);
            return this.localTransform
        },
        getPosition: function() {
            this.getWorldTransform().getTranslation(this.position);
            return this.position
        },
        getRotation: function() {
            this.rotation.setFromMat4(this.getWorldTransform());
            return this.rotation
        },
        getScale: function() {
            this._scale || (this._scale = new z);
            return this.getWorldTransform().getScale(this._scale)
        },
        getWorldTransform: function() {
            if (!this._dirtyLocal && !this._dirtyWorld)
                return this.worldTransform;
            this._parent && this._parent.getWorldTransform();
            this._sync();
            return this.worldTransform
        },
        reparent: function(a, b) {
            var c = this._parent;
            c && c.removeChild(this);
            a && (0 <= b ? a.insertChild(this, b) : a.addChild(this))
        },
        setLocalEulerAngles: function(a, b, c) {
            a instanceof z ? this.localRotation.setFromEulerAngles(a.x, a.y, a.z) : this.localRotation.setFromEulerAngles(a, b, c);
            this._dirtyLocal || this._dirtifyLocal()
        },
        setLocalPosition: function(a, b, c) {
            a instanceof z ? this.localPosition.copy(a) : this.localPosition.set(a, b, c);
            this._dirtyLocal || this._dirtifyLocal()
        },
        setLocalRotation: function(a, b, c, d) {
            a instanceof Y ? this.localRotation.copy(a) : this.localRotation.set(a, b, c, d);
            this._dirtyLocal || this._dirtifyLocal()
        },
        setLocalScale: function(a, b, c) {
            a instanceof z ? this.localScale.copy(a) : this.localScale.set(a, b, c);
            this._dirtyLocal || this._dirtifyLocal()
        },
        _dirtifyLocal: function() {
            this._dirtyLocal || (this._dirtyLocal = !0,
            this._dirtyWorld || this._dirtifyWorld())
        },
        _unfreezeParentToRoot: function() {
            for (var a = this._parent; a; )
                a._frozen = !1,
                a = a._parent
        },
        _dirtifyWorld: function() {
            this._dirtyWorld || this._unfreezeParentToRoot();
            this._dirtifyWorldInternal()
        },
        _dirtifyWorldInternal: function() {
            if (!this._dirtyWorld) {
                this._frozen = !1;
                this._dirtyWorld = !0;
                for (var a = 0; a < this._children.length; a++)
                    this._children[a]._dirtyWorld || this._children[a]._dirtifyWorldInternal()
            }
            this._dirtyNormal = !0;
            this._aabbVer++
        },
        setPosition: function() {
            var a = new z
              , b = new K;
            return function(c, d, e) {
                c instanceof z ? a.copy(c) : a.set(c, d, e);
                null === this._parent ? this.localPosition.copy(a) : (b.copy(this._parent.getWorldTransform()).invert(),
                b.transformPoint(a, this.localPosition));
                this._dirtyLocal || this._dirtifyLocal()
            }
        }(),
        setRotation: function() {
            var a = new Y
              , b = new Y;
            return function(c, d, e, f) {
                c instanceof Y ? a.copy(c) : a.set(c, d, e, f);
                null === this._parent ? this.localRotation.copy(a) : (c = this._parent.getRotation(),
                b.copy(c).invert(),
                this.localRotation.copy(b).mul(a));
                this._dirtyLocal || this._dirtifyLocal()
            }
        }(),
        setEulerAngles: function() {
            var a = new Y;
            return function(b, c, d) {
                b instanceof z ? this.localRotation.setFromEulerAngles(b.x, b.y, b.z) : this.localRotation.setFromEulerAngles(b, c, d);
                null !== this._parent && (b = this._parent.getRotation(),
                a.copy(b).invert(),
                this.localRotation.mul2(a, this.localRotation));
                this._dirtyLocal || this._dirtifyLocal()
            }
        }(),
        addChild: function(a) {
            if (null !== a._parent)
                throw Error("GraphNode is already parented");
            this._children.push(a);
            this._onInsertChild(a)
        },
        addChildAndSaveTransform: function(a) {
            var b = a.getPosition()
              , c = a.getRotation()
              , d = a._parent;
            d && d.removeChild(a);
            a.setPosition(ap.copy(this.worldTransform).invert().transformPoint(b));
            a.setRotation(bp.copy(this.getRotation()).invert().mul(c));
            this._children.push(a);
            this._onInsertChild(a)
        },
        insertChild: function(a, b) {
            if (null !== a._parent)
                throw Error("GraphNode is already parented");
            this._children.splice(b, 0, a);
            this._onInsertChild(a)
        },
        _onInsertChild: function(a) {
            a._parent = this;
            var b = a._enabled && this.enabled;
            a._enabledInHierarchy !== b && (a._enabledInHierarchy = b,
            a._notifyHierarchyStateChanged(a, b));
            a._updateGraphDepth();
            a._dirtifyWorld();
            this._frozen && a._unfreezeParentToRoot();
            a.fire && a.fire("insert", this);
            this.fire && this.fire("childinsert", a)
        },
        _updateGraphDepth: function() {
            this._graphDepth = this._parent ? this._parent._graphDepth + 1 : 0;
            for (var a = 0, b = this._children.length; a < b; a++)
                this._children[a]._updateGraphDepth()
        },
        removeChild: function(a) {
            var b, c = this._children.length;
            for (b = 0; b < c; ++b)
                if (this._children[b] === a) {
                    this._children.splice(b, 1);
                    a._parent = null;
                    a.fire && a.fire("remove", this);
                    this.fire && this.fire("childremove", a);
                    break
                }
        },
        _sync: function() {
            this._dirtyLocal && (this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale),
            this._dirtyLocal = !1);
            if (this._dirtyWorld) {
                if (null === this._parent)
                    this.worldTransform.copy(this.localTransform);
                else if (this.scaleCompensation) {
                    var a = this._parent
                      , b = this.localScale
                      , c = a;
                    if (c) {
                        for (; c && c.scaleCompensation; )
                            c = c._parent;
                        if (c && (c = c._parent)) {
                            var d = c.worldTransform.getScale();
                            $l.mul2(d, this.localScale);
                            b = $l
                        }
                    }
                    Rj.setFromMat4(a.worldTransform);
                    Zl.mul2(Rj, this.localRotation);
                    c = a.worldTransform;
                    a.scaleCompensation && (am.mul2(d, a.getLocalScale()),
                    Yl.setTRS(a.worldTransform.getTranslation(Qj), Rj, am),
                    c = Yl);
                    c.transformPoint(this.localPosition, Qj);
                    this.worldTransform.setTRS(Qj, Zl, b)
                } else
                    this.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);
                this._dirtyWorld = !1
            }
        },
        syncHierarchy: function() {
            if (this._enabled && !this._frozen) {
                this._frozen = !0;
                (this._dirtyLocal || this._dirtyWorld) && this._sync();
                for (var a = this._children, b = 0, c = a.length; b < c; b++)
                    a[b].syncHierarchy()
            }
        },
        lookAt: function() {
            var a = new K
              , b = new z
              , c = new z
              , d = new Y;
            return function(e, f, g, k, h, l) {
                if (e instanceof z)
                    b.copy(e),
                    f instanceof z ? c.copy(f) : c.copy(z.UP);
                else {
                    if (void 0 === g)
                        return;
                    b.set(e, f, g);
                    void 0 !== k ? c.set(k, h, l) : c.copy(z.UP)
                }
                a.setLookAt(this.getPosition(), b, c);
                d.setFromMat4(a);
                this.setRotation(d)
            }
        }(),
        translate: function() {
            var a = new z;
            return function(b, c, d) {
                b instanceof z ? a.copy(b) : a.set(b, c, d);
                a.add(this.getPosition());
                this.setPosition(a)
            }
        }(),
        translateLocal: function() {
            var a = new z;
            return function(b, c, d) {
                b instanceof z ? a.copy(b) : a.set(b, c, d);
                this.localRotation.transformVector(a, a);
                this.localPosition.add(a);
                this._dirtyLocal || this._dirtifyLocal()
            }
        }(),
        rotate: function() {
            var a = new Y
              , b = new Y;
            return function(c, d, e) {
                c instanceof z ? a.setFromEulerAngles(c.x, c.y, c.z) : a.setFromEulerAngles(c, d, e);
                null === this._parent ? this.localRotation.mul2(a, this.localRotation) : (c = this.getRotation(),
                d = this._parent.getRotation(),
                b.copy(d).invert(),
                a.mul2(b, a),
                this.localRotation.mul2(a, c));
                this._dirtyLocal || this._dirtifyLocal()
            }
        }(),
        rotateLocal: function() {
            var a = new Y;
            return function(b, c, d) {
                b instanceof z ? a.setFromEulerAngles(b.x, b.y, b.z) : a.setFromEulerAngles(b, c, d);
                this.localRotation.mul(a);
                this._dirtyLocal || this._dirtifyLocal()
            }
        }()
    });
    var Sj, Tj, ph, qh, cp = [null, function(a, b) {
        return a.drawOrder - b.drawOrder
    }
    , function(a, b) {
        Sj = a._key[0];
        Tj = b._key[0];
        return Sj === Tj && a.mesh && b.mesh ? b.mesh.id - a.mesh.id : Tj - Sj
    }
    , function(a, b) {
        return b.zdist - a.zdist
    }
    , function(a, b) {
        return a.zdist - b.zdist
    }
    ], hi = 0;
    Bk.prototype.clearVisibleLists = function(a) {
        this.visibleOpaque[a] && (this.visibleOpaque[a].length = 0,
        this.visibleOpaque[a].list.length = 0);
        this.visibleTransparent[a] && (this.visibleTransparent[a].length = 0,
        this.visibleTransparent[a].list.length = 0)
    }
    ;
    Object.defineProperty(ma.prototype, "enabled", {
        get: function() {
            return this._enabled
        },
        set: function(a) {
            if (a !== this._enabled)
                if (this._enabled = a) {
                    if (this.incrementCounter(),
                    this.onEnable)
                        this.onEnable()
                } else if (this.decrementCounter(),
                this.onDisable)
                    this.onDisable()
        }
    });
    Object.defineProperty(ma.prototype, "clearColor", {
        get: function() {
            return this._clearColor
        },
        set: function(a) {
            this._clearColor.copy(a)
        }
    });
    ma.prototype._updateClearFlags = function() {
        var a = 0;
        this._clearColorBuffer && (a |= 1);
        this._clearDepthBuffer && (a |= 2);
        this._clearStencilBuffer && (a |= 4);
        this._clearOptions.flags = a
    }
    ;
    Object.defineProperty(ma.prototype, "clearColorBuffer", {
        get: function() {
            return this._clearColorBuffer
        },
        set: function(a) {
            this._clearColorBuffer = a;
            this._updateClearFlags()
        }
    });
    Object.defineProperty(ma.prototype, "clearDepthBuffer", {
        get: function() {
            return this._clearDepthBuffer
        },
        set: function(a) {
            this._clearDepthBuffer = a;
            this._updateClearFlags()
        }
    });
    Object.defineProperty(ma.prototype, "clearStencilBuffer", {
        get: function() {
            return this._clearStencilBuffer
        },
        set: function(a) {
            this._clearStencilBuffer = a;
            this._updateClearFlags()
        }
    });
    ma.prototype.incrementCounter = function() {
        if (0 === this._refCounter && (this._enabled = !0,
        this.onEnable))
            this.onEnable();
        this._refCounter++
    }
    ;
    ma.prototype.decrementCounter = function() {
        if (1 === this._refCounter) {
            if (this._enabled = !1,
            this.onDisable)
                this.onDisable()
        } else if (0 === this._refCounter)
            return;
        this._refCounter--
    }
    ;
    ma.prototype.addMeshInstances = function(a, b) {
        for (var c = this._shaderVersion, d, e, f, g = this.shadowCasters, k = 0; k < a.length; k++)
            d = a[k],
            f = d.material,
            e = 3 === f.blendType ? this.opaqueMeshInstances : this.transparentMeshInstances,
            0 > e.indexOf(d) && e.push(d),
            !b && d.castShadow && 0 > g.indexOf(d) && g.push(d),
            !this.passThrough && 0 <= c && f._shaderVersion !== c && (f.updateShader !== ka.prototype.updateShader && (f.clearVariants(),
            f.shader = null),
            f._shaderVersion = c);
        this.passThrough || (this._dirty = !0)
    }
    ;
    ma.prototype.removeMeshInstances = function(a, b) {
        var c, d, e = this.opaqueMeshInstances, f = this.transparentMeshInstances, g = this.shadowCasters;
        for (c = 0; c < a.length; c++) {
            var k = a[c];
            var h = -1;
            var l = 0;
            var n = e.length;
            for (d = 0; d < n; d++) {
                var p = e[d];
                if (p === k) {
                    h = d;
                    l = 1;
                    break
                }
                if (p._staticSource === k)
                    0 > h && (h = d),
                    l++;
                else if (0 <= h)
                    break
            }
            0 <= h && e.splice(h, l);
            h = -1;
            l = 0;
            n = f.length;
            for (d = 0; d < n; d++) {
                p = f[d];
                if (p === k) {
                    h = d;
                    l = 1;
                    break
                }
                if (p._staticSource === k)
                    0 > h && (h = d),
                    l++;
                else if (0 <= h)
                    break
            }
            0 <= h && f.splice(h, l);
            b || (d = g.indexOf(k),
            0 <= d && g.splice(d, 1))
        }
        this._dirty = !0
    }
    ;
    ma.prototype.clearMeshInstances = function(a) {
        if (0 !== this.opaqueMeshInstances.length || 0 !== this.transparentMeshInstances.length || !a && 0 !== this.shadowCasters.length)
            this.opaqueMeshInstances.length = 0,
            this.transparentMeshInstances.length = 0,
            a || (this.shadowCasters.length = 0),
            this.passThrough || (this._dirty = !0)
    }
    ;
    ma.prototype.addLight = function(a) {
        0 <= this._lightComponents.indexOf(a) || (this._lightComponents.push(a),
        this._lights.push(a.light),
        this._dirtyLights = !0,
        this._generateLightHash())
    }
    ;
    ma.prototype.removeLight = function(a) {
        var b = this._lightComponents.indexOf(a);
        0 > b || (this._lightComponents.splice(b, 1),
        b = this._lights.indexOf(a.light),
        this._lights.splice(b, 1),
        this._dirtyLights = !0,
        this._generateLightHash())
    }
    ;
    ma.prototype.clearLights = function() {
        this._lightComponents.length = 0;
        this._lights.length = 0;
        this._dirtyLights = !0
    }
    ;
    ma.prototype.addShadowCasters = function(a) {
        for (var b, c = this.shadowCasters, d = 0; d < a.length; d++)
            b = a[d],
            b.castShadow && 0 > c.indexOf(b) && c.push(b);
        this._dirtyLights = !0
    }
    ;
    ma.prototype.removeShadowCasters = function(a) {
        for (var b, c = this.shadowCasters, d = 0; d < a.length; d++)
            b = c.indexOf(a[d]),
            0 <= b && c.splice(b, 1);
        this._dirtyLights = !0
    }
    ;
    ma.prototype._generateLightHash = function() {
        if (0 < this._lights.length) {
            this._lights.sort(Pn);
            for (var a = "", b = "", c = 0; c < this._lights.length; c++)
                this._lights[c].isStatic ? b += this._lights[c].key : a += this._lights[c].key;
            this._lightHash = 0 === a.length ? 0 : qe(a);
            this._staticLightHash = 0 === b.length ? 0 : qe(b)
        } else
            this._staticLightHash = this._lightHash = 0
    }
    ;
    ma.prototype._generateCameraHash = function() {
        if (1 < this.cameras.length) {
            this.cameras.sort(On);
            for (var a = "", b = 0; b < this.cameras.length; b++)
                a += this.cameras[b].entity.getGuid();
            this._cameraHash = qe(a)
        } else
            this._cameraHash = 0;
        this._dirtyCameras = !0
    }
    ;
    ma.prototype.addCamera = function(a) {
        0 <= this.cameras.indexOf(a) || (this.cameras.push(a),
        this._generateCameraHash())
    }
    ;
    ma.prototype.removeCamera = function(a) {
        a = this.cameras.indexOf(a);
        0 > a || (this.cameras.splice(a, 1),
        this._generateCameraHash(),
        this.instances.clearVisibleLists(a))
    }
    ;
    ma.prototype.clearCameras = function() {
        this._cameraHash = this.cameras.length = 0;
        this._dirtyCameras = !0
    }
    ;
    ma.prototype._sortCameras = function() {
        this._generateCameraHash()
    }
    ;
    ma.prototype._calculateSortDistances = function(a, b, c, d) {
        var e;
        for (e = 0; e < b; e++) {
            var f = a[e];
            if (!(f.command || 2 >= f.layer))
                if (f.calculateSortDistance)
                    f.zdist = f.calculateSortDistance(f, c, d);
                else {
                    var g = f.aabb.center;
                    var k = g.x - c.x;
                    var h = g.y - c.y;
                    g = g.z - c.z;
                    f.zdist = k * d.x + h * d.y + g * d.z
                }
        }
    }
    ;
    ma.prototype._sortVisible = function(a, b, c) {
        var d = this.instances
          , e = a ? this.transparentSortMode : this.opaqueSortMode;
        if (0 !== e)
            if (a = a ? d.visibleTransparent[c] : d.visibleOpaque[c],
            5 === e)
                ph = b.getPosition(),
                qh = b.forward,
                this.customCalculateSortValues && this.customCalculateSortValues(a.list, a.length, ph, qh),
                a.list.length !== a.length && (a.list.length = a.length),
                this.customSortCallback && a.list.sort(this.customSortCallback);
            else {
                if (3 === e || 4 === e)
                    ph = b.getPosition(),
                    qh = b.forward,
                    this._calculateSortDistances(a.list, a.length, ph, qh);
                a.list.length !== a.length && (a.list.length = a.length);
                a.list.sort(cp[e])
            }
    }
    ;
    for (var bm = (new K).mul2((new K).setTranslate(.5, .5, .5), (new K).setScale(.5, .5, .5)), dp = {
        r: 1,
        g: 2,
        b: 3,
        a: 4
    }, cm = [(new Y).setFromEulerAngles(0, 90, 180), (new Y).setFromEulerAngles(0, -90, 180), (new Y).setFromEulerAngles(90, 0, 0), (new Y).setFromEulerAngles(-90, 0, 0), (new Y).setFromEulerAngles(0, 180, 180), (new Y).setFromEulerAngles(0, 0, 180)], Fk = [{}, {}, {}, {}, {}], fe = new Float32Array(2), Tf = {
        x: 1,
        y: 1,
        z: 0,
        w: 0
    }, ge = new K, rh = new K, dm = new K, Xb = new K, Bb = new K, em = new xb, nc = new K, Yb, Pc = new K, Qc = new K, Ve = new K, We = new K, Xe = new z, Ye = new z, Uf, Vf, fm = new K, gm = new K, hm = new K, im = new K, sh = new z, jm = new z, km = new z, lm = new z, he = {
        center: null,
        radius: 0
    }, th = new oa, Wf = [0, 0, 0, 0], Ze, Mb, Uj, uh, Hk = {}, $e, af, vh = null, ua = [], mm = 0; 8 > mm; mm++)
        ua.push(new z);
    var za = [new z, new z, new z, new z, new z, new z, new z, new z];
    Object.assign(xg.prototype, {
        sortCompare: function(a, b) {
            if (a.layer === b.layer) {
                if (a.drawOrder && b.drawOrder)
                    return a.drawOrder - b.drawOrder;
                if (a.zdist && b.zdist)
                    return b.zdist - a.zdist;
                if (a.zdist2 && b.zdist2)
                    return a.zdist2 - b.zdist2
            }
            return b._key[0] - a._key[0]
        },
        sortCompareMesh: function(a, b) {
            if (a.layer === b.layer) {
                if (a.drawOrder && b.drawOrder)
                    return a.drawOrder - b.drawOrder;
                if (a.zdist && b.zdist)
                    return b.zdist - a.zdist
            }
            $e = a._key[0];
            af = b._key[0];
            return $e === af && a.mesh && b.mesh ? b.mesh.id - a.mesh.id : af - $e
        },
        depthSortCompare: function(a, b) {
            $e = a._key[1];
            af = b._key[1];
            return $e === af && a.mesh && b.mesh ? b.mesh.id - a.mesh.id : af - $e
        },
        lightCompare: function(a, b) {
            return a.key - b.key
        },
        getShadowCamera: function(a, b) {
            var c = b._shadowCamera;
            if (null === c) {
                c = b._shadowType;
                var d = 4 === c || 0 === c && a.webgl2;
                1 === b._type && (d = !1);
                var e = new pa;
                e.clearColor = 1 <= c && 3 >= c ? new L(0,0,0,0) : new L(1,1,1,1);
                e.clearColorBuffer = !d;
                e.clearDepthBuffer = !0;
                e.clearStencilBuffer = !1;
                e.node = new Z;
                c = b._shadowCamera = e;
                Gk(a, b)
            } else
                d = c.renderTarget,
                d.width === b._shadowResolution && d.height === b._shadowResolution || Gk(a, b);
            return c
        },
        updateCameraFrustum: function(a) {
            if (a.vrDisplay && a.vrDisplay.presenting) {
                Yb = a.vrDisplay.combinedProj;
                var b = a._node.parent;
                b ? Bb.copy(b.getWorldTransform()).mul(a.vrDisplay.combinedViewInv).invert() : Bb.copy(a.vrDisplay.combinedView);
                Xb.copy(Bb).invert();
                this.viewInvId.setValue(Xb.data);
                nc.mul2(Yb, Bb);
                a.frustum.setFromMat4(nc)
            } else if (a.xr && a.xr.views.length) {
                b = a.xr.views[0];
                nc.mul2(b.projMat, b.viewOffMat);
                a.frustum.setFromMat4(nc);
                return
            }
            Yb = a.projectionMatrix;
            a.calculateProjection && a.calculateProjection(Yb, 0);
            if (a.calculateTransform)
                a.calculateTransform(Xb, 0);
            else {
                b = a._node.getPosition();
                var c = a._node.getRotation();
                Xb.setTRS(b, c, z.ONE);
                this.viewInvId.setValue(Xb.data)
            }
            Bb.copy(Xb).invert();
            nc.mul2(Yb, Bb);
            a.frustum.setFromMat4(nc)
        },
        setCamera: function(a, b, c, d) {
            var e = a.vrDisplay, f;
            if (e && e.presenting) {
                Uf = e.leftProj;
                Vf = e.rightProj;
                Yb = e.combinedProj;
                a.calculateProjection && (a.calculateProjection(Uf, 1),
                a.calculateProjection(Vf, 2),
                a.calculateProjection(Yb, 0));
                if (a.calculateTransform)
                    a.calculateTransform(Pc, 1),
                    a.calculateTransform(Qc, 2),
                    a.calculateTransform(Xb, 0),
                    Ve.copy(Pc).invert(),
                    We.copy(Qc).invert(),
                    Bb.copy(Xb).invert();
                else if (f = a._node.parent) {
                    var g = f.getWorldTransform();
                    Pc.mul2(g, e.leftViewInv);
                    Qc.mul2(g, e.rightViewInv);
                    Ve.copy(Pc).invert();
                    We.copy(Qc).invert();
                    Bb.copy(f.getWorldTransform()).mul(e.combinedViewInv).invert()
                } else
                    Pc.copy(e.leftViewInv),
                    Qc.copy(e.rightViewInv),
                    Ve.copy(e.leftView),
                    We.copy(e.rightView),
                    Bb.copy(e.combinedView);
                yg(fm, Ve);
                yg(gm, We);
                hm.mul2(Uf, Ve);
                im.mul2(Vf, We);
                Xe.x = Pc.data[12];
                Xe.y = Pc.data[13];
                Xe.z = Pc.data[14];
                Ye.x = Qc.data[12];
                Ye.y = Qc.data[13];
                Ye.z = Qc.data[14];
                nc.mul2(Yb, Bb);
                a.frustum.setFromMat4(nc)
            } else if (a.xr && a.xr.session) {
                (f = a._node.parent) && (g = f.getWorldTransform());
                e = a.xr.views;
                for (var k = 0; k < e.length; k++) {
                    var h = e[k];
                    f ? (h.viewInvOffMat.mul2(g, h.viewInvMat),
                    h.viewOffMat.copy(h.viewInvOffMat).invert()) : (h.viewInvOffMat.copy(h.viewInvMat),
                    h.viewOffMat.copy(h.viewMat));
                    yg(h.viewMat3, h.viewOffMat);
                    h.projViewOffMat.mul2(h.projMat, h.viewOffMat);
                    h.position[0] = h.viewInvOffMat.data[12];
                    h.position[1] = h.viewInvOffMat.data[13];
                    h.position[2] = h.viewInvOffMat.data[14];
                    a.frustum.setFromMat4(h.projViewOffMat)
                }
            } else
                Yb = a.projectionMatrix,
                a.calculateProjection && a.calculateProjection(Yb, 0),
                this.projId.setValue(Yb.data),
                this.projSkyboxId.setValue(a.getProjectionMatrixSkybox().data),
                a.calculateTransform ? a.calculateTransform(Xb, 0) : (f = a._node.getPosition(),
                g = a._node.getRotation(),
                Xb.setTRS(f, g, z.ONE)),
                this.viewInvId.setValue(Xb.data),
                Bb.copy(Xb).invert(),
                this.viewId.setValue(Bb.data),
                yg(em, Bb),
                this.viewId3.setValue(em.data),
                nc.mul2(Yb, Bb),
                this.viewProjId.setValue(nc.data),
                f = a._node.getPosition(),
                this.viewPos[0] = f.x,
                this.viewPos[1] = f.y,
                this.viewPos[2] = f.z,
                this.viewPosId.setValue(this.viewPos),
                a.frustum.setFromMat4(nc);
            this.nearClipId.setValue(a._nearClip);
            this.farClipId.setValue(a._farClip);
            f = a._nearClip;
            g = a._farClip;
            this.cameraParams[0] = 1 / g;
            this.cameraParams[1] = g;
            this.cameraParams[2] = .5 * (1 - g / f);
            this.cameraParams[3] = .5 * (1 + g / f);
            this.cameraParamsId.setValue(this.cameraParams);
            this.clearView(a, b, c, !1);
            c = this.device;
            f = b ? b.width : c.width;
            b = b ? b.height : c.height;
            a = a.scissorRect;
            c.setScissor(Math.floor(a.x * f), Math.floor(a.y * b), Math.floor(a.z * f), Math.floor(a.w * b));
            d && c.setScissor(1, 1, f - 2, b - 2)
        },
        clearView: function(a, b, c, d, e) {
            var f = this.device;
            f.setRenderTarget(b);
            f.updateBegin();
            d && (f.setColorWrite(!0, !0, !0, !0),
            f.setDepthWrite(!0));
            d = a.rect;
            var g = b ? b.width : f.width
              , k = b ? b.height : f.height;
            b = Math.floor(d.x * g);
            var h = Math.floor(d.y * k);
            g = Math.floor(d.z * g);
            d = Math.floor(d.w * k);
            f.setViewport(b, h, g, d);
            f.setScissor(b, h, g, d);
            c && f.clear(e ? e : {
                color: [a._clearColor.r, a._clearColor.g, a._clearColor.b, a._clearColor.a],
                depth: a._clearDepth,
                flags: (a._clearColorBuffer ? 1 : 0) | (a._clearDepthBuffer ? 2 : 0) | (a._clearStencilBuffer ? 4 : 0),
                stencil: a._clearStencil
            })
        },
        dispatchGlobalLights: function(a) {
            var b;
            this.mainLight = -1;
            this.ambientColor[0] = a.ambientLight.r;
            this.ambientColor[1] = a.ambientLight.g;
            this.ambientColor[2] = a.ambientLight.b;
            if (a.gammaCorrection)
                for (b = 0; 3 > b; b++)
                    this.ambientColor[b] = Math.pow(this.ambientColor[b], 2.2);
            this.ambientId.setValue(this.ambientColor);
            this.exposureId.setValue(a.exposure);
            a.skyboxModel && this.skyboxIntensityId.setValue(a.skyboxIntensity)
        },
        _resolveLight: function(a, b) {
            var c = "light" + b;
            this.lightColorId[b] = a.resolve(c + "_color");
            this.lightDir[b] = new Float32Array(3);
            this.lightDirId[b] = a.resolve(c + "_direction");
            this.lightShadowMapId[b] = a.resolve(c + "_shadowMap");
            this.lightShadowMatrixId[b] = a.resolve(c + "_shadowMatrix");
            this.lightShadowParamsId[b] = a.resolve(c + "_shadowParams");
            this.lightShadowMatrixVsId[b] = a.resolve(c + "_shadowMatrixVS");
            this.lightShadowParamsVsId[b] = a.resolve(c + "_shadowParamsVS");
            this.lightDirVs[b] = new Float32Array(3);
            this.lightDirVsId[b] = a.resolve(c + "_directionVS");
            this.lightRadiusId[b] = a.resolve(c + "_radius");
            this.lightPos[b] = new Float32Array(3);
            this.lightPosId[b] = a.resolve(c + "_position");
            this.lightInAngleId[b] = a.resolve(c + "_innerConeAngle");
            this.lightOutAngleId[b] = a.resolve(c + "_outerConeAngle");
            this.lightPosVsId[b] = a.resolve(c + "_positionVS");
            this.lightCookieId[b] = a.resolve(c + "_cookie");
            this.lightCookieIntId[b] = a.resolve(c + "_cookieIntensity");
            this.lightCookieMatrixId[b] = a.resolve(c + "_cookieMatrix");
            this.lightCookieOffsetId[b] = a.resolve(c + "_cookieOffset")
        },
        dispatchDirectLights: function(a, b, c) {
            var d = a.length, e, f = 0;
            this.mainLight = -1;
            var g = this.device.scope;
            for (e = 0; e < d; e++)
                if (a[e].mask & c) {
                    var k = a[e];
                    var h = k._node.getWorldTransform();
                    this.lightColorId[f] || this._resolveLight(g, f);
                    this.lightColorId[f].setValue(b.gammaCorrection ? k._linearFinalColor : k._finalColor);
                    h.getY(k._direction).scale(-1);
                    k._direction.normalize();
                    this.lightDir[f][0] = k._direction.x;
                    this.lightDir[f][1] = k._direction.y;
                    this.lightDir[f][2] = k._direction.z;
                    this.lightDirId[f].setValue(this.lightDir[f]);
                    if (k.castShadows) {
                        var l = k._isPcf && this.device.webgl2 ? k._shadowCamera.renderTarget.depthBuffer : k._shadowCamera.renderTarget.colorBuffer;
                        k._isVsm ? h = -2E-4 : (h = k.shadowBias / k._shadowCamera._farClip * 100,
                        !this.device.webgl2 && this.device.extStandardDerivatives && (h *= -100));
                        var n = k._isVsm ? k.vsmBias / (k._shadowCamera._farClip / 7) : k._normalOffsetBias;
                        this.lightShadowMapId[f].setValue(l);
                        this.lightShadowMatrixId[f].setValue(k._shadowMatrix.data);
                        l = k._rendererParams;
                        3 !== l.length && (l.length = 3);
                        l[0] = k._shadowResolution;
                        l[1] = n;
                        l[2] = h;
                        this.lightShadowParamsId[f].setValue(l);
                        0 > this.mainLight && (this.lightShadowMatrixVsId[f].setValue(k._shadowMatrix.data),
                        this.lightShadowParamsVsId[f].setValue(l),
                        k._direction.normalize(),
                        this.lightDirVs[f][0] = k._direction.x,
                        this.lightDirVs[f][1] = k._direction.y,
                        this.lightDirVs[f][2] = k._direction.z,
                        this.lightDirVsId[f].setValue(this.lightDirVs[f]),
                        this.mainLight = e)
                    }
                    f++
                }
            return f
        },
        dispatchPointLight: function(a, b, c, d) {
            var e = c._node.getWorldTransform();
            this.lightColorId[d] || this._resolveLight(b, d);
            this.lightRadiusId[d].setValue(c.attenuationEnd);
            this.lightColorId[d].setValue(a.gammaCorrection ? c._linearFinalColor : c._finalColor);
            e.getTranslation(c._position);
            this.lightPos[d][0] = c._position.x;
            this.lightPos[d][1] = c._position.y;
            this.lightPos[d][2] = c._position.z;
            this.lightPosId[d].setValue(this.lightPos[d]);
            c.castShadows && (this.lightShadowMapId[d].setValue(c._shadowCamera.renderTarget.colorBuffer),
            a = c._rendererParams,
            4 !== a.length && (a.length = 4),
            a[0] = c._shadowResolution,
            a[1] = c._normalOffsetBias,
            a[2] = c.shadowBias,
            a[3] = 1 / c.attenuationEnd,
            this.lightShadowParamsId[d].setValue(a));
            c._cookie && (this.lightCookieId[d].setValue(c._cookie),
            this.lightShadowMatrixId[d].setValue(e.data),
            this.lightCookieIntId[d].setValue(c.cookieIntensity))
        },
        dispatchSpotLight: function(a, b, c, d) {
            var e = c._node.getWorldTransform();
            this.lightColorId[d] || this._resolveLight(b, d);
            this.lightInAngleId[d].setValue(c._innerConeAngleCos);
            this.lightOutAngleId[d].setValue(c._outerConeAngleCos);
            this.lightRadiusId[d].setValue(c.attenuationEnd);
            this.lightColorId[d].setValue(a.gammaCorrection ? c._linearFinalColor : c._finalColor);
            e.getTranslation(c._position);
            this.lightPos[d][0] = c._position.x;
            this.lightPos[d][1] = c._position.y;
            this.lightPos[d][2] = c._position.z;
            this.lightPosId[d].setValue(this.lightPos[d]);
            e.getY(c._direction).scale(-1);
            c._direction.normalize();
            this.lightDir[d][0] = c._direction.x;
            this.lightDir[d][1] = c._direction.y;
            this.lightDir[d][2] = c._direction.z;
            this.lightDirId[d].setValue(this.lightDir[d]);
            c.castShadows && (c._isVsm ? a = -2E-4 : (a = 20 * c.shadowBias,
            !this.device.webgl2 && this.device.extStandardDerivatives && (a *= -100)),
            b = c._isVsm ? c.vsmBias / (c.attenuationEnd / 7) : c._normalOffsetBias,
            this.lightShadowMapId[d].setValue(c._isPcf && this.device.webgl2 ? c._shadowCamera.renderTarget.depthBuffer : c._shadowCamera.renderTarget.colorBuffer),
            this.lightShadowMatrixId[d].setValue(c._shadowMatrix.data),
            e = c._rendererParams,
            4 !== e.length && (e.length = 4),
            e[0] = c._shadowResolution,
            e[1] = b,
            e[2] = a,
            e[3] = 1 / c.attenuationEnd,
            this.lightShadowParamsId[d].setValue(e));
            c._cookie && (this.lightCookieId[d].setValue(c._cookie),
            c.castShadows || (a = this.getShadowCamera(this.device, c),
            b = a._node,
            b.setPosition(c._node.getPosition()),
            b.setRotation(c._node.getRotation()),
            b.rotateLocal(-90, 0, 0),
            a.projection = 0,
            a.aspectRatio = 1,
            a.fov = 2 * c._outerConeAngle,
            ge.setTRS(b.getPosition(), b.getRotation(), z.ONE).invert(),
            rh.mul2(a.projectionMatrix, ge),
            c._shadowMatrix.mul2(bm, rh)),
            this.lightShadowMatrixId[d].setValue(c._shadowMatrix.data),
            this.lightCookieIntId[d].setValue(c.cookieIntensity),
            c._cookieTransform && (c._cookieTransformUniform[0] = c._cookieTransform.x,
            c._cookieTransformUniform[1] = c._cookieTransform.y,
            c._cookieTransformUniform[2] = c._cookieTransform.z,
            c._cookieTransformUniform[3] = c._cookieTransform.w,
            this.lightCookieMatrixId[d].setValue(c._cookieTransformUniform),
            c._cookieOffsetUniform[0] = c._cookieOffset.x,
            c._cookieOffsetUniform[1] = c._cookieOffset.y,
            this.lightCookieOffsetId[d].setValue(c._cookieOffsetUniform)))
        },
        dispatchLocalLights: function(a, b, c, d, e) {
            var f = a[1];
            a = a[2];
            var g = f.length
              , k = a.length
              , h = d
              , l = this.device.scope;
            for (d = 0; d < g; d++) {
                var n = f[d];
                n.mask & c && !n.isStatic && (this.dispatchPointLight(b, l, n, h),
                h++)
            }
            f = 0;
            if (e)
                for (n = e[f]; n && 1 === n._type; )
                    this.dispatchPointLight(b, l, n, h),
                    h++,
                    f++,
                    n = e[f];
            for (d = 0; d < k; d++)
                n = a[d],
                n.mask & c && !n.isStatic && (this.dispatchSpotLight(b, l, n, h),
                h++);
            if (e)
                for (n = e[f]; n && 2 === n._type; )
                    this.dispatchSpotLight(b, l, n, h),
                    h++,
                    f++,
                    n = e[f]
        },
        cull: function(a, b, c) {
            var d = 0, e, f = b.length, g = a.cullingMask || 4294967295;
            if (!a.frustumCulling) {
                for (e = 0; e < f; e++) {
                    var k = b[e];
                    if (k.visible || k.command)
                        k.mask && 0 === (k.mask & g) || (c[d] = k,
                        d++,
                        k.visibleThisFrame = !0)
                }
                return d
            }
            for (e = 0; e < f; e++)
                if (k = b[e],
                k.command)
                    c[d] = k,
                    d++,
                    k.visibleThisFrame = !0;
                else if (k.visible) {
                    var h = !0;
                    k.mask && 0 === (k.mask & g) || (k.cull && (h = k._isVisible(a)),
                    h && (c[d] = k,
                    d++,
                    k.visibleThisFrame = !0))
                }
            return d
        },
        cullLights: function(a, b) {
            var c;
            for (c = 0; c < b.length; c++) {
                var d = b[c];
                var e = d._type;
                d.castShadows && d.enabled && 0 !== d.shadowUpdateMode && 0 !== e && (d.getBoundingSphere(he),
                a.frustum.containsSphere(he) && (d.visibleThisFrame = !0))
            }
        },
        updateCpuSkinMatrices: function(a) {
            var b = a.length;
            if (0 !== b) {
                var c, d;
                for (c = 0; c < b; c++)
                    if (d = a[c].skinInstance)
                        d.updateMatrices(a[c].node),
                        d._dirty = !0
            }
        },
        updateGpuSkinMatrices: function(a) {
            var b, c, d = a.length;
            for (b = 0; b < d; b++)
                a[b].visibleThisFrame && (c = a[b].skinInstance) && c._dirty && (c.updateMatrixPalette(),
                c._dirty = !1)
        },
        updateMorphing: function(a) {
            var b, c, d = a.length;
            for (b = 0; b < d; b++)
                (c = a[b].morphInstance) && c._dirty && a[b].visibleThisFrame && c.update()
        },
        setBaseConstants: function(a, b) {
            a.setCullMode(b.cull);
            b.opacityMap && (this.opacityMapId.setValue(b.opacityMap),
            this.alphaTestId.setValue(b.alphaTest))
        },
        setSkinning: function(a, b, c) {
            b.skinInstance && (this._skinDrawCalls++,
            a.supportsBoneTextures ? (Ze = b.skinInstance.boneTexture,
            this.boneTextureId.setValue(Ze),
            Wf[0] = Ze.width,
            Wf[1] = Ze.height,
            Wf[2] = 1 / Ze.width,
            Wf[3] = 1 / Ze.height,
            this.boneTextureSizeId.setValue(Wf)) : this.poseMatrixId.setValue(b.skinInstance.matrixPalette))
        },
        drawInstance: function(a, b, c, d, e) {
            if (Mb = b.instancingData) {
                if (0 < Mb.count && (this._instancedDrawCalls++,
                a.setVertexBuffer(Mb.vertexBuffer),
                a.draw(c.primitive[d], Mb.count),
                Mb.vertexBuffer === vh))
                    return this._removedByInstancing += Mb.count,
                    b.instancingData = null,
                    Mb.count - 1
            } else
                Uj = b.node.worldTransform,
                this.modelMatrixId.setValue(Uj.data),
                e && (uh = b.node.normalMatrix,
                b.node._dirtyNormal && (Uj.invertTo3x3(uh),
                uh.transpose(),
                b.node._dirtyNormal = !1),
                this.normalMatrixId.setValue(uh.data)),
                a.draw(c.primitive[d]);
            return 0
        },
        drawInstance2: function(a, b, c, d) {
            if (Mb = b.instancingData) {
                if (0 < Mb.count && (this._instancedDrawCalls++,
                a.draw(c.primitive[d], Mb.count, !0),
                Mb.vertexBuffer === vh))
                    return this._removedByInstancing += Mb.count,
                    b.instancingData = null,
                    Mb.count - 1
            } else
                a.draw(c.primitive[d], void 0, !0);
            return 0
        },
        renderShadows: function(a, b) {
            var c = this.device, d;
            for (d = 0; d < a.length; d++) {
                var e = a[d];
                var f = e._type;
                if (e.castShadows && e.enabled && (e._shadowCamera || this.getShadowCamera(c, e),
                0 !== e.shadowUpdateMode && e.visibleThisFrame)) {
                    var g = this.getShadowCamera(c, e);
                    var k = g._node;
                    var h = 0;
                    var l = 1;
                    if (0 === f) {
                        if (0 > e._visibleLength[b])
                            continue;
                        h = e._visibleCameraSettings[b];
                        k.setPosition(h.x, h.y, h.z);
                        g.orthoHeight = h.orthoHeight;
                        g.farClip = h.farClip;
                        h = b
                    } else if (2 === f) {
                        var n = k.getPosition();
                        this.viewPos[0] = n.x;
                        this.viewPos[1] = n.y;
                        this.viewPos[2] = n.z;
                        this.viewPosId.setValue(this.viewPos);
                        this.shadowMapLightRadiusId.setValue(e.attenuationEnd)
                    } else
                        1 === f && (n = k.getPosition(),
                        this.viewPos[0] = n.x,
                        this.viewPos[1] = n.y,
                        this.viewPos[2] = n.z,
                        this.viewPosId.setValue(this.viewPos),
                        this.shadowMapLightRadiusId.setValue(e.attenuationEnd),
                        l = 6);
                    1 !== f && (ge.setTRS(k.getPosition(), k.getRotation(), z.ONE).invert(),
                    rh.mul2(g.projectionMatrix, ge),
                    e._shadowMatrix.mul2(bm, rh));
                    c.webgl2 ? 1 === f ? c.setDepthBias(!1) : (c.setDepthBias(!0),
                    c.setDepthBiasValues(-1E3 * e.shadowBias, -1E3 * e.shadowBias)) : c.extStandardDerivatives && (1 === f ? (this.polygonOffset[0] = 0,
                    this.polygonOffset[1] = 0) : (this.polygonOffset[0] = -1E3 * e.shadowBias,
                    this.polygonOffset[1] = -1E3 * e.shadowBias),
                    this.polygonOffsetId.setValue(this.polygonOffset));
                    1 === e.shadowUpdateMode && (e.shadowUpdateMode = 0);
                    this._shadowMapUpdates += l;
                    c.setBlending(!1);
                    c.setDepthWrite(!0);
                    c.setDepthTest(!0);
                    e._isPcf && c.webgl2 && 1 !== f ? c.setColorWrite(!1, !1, !1, !1) : c.setColorWrite(!0, !0, !0, !0);
                    for (h ? l = h + 1 : h = 0; h < l; ) {
                        1 === f && (k.setRotation(cm[h]),
                        g.renderTarget = e._shadowCubeMap[h]);
                        this.setCamera(g, g.renderTarget, !0, 1 !== f);
                        n = e._visibleList[h];
                        var p = e._visibleLength[h];
                        var q = e._shadowType;
                        var r = q + 5 * f;
                        for (q = 0; q < p; q++) {
                            var t = n[q];
                            var u = t.mesh;
                            var x = t.material;
                            this.setBaseConstants(c, x);
                            this.setSkinning(c, t, x);
                            x.dirty && (x.updateUniforms(),
                            x.dirty = !1);
                            x.chunks && (this.setCullMode(!0, !1, t),
                            x.setParameters(c),
                            t.setParameters(c, 8));
                            x = t._shader[3 + r];
                            if (!x) {
                                this.updateShader(t, t._shaderDefs, null, 3 + r);
                                x = t._shader[3 + r];
                                var v = t._key
                                  , w = t.material
                                  , y = t.skinInstance ? 10 : 0
                                  , A = 0;
                                w.opacityMap && (w = w.opacityMapChannel) && (A = dp[w]);
                                v[1] = y + A
                            }
                            c.setShader(x);
                            x = t.renderStyle;
                            this.setVertexBuffers(c, u);
                            this.setMorphing(c, t.morphInstance);
                            c.setIndexBuffer(u.indexBuffer[x]);
                            q += this.drawInstance(c, t, u, x);
                            this._shadowDrawCalls++
                        }
                        h++;
                        0 === f && (e._visibleLength[b] = -1)
                    }
                    if (e._isVsm && (f = e._vsmBlurSize,
                    1 < f)) {
                        g = g.renderTarget;
                        k = Ek(c, e._shadowResolution, e._shadowType, 1);
                        l = 1 === e._shadowType;
                        h = e.vsmBlurMode;
                        n = (l ? this.blurPackedVsmShader : this.blurVsmShader)[h][f];
                        if (!n) {
                            n = this.blurVsmWeights;
                            x = q = f;
                            25 < x && (x = 25);
                            v = (x - 1) / 6;
                            r = .5 * (x - 1);
                            t = Array(x);
                            for (u = p = 0; u < x; ++u)
                                y = u - r,
                                t[u] = Math.exp(-(y * y) / (2 * v * v)),
                                p += t[u];
                            for (u = 0; u < x; ++u)
                                t[u] /= p;
                            n[q] = t;
                            n = F.fullscreenQuadVS;
                            q = "#define SAMPLES " + f + "\n";
                            q = l ? q + this.blurPackedVsmShaderCode[h] : q + this.blurVsmShaderCode[h];
                            n = Wa(this.device, n, q, "blurVsm" + h + f + l);
                            l ? this.blurPackedVsmShader[h][f] = n : this.blurVsmShader[h][f] = n
                        }
                        Tf.z = e._shadowResolution - 2;
                        Tf.w = Tf.z;
                        this.sourceId.setValue(g.colorBuffer);
                        fe[0] = 1 / e._shadowResolution;
                        fe[1] = 0;
                        this.pixelOffsetId.setValue(fe);
                        1 === h && this.weightId.setValue(this.blurVsmWeights[f]);
                        La(c, k, n, null, Tf);
                        this.sourceId.setValue(k.colorBuffer);
                        fe[1] = fe[0];
                        fe[0] = 0;
                        this.pixelOffsetId.setValue(fe);
                        La(c, g, n, null, Tf)
                    }
                }
            }
            c.webgl2 ? c.setDepthBias(!1) : c.extStandardDerivatives && (this.polygonOffset[0] = 0,
            this.polygonOffset[1] = 0,
            this.polygonOffsetId.setValue(this.polygonOffset))
        },
        updateShader: function(a, b, c, d, e) {
            a.material._scene = this.scene;
            a.material.updateShader(this.device, this.scene, b, c, d, e);
            a._shader[d] = a.material.shader
        },
        setCullMode: function(a, b, c) {
            var d = c.material
              , e = 0;
            a && (a = 1,
            0 < d.cull && 3 > d.cull && (c.flipFaces && (a *= -1),
            b && (a *= -1),
            b = c.node.worldTransform,
            b.getX(sh),
            b.getY(jm),
            b.getZ(km),
            sh.cross(sh, jm),
            0 > sh.dot(km) && (a *= -1)),
            e = 0 > a ? 2 === d.cull ? 1 : 2 : d.cull);
            this.device.setCullMode(e)
        },
        setVertexBuffers: function(a, b) {
            a.setVertexBuffer(b.vertexBuffer)
        },
        setMorphing: function(a, b) {
            if (b)
                if (b.morph.useTextureMorph)
                    a.setVertexBuffer(b.morph.vertexBufferIds),
                    this.morphPositionTex.setValue(b.texturePositions),
                    this.morphNormalTex.setValue(b.textureNormals),
                    this.morphTexParams.setValue(b._textureParams);
                else {
                    for (var c, d, e = 0; e < b._activeVertexBuffers.length; e++)
                        if (c = b._activeVertexBuffers[e])
                            d = "ATTR" + (e + 8),
                            c.format.elements[0].name = d,
                            c.format.elements[0].scopeId = a.scope.resolve(d),
                            c.format.update(),
                            a.setVertexBuffer(c);
                    this.morphWeightsA.setValue(b._shaderMorphWeightsA);
                    this.morphWeightsB.setValue(b._shaderMorphWeightsB)
                }
        },
        renderForward: function(a, b, c, d, e, f, g, k) {
            var h = this.device
              , l = this.scene
              , n = a.vrDisplay;
            k = k ? k._lightHash : 0;
            var p = 1 << e, q, r = null, t = .5 * h.width;
            for (q = 0; q < c; q++) {
                var u = b[q];
                if (!f || !u.mask || f & u.mask)
                    if (u.command)
                        u.command();
                    else {
                        var x = u.mesh;
                        var v = u.material;
                        var w = u._shaderDefs;
                        var y = u.mask;
                        this.setSkinning(h, u, v);
                        v && v === r && w !== A && (r = null);
                        if (u.isStatic || E)
                            r = null;
                        if (v !== r) {
                            this._materialSwitches++;
                            v.dirty && (v.updateUniforms(),
                            v.dirty = !1);
                            if (!u._shader[e] || u._shaderDefs !== w || u._lightHash !== k) {
                                if (u.isStatic)
                                    this.updateShader(u, w, u._staticLightList, e, d);
                                else {
                                    var A = e + "_" + w + "_" + k;
                                    u._shader[e] = v.variants[A];
                                    u._shader[e] || (this.updateShader(u, w, null, e, d),
                                    v.variants[A] = u._shader[e])
                                }
                                u._shaderDefs = w;
                                u._lightHash = k
                            }
                            u._shader[e].failed || h.setShader(u._shader[e]) || (u._shader[e].failed = !0);
                            v.setParameters(h);
                            if (!r || y !== B) {
                                var B = this.dispatchDirectLights(d[0], l, y);
                                this.dispatchLocalLights(d, l, y, B, u._staticLightList)
                            }
                            this.alphaTestId.setValue(v.alphaTest);
                            h.setBlending(v.blend);
                            v.blend && (v.separateAlphaBlend ? (h.setBlendFunctionSeparate(v.blendSrc, v.blendDst, v.blendSrcAlpha, v.blendDstAlpha),
                            h.setBlendEquationSeparate(v.blendEquation, v.blendAlphaEquation)) : (h.setBlendFunction(v.blendSrc, v.blendDst),
                            h.setBlendEquation(v.blendEquation)));
                            h.setColorWrite(v.redWrite, v.greenWrite, v.blueWrite, v.alphaWrite);
                            h.setDepthWrite(v.depthWrite);
                            h.setDepthTest(v.depthTest);
                            h.setAlphaToCoverage(v.alphaToCoverage);
                            v.depthBias || v.slopeDepthBias ? (h.setDepthBias(!0),
                            h.setDepthBiasValues(v.depthBias, v.slopeDepthBias)) : h.setDepthBias(!1)
                        }
                        this.setCullMode(a._cullFaces, a._flipFaces, u);
                        B = u.stencilFront || v.stencilFront;
                        r = u.stencilBack || v.stencilBack;
                        B || r ? (h.setStencilTest(!0),
                        B === r ? (h.setStencilFunc(B.func, B.ref, B.readMask),
                        h.setStencilOperation(B.fail, B.zfail, B.zpass, B.writeMask)) : (B ? (h.setStencilFuncFront(B.func, B.ref, B.readMask),
                        h.setStencilOperationFront(B.fail, B.zfail, B.zpass, B.writeMask)) : (h.setStencilFuncFront(7, 0, 255),
                        h.setStencilOperationFront(0, 0, 0, 255)),
                        r ? (h.setStencilFuncBack(r.func, r.ref, r.readMask),
                        h.setStencilOperationBack(r.fail, r.zfail, r.zpass, r.writeMask)) : (h.setStencilFuncBack(7, 0, 255),
                        h.setStencilOperationBack(0, 0, 0, 255)))) : h.setStencilTest(!1);
                        u.setParameters(h, p);
                        this.setVertexBuffers(h, x);
                        this.setMorphing(h, u.morphInstance);
                        B = u.renderStyle;
                        h.setIndexBuffer(x.indexBuffer[B]);
                        g && g(u, q);
                        if (n && n.presenting)
                            h.setViewport(0, 0, t, h.height),
                            this.projId.setValue(Uf.data),
                            this.projSkyboxId.setValue(Uf.data),
                            this.viewInvId.setValue(Pc.data),
                            this.viewId.setValue(Ve.data),
                            this.viewId3.setValue(fm.data),
                            this.viewProjId.setValue(hm.data),
                            this.viewPos[0] = Xe.x,
                            this.viewPos[1] = Xe.y,
                            this.viewPos[2] = Xe.z,
                            this.viewPosId.setValue(this.viewPos),
                            q += this.drawInstance(h, u, x, B, !0),
                            this._forwardDrawCalls++,
                            h.setViewport(t, 0, t, h.height),
                            this.projId.setValue(Vf.data),
                            this.projSkyboxId.setValue(Vf.data),
                            this.viewInvId.setValue(Qc.data),
                            this.viewId.setValue(We.data),
                            this.viewId3.setValue(gm.data),
                            this.viewProjId.setValue(im.data),
                            this.viewPos[0] = Ye.x,
                            this.viewPos[1] = Ye.y,
                            this.viewPos[2] = Ye.z,
                            this.viewPosId.setValue(this.viewPos),
                            q += this.drawInstance2(h, u, x, B),
                            this._forwardDrawCalls++;
                        else if (a.xr && a.xr.session && a.xr.views.length)
                            for (r = a.xr.views,
                            A = 0; A < r.length; A++) {
                                var E = r[A];
                                h.setViewport(E.viewport.x, E.viewport.y, E.viewport.z, E.viewport.w);
                                this.projId.setValue(E.projMat.data);
                                this.projSkyboxId.setValue(E.projMat.data);
                                this.viewId.setValue(E.viewOffMat.data);
                                this.viewInvId.setValue(E.viewInvOffMat.data);
                                this.viewId3.setValue(E.viewMat3.data);
                                this.viewProjId.setValue(E.projViewOffMat.data);
                                this.viewPosId.setValue(E.position);
                                q = 0 === A ? q + this.drawInstance(h, u, x, B, !0) : q + this.drawInstance2(h, u, x, B);
                                this._forwardDrawCalls++
                            }
                        else
                            q += this.drawInstance(h, u, x, B, !0),
                            this._forwardDrawCalls++;
                        q < c - 1 && b[q + 1].material === v && v.setParameters(h, u.parameters);
                        r = v;
                        A = w;
                        B = y;
                        E = u.isStatic
                    }
            }
            h.updateEnd()
        },
        setupInstancing: function(a) {
            a.enableAutoInstancing && (vh || (vh = new ab(a,Na.defaultInstancingFormat,a.autoInstancingMaxObjects,1)))
        },
        revertStaticMeshes: function(a) {
            var b, c = a.length, d = [];
            for (b = 0; b < c; b++) {
                var e = a[b];
                if (e._staticSource) {
                    if (e._staticSource !== f) {
                        d.push(e._staticSource);
                        var f = e._staticSource
                    }
                } else
                    d.push(e)
            }
            a.length = d.length;
            for (b = 0; b < d.length; b++)
                a[b] = d[b]
        },
        prepareStaticMeshes: function(a, b) {
            var c, d, e, f, g = this.device, k = a.length, h = [], l, n, p, q = new z, r = new z, t = new oa, u = new K, x = [], v, w = [], y = [], A = [];
            for (c = 0; c < k; c++) {
                var B = a[c];
                if (B.isStatic) {
                    var E = B.aabb;
                    A.length = 0;
                    for (v = 1; 2 >= v; v++)
                        for (d = 0; d < b.length; d++) {
                            var C = b[d];
                            C._type === v && C.enabled && C.mask & B.mask && C.isStatic && (w[d] || (w[d] = new oa,
                            C._node.getWorldTransform(),
                            C.getBoundingSphere(he),
                            w[d].center.copy(he.center),
                            w[d].halfExtents.x = he.radius,
                            w[d].halfExtents.y = he.radius,
                            w[d].halfExtents.z = he.radius),
                            w[d].intersects(E) && A.push(d))
                        }
                    if (0 === A.length)
                        h.push(B);
                    else {
                        E = B.mesh;
                        v = E.vertexBuffer;
                        C = E.indexBuffer[B.renderStyle];
                        var D = 2 === C.bytesPerIndex ? new Uint16Array(C.lock()) : new Uint32Array(C.lock());
                        var G = E.primitive[B.renderStyle].count / 3;
                        var J = E.primitive[B.renderStyle].base;
                        var R = v.format.elements;
                        var I = v.format.size / 4;
                        E = new Float32Array(v.storage);
                        for (e = 0; e < R.length; e++)
                            "POSITION" === R[e].name && (l = R[e].offset / 4);
                        x.length = G;
                        for (e = 0; e < G; e++)
                            x[e] = 0;
                        R = !1;
                        y.length = 6 * G;
                        for (e = 0; e < G; e++) {
                            var T = p = n = Number.MAX_VALUE;
                            var S = -Number.MAX_VALUE;
                            var ba = -Number.MAX_VALUE;
                            var ha = -Number.MAX_VALUE;
                            for (f = 0; 3 > f; f++) {
                                d = D[3 * e + f + J];
                                d = d * I + l;
                                var W = E[d];
                                var Q = E[d + 1];
                                d = E[d + 2];
                                W < n && (n = W);
                                Q < p && (p = Q);
                                d < T && (T = d);
                                W > S && (S = W);
                                Q > ba && (ba = Q);
                                d > ha && (ha = d)
                            }
                            d = 6 * e;
                            y[d] = n;
                            y[d + 1] = p;
                            y[d + 2] = T;
                            y[d + 3] = S;
                            y[d + 4] = ba;
                            y[d + 5] = ha
                        }
                        for (W = 0; W < A.length; W++)
                            for (d = A[W],
                            u.copy(B.node.worldTransform).invert(),
                            t.setFromTransformedAabb(w[d], u),
                            Q = t.getMin(),
                            n = t.getMax(),
                            f = 1 << W,
                            e = 0; e < G; e++)
                                d = 6 * e,
                                y[d] <= n.x && y[d + 3] >= Q.x && y[d + 1] <= n.y && y[d + 4] >= Q.y && y[d + 2] <= n.z && y[d + 5] >= Q.z && (x[e] |= f,
                                R = !0);
                        if (R) {
                            R = {};
                            for (e = 0; e < G; e++) {
                                d = 3 * e + J;
                                var Nb = x[e];
                                R[Nb] || (R[Nb] = []);
                                f = R[Nb];
                                f.push(D[d]);
                                f.push(D[d + 1]);
                                f.push(D[d + 2])
                            }
                            for (Nb in R) {
                                f = R[Nb];
                                D = new dc(g,C.format,f.length,C.usage);
                                (2 === D.bytesPerIndex ? new Uint16Array(D.lock()) : new Uint32Array(D.lock())).set(f);
                                D.unlock();
                                T = p = n = Number.MAX_VALUE;
                                S = -Number.MAX_VALUE;
                                ba = -Number.MAX_VALUE;
                                ha = -Number.MAX_VALUE;
                                for (e = 0; e < f.length; e++)
                                    d = f[e],
                                    W = E[d * I + l],
                                    Q = E[d * I + l + 1],
                                    d = E[d * I + l + 2],
                                    W < n && (n = W),
                                    Q < p && (p = Q),
                                    d < T && (T = d),
                                    W > S && (S = W),
                                    Q > ba && (ba = Q),
                                    d > ha && (ha = d);
                                q.set(n, p, T);
                                r.set(S, ba, ha);
                                e = new oa;
                                e.setMinMax(q, r);
                                G = new rb(g);
                                G.vertexBuffer = v;
                                G.indexBuffer[0] = D;
                                G.primitive[0].type = 4;
                                G.primitive[0].base = 0;
                                G.primitive[0].count = f.length;
                                G.primitive[0].indexed = !0;
                                G.aabb = e;
                                D = new va(B.node,G,B.material);
                                D.isStatic = B.isStatic;
                                D.visible = B.visible;
                                D.layer = B.layer;
                                D.castShadow = B.castShadow;
                                D._receiveShadow = B._receiveShadow;
                                D.cull = B.cull;
                                D.pick = B.pick;
                                D.mask = B.mask;
                                D.parameters = B.parameters;
                                D._shaderDefs = B._shaderDefs;
                                D._staticSource = B;
                                D._staticLightList = B._staticLightList ? B._staticLightList : [];
                                for (e = 0; e < A.length; e++)
                                    f = 1 << e,
                                    Nb & f && (G = b[A[e]],
                                    0 > D._staticLightList.indexOf(G) && D._staticLightList.push(G));
                                D._staticLightList.sort(this.lightCompare);
                                h.push(D)
                            }
                        } else
                            h.push(B)
                    }
                } else
                    h.push(B)
            }
            a.length = h.length;
            for (c = 0; c < h.length; c++)
                a[c] = h[c]
        },
        updateShaders: function(a) {
            var b, c = [];
            for (b = 0; b < a.length; b++) {
                var d = a[b];
                void 0 !== d.material && -1 === c.indexOf(d.material) && c.push(d.material)
            }
            for (b = 0; b < c.length; b++)
                a = c[b],
                a.updateShader !== ka.prototype.updateShader && (a.clearVariants(),
                a.shader = null)
        },
        updateLitShaders: function(a) {
            for (var b = 0; b < a.length; b++) {
                var c = a[b];
                void 0 !== c.material && (c = c.material,
                c.updateShader === ka.prototype.updateShader || !1 === c.useLighting || c.emitter && !c.emitter.lighting || (c.clearVariants(),
                c.shader = null))
            }
        },
        beginFrame: function(a) {
            var b = this.scene
              , c = a._meshInstances;
            a = a._lights;
            b.updateShaders ? (this.updateShaders(c),
            b.updateShaders = !1,
            b.updateLitShaders = !1,
            b._shaderVersion++) : b.updateLitShaders && (this.updateLitShaders(c),
            b.updateLitShaders = !1,
            b._shaderVersion++);
            this.updateCpuSkinMatrices(c);
            var d = c.length;
            for (b = 0; b < d; b++)
                c[b].visibleThisFrame = !1;
            d = a.length;
            for (b = 0; b < d; b++)
                a[b].visibleThisFrame = 0 === a[b]._type
        },
        beginLayers: function(a) {
            var b = this.scene, c = a.layerList.length, d, e = this.scene._shaderVersion;
            for (d = 0; d < c; d++)
                a.layerList[d]._postRenderCounter = 0;
            for (d = 0; d < c; d++) {
                var f = a.layerList[d];
                f._shaderVersion = e;
                f._preRenderCalledForCameras = 0;
                f._postRenderCalledForCameras = 0;
                var g = a.subLayerList[d];
                f._postRenderCounter = g ? f._postRenderCounter | 2 : f._postRenderCounter | 1;
                f._postRenderCounterMax = f._postRenderCounter;
                for (g = 0; g < f.cameras.length; g++)
                    f.instances.visibleOpaque[g] || (f.instances.visibleOpaque[g] = new Ak),
                    f.instances.visibleTransparent[g] || (f.instances.visibleTransparent[g] = new Ak),
                    f.instances.visibleOpaque[g].done = !1,
                    f.instances.visibleTransparent[g].done = !1;
                f.cameras.length < f.instances.visibleOpaque.length && f.instances.visibleOpaque.splice(f.cameras.length, 1);
                f.cameras.length < f.instances.visibleTransparent.length && f.instances.visibleTransparent.splice(f.cameras.length, 1);
                f._needsStaticPrepare && f._staticLightHash && (f._staticPrepareDone && (this.revertStaticMeshes(f.opaqueMeshInstances),
                this.revertStaticMeshes(f.transparentMeshInstances)),
                this.prepareStaticMeshes(f.opaqueMeshInstances, f._lights),
                this.prepareStaticMeshes(f.transparentMeshInstances, f._lights),
                a._dirty = !0,
                b.updateShaders = !0,
                f._needsStaticPrepare = !1,
                f._staticPrepareDone = !0)
            }
        },
        cullLocalShadowmap: function(a, b) {
            var c, d, e, f;
            var g = a._type;
            if (0 !== g) {
                a.visibleThisFrame = !0;
                var k = this.getShadowCamera(this.device, a);
                k.projection = 0;
                k.nearClip = a.attenuationEnd / 1E3;
                k.farClip = a.attenuationEnd;
                k.aspectRatio = 1;
                if (2 === g) {
                    k.fov = 2 * a._outerConeAngle;
                    var h = 1
                } else
                    k.fov = 90,
                    h = 6;
                var l = k._node;
                var n = a._node;
                l.setPosition(n.getPosition());
                2 === g && (l.setRotation(n.getRotation()),
                l.rotateLocal(-90, 0, 0));
                for (c = 0; c < h; c++) {
                    1 === g && (l.setRotation(cm[c]),
                    k.renderTarget = a._shadowCubeMap[c]);
                    this.updateCameraFrustum(k);
                    (e = a._visibleList[c]) || (e = a._visibleList[c] = []);
                    n = f = a._visibleLength[c] = 0;
                    for (d = b.length; n < d; n++) {
                        var p = b[n];
                        var q = !0;
                        p.cull && (q = p._isVisible(k));
                        q && (e[f] = p,
                        f++,
                        p.visibleThisFrame = !0)
                    }
                    a._visibleLength[c] = f;
                    e.length !== f && (e.length = f);
                    e.sort(this.depthSortCompare)
                }
            }
        },
        cullDirectionalShadowmap: function(a, b, c, d) {
            var e = this.device;
            a.visibleThisFrame = !0;
            e = this.getShadowCamera(e, a);
            var f = e._node;
            var g = a._node;
            f.setPosition(g.getPosition());
            f.setRotation(g.getRotation());
            f.rotateLocal(-90, 0, 0);
            var k = a.shadowDistance || c._farClip;
            var h = c._nearClip;
            var l = c._fov * Math.PI / 180;
            var n = c._aspectRatio;
            var p = c._projection;
            var q = 0 === p ? Math.tan(l / 2) * h : c._orthoHeight;
            var r = q * n;
            ua[0].x = r;
            ua[0].y = -q;
            ua[0].z = -h;
            ua[1].x = r;
            ua[1].y = q;
            ua[1].z = -h;
            ua[2].x = -r;
            ua[2].y = q;
            ua[2].z = -h;
            ua[3].x = -r;
            ua[3].y = -q;
            ua[3].z = -h;
            0 === p && (q = Math.tan(l / 2) * k,
            r = q * n);
            ua[4].x = r;
            ua[4].y = -q;
            ua[4].z = -k;
            ua[5].x = r;
            ua[5].y = q;
            ua[5].z = -k;
            ua[6].x = -r;
            ua[6].y = q;
            ua[6].z = -k;
            ua[7].x = -r;
            ua[7].y = -q;
            ua[7].z = -k;
            n = lm.sub2(ua[0], ua[6]).length();
            n = Math.max(n, lm.sub2(ua[4], ua[6]).length());
            ge.copy(f.getWorldTransform()).invert();
            dm.copy(ge).mul(c._node.getWorldTransform());
            for (l = 0; 8 > l; l++)
                dm.transformPoint(ua[l], ua[l]);
            k = h = c = 1E6;
            r = q = p = -1E6;
            for (l = 0; 8 > l; l++) {
                var t = ua[l];
                t.x < k && (k = t.x);
                t.x > r && (r = t.x);
                t.y < h && (h = t.y);
                t.y > q && (q = t.y);
                t.z < c && (c = t.z);
                t.z > p && (p = t.z)
            }
            l = n / a._shadowResolution;
            k = Math.floor((k - .5 * (n - (r - k))) / l) * l;
            h = Math.floor((h - .5 * (n - (q - h))) / l) * l;
            k = .5 * (k + n + k);
            h = .5 * (h + n + h);
            f.translateLocal(k, h, 1E5);
            e.projection = 1;
            e.nearClip = 0;
            e.farClip = 2E5;
            e.aspectRatio = 1;
            e.orthoHeight = .5 * n;
            this.updateCameraFrustum(e);
            q = !0;
            (p = a._visibleList[d]) || (p = a._visibleList[d] = []);
            l = n = a._visibleLength[d] = 0;
            for (r = b.length; l < r; l++) {
                var u = b[l];
                t = !0;
                u.cull && (t = u._isVisible(e));
                t && (p[n] = u,
                n++,
                u.visibleThisFrame = !0,
                t = u.aabb,
                q ? (th.copy(t),
                q = !1) : th.add(t))
            }
            a._visibleLength[d] = n;
            p.length !== n && (p.length = n);
            p.sort(this.depthSortCompare);
            b = th.getMin();
            l = th.getMax();
            za[0].x = za[1].x = za[2].x = za[3].x = b.x;
            za[1].y = za[3].y = za[7].y = za[5].y = b.y;
            za[2].z = za[3].z = za[6].z = za[7].z = b.z;
            za[4].x = za[5].x = za[6].x = za[7].x = l.x;
            za[0].y = za[2].y = za[4].y = za[6].y = l.y;
            za[0].z = za[1].z = za[4].z = za[5].z = l.z;
            l = 9999999999;
            b = -9999999999;
            for (p = 0; 8 > p; ++p)
                ge.transformPoint(za[p], za[p]),
                n = za[p].z,
                n < l && (l = n),
                n > b && (b = n);
            p = b;
            l > c && (c = l);
            f.setPosition(g.getPosition());
            f.translateLocal(k, h, p + .01);
            e.farClip = p - c;
            (g = a._visibleCameraSettings[d]) || (g = a._visibleCameraSettings[d] = {});
            a = f.getPosition();
            g.x = a.x;
            g.y = a.y;
            g.z = a.z;
            g.orthoHeight = e.orthoHeight;
            g.farClip = e.farClip
        },
        gpuUpdate: function(a) {
            this.updateGpuSkinMatrices(a);
            this.updateMorphing(a)
        },
        setSceneConstants: function() {
            var a, b = this.device, c = this.scene;
            this.dispatchGlobalLights(c);
            if ("none" !== c.fog) {
                this.fogColor[0] = c.fogColor.r;
                this.fogColor[1] = c.fogColor.g;
                this.fogColor[2] = c.fogColor.b;
                if (c.gammaCorrection)
                    for (a = 0; 3 > a; a++)
                        this.fogColor[a] = Math.pow(this.fogColor[a], 2.2);
                this.fogColorId.setValue(this.fogColor);
                "linear" === c.fog ? (this.fogStartId.setValue(c.fogStart),
                this.fogEndId.setValue(c.fogEnd)) : this.fogDensityId.setValue(c.fogDensity)
            }
            this._screenSize[0] = b.width;
            this._screenSize[1] = b.height;
            this._screenSize[2] = 1 / b.width;
            this._screenSize[3] = 1 / b.height;
            this.screenSizeId.setValue(this._screenSize)
        },
        renderComposition: function(a) {
            var b = this.device, c, d = a._renderedRt, e = a._renderedByCam, f = a._renderedLayer, g, k, h, l;
            this.scene.updateSkybox && (this.scene._updateSkybox(b),
            this.scene.updateSkybox = !1);
            this.beginLayers(a);
            a._update() & 2 && (this.scene.updateLitShaders = !0);
            this.beginFrame(a);
            this.setSceneConstants();
            var n = 0;
            for (g = 0; g < a.layerList.length; g++) {
                var p = a.layerList[g];
                if (p.enabled && a.subLayerEnabled[g]) {
                    var q = a.subLayerList[g];
                    var r = p.instances;
                    var t = p.cameras;
                    for (k = 0; k < t.length; k++)
                        if (c = t[k]) {
                            c.frameBegin(p.renderTarget);
                            var u = q ? p.transparentMeshInstances : p.opaqueMeshInstances;
                            var x = l = !1;
                            for (h = 0; h < n; h++)
                                if (e[h] === c && (l = !0,
                                f[h] === p)) {
                                    x = !0;
                                    break
                                }
                            l || (this.updateCameraFrustum(c.camera),
                            this._camerasRendered++);
                            x || this.cullLights(c.camera, p._lights);
                            l && x || (e[n] = c,
                            f[n] = p,
                            n++);
                            h = q ? r.visibleTransparent[k] : r.visibleOpaque[k];
                            if (!h.done) {
                                if (p.onPreCull)
                                    p.onPreCull(k);
                                h.length = this.cull(c.camera, u, h.list);
                                h.done = !0;
                                if (p.onPostCull)
                                    p.onPostCull(k)
                            }
                            c.frameEnd()
                        }
                }
            }
            for (g = 0; g < a._lights.length; g++)
                c = a._lights[g],
                c.visibleThisFrame && 0 !== c._type && c.castShadows && c.enabled && 0 !== c.shadowUpdateMode && (p = a._lightShadowCasters[g],
                this.cullLocalShadowmap(c, p));
            q = -1;
            for (g = 0; g < a._lights.length; g++)
                if (c = a._lights[g],
                0 === c._type && (q++,
                c.castShadows && c.enabled && 0 !== c.shadowUpdateMode))
                    for (p = a._lightShadowCasters[g],
                    t = a._globalLightCameras[q],
                    k = 0; k < t.length; k++)
                        this.cullDirectionalShadowmap(c, p, t[k].camera, a._globalLightCameraIds[q][k]);
            this.gpuUpdate(a._meshInstances);
            this.renderShadows(a._sortedLights[2]);
            this.renderShadows(a._sortedLights[1]);
            for (g = n = 0; g < a._renderList.length; g++)
                if (p = a.layerList[a._renderList[g]],
                p.enabled && a.subLayerEnabled[a._renderList[g]]) {
                    r = p.instances;
                    q = a.subLayerList[a._renderList[g]];
                    t = a._renderListCamera[g];
                    (c = p.cameras[t]) && c.frameBegin(p.renderTarget);
                    if (!q && p.onPreRenderOpaque)
                        p.onPreRenderOpaque(t);
                    else if (q && p.onPreRenderTransparent)
                        p.onPreRenderTransparent(t);
                    if (!(p._preRenderCalledForCameras & 1 << t)) {
                        if (p.onPreRender)
                            p.onPreRender(t);
                        p._preRenderCalledForCameras |= 1 << t;
                        p.overrideClear && this.clearView(c.camera, p.renderTarget, !0, !0, p._clearOptions)
                    }
                    if (c) {
                        k = p.renderTarget;
                        f = !1;
                        for (h = 0; h < n; h++)
                            if (d[h] === k && e[h] === c) {
                                f = !0;
                                break
                            }
                        f || (p.overrideClear || this.clearView(c.camera, p.renderTarget, !0, !0),
                        d[n] = k,
                        e[n] = c,
                        n++);
                        this.renderShadows(p._sortedLights[0], t);
                        p._sortVisible(q, c.camera.node, t);
                        h = q ? r.visibleTransparent[t] : r.visibleOpaque[t];
                        this.scene._activeCamera = c.camera;
                        this.setCamera(c.camera, p.renderTarget);
                        this.renderForward(c.camera, h.list, h.length, p._sortedLights, p.shaderPass, p.cullingMask, p.onDrawCall, p);
                        b.setColorWrite(!0, !0, !0, !0);
                        b.setStencilTest(!1);
                        b.setAlphaToCoverage(!1);
                        b.setDepthBias(!1);
                        c.frameEnd()
                    }
                    if (!q && p.onPostRenderOpaque)
                        p.onPostRenderOpaque(t);
                    else if (q && p.onPostRenderTransparent)
                        p.onPostRenderTransparent(t);
                    !p.onPostRender || p._postRenderCalledForCameras & 1 << t || (p._postRenderCounter &= ~(q ? 2 : 1),
                    0 === p._postRenderCounter && (p.onPostRender(t),
                    p._postRenderCalledForCameras |= 1 << t,
                    p._postRenderCounter = p._postRenderCounterMax))
                }
        }
    });
    dd.prototype = Object.create(ka.prototype);
    dd.prototype.constructor = dd;
    Object.assign(dd.prototype, {
        clone: function() {
            var a = new dd;
            ka.prototype._cloneInternal.call(this, a);
            a.color.copy(this.color);
            a.colorMap = this.colorMap;
            a.vertexColors = this.vertexColors;
            return a
        },
        updateUniforms: function() {
            this.clearParameters();
            this.colorUniform[0] = this.color.r;
            this.colorUniform[1] = this.color.g;
            this.colorUniform[2] = this.color.b;
            this.colorUniform[3] = this.color.a;
            this.setParameter("uColor", this.colorUniform);
            this.colorMap && this.setParameter("texture_diffuseMap", this.colorMap)
        },
        updateShader: function(a, b, c, d, e, f) {
            b = {
                skin: !!this.meshInstances[0].skinInstance,
                vertexColors: this.vertexColors,
                diffuseMap: !!this.colorMap,
                pass: e
            };
            this.shader = a.getProgramLibrary().getProgram("basic", b)
        }
    });
    var wh = new Z;
    zg.prototype.addLayer = function(a) {
        0 > this.layers.indexOf(a) && this.layers.push(a)
    }
    ;
    zg.prototype.getLayerIdx = function(a) {
        return this.layerToBatch[a.id]
    }
    ;
    zg.prototype.addLayerIdx = function(a, b) {
        this.layerToBatch[b.id] = a
    }
    ;
    Object.assign(Ik.prototype, {
        init: function(a, b, c, d) {
            this.mesh || (this.mesh = new rb(a),
            this.mesh.primitive[0].type = 1,
            this.mesh.primitive[0].base = 0,
            this.mesh.primitive[0].indexed = !1,
            this.material = new dd,
            this.material.vertexColors = !0,
            this.material.blend = !0,
            this.material.blendType = 2,
            this.material.update());
            for (this.layer = c; this.linesUsed + d > this.numLinesAllocated; )
                this.vb && (this.vb.destroy(),
                this.vb = null),
                this.numLinesAllocated *= 2;
            this.vertexFormat = b;
            this.vb || (this.vb = new ab(a,b,2 * this.numLinesAllocated,1),
            this.mesh.vertexBuffer = this.vb,
            this.vbRam = new DataView(this.vb.lock()),
            this.meshInstance || (wh.worldTransform = K.IDENTITY,
            wh._dirtyWorld = wh._dirtyNormal = !1,
            this.meshInstance = new va(wh,this.mesh,this.material),
            this.meshInstance.cull = !1))
        },
        addLines: function(a, b) {
            for (var c = !!b.length, d = 2 * this.linesUsed * this.vertexFormat.size, e, f = 0; f < a.length; f++)
                this.vbRam.setFloat32(d, a[f].x, !0),
                d += 4,
                this.vbRam.setFloat32(d, a[f].y, !0),
                d += 4,
                this.vbRam.setFloat32(d, a[f].z, !0),
                d += 4,
                e = c ? b[f] : b,
                this.vbRam.setUint8(d, 255 * e.r),
                d += 1,
                this.vbRam.setUint8(d, 255 * e.g),
                d += 1,
                this.vbRam.setUint8(d, 255 * e.b),
                d += 1,
                this.vbRam.setUint8(d, 255 * e.a),
                d += 1;
            this.linesUsed += a.length / 2
        },
        finalize: function(a) {
            0 < this.linesUsed && (this.vb.setData(this.vbRam.buffer),
            this.mesh.primitive[0].count = 2 * this.linesUsed,
            a[0] = this.meshInstance,
            this.layer.addMeshInstances(a, !0),
            this.linesUsed = 0)
        }
    });
    xa.prototype = Object.create(M.prototype);
    xa.prototype.constructor = xa;
    xa.prototype._sortLights = function(a) {
        var b = a._lights;
        a._sortedLights[0].length = 0;
        a._sortedLights[1].length = 0;
        for (var c = a._sortedLights[2].length = 0; c < b.length; c++) {
            var d = b[c];
            d.enabled && a._sortedLights[d._type].push(d)
        }
    }
    ;
    xa.prototype._update = function() {
        var a, b, c = this.layerList.length, d = 0;
        if (!this._dirty || !this._dirtyLights || !this._dirtyCameras)
            for (a = 0; a < c; a++) {
                var e = this.layerList[a];
                e._dirty && (this._dirty = !0);
                e._dirtyLights && (this._dirtyLights = !0);
                e._dirtyCameras && (this._dirtyCameras = !0)
            }
        if (this._dirty) {
            d |= 1;
            for (a = this._meshInstances.length = 0; a < c; a++)
                if (e = this.layerList[a],
                !e.passThrough) {
                    var f = e.opaqueMeshInstances;
                    for (b = 0; b < f.length; b++) {
                        var g = f[b];
                        0 > this._meshInstances.indexOf(g) && (this._meshInstances.push(g),
                        g.material && g.material._dirtyBlend && (this._dirtyBlend = !0,
                        g.material._dirtyBlend = !1))
                    }
                    f = e.transparentMeshInstances;
                    for (b = 0; b < f.length; b++)
                        g = f[b],
                        0 > this._meshInstances.indexOf(g) && (this._meshInstances.push(g),
                        g.material && g.material._dirtyBlend && (this._dirtyBlend = !0,
                        g.material._dirtyBlend = !1))
                }
            for (a = 0; a < c; a++)
                this.layerList[a]._dirty = !1,
                this.layerList[a]._version++;
            this._dirty = !1
        }
        if (this._dirtyBlend) {
            d |= 8;
            for (a = 0; a < c; a++)
                if (e = this.layerList[a],
                !e.passThrough) {
                    f = e.opaqueMeshInstances;
                    g = e.transparentMeshInstances;
                    var k = [];
                    var h = [];
                    for (b = 0; b < f.length; b++)
                        f[b].material && 3 !== f[b].material.blendType ? h.push(f[b]) : k.push(f[b]);
                    for (b = 0; b < g.length; b++)
                        g[b].material && 3 !== g[b].material.blendType ? h.push(g[b]) : k.push(g[b]);
                    e.opaqueMeshInstances.length = k.length;
                    for (b = 0; b < k.length; b++)
                        e.opaqueMeshInstances[b] = k[b];
                    e.transparentMeshInstances.length = h.length;
                    for (b = 0; b < h.length; b++)
                        e.transparentMeshInstances[b] = h[b]
                }
            this._dirtyBlend = !1
        }
        if (this._dirtyLights) {
            d |= 2;
            this._lights.length = 0;
            for (a = this._lightShadowCasters.length = 0; a < c; a++)
                for (e = this.layerList[a],
                f = e._lights,
                b = 0; b < f.length; b++)
                    k = f[b],
                    g = this._lights.indexOf(k),
                    0 > g && (this._lights.push(k),
                    g = this._lights.length - 1),
                    (k = this._lightShadowCasters[g]) || (this._lightShadowCasters[g] = []);
            this._sortLights(this);
            this._dirtyLights = !1;
            for (a = 0; a < c; a++)
                e = this.layerList[a],
                this._sortLights(e),
                e._dirtyLights = !1
        }
        if (d)
            for (a = 0; a < c; a++)
                for (e = this.layerList[a],
                f = e._lights,
                b = 0; b < f.length; b++) {
                    k = f[b];
                    g = this._lights.indexOf(k);
                    k = this._lightShadowCasters[g];
                    h = e.shadowCasters;
                    for (g = 0; g < k.length; )
                        0 > this._meshInstances.indexOf(k[g]) ? (k[g] = k[k.length - 1],
                        --k.length) : g++;
                    for (g = 0; g < h.length; g++)
                        0 > k.indexOf(h[g]) && k.push(h[g])
                }
        if (d & 2 || this._dirtyCameras)
            for (this._globalLightCameras.length = 0,
            f = this._sortedLights[0],
            b = 0; b < f.length; b++)
                for (k = f[b],
                this._globalLightCameras[b] = [],
                a = 0; a < c; a++)
                    if (e = this.layerList[a],
                    !(0 > e._sortedLights[0].indexOf(k)))
                        for (g = 0; g < e.cameras.length; g++)
                            0 <= this._globalLightCameras[b].indexOf(e.cameras[g]) || this._globalLightCameras[b].push(e.cameras[g]);
        if (this._dirtyCameras) {
            d |= 4;
            for (a = this.cameras.length = 0; a < c; a++)
                for (e = this.layerList[a],
                b = 0; b < e.cameras.length; b++)
                    f = e.cameras[b],
                    g = this.cameras.indexOf(f),
                    0 > g && this.cameras.push(f);
            this._renderList.length = 0;
            for (a = g = this._renderListCamera.length = 0; a < c; a++)
                if (g)
                    g--;
                else if (e = this.layerList[a],
                0 !== e.cameras.length || e.isPostEffect)
                    if (k = e._cameraHash,
                    0 === k)
                        this._renderList.push(a),
                        this._renderListCamera.push(0);
                    else {
                        f = 1;
                        for (b = a + 1; b < c; b++)
                            if (h = this.layerList[b]._cameraHash,
                            k !== h) {
                                f = b - a - 1;
                                break
                            } else
                                b === c - 1 && (f = b - a);
                        if (1 === f)
                            for (k = 0; k < e.cameras.length; k++)
                                this._renderList.push(a),
                                this._renderListCamera.push(k);
                        else {
                            for (k = 0; k < e.cameras.length; k++)
                                for (b = 0; b <= f; b++)
                                    this._renderList.push(a + b),
                                    this._renderListCamera.push(k);
                            g = f
                        }
                    }
            this._dirtyCameras = !1;
            for (a = 0; a < c; a++)
                this.layerList[a]._dirtyCameras = !1
        }
        if (d & 2 || d & 4)
            for (b = this._globalLightCameraIds.length = 0; b < this._globalLightCameras.length; b++) {
                f = [];
                for (a = 0; a < this._globalLightCameras[b].length; a++)
                    g = this.cameras.indexOf(this._globalLightCameras[b][a]),
                    0 > g || f.push(g);
                this._globalLightCameraIds.push(f)
            }
        return d
    }
    ;
    xa.prototype._isLayerAdded = function(a) {
        return 0 <= this.layerList.indexOf(a) ? !0 : !1
    }
    ;
    xa.prototype._isSublayerAdded = function(a, b) {
        for (var c = 0; c < this.layerList.length; c++)
            if (this.layerList[c] === a && this.subLayerList[c] === b)
                return !0;
        return !1
    }
    ;
    xa.prototype.push = function(a) {
        this._isLayerAdded(a) || (this.layerList.push(a),
        this.layerList.push(a),
        this._opaqueOrder[a.id] = this.subLayerList.push(!1) - 1,
        this._transparentOrder[a.id] = this.subLayerList.push(!0) - 1,
        this.subLayerEnabled.push(!0),
        this.subLayerEnabled.push(!0),
        this._dirtyCameras = this._dirtyLights = this._dirty = !0,
        this.fire("add", a))
    }
    ;
    xa.prototype.insert = function(a, b) {
        if (!this._isLayerAdded(a)) {
            this.layerList.splice(b, 0, a, a);
            this.subLayerList.splice(b, 0, !1, !0);
            var c = this.layerList.length;
            this._updateOpaqueOrder(b, c - 1);
            this._updateTransparentOrder(b, c - 1);
            this.subLayerEnabled.splice(b, 0, !0, !0);
            this._dirtyCameras = this._dirtyLights = this._dirty = !0;
            this.fire("add", a)
        }
    }
    ;
    xa.prototype.remove = function(a) {
        var b = this.layerList.indexOf(a);
        delete this._opaqueOrder[b];
        for (delete this._transparentOrder[b]; 0 <= b; )
            this.layerList.splice(b, 1),
            this.subLayerList.splice(b, 1),
            this.subLayerEnabled.splice(b, 1),
            b = this.layerList.indexOf(a),
            this._dirtyCameras = this._dirtyLights = this._dirty = !0,
            this.fire("remove", a);
        a = this.layerList.length;
        this._updateOpaqueOrder(0, a - 1);
        this._updateTransparentOrder(0, a - 1)
    }
    ;
    xa.prototype.pushOpaque = function(a) {
        this._isSublayerAdded(a, !1) || (this.layerList.push(a),
        this._opaqueOrder[a.id] = this.subLayerList.push(!1) - 1,
        this.subLayerEnabled.push(!0),
        this._dirtyCameras = this._dirtyLights = this._dirty = !0,
        this.fire("add", a))
    }
    ;
    xa.prototype.insertOpaque = function(a, b) {
        this._isSublayerAdded(a, !1) || (this.layerList.splice(b, 0, a),
        this.subLayerList.splice(b, 0, !1),
        this._updateOpaqueOrder(b, this.subLayerList.length - 1),
        this.subLayerEnabled.splice(b, 0, !0),
        this._dirtyCameras = this._dirtyLights = this._dirty = !0,
        this.fire("add", a))
    }
    ;
    xa.prototype.removeOpaque = function(a) {
        for (var b = 0, c = this.layerList.length; b < c; b++)
            if (this.layerList[b] === a && !this.subLayerList[b]) {
                this.layerList.splice(b, 1);
                this.subLayerList.splice(b, 1);
                c--;
                this._updateOpaqueOrder(b, c - 1);
                this.subLayerEnabled.splice(b, 1);
                this._dirtyCameras = this._dirtyLights = this._dirty = !0;
                0 > this.layerList.indexOf(a) && this.fire("remove", a);
                break
            }
    }
    ;
    xa.prototype.pushTransparent = function(a) {
        this._isSublayerAdded(a, !0) || (this.layerList.push(a),
        this._transparentOrder[a.id] = this.subLayerList.push(!0) - 1,
        this.subLayerEnabled.push(!0),
        this._dirtyCameras = this._dirtyLights = this._dirty = !0,
        this.fire("add", a))
    }
    ;
    xa.prototype.insertTransparent = function(a, b) {
        this._isSublayerAdded(a, !0) || (this.layerList.splice(b, 0, a),
        this.subLayerList.splice(b, 0, !0),
        this._updateTransparentOrder(b, this.subLayerList.length - 1),
        this.subLayerEnabled.splice(b, 0, !0),
        this._dirtyCameras = this._dirtyLights = this._dirty = !0,
        this.fire("add", a))
    }
    ;
    xa.prototype.removeTransparent = function(a) {
        for (var b = 0, c = this.layerList.length; b < c; b++)
            if (this.layerList[b] === a && this.subLayerList[b]) {
                this.layerList.splice(b, 1);
                this.subLayerList.splice(b, 1);
                c--;
                this._updateTransparentOrder(b, c - 1);
                this.subLayerEnabled.splice(b, 1);
                this._dirtyCameras = this._dirtyLights = this._dirty = !0;
                0 > this.layerList.indexOf(a) && this.fire("remove", a);
                break
            }
    }
    ;
    xa.prototype._getSublayerIndex = function(a, b) {
        var c = this.layerList.indexOf(a);
        return 0 > c || this.subLayerList[c] !== b && (c = this.layerList.indexOf(a, c + 1),
        0 > c || this.subLayerList[c] !== b) ? -1 : c
    }
    ;
    xa.prototype.getOpaqueIndex = function(a) {
        return this._getSublayerIndex(a, !1)
    }
    ;
    xa.prototype.getTransparentIndex = function(a) {
        return this._getSublayerIndex(a, !0)
    }
    ;
    xa.prototype.getLayerById = function(a) {
        for (var b = 0; b < this.layerList.length; b++)
            if (this.layerList[b].id === a)
                return this.layerList[b];
        return null
    }
    ;
    xa.prototype.getLayerByName = function(a) {
        for (var b = 0; b < this.layerList.length; b++)
            if (this.layerList[b].name === a)
                return this.layerList[b];
        return null
    }
    ;
    xa.prototype._updateOpaqueOrder = function(a, b) {
        for (; a <= b; a++)
            !1 === this.subLayerList[a] && (this._opaqueOrder[this.layerList[a].id] = a)
    }
    ;
    xa.prototype._updateTransparentOrder = function(a, b) {
        for (; a <= b; a++)
            !0 === this.subLayerList[a] && (this._transparentOrder[this.layerList[a].id] = a)
    }
    ;
    xa.prototype._sortLayersDescending = function(a, b, c) {
        var d, e = -1, f = -1;
        var g = 0;
        for (d = a.length; g < d; g++) {
            var k = a[g];
            c.hasOwnProperty(k) && (e = Math.max(e, c[k]))
        }
        g = 0;
        for (d = b.length; g < d; g++)
            k = b[g],
            c.hasOwnProperty(k) && (f = Math.max(f, c[k]));
        return -1 === e && -1 !== f ? 1 : -1 === f && -1 !== e ? -1 : f - e
    }
    ;
    xa.prototype.sortTransparentLayers = function(a, b) {
        return this._sortLayersDescending(a, b, this._transparentOrder)
    }
    ;
    xa.prototype.sortOpaqueLayers = function(a, b) {
        return this._sortLayersDescending(a, b, this._opaqueOrder)
    }
    ;
    var oc = [], Rc = [], Ya, Za = new z, Bc = new oa, Xf = new oa, Yf = {}, nm = ["texture_lightMap", "texture_dirLightMap"], Vj = [];
    Object.assign(ii.prototype, {
        destroy: function() {
            this.assets = this.renderer = this.scene = this.root = this.device = null
        },
        calculateLightmapSize: function(a) {
            var b = this.scene.lightmapSizeMultiplier || 16
              , c = 1
              , d = 1
              , e = 1
              , f = 1;
            if (a.model.asset) {
                var g = this.assets.get(a.model.asset).data;
                g.area && (c = g.area.x,
                d = g.area.y,
                e = g.area.z,
                f = g.area.uv)
            } else
                a.model._area && (g = a.model,
                g._area && (c = g._area.x,
                d = g._area.y,
                e = g._area.z,
                f = g._area.uv));
            g = a.model.lightmapSizeMultiplier || 1;
            c *= g;
            d *= g;
            e *= g;
            Za.copy(a.localScale);
            for (a = a._parent; a; )
                Za.mul(a.localScale),
                a = a._parent;
            Za.x = Math.abs(Za.x);
            Za.y = Math.abs(Za.y);
            Za.z = Math.abs(Za.z);
            c = c * Za.y * Za.z + d * Za.x * Za.z + e * Za.x * Za.y;
            c = Math.sqrt(c / f);
            return Math.min(N.nextPowerOfTwo(c * b), this.scene.lightmapMaxResolution || 2048)
        },
        bake: function(a, b) {
            var c, d, e = this.device, f = this.scene, g = 1;
            void 0 === b && (b = 1);
            1 === b && (g = 2);
            var k;
            b = [];
            var h = [];
            if (a) {
                var l;
                for (c = Rc.length - 1; 0 <= c; c--)
                    for (d = 0; d < a.length; d++)
                        if (Rc[c] === a[d]) {
                            for (l = 0; l < oc[c].length; l++)
                                oc[c][l].destroy();
                            oc.splice(c, 1);
                            Rc.splice(c, 1)
                        }
                l = [];
                for (c = 0; c < a.length; c++)
                    Ag(a[c], l, h);
                a = l;
                Ag(this.root, null, null, b)
            } else {
                for (c = 0; c < oc.length; c++)
                    for (d = 0; d < oc[c].length; d++)
                        oc[c][d].destroy();
                oc = [];
                Rc = [];
                a = [];
                Ag(this.root, a, h, b)
            }
            if (0 === a.length)
                e.fire("lightmapper:end", {
                    timestamp: Lb(),
                    target: this
                });
            else {
                l = !1;
                f._needsStaticPrepare && (f._needsStaticPrepare = !1,
                l = !0);
                var n = [[], []]
                  , p = {};
                d = new V(this.device,{
                    width: 4,
                    height: 4,
                    format: 7,
                    type: "rgbm"
                });
                d.name = "lightmap";
                for (c = 0; c < a.length; c++) {
                    var q = this.calculateLightmapSize(a[c]);
                    for (k = 0; k < g; k++) {
                        var r = new V(e,{
                            width: q,
                            height: q,
                            format: 7,
                            mipmaps: !1,
                            type: 0 === k ? "rgbm" : "default",
                            minFilter: 0,
                            magFilter: 0
                        });
                        r.name = "lightmap";
                        n[k].push(r)
                    }
                    if (!p[q]) {
                        var t = new V(e,{
                            width: q,
                            height: q,
                            format: 7,
                            mipmaps: !1,
                            type: "rgbm",
                            minFilter: 0,
                            magFilter: 0
                        });
                        t.name = "lightmap";
                        t = new ra(e,t,{
                            depth: !1
                        });
                        p[q] = t
                    }
                }
                var u = f.layers;
                u._update();
                q = [];
                t = [];
                var x = []
                  , v = []
                  , w = u._lights;
                for (c = 0; c < w.length; c++)
                    w[c].enabled && (r = w[c].mask,
                    0 !== (r & 4) && (t.push(r),
                    x.push(w[c].shadowUpdateMode),
                    w[c].mask = 4294967295,
                    w[c].shadowUpdateMode = 0 === w[c]._type ? 2 : 1,
                    q.push(w[c]),
                    w[c].isStatic = !1)),
                    v.push(w[c].enabled),
                    w[c].enabled = !1;
                var y = "#define UV1LAYOUT\n" + F.transformVS
                  , A = F.bakeLmEndPS;
                r = Wa(e, F.fullscreenQuadVS, F.dilatePS, "lmDilate");
                var B = e.scope.resolve("source")
                  , E = e.scope.resolve("pixelOffset")
                  , C = e.scope.resolve("bakeDir")
                  , D = new Float32Array(2);
                u = u._meshInstances;
                for (c = 0; c < u.length; c++)
                    u[c].node && u[c].node.getWorldTransform();
                u = f.fog;
                var G = f.ambientLight.r
                  , J = f.ambientLight.g
                  , R = f.ambientLight.b;
                f.fog = "none";
                f.ambientLight.set(0, 0, 0);
                Ya || (Ya = new pa,
                Ya.clearColor = new L(0,0,0,0),
                Ya.clearColorBuffer = !0,
                Ya.clearDepthBuffer = !1,
                Ya.clearStencilBuffer = !1,
                Ya.frustumCulling = !1,
                Ya.node = new Z);
                var I, T = [];
                T.length = Rc.length;
                for (I = 0; I < b.length; I++) {
                    var S = b[I].model.model.meshInstances;
                    var ba = [];
                    for (c = 0; c < S.length; c++)
                        ba.push(S[c]._shaderDefs),
                        S[c]._shaderDefs &= -193;
                    for (c = 0; c < Rc.length; c++)
                        if (Rc[c] === b[I]) {
                            T[c] = ba;
                            break
                        }
                }
                ba = [];
                var ha = [];
                for (I = 0; I < b.length; I++)
                    if (ba[I] = b[I].model.castShadows,
                    b[I].model.castShadows = b[I].model.castShadowsLightmap,
                    b[I].model.castShadowsLightmap) {
                        var W = b[I].model.meshInstances;
                        for (c = 0; c < W.length; c++)
                            W[c].visibleThisFrame = !0,
                            ha.push(W[c])
                    }
                this.renderer.updateCpuSkinMatrices(ha);
                this.renderer.gpuUpdate(ha);
                var Q = []
                  , Nb = [];
                W = [[], []];
                var bf = [];
                bf.length = a.length;
                for (k = 0; k < g; k++)
                    Vj[k] || (c = new la,
                    c.chunks.transformVS = y,
                    0 === k ? (c.chunks.endPS = A,
                    c.ambient = new L(0,0,0),
                    c.ambientTint = !0,
                    c.lightMap = d) : (c.chunks.basePS = F.basePS + "\nuniform sampler2D texture_dirLightMap;\nuniform float bakeDir;\n",
                    c.chunks.endPS = F.bakeDirLmEndPS),
                    c.chunks.outputAlphaPS = "\n",
                    c.chunks.outputAlphaOpaquePS = "\n",
                    c.chunks.outputAlphaPremulPS = "\n",
                    c.cull = 0,
                    c.forceUv1 = !0,
                    c.update(),
                    c.updateShader(e, f),
                    c.name = "lmMaterial" + k,
                    Vj[k] = c);
                for (I = 0; I < a.length; I++) {
                    S = h[I];
                    bf[I] = 0;
                    if (0 < S.length)
                        for (Bc.copy(S[0].aabb),
                        c = 0; c < S.length; c++)
                            S[c].node.getWorldTransform(),
                            Bc.add(S[c].aabb);
                    c = new oa;
                    c.copy(Bc);
                    Nb.push(c);
                    for (c = 0; c < S.length; c++) {
                        var Da = S[c];
                        Da._shaderDefs &= -193;
                        Da.mask = 4;
                        Da.deleteParameter("texture_lightMap");
                        Da.deleteParameter("texture_dirLightMap");
                        Da.setParameter("texture_lightMap", Da.material.lightMap ? Da.material.lightMap : d);
                        Da.setParameter("texture_dirLightMap", d)
                    }
                    for (k = 0; k < g; k++) {
                        var lb = n[k][I];
                        var Cc = new ra(e,lb,{
                            depth: !1
                        });
                        W[k].push(Cc)
                    }
                }
                for (d = 0; d < q.length; d++)
                    q[d].enabled = !1;
                y = [[], [], []];
                A = !1;
                for (c = 0; c < q.length; c++) {
                    q[c].enabled = !0;
                    var Sc = !1;
                    q[c]._cacheShadowMap = !0;
                    0 !== q[c]._type && (q[c]._node.getWorldTransform(),
                    q[c].getBoundingSphere(Yf),
                    Xf.center = Yf.center,
                    Xf.halfExtents.x = Yf.radius,
                    Xf.halfExtents.y = Yf.radius,
                    Xf.halfExtents.z = Yf.radius);
                    if (2 === q[c]._type) {
                        I = q[c];
                        var mb = this.renderer.getShadowCamera(e, I);
                        mb._node.setPosition(I._node.getPosition());
                        mb._node.setRotation(I._node.getRotation());
                        mb._node.rotateLocal(-90, 0, 0);
                        mb.projection = 0;
                        mb.nearClip = I.attenuationEnd / 1E3;
                        mb.farClip = I.attenuationEnd;
                        mb.aspectRatio = 1;
                        mb.fov = 2 * I._outerConeAngle;
                        this.renderer.updateCameraFrustum(mb)
                    }
                    0 < h.length && this.renderer.updateShaders(h[0]);
                    for (I = 0; I < a.length; I++) {
                        S = h[I];
                        Bc = Nb[I];
                        if (0 === q[c]._type)
                            Za.copy(Bc.center),
                            Za.y += Bc.halfExtents.y,
                            Ya.node.setPosition(Za),
                            Ya.node.setEulerAngles(-90, 0, 0),
                            d = Math.max(Bc.halfExtents.x, Bc.halfExtents.z),
                            Ya.projection = 1,
                            Ya.nearClip = 0,
                            Ya.farClip = 2 * Bc.halfExtents.y,
                            Ya.aspectRatio = 1,
                            Ya.orthoHeight = d;
                        else if (!Xf.intersects(Bc))
                            continue;
                        if (2 === q[c]._type) {
                            k = !1;
                            for (d = 0; d < S.length; d++)
                                if (S[d]._isVisible(mb)) {
                                    k = !0;
                                    break
                                }
                            if (!k)
                                continue
                        }
                        0 === q[c]._type ? (y[0][0] = q[c],
                        y[1].length = 0,
                        y[2].length = 0,
                        !Sc && q[c].castShadows && (this.renderer.cullDirectionalShadowmap(q[c], ha, Ya, 0),
                        this.renderer.renderShadows(y[0], 0),
                        Sc = !0)) : (y[0].length = 0,
                        1 === q[c]._type ? (y[1][0] = q[c],
                        y[2].length = 0,
                        !Sc && q[c].castShadows && (this.renderer.cullLocalShadowmap(q[c], ha),
                        this.renderer.renderShadows(y[1]),
                        Sc = !0)) : (y[1].length = 0,
                        y[2][0] = q[c],
                        !Sc && q[c].castShadows && (this.renderer.cullLocalShadowmap(q[c], ha),
                        this.renderer.renderShadows(y[2]),
                        Sc = !0)));
                        for (d = 0; d < S.length; d++)
                            Q[d] = S[d].material;
                        for (k = 0; k < g; k++) {
                            lb = n[k][I];
                            Cc = W[k][I];
                            Da = p[lb.width];
                            var qc = Da.colorBuffer;
                            0 === k ? A = f.updateShaders : A && (f.updateShaders = !0);
                            for (d = 0; d < S.length; d++)
                                S[d].material = Vj[k];
                            1 < g && this.renderer.updateShaders(S);
                            this.renderer.setCamera(Ya, Da, !0);
                            1 === k && C.setValue(q[c].bakeDir ? 1 : 0);
                            this.renderer._forwardTime = 0;
                            this.renderer._shadowMapTime = 0;
                            this.renderer.renderForward(Ya, S, S.length, y, 1);
                            n[k][I] = qc;
                            W[k][I] = Da;
                            p[lb.width] = Cc;
                            for (d = 0; d < S.length; d++)
                                Da = S[d],
                                Da.setParameter(nm[k], qc),
                                Da._shaderDefs |= 64
                        }
                        bf[I]++;
                        for (d = 0; d < S.length; d++)
                            S[d].material = Q[d]
                    }
                    q[c].enabled = !1;
                    q[c]._cacheShadowMap = !1;
                    q[c]._isCachedShadowMap && q[c]._destroyShadowMap()
                }
                for (I = 0; I < a.length; I++) {
                    S = h[I];
                    mb = [];
                    for (k = 0; k < g; k++) {
                        lb = n[k][I];
                        Cc = W[k][I];
                        Da = p[lb.width];
                        qc = Da.colorBuffer;
                        D[0] = 1 / lb.width;
                        D[1] = 1 / lb.height;
                        E.setValue(D);
                        for (c = 0; 4 > c; c++)
                            B.setValue(lb),
                            La(e, Da, r),
                            B.setValue(qc),
                            La(e, Cc, r);
                        for (c = 0; c < S.length; c++)
                            Da = S[c],
                            Da.mask = 2,
                            S[c].setParameter(nm[k], lb),
                            1 === k && (S[c]._shaderDefs |= 128);
                        mb[k] = lb;
                        k === g - 1 && Cc.destroy()
                    }
                    oc.push(mb);
                    Rc.push(a[I])
                }
                for (var Tc in p)
                    p.hasOwnProperty(Tc) && (p[Tc].colorBuffer.destroy(),
                    p[Tc].destroy());
                for (c = 0; c < oc.length; c++)
                    for (d = 0; d < oc[c].length; d++)
                        r = oc[c][d],
                        r.minFilter = 1,
                        r.magFilter = 1;
                for (I = 0; I < b.length; I++)
                    b[I].model.castShadows = ba[I];
                for (c = 0; c < T.length; c++)
                    if (T[c])
                        for (S = Rc[c].model.model.meshInstances,
                        d = 0; d < S.length; d++)
                            S[d]._shaderDefs |= T[c][d] & 192;
                for (c = 0; c < q.length; c++)
                    q[c].mask = t[c],
                    q[c].shadowUpdateMode = x[c];
                for (c = 0; c < w.length; c++)
                    w[c].enabled = v[c];
                f.fog = u;
                f.ambientLight.set(G, J, R);
                l && (f._needsStaticPrepare = !0)
            }
        }
    });
    var Uc, om = 1, Wj = new K, Xj = new K, Dc = new z, Ea = new z, rc = new z, cf = new z, nb = new z, Aa = new z, df = new z, ef = new z, Zf = new z, pm = new z, ob = new z, xh = new z, ie = new z;
    ki.prototype.calcSpawnPosition = function(a, b, c, d, e) {
        var f = this._emitter
          , g = Math.random()
          , k = Math.random()
          , h = Math.random()
          , l = Math.random();
        f.useCpu && (a[4 * e + 8 * f.numParticlesPot] = g,
        a[4 * e + 1 + 8 * f.numParticlesPot] = k,
        a[4 * e + 2 + 8 * f.numParticlesPot] = h);
        Ea.x = g - .5;
        Ea.y = k - .5;
        Ea.z = h - .5;
        0 === f.emitterShape ? (l = Math.max(Math.abs(Ea.x), Math.max(Math.abs(Ea.y), Math.abs(Ea.z))),
        k = l + (.5 - l) * c[1],
        h = l + (.5 - l) * c[2],
        Ea.x = (l + (.5 - l) * c[0]) * (l == Math.abs(Ea.x) ? Math.sign(Ea.x) : 2 * Ea.x),
        Ea.y = k * (l == Math.abs(Ea.y) ? Math.sign(Ea.y) : 2 * Ea.y),
        Ea.z = h * (l == Math.abs(Ea.z) ? Math.sign(Ea.z) : 2 * Ea.z),
        f.localSpace ? Dc.copy(b.transformPoint(Ea)) : Dc.copy(d).add(b.transformPoint(Ea))) : (Ea.normalize(),
        b = 0 === f.emitterRadius ? 0 : f.emitterRadiusInner / f.emitterRadius,
        b = l * (1 - b) + b,
        f.localSpace ? Dc.copy(Ea.scale(b * f.emitterRadius)) : Dc.copy(d).add(Ea.scale(b * f.emitterRadius)));
        d = -N.lerp(f.rate, f.rate2, g) * e;
        f.pack8 ? (l = (Dc.x - f.worldBounds.center.x) / f.worldBoundsSize.x + .5,
        c = (Dc.y - f.worldBounds.center.y) / f.worldBoundsSize.y + .5,
        b = (Dc.z - f.worldBounds.center.z) / f.worldBoundsSize.z + .5,
        g = N.lerp(f.startAngle * N.DEG_TO_RAD, f.startAngle2 * N.DEG_TO_RAD, g),
        g = g % (2 * Math.PI) / (2 * Math.PI),
        l = Bg(l),
        a[4 * e] = l[0],
        a[4 * e + 1] = l[1],
        c = Bg(c),
        a[4 * e + 2] = c[0],
        a[4 * e + 3] = c[1],
        b = Bg(b),
        a[4 * e + 4 * f.numParticlesPot] = b[0],
        a[4 * e + 1 + 4 * f.numParticlesPot] = b[1],
        g = Bg(g),
        a[4 * e + 2 + 4 * f.numParticlesPot] = g[0],
        a[4 * e + 3 + 4 * f.numParticlesPot] = g[1],
        a[4 * e + 3 + 8 * f.numParticlesPot] = 1,
        g = Math.max(f.lifetime, (f.numParticles - 1) * Math.max(f.rate, f.rate2)),
        c = (d + g) / (g + (f.lifetime + 1)),
        g = te(c),
        d = te(255 * c),
        b = te(65025 * c),
        c = te(160581375 * c),
        g -= d / 255,
        d -= b / 255,
        g = [g, d, b - c / 255, c - c / 255],
        a[4 * e + 12 * f.numParticlesPot] = g[0],
        a[4 * e + 1 + 12 * f.numParticlesPot] = g[1],
        a[4 * e + 2 + 12 * f.numParticlesPot] = g[2],
        a[4 * e + 3 + 12 * f.numParticlesPot] = g[3]) : (a[4 * e] = Dc.x,
        a[4 * e + 1] = Dc.y,
        a[4 * e + 2] = Dc.z,
        a[4 * e + 3] = N.lerp(f.startAngle * N.DEG_TO_RAD, f.startAngle2 * N.DEG_TO_RAD, g),
        a[4 * e + 3 + 4 * f.numParticlesPot] = d)
    }
    ;
    ki.prototype.update = function(a, b, c, d, e, f, g, k) {
        var h = this._emitter;
        if (h.meshInstance.node) {
            var l = h.meshInstance.node.worldTransform;
            for (f = 0; 12 > f; f++)
                Wj.data[f] = l.data[f];
            Xj.copy(Wj);
            Xj.invert();
            Uc = h.meshInstance.node.localScale;
            om = Math.max(Math.max(Uc.x, Uc.y), Uc.z)
        }
        f = null === h.meshInstance.node || h.localSpace ? z.ZERO : h.meshInstance.node.getPosition();
        var n = h.camera ? h.camera._node.getPosition() : z.ZERO
          , p = h.useMesh ? 17 : 15
          , q = h.precision - 1;
        for (l = 0; l < h.numParticles; l++) {
            var r = Math.floor(h.vbCPU[l * h.numParticleVerts * (h.useMesh ? 6 : 4) + 3])
              , t = c[4 * r + 8 * h.numParticlesPot];
            rc.x = t;
            rc.y = c[4 * r + 1 + 8 * h.numParticlesPot];
            rc.z = c[4 * r + 2 + 8 * h.numParticlesPot];
            var u = h.rate + (h.rate2 - h.rate) * t
              , x = h.lifetime
              , v = c[4 * r + 3 + 4 * h.numParticlesPot] + g
              , w = Math.max(Math.min(v / x, 1), 0)
              , y = 0;
            var A = 0;
            (0 >= v - g || v >= x) && this.calcSpawnPosition(c, d, e, f, r);
            var B = 0 < v && v < x;
            if (B) {
                A = w * q;
                var E = Math.floor(A);
                var C = Math.ceil(A);
                A %= 1;
                var D = h.qRotSpeed[E];
                var G = h.qRotSpeed[C];
                var J = D + (G - D) * A;
                D = h.qRotSpeed2[E];
                G = h.qRotSpeed2[C];
                var R = D + (G - D) * A;
                D = h.qScale[E];
                G = h.qScale[C];
                y = D + (G - D) * A;
                D = h.qScale2[E];
                G = h.qScale2[C];
                var I = D + (G - D) * A;
                D = h.qAlpha[E];
                G = h.qAlpha[C];
                var T = D + (G - D) * A;
                D = h.qAlpha2[E];
                G = h.qAlpha2[C];
                var S = D + (G - D) * A;
                D = h.qRadialSpeed[E];
                G = h.qRadialSpeed[C];
                var ba = D + (G - D) * A;
                D = h.qRadialSpeed2[E];
                G = h.qRadialSpeed2[C];
                D += (G - D) * A;
                ba += 100 * t % 1 * (D - ba);
                cf.x = c[4 * r];
                cf.y = c[4 * r + 1];
                cf.z = c[4 * r + 2];
                h.localSpace ? Zf.copy(cf) : Zf.copy(cf).sub(f);
                Zf.normalize().scale(ba);
                E *= 3;
                C *= 3;
                D = h.qLocalVelocity[E];
                G = h.qLocalVelocity[C];
                Aa.x = D + (G - D) * A;
                D = h.qLocalVelocity[E + 1];
                G = h.qLocalVelocity[C + 1];
                Aa.y = D + (G - D) * A;
                D = h.qLocalVelocity[E + 2];
                G = h.qLocalVelocity[C + 2];
                Aa.z = D + (G - D) * A;
                D = h.qLocalVelocity2[E];
                G = h.qLocalVelocity2[C];
                ef.x = D + (G - D) * A;
                D = h.qLocalVelocity2[E + 1];
                G = h.qLocalVelocity2[C + 1];
                ef.y = D + (G - D) * A;
                D = h.qLocalVelocity2[E + 2];
                G = h.qLocalVelocity2[C + 2];
                ef.z = D + (G - D) * A;
                D = h.qVelocity[E];
                G = h.qVelocity[C];
                nb.x = D + (G - D) * A;
                D = h.qVelocity[E + 1];
                G = h.qVelocity[C + 1];
                nb.y = D + (G - D) * A;
                D = h.qVelocity[E + 2];
                G = h.qVelocity[C + 2];
                nb.z = D + (G - D) * A;
                D = h.qVelocity2[E];
                G = h.qVelocity2[C];
                df.x = D + (G - D) * A;
                D = h.qVelocity2[E + 1];
                G = h.qVelocity2[C + 1];
                df.y = D + (G - D) * A;
                D = h.qVelocity2[E + 2];
                G = h.qVelocity2[C + 2];
                df.z = D + (G - D) * A;
                Aa.x += (ef.x - Aa.x) * rc.x;
                Aa.y += (ef.y - Aa.y) * rc.y;
                Aa.z += (ef.z - Aa.z) * rc.z;
                0 < h.initialVelocity && (1 === h.emitterShape ? (Ea.copy(rc).scale(2).sub(z.ONE).normalize(),
                Aa.add(Ea.scale(h.initialVelocity))) : Aa.add(z.FORWARD.scale(h.initialVelocity)));
                nb.x += (df.x - nb.x) * rc.x;
                nb.y += (df.y - nb.y) * rc.y;
                nb.z += (df.z - nb.z) * rc.z;
                J += (R - J) * rc.y;
                y = (y + 1E4 * t % 1 * (I - y)) * om;
                A = 1E3 * t % 1 * (S - T);
                h.meshInstance.node && (h.localSpace ? (Aa.x /= Uc.x,
                Aa.y /= Uc.y,
                Aa.z /= Uc.z) : Wj.transformPoint(Aa, Aa));
                h.localSpace ? (Xj.transformPoint(nb, nb),
                Aa.add(nb).add(Zf)) : (Aa.add(nb.mul(Uc)),
                Aa.add(Zf.mul(Uc)));
                xh.copy(Aa);
                pm.copy(cf).add(Aa.scale(g));
                ob.copy(pm);
                c[4 * r] = ob.x;
                c[4 * r + 1] = ob.y;
                c[4 * r + 2] = ob.z;
                c[4 * r + 3] += J * g;
                h.wrap && h.wrapBounds && (h.localSpace || ob.sub(f),
                ob.x = ji(ob.x, h.wrapBounds.x) - .5 * h.wrapBounds.x,
                ob.y = ji(ob.y, h.wrapBounds.y) - .5 * h.wrapBounds.y,
                ob.z = ji(ob.z, h.wrapBounds.z) - .5 * h.wrapBounds.z,
                h.localSpace || ob.add(f));
                0 < h.sort && (1 === h.sort ? (ie.copy(ob).sub(n),
                h.particleDistance[r] = -(ie.x * ie.x + ie.y * ie.y + ie.z * ie.z)) : 2 === h.sort ? h.particleDistance[r] = v : 3 === h.sort && (h.particleDistance[r] = -v))
            }
            k ? 0 > v && (c[4 * r + 3 + 8 * h.numParticlesPot] = -1) : (v >= x && (v -= Math.max(x, (h.numParticles - 1) * u),
            c[4 * r + 3 + 8 * h.numParticlesPot] = h.loop ? 1 : -1),
            0 > v && h.loop && (c[4 * r + 3 + 8 * h.numParticlesPot] = 1));
            0 > c[4 * r + 3 + 8 * h.numParticlesPot] && (B = !1);
            c[4 * r + 3 + 4 * h.numParticlesPot] = v;
            for (J = 0; J < h.numParticleVerts; J++)
                t = (l * h.numParticleVerts + J) * (h.useMesh ? 6 : 4),
                u = h.vbCPU[t],
                x = h.vbCPU[t + 1],
                v = h.vbCPU[t + 2],
                B || (u = x = v = 0),
                E = l * h.numParticleVerts * p + J * p,
                a[E] = ob.x,
                a[E + 1] = ob.y,
                a[E + 2] = ob.z,
                a[E + 3] = w,
                a[E + 4] = h.alignToMotion ? 0 : c[4 * r + 3],
                a[E + 5] = y,
                a[E + 6] = A,
                a[E + 7] = xh.x,
                a[E + 8] = u,
                a[E + 9] = x,
                a[E + 10] = v,
                a[E + 11] = xh.y,
                a[E + 12] = r,
                a[E + 13] = xh.z,
                a[E + 14] = h.vbCPU[t + 3],
                h.useMesh && (a[E + 15] = h.vbCPU[t + 4],
                a[E + 16] = h.vbCPU[t + 5])
        }
        if (0 < h.sort && h.camera) {
            a = h.useMesh ? 6 : 4;
            c = h.particleDistance;
            for (l = 0; l < h.numParticles; l++)
                b[l][0] = l,
                b[l][1] = c[Math.floor(h.vbCPU[l * h.numParticleVerts * a + 3])];
            h.vbOld.set(h.vbCPU);
            b.sort(function(ha, W) {
                return ha[1] - W[1]
            });
            for (l = 0; l < h.numParticles; l++)
                for (c = b[l][0] * h.numParticleVerts * a,
                d = l * h.numParticleVerts * a,
                f = 0; f < h.numParticleVerts * a; f++)
                    h.vbCPU[d + f] = h.vbOld[c + f]
        }
    }
    ;
    var qm = new xb
      , rm = new xb
      , sm = new xb;
    Cg.prototype._setInputBounds = function() {
        this.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x;
        this.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y;
        this.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z;
        this.constantInBoundsSize.setValue(this.inBoundsSizeUniform);
        this.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x;
        this.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y;
        this.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z;
        this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform)
    }
    ;
    Cg.prototype.randomize = function() {
        this.frameRandomUniform[0] = Math.random();
        this.frameRandomUniform[1] = Math.random();
        this.frameRandomUniform[2] = Math.random()
    }
    ;
    Cg.prototype.update = function(a, b, c, d, e) {
        var f = this._emitter;
        a.setBlending(!1);
        a.setColorWrite(!0, !0, !0, !0);
        a.setCullMode(0);
        a.setDepthTest(!1);
        a.setDepthWrite(!1);
        this.randomize();
        this.constantGraphSampleSize.setValue(1 / f.precision);
        this.constantGraphNumSamples.setValue(f.precision);
        this.constantNumParticles.setValue(f.numParticles);
        this.constantNumParticlesPot.setValue(f.numParticlesPot);
        this.constantInternalTex0.setValue(f.internalTex0);
        this.constantInternalTex1.setValue(f.internalTex1);
        this.constantInternalTex2.setValue(f.internalTex2);
        this.constantInternalTex3.setValue(f.internalTex3);
        var g = f.meshInstance.node
          , k = null === g ? z.ONE : g.localScale;
        if (f.pack8) {
            this.worldBoundsMulUniform[0] = f.worldBoundsMul.x;
            this.worldBoundsMulUniform[1] = f.worldBoundsMul.y;
            this.worldBoundsMulUniform[2] = f.worldBoundsMul.z;
            this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);
            this.worldBoundsAddUniform[0] = f.worldBoundsAdd.x;
            this.worldBoundsAddUniform[1] = f.worldBoundsAdd.y;
            this.worldBoundsAddUniform[2] = f.worldBoundsAdd.z;
            this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);
            this._setInputBounds();
            var h = f.maxVel * Math.max(Math.max(k.x, k.y), k.z);
            h = Math.max(h, 1);
            this.constantMaxVel.setValue(h)
        }
        h = null === g || f.localSpace ? z.ZERO : g.getPosition();
        g = null === g ? K.IDENTITY : g.getWorldTransform();
        0 === f.emitterShape ? (Jk(b, qm),
        this.constantSpawnBounds.setValue(qm.data),
        this.constantSpawnPosInnerRatio.setValue(c)) : (this.constantSpawnBoundsSphere.setValue(f.emitterRadius),
        this.constantSpawnBoundsSphereInnerRatio.setValue(0 === f.emitterRadius ? 0 : f.emitterRadiusInner / f.emitterRadius));
        this.constantInitialVelocity.setValue(f.initialVelocity);
        Jk(g, rm);
        g.invertTo3x3(sm);
        this.emitterPosUniform[0] = h.x;
        this.emitterPosUniform[1] = h.y;
        this.emitterPosUniform[2] = h.z;
        this.constantEmitterPos.setValue(this.emitterPosUniform);
        this.constantFrameRandom.setValue(this.frameRandomUniform);
        this.constantDelta.setValue(d);
        this.constantRate.setValue(f.rate);
        this.constantRateDiv.setValue(f.rate2 - f.rate);
        this.constantStartAngle.setValue(f.startAngle * N.DEG_TO_RAD);
        this.constantStartAngle2.setValue(f.startAngle2 * N.DEG_TO_RAD);
        this.constantSeed.setValue(f.seed);
        this.constantLifetime.setValue(f.lifetime);
        this.emitterScaleUniform[0] = k.x;
        this.emitterScaleUniform[1] = k.y;
        this.emitterScaleUniform[2] = k.z;
        this.constantEmitterScale.setValue(this.emitterScaleUniform);
        this.constantEmitterMatrix.setValue(rm.data);
        this.constantEmitterMatrixInv.setValue(sm.data);
        this.constantLocalVelocityDivMult.setValue(f.localVelocityUMax);
        this.constantVelocityDivMult.setValue(f.velocityUMax);
        this.constantRotSpeedDivMult.setValue(f.rotSpeedUMax[0]);
        b = f.swapTex ? f.particleTexOUT : f.particleTexIN;
        b = f.beenReset ? f.particleTexStart : b;
        c = f.swapTex ? f.particleTexIN : f.particleTexOUT;
        this.constantParticleTexIN.setValue(b);
        La(a, f.swapTex ? f.rtParticleTexIN : f.rtParticleTexOUT, e ? f.shaderParticleUpdateOnStop : f.loop ? f.shaderParticleUpdateRespawn : f.shaderParticleUpdateNoRespawn);
        f.material.setParameter("particleTexOUT", b);
        f.material.setParameter("particleTexIN", c);
        f.beenReset = !1;
        f.swapTex = !f.swapTex;
        a.setDepthTest(!0);
        a.setDepthWrite(!0);
        f.prevWorldBoundsSize.copy(f.worldBoundsSize);
        f.prevWorldBoundsCenter.copy(f.worldBounds.center);
        f.pack8 && this._setInputBounds()
    }
    ;
    var tm = [[-1, -1], [1, -1], [1, 1], [-1, 1]], Zb = function(a, b, c, d, e, f, g) {
        e || (e = 14);
        var k = 0;
        g && 7 === e && (k = 1);
        a = new V(a,{
            width: b,
            height: c,
            format: e,
            cubemap: !1,
            mipmaps: !1,
            minFilter: k,
            magFilter: k,
            addressU: 1,
            addressV: 1
        });
        a.name = "PSTexture";
        b = a.lock();
        if (7 === e) {
            e = new Uint8Array(d.length);
            for (c = 0; c < d.length; c++)
                e[c] = d[c] * f * 255;
            d = e
        }
        b.set(d);
        a.unlock();
        return a
    }, um = new gb([0, 0, 1, 0]), vm = new gb([0, 1, 1, 1]), wm = new Cb([0, 0, 1, 0],[0, 0, 1, 0],[0, 0, 1, 0]), ep = new Cb([0, 1, 1, 1],[0, 1, 1, 1],[0, 1, 1, 1]), Vc = 2, Wc = new Float32Array(3), je = new K, xm = new z, yh = new z, zh = new z, Kk, Dg, $b = function(a, b) {
        this.graphicsDevice = a;
        this.precision = 32;
        this._addTimeTime = 0;
        if (!$b.DEFAULT_PARAM_TEXTURE) {
            var c = new Float32Array(1024), d, e;
            for (e = 0; 16 > e; e++)
                for (d = 0; 16 > d; d++) {
                    var f = d + 1 - 8.5;
                    var g = e + 1 - 8.5;
                    g = Math.max(Math.min(1 - Math.max(Math.min(Math.sqrt(f * f + g * g) / 16, 1), 0) - .5, 1), 0);
                    f = 16 * e + d;
                    c[4 * f] = 1;
                    c[4 * f + 1] = 1;
                    c[4 * f + 2] = 1;
                    c[4 * f + 3] = g
                }
            $b.DEFAULT_PARAM_TEXTURE = Zb(a, 16, 16, c, 7, 1, !0);
            $b.DEFAULT_PARAM_TEXTURE.minFilter = 1;
            $b.DEFAULT_PARAM_TEXTURE.magFilter = 1
        }
        Kk = this;
        Dg = b;
        U("numParticles", 1);
        this.numParticles > a.maxTextureSize && (console.warn("WARNING: can't create more than " + a.maxTextureSize + " particles on this device."),
        this.numParticles = a.maxTextureSize);
        U("rate", 1);
        U("rate2", this.rate);
        U("lifetime", 50);
        U("emitterExtents", new z(0,0,0));
        U("emitterExtentsInner", new z(0,0,0));
        U("emitterRadius", 0);
        U("emitterRadiusInner", 0);
        U("emitterShape", 0);
        U("initialVelocity", 1);
        U("wrap", !1);
        U("localSpace", !1);
        U("screenSpace", !1);
        U("wrapBounds", null);
        U("colorMap", $b.DEFAULT_PARAM_TEXTURE);
        U("normalMap", null);
        U("loop", !0);
        U("preWarm", !1);
        U("sort", 0);
        U("mode", 0);
        U("scene", null);
        U("lighting", !1);
        U("halfLambert", !1);
        U("intensity", 1);
        U("stretch", 0);
        U("alignToMotion", !1);
        U("depthSoftening", 0);
        U("mesh", null);
        U("particleNormal", new z(0,1,0));
        U("orientation", 0);
        U("depthWrite", !1);
        U("noFog", !1);
        U("blendType", 2);
        U("node", null);
        U("startAngle", 0);
        U("startAngle2", this.startAngle);
        U("animTilesX", 1);
        U("animTilesY", 1);
        U("animStartFrame", 0);
        U("animNumFrames", 1);
        U("animNumAnimations", 1);
        U("animIndex", 0);
        U("randomizeAnimIndex", !1);
        U("animSpeed", 1);
        U("animLoop", !0);
        this._gpuUpdater = new Cg(this,a);
        this._cpuUpdater = new ki(this);
        this.constantLightCube = a.scope.resolve("lightCube[0]");
        this.emitterPosUniform = new Float32Array(3);
        this.wrapBoundsUniform = new Float32Array(3);
        this.emitterScaleUniform = new Float32Array([1, 1, 1]);
        U("colorGraph", ep);
        U("colorGraph2", this.colorGraph);
        U("scaleGraph", vm);
        U("scaleGraph2", this.scaleGraph);
        U("alphaGraph", vm);
        U("alphaGraph2", this.alphaGraph);
        U("localVelocityGraph", wm);
        U("localVelocityGraph2", this.localVelocityGraph);
        U("velocityGraph", wm);
        U("velocityGraph2", this.velocityGraph);
        U("rotationSpeedGraph", um);
        U("rotationSpeedGraph2", this.rotationSpeedGraph);
        U("radialSpeedGraph", um);
        U("radialSpeedGraph2", this.radialSpeedGraph);
        this.lightCube = new Float32Array(18);
        this.lightCubeDir = Array(6);
        this.lightCubeDir[0] = new z(-1,0,0);
        this.lightCubeDir[1] = new z(1,0,0);
        this.lightCubeDir[2] = new z(0,-1,0);
        this.lightCubeDir[3] = new z(0,1,0);
        this.lightCubeDir[4] = new z(0,0,-1);
        this.lightCubeDir[5] = new z(0,0,1);
        this.animTilesParams = new Float32Array(2);
        this.animParams = new Float32Array(4);
        this.animIndexParams = new Float32Array(2);
        this.camera = this.particleDistance = this.vbOld = this.vbToSort = this.colorParam = this.internalTex2 = this.internalTex1 = this.internalTex0 = null;
        this.swapTex = !1;
        this.useMesh = !0;
        this.useCpu = !1;
        this.pack8 = !0;
        this.localBounds = new oa;
        this.worldBoundsNoTrail = new oa;
        this.worldBoundsTrail = [new oa, new oa];
        this.worldBounds = new oa;
        this.worldBoundsSize = new z;
        this.prevWorldBoundsSize = new z;
        this.prevWorldBoundsCenter = new z;
        this.prevEmitterExtents = this.emitterExtents;
        this.prevEmitterRadius = this.emitterRadius;
        this.worldBoundsMul = new z;
        this.worldBoundsAdd = new z;
        this.timeToSwitchBounds = 0;
        this.shaderParticleUpdateOnStop = this.shaderParticleUpdateNoRespawn = this.shaderParticleUpdateRespawn = null;
        this.numParticleIndices = this.numParticleVerts = 0;
        this.meshInstance = this.material = null;
        this.drawOrder = 0;
        this.seed = Math.random();
        this.fixedTimeStep = 1 / 60;
        this.maxSubSteps = 10;
        this.simTimeTotal = this.simTime = 0;
        this.beenReset = !1;
        this._layer = null;
        this.rebuild()
    };
    Object.assign($b.prototype, {
        onChangeCamera: function() {
            this.regenShader();
            this.resetMaterial()
        },
        calculateBoundsMad: function() {
            this.worldBoundsMul.x = 1 / this.worldBoundsSize.x;
            this.worldBoundsMul.y = 1 / this.worldBoundsSize.y;
            this.worldBoundsMul.z = 1 / this.worldBoundsSize.z;
            this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).scale(-1);
            this.worldBoundsAdd.x += .5;
            this.worldBoundsAdd.y += .5;
            this.worldBoundsAdd.z += .5
        },
        calculateWorldBounds: function() {
            if (this.node) {
                this.prevWorldBoundsSize.copy(this.worldBoundsSize);
                this.prevWorldBoundsCenter.copy(this.worldBounds.center);
                this.useCpu || (0 === this.emitterShape ? !this.emitterExtents.equals(this.prevEmitterExtents) : this.emitterRadius !== this.prevEmitterRadius) && this.calculateLocalBounds();
                var a = this.node.getWorldTransform();
                this.localSpace ? this.worldBoundsNoTrail.copy(this.localBounds) : this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, a);
                this.worldBoundsTrail[0].add(this.worldBoundsNoTrail);
                this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);
                var b = this.simTimeTotal;
                b >= this.timeToSwitchBounds && (this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]),
                this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail),
                this.timeToSwitchBounds = b + this.lifetime);
                this.worldBounds.copy(this.worldBoundsTrail[0]);
                this.worldBoundsSize.copy(this.worldBounds.halfExtents).scale(2);
                this.localSpace ? (this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, a),
                this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, a)) : (this.meshInstance.aabb.copy(this.worldBounds),
                this.meshInstance.mesh.aabb.copy(this.worldBounds));
                this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;
                this.pack8 && this.calculateBoundsMad()
            }
        },
        resetWorldBounds: function() {
            this.node && (this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.localSpace ? K.IDENTITY : this.node.getWorldTransform()),
            this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail),
            this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail),
            this.worldBounds.copy(this.worldBoundsTrail[0]),
            this.worldBoundsSize.copy(this.worldBounds.halfExtents).scale(2),
            this.prevWorldBoundsSize.copy(this.worldBoundsSize),
            this.prevWorldBoundsCenter.copy(this.worldBounds.center),
            this.timeToSwitchBounds = this.simTimeTotal = 0)
        },
        calculateLocalBounds: function() {
            var a = Number.MAX_VALUE, b = Number.MAX_VALUE, c = Number.MAX_VALUE, d = -Number.MAX_VALUE, e = -Number.MAX_VALUE, f = -Number.MAX_VALUE, g = 0, k = 0, h = this.lifetime / this.precision, l = [this.qVelocity, this.qVelocity2], n = [this.qLocalVelocity, this.qLocalVelocity2], p = [0, 0], q = [0, 0], r = [0, 0], t = [0, 0], u = [0, 0], x, v;
            for (x = 0; x < this.precision + 1; x++) {
                var w = Math.min(x, this.precision - 1);
                for (v = 0; 2 > v; v++) {
                    var y = n[v][3 * w] * h + p[v];
                    var A = n[v][3 * w + 1] * h + q[v];
                    var B = n[v][3 * w + 2] * h + r[v];
                    a = Math.min(y, a);
                    b = Math.min(A, b);
                    c = Math.min(B, c);
                    d = Math.max(y, d);
                    e = Math.max(A, e);
                    f = Math.max(B, f);
                    p[v] = y;
                    q[v] = A;
                    r[v] = B
                }
                for (v = 0; 2 > v; v++)
                    u[v] += h * Math.sqrt(l[v][3 * w] * l[v][3 * w] + l[v][3 * w + 1] * l[v][3 * w + 1] + l[v][3 * w + 2] * l[v][3 * w + 2]);
                t[0] += this.qRadialSpeed[w] * h;
                t[1] += this.qRadialSpeed2[w] * h;
                g = Math.max(g, Math.max(Math.abs(t[0]), Math.abs(t[1])));
                k = Math.max(k, this.qScale[w])
            }
            0 === this.emitterShape ? (y = .5 * this.emitterExtents.x,
            A = .5 * this.emitterExtents.y,
            B = .5 * this.emitterExtents.z) : B = A = y = this.emitterRadius;
            h = Math.max(u[0], u[1]);
            yh.x = a - k - y - g - h;
            yh.y = b - k - A - g - h;
            yh.z = c - k - B - g - h;
            zh.x = d + k + y + g + h;
            zh.y = e + k + A + g + h;
            zh.z = f + k + B + g + h;
            this.localBounds.setMinMax(yh, zh)
        },
        rebuild: function() {
            var a, b = this.graphicsDevice;
            null === this.colorMap && (this.colorMap = $b.DEFAULT_PARAM_TEXTURE);
            this.spawnBounds = 0 === this.emitterShape ? this.emitterExtents : this.emitterRadius;
            this.useCpu = this.useCpu || 0 < this.sort || 1 >= b.maxVertexTextures || 64 > b.fragmentUniformsCount || b.forceCpuParticles || !b.extTextureFloat;
            this._destroyResources();
            this.pack8 = (this.pack8 || !b.textureFloatRenderable) && !this.useCpu;
            Vc = this.useCpu || this.pack8 ? 4 : 2;
            this.useMesh = !1;
            this.mesh && (65535 < this.numParticles * this.mesh.vertexBuffer.numVertices ? console.warn("WARNING: particle system can't render mesh particles because numParticles * numVertices is more than 65k. Reverting to quad particles.") : this.useMesh = !0);
            this.numParticlesPot = N.nextPowerOfTwo(this.numParticles);
            this.rebuildGraphs();
            this.calculateLocalBounds();
            this.resetWorldBounds();
            this.node && (this.worldBounds.setFromTransformedAabb(this.localBounds, this.localSpace ? K.IDENTITY : this.node.getWorldTransform()),
            this.worldBoundsTrail[0].copy(this.worldBounds),
            this.worldBoundsTrail[1].copy(this.worldBounds),
            this.worldBoundsSize.copy(this.worldBounds.halfExtents).scale(2),
            this.prevWorldBoundsSize.copy(this.worldBoundsSize),
            this.prevWorldBoundsCenter.copy(this.worldBounds.center),
            this.pack8 && this.calculateBoundsMad());
            this.vbToSort = Array(this.numParticles);
            for (a = 0; a < this.numParticles; a++)
                this.vbToSort[a] = [0, 0];
            this.particleDistance = new Float32Array(this.numParticles);
            this._gpuUpdater.randomize();
            this.particleTex = new Float32Array(this.numParticlesPot * Vc * 4);
            var c = null === this.node || this.localSpace ? z.ZERO : this.node.getPosition();
            0 === this.emitterShape && (null === this.node || this.localSpace ? je.setTRS(z.ZERO, Y.IDENTITY, this.spawnBounds) : je.setTRS(z.ZERO, this.node.getRotation(), xm.copy(this.spawnBounds).mul(this.node.localScale)),
            Wc[0] = 0 != this.emitterExtents.x ? this.emitterExtentsInner.x / this.emitterExtents.x : 0,
            Wc[1] = 0 != this.emitterExtents.y ? this.emitterExtentsInner.y / this.emitterExtents.y : 0,
            Wc[2] = 0 != this.emitterExtents.z ? this.emitterExtentsInner.z / this.emitterExtents.z : 0);
            for (a = 0; a < this.numParticles; a++)
                this._cpuUpdater.calcSpawnPosition(this.particleTex, je, Wc, c, a),
                this.useCpu && (this.particleTex[4 * a + 3 + 8 * this.numParticlesPot] = 1);
            this.particleTexStart = new Float32Array(this.numParticlesPot * Vc * 4);
            for (a = 0; a < this.particleTexStart.length; a++)
                this.particleTexStart[a] = this.particleTex[a];
            this.useCpu || (this.pack8 ? (this.particleTexIN = Zb(b, this.numParticlesPot, Vc, this.particleTex, 7, 1, !1),
            this.particleTexOUT = Zb(b, this.numParticlesPot, Vc, this.particleTex, 7, 1, !1),
            this.particleTexStart = Zb(b, this.numParticlesPot, Vc, this.particleTexStart, 7, 1, !1)) : (this.particleTexIN = Zb(b, this.numParticlesPot, Vc, this.particleTex),
            this.particleTexOUT = Zb(b, this.numParticlesPot, Vc, this.particleTex),
            this.particleTexStart = Zb(b, this.numParticlesPot, Vc, this.particleTexStart)),
            this.rtParticleTexIN = new ra(b,this.particleTexIN,{
                depth: !1
            }),
            this.rtParticleTexOUT = new ra(b,this.particleTexOUT,{
                depth: !1
            }),
            this.swapTex = !1);
            a = (this.localSpace ? "#define LOCAL_SPACE\n" : "") + F.particleUpdaterInitPS + (this.pack8 ? F.particleInputRgba8PS + F.particleOutputRgba8PS : F.particleInputFloatPS + F.particleOutputFloatPS) + (0 === this.emitterShape ? F.particleUpdaterAABBPS : F.particleUpdaterSpherePS) + F.particleUpdaterStartPS;
            c = a + F.particleUpdaterNoRespawnPS + F.particleUpdaterEndPS;
            var d = a + F.particleUpdaterOnStopPS + F.particleUpdaterEndPS
              , e = this.emitterShape + "" + this.pack8 + this.localSpace;
            this.shaderParticleUpdateRespawn = Wa(b, F.fullscreenQuadVS, a + F.particleUpdaterRespawnPS + F.particleUpdaterEndPS, "fsQuad0" + e);
            this.shaderParticleUpdateNoRespawn = Wa(b, F.fullscreenQuadVS, c, "fsQuad1" + e);
            this.shaderParticleUpdateOnStop = Wa(b, F.fullscreenQuadVS, d, "fsQuad2" + e);
            this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;
            this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;
            this._allocate(this.numParticles);
            b = new rb(b);
            b.vertexBuffer = this.vertexBuffer;
            b.indexBuffer[0] = this.indexBuffer;
            b.primitive[0].type = 4;
            b.primitive[0].base = 0;
            b.primitive[0].count = this.numParticles * this.numParticleIndices;
            b.primitive[0].indexed = !0;
            this.material = new ka;
            this.material.name = this.node.name;
            this.material.cull = 0;
            this.material.alphaWrite = !1;
            this.material.blend = !0;
            this.material.blendType = this.blendType;
            this.material.depthWrite = this.depthWrite;
            this.material.emitter = this;
            this.regenShader();
            this.resetMaterial();
            a = this.meshInstance ? this.meshInstance.visible : !0;
            this.meshInstance = new va(this.node,b,this.material);
            this.meshInstance.pick = !1;
            this.meshInstance.updateKey();
            this.meshInstance.cull = !0;
            this.meshInstance._noDepthDrawGl1 = !0;
            this.localSpace ? this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform()) : this.meshInstance.aabb.copy(this.worldBounds);
            this.meshInstance._updateAabb = !1;
            this.meshInstance.visible = a;
            this._initializeTextures();
            this.resetTime();
            this.addTime(0, !1);
            this.preWarm && this.prewarm(this.lifetime)
        },
        _isAnimated: function() {
            return 1 <= this.animNumFrames && (1 < this.animTilesX || 1 < this.animTilesY) && (this.colorMap && this.colorMap !== $b.DEFAULT_PARAM_TEXTURE || this.normalMap)
        },
        rebuildGraphs: function() {
            var a = this.precision, b = this.graphicsDevice, c;
            this.qLocalVelocity = this.localVelocityGraph.quantize(a);
            this.qVelocity = this.velocityGraph.quantize(a);
            this.qColor = this.colorGraph.quantizeClamped(a, 0, 1);
            this.qRotSpeed = this.rotationSpeedGraph.quantize(a);
            this.qScale = this.scaleGraph.quantize(a);
            this.qAlpha = this.alphaGraph.quantize(a);
            this.qRadialSpeed = this.radialSpeedGraph.quantize(a);
            this.qLocalVelocity2 = this.localVelocityGraph2.quantize(a);
            this.qVelocity2 = this.velocityGraph2.quantize(a);
            this.qColor2 = this.colorGraph2.quantizeClamped(a, 0, 1);
            this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(a);
            this.qScale2 = this.scaleGraph2.quantize(a);
            this.qAlpha2 = this.alphaGraph2.quantize(a);
            this.qRadialSpeed2 = this.radialSpeedGraph2.quantize(a);
            for (c = 0; c < a; c++)
                this.qRotSpeed[c] *= N.DEG_TO_RAD,
                this.qRotSpeed2[c] *= N.DEG_TO_RAD;
            this.localVelocityUMax = new Float32Array(3);
            this.velocityUMax = new Float32Array(3);
            this.colorUMax = new Float32Array(3);
            this.rotSpeedUMax = [0];
            this.scaleUMax = [0];
            this.alphaUMax = [0];
            this.radialSpeedUMax = [0];
            this.qLocalVelocityDiv = Jd(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);
            this.qVelocityDiv = Jd(this.qVelocity, this.qVelocity2, this.velocityUMax);
            this.qColorDiv = Jd(this.qColor, this.qColor2, this.colorUMax);
            this.qRotSpeedDiv = Jd(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);
            this.qScaleDiv = Jd(this.qScale, this.qScale2, this.scaleUMax);
            this.qAlphaDiv = Jd(this.qAlpha, this.qAlpha2, this.alphaUMax);
            this.qRadialSpeedDiv = Jd(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax);
            if (this.pack8) {
                var d = [0, 0, 0];
                Id(this.qVelocity, d);
                var e = [0, 0, 0];
                Id(this.qVelocity2, e);
                c = [0, 0, 0];
                Id(this.qLocalVelocity, c);
                var f = [0, 0, 0];
                Id(this.qLocalVelocity2, f);
                var g = [0];
                Id(this.qRadialSpeed, g);
                var k = [0];
                Id(this.qRadialSpeed2, k);
                var h = Math.max(d[0], e[0]);
                h = Math.max(h, d[1]);
                h = Math.max(h, e[1]);
                h = Math.max(h, d[2]);
                h = Math.max(h, e[2]);
                d = Math.max(c[0], f[0]);
                d = Math.max(d, c[1]);
                d = Math.max(d, f[1]);
                d = Math.max(d, c[2]);
                d = Math.max(d, f[2]);
                this.maxVel = h + d + Math.max(g[0], k[0])
            }
            if (!this.useCpu) {
                this.internalTex0 = Zb(b, a, 1, Lk(this.qLocalVelocity, this.qLocalVelocityDiv));
                this.internalTex1 = Zb(b, a, 1, Lk(this.qVelocity, this.qVelocityDiv));
                c = this.qRotSpeed;
                f = this.qScale;
                g = this.qScaleDiv;
                k = this.qRotSpeedDiv;
                h = this.qAlphaDiv;
                d = Array(4 * c.length);
                for (e = 0; e < c.length; e++)
                    d[4 * e] = c[e],
                    d[4 * e + 1] = f[e],
                    d[4 * e + 2] = 0,
                    d[4 * e + 3] = (255 * g[e] << 16 | 255 * k[e] << 8 | 255 * h[e]) / 16777216;
                this.internalTex2 = Zb(b, a, 1, d);
                c = this.qRadialSpeed;
                f = this.qRadialSpeedDiv;
                g = Array(4 * c.length);
                for (k = 0; k < c.length; k++)
                    g[4 * k] = c[k],
                    g[4 * k + 1] = f[k],
                    g[4 * k + 2] = 0,
                    g[4 * k + 3] = 0;
                this.internalTex3 = Zb(b, a, 1, g)
            }
            c = this.qColor;
            f = this.qAlpha;
            g = Array(4 * f.length);
            for (k = 0; k < f.length; k++)
                g[4 * k] = c[3 * k],
                g[4 * k + 1] = c[3 * k + 1],
                g[4 * k + 2] = c[3 * k + 2],
                g[4 * k + 3] = f[k];
            this.colorParam = Zb(b, a, 1, g, 7, 1, !0)
        },
        _initializeTextures: function() {
            this.colorMap && (this.material.setParameter("colorMap", this.colorMap),
            this.lighting && this.normalMap && this.material.setParameter("normalMap", this.normalMap))
        },
        regenShader: function() {
            var a = this.graphicsDevice.getProgramLibrary()
              , b = null !== this.normalMap;
            this.normalOption = 0;
            this.lighting && (this.normalOption = b ? 2 : 1);
            this.material.updateShader = function() {
                this.emitter.scene && this.emitter.camera != this.emitter.scene._activeCamera && (this.emitter.camera = this.emitter.scene._activeCamera,
                this.emitter.onChangeCamera());
                this.shader = a.getProgram("particle", {
                    useCpu: this.emitter.useCpu,
                    normal: this.emitter.normalOption,
                    halflambert: this.emitter.halfLambert,
                    stretch: this.emitter.stretch,
                    alignToMotion: this.emitter.alignToMotion,
                    soft: this.emitter.depthSoftening,
                    mesh: this.emitter.useMesh,
                    gamma: this.emitter.scene ? this.emitter.scene.gammaCorrection : 0,
                    toneMap: this.emitter.scene ? this.emitter.scene.toneMapping : 0,
                    fog: this.emitter.scene && !this.emitter.noFog ? this.emitter.scene.fog : "none",
                    wrap: this.emitter.wrap && this.emitter.wrapBounds,
                    localSpace: this.emitter.localSpace,
                    screenSpace: this.emitter.inTools ? !1 : this.emitter.screenSpace,
                    blend: this.blendType,
                    animTex: this.emitter._isAnimated(),
                    animTexLoop: this.emitter.animLoop,
                    pack8: this.emitter.pack8,
                    customFace: 0 != this.emitter.orientation
                })
            }
            ;
            this.material.updateShader()
        },
        resetMaterial: function() {
            var a = this.material;
            a.setParameter("stretch", this.stretch);
            this._isAnimated() && (a.setParameter("animTexTilesParams", this.animTilesParams),
            a.setParameter("animTexParams", this.animParams),
            a.setParameter("animTexIndexParams", this.animIndexParams));
            a.setParameter("colorMult", this.intensity);
            this.useCpu || (a.setParameter("internalTex0", this.internalTex0),
            a.setParameter("internalTex1", this.internalTex1),
            a.setParameter("internalTex2", this.internalTex2),
            a.setParameter("internalTex3", this.internalTex3));
            a.setParameter("colorParam", this.colorParam);
            a.setParameter("numParticles", this.numParticles);
            a.setParameter("numParticlesPot", this.numParticlesPot);
            a.setParameter("lifetime", this.lifetime);
            a.setParameter("rate", this.rate);
            a.setParameter("rateDiv", this.rate2 - this.rate);
            a.setParameter("seed", this.seed);
            a.setParameter("scaleDivMult", this.scaleUMax[0]);
            a.setParameter("alphaDivMult", this.alphaUMax[0]);
            a.setParameter("radialSpeedDivMult", this.radialSpeedUMax[0]);
            a.setParameter("graphNumSamples", this.precision);
            a.setParameter("graphSampleSize", 1 / this.precision);
            a.setParameter("emitterScale", new Float32Array([1, 1, 1]));
            this.pack8 && (this._gpuUpdater._setInputBounds(),
            a.setParameter("inBoundsSize", this._gpuUpdater.inBoundsSizeUniform),
            a.setParameter("inBoundsCenter", this._gpuUpdater.inBoundsCenterUniform),
            a.setParameter("maxVel", this.maxVel));
            this.wrap && this.wrapBounds && (this.wrapBoundsUniform[0] = this.wrapBounds.x,
            this.wrapBoundsUniform[1] = this.wrapBounds.y,
            this.wrapBoundsUniform[2] = this.wrapBounds.z,
            a.setParameter("wrapBounds", this.wrapBoundsUniform));
            this.colorMap && a.setParameter("colorMap", this.colorMap);
            this.lighting && this.normalMap && a.setParameter("normalMap", this.normalMap);
            0 < this.depthSoftening && a.setParameter("softening", 1 / (this.depthSoftening * this.depthSoftening * 100));
            0 < this.stretch && (a.cull = 0);
            this._compParticleFaceParams()
        },
        _compParticleFaceParams: function() {
            if (0 == this.orientation) {
                var a = new Float32Array([1, 0, 0]);
                var b = new Float32Array([0, 0, 1])
            } else {
                a = 1 == this.orientation ? this.particleNormal.normalize() : (null === this.node ? K.IDENTITY : this.node.getWorldTransform()).transformVector(this.particleNormal).normalize();
                var c = new z(1,0,0);
                1 == Math.abs(c.dot(a)) && c.set(0, 0, 1);
                b = (new z).cross(a, c).normalize();
                c.cross(b, a).normalize();
                a = new Float32Array([c.x, c.y, c.z]);
                b = new Float32Array([b.x, b.y, b.z])
            }
            this.material.setParameter("faceTangent", a);
            this.material.setParameter("faceBinorm", b)
        },
        _allocate: function(a) {
            var b = a * this.numParticleVerts
              , c = a * this.numParticleIndices;
            if (void 0 === this.vertexBuffer || this.vertexBuffer.getNumVertices() !== b) {
                if (this.useCpu)
                    var d = [{
                        semantic: "ATTR0",
                        components: 4,
                        type: 6
                    }, {
                        semantic: "ATTR1",
                        components: 4,
                        type: 6
                    }, {
                        semantic: "ATTR2",
                        components: 4,
                        type: 6
                    }, {
                        semantic: "ATTR3",
                        components: 1,
                        type: 6
                    }, {
                        semantic: "ATTR4",
                        components: this.useMesh ? 4 : 2,
                        type: 6
                    }];
                else
                    d = [{
                        semantic: "ATTR0",
                        components: 4,
                        type: 6
                    }],
                    this.useMesh && d.push({
                        semantic: "ATTR1",
                        components: 2,
                        type: 6
                    });
                d = new Na(this.graphicsDevice,d);
                this.vertexBuffer = new ab(this.graphicsDevice,d,b,1);
                this.indexBuffer = new dc(this.graphicsDevice,1,c);
                d = new Float32Array(this.vertexBuffer.lock());
                if (this.useMesh) {
                    var e = new Float32Array(this.mesh.vertexBuffer.lock());
                    var f = e.length / this.mesh.vertexBuffer.numVertices;
                    for (c = 0; c < this.mesh.vertexBuffer.format.elements.length; c++)
                        if ("TEXCOORD0" === this.mesh.vertexBuffer.format.elements[c].name) {
                            var g = this.mesh.vertexBuffer.format.elements[c].offset / 4;
                            break
                        }
                }
                for (c = 0; c < b; c++) {
                    var k = Math.floor(c / this.numParticleVerts);
                    if (this.useMesh) {
                        var h = c % this.numParticleVerts;
                        d[6 * c] = e[h * f];
                        d[6 * c + 1] = e[h * f + 1];
                        d[6 * c + 2] = e[h * f + 2];
                        d[6 * c + 3] = k;
                        d[6 * c + 4] = e[h * f + g + 0];
                        d[6 * c + 5] = e[h * f + g + 1]
                    } else
                        h = c % 4,
                        d[4 * c] = tm[h][0],
                        d[4 * c + 1] = tm[h][1],
                        d[4 * c + 2] = 0,
                        d[4 * c + 3] = k
                }
                this.useCpu && (this.vbCPU = new Float32Array(d),
                this.vbOld = new Float32Array(this.vbCPU.length));
                this.vertexBuffer.unlock();
                this.useMesh && this.mesh.vertexBuffer.unlock();
                b = 0;
                f = new Uint16Array(this.indexBuffer.lock());
                this.useMesh && (e = new Uint16Array(this.mesh.indexBuffer[0].lock()));
                for (c = 0; c < a; c++)
                    if (this.useMesh)
                        for (g = 0; g < this.numParticleIndices; g++)
                            f[c * this.numParticleIndices + g] = e[g] + c * this.numParticleVerts;
                    else
                        g = 4 * c,
                        f[b++] = g,
                        f[b++] = g + 1,
                        f[b++] = g + 2,
                        f[b++] = g,
                        f[b++] = g + 2,
                        f[b++] = g + 3;
                this.indexBuffer.unlock();
                this.useMesh && this.mesh.indexBuffer[0].unlock()
            }
        },
        reset: function() {
            this.beenReset = !0;
            this.seed = Math.random();
            this.material.setParameter("seed", this.seed);
            if (this.useCpu)
                for (var a = 0; a < this.particleTexStart.length; a++)
                    this.particleTex[a] = this.particleTexStart[a];
            else
                this._initializeTextures();
            this.resetWorldBounds();
            this.resetTime();
            a = this.loop;
            this.loop = !0;
            this.addTime(0, !1);
            this.loop = a;
            this.preWarm && this.prewarm(this.lifetime)
        },
        prewarm: function(a) {
            var b = Math.min(Math.floor(a / this.lifetime * this.precision), this.precision);
            a /= b;
            for (var c = 0; c < b; c++)
                this.addTime(a, !1)
        },
        resetTime: function() {
            var a = Math.max(this.rate, this.rate2) * this.numParticles + this.lifetime;
            this.endTime = Date.now() + 1E3 * a
        },
        finishFrame: function() {
            this.useCpu && this.vertexBuffer.unlock()
        },
        addTime: function(a, b) {
            var c = this.graphicsDevice;
            this.simTimeTotal += a;
            this.calculateWorldBounds();
            if (this._isAnimated()) {
                var d = this.animTilesParams;
                d[0] = 1 / this.animTilesX;
                d[1] = 1 / this.animTilesY;
                d = this.animParams;
                d[0] = this.animStartFrame;
                d[1] = this.animNumFrames * this.animSpeed;
                d[2] = this.animNumFrames - 1;
                d[3] = this.animNumAnimations - 1;
                d = this.animIndexParams;
                d[0] = this.animIndex;
                d[1] = this.randomizeAnimIndex
            }
            this.scene && this.camera != this.scene._activeCamera && (this.camera = this.scene._activeCamera,
            this.onChangeCamera());
            0 === this.emitterShape && (Wc[0] = 0 != this.emitterExtents.x ? this.emitterExtentsInner.x / this.emitterExtents.x : 0,
            Wc[1] = 0 != this.emitterExtents.y ? this.emitterExtentsInner.y / this.emitterExtents.y : 0,
            Wc[2] = 0 != this.emitterExtents.z ? this.emitterExtentsInner.z / this.emitterExtents.z : 0,
            null === this.meshInstance.node ? je.setTRS(z.ZERO, Y.IDENTITY, this.emitterExtents) : je.setTRS(z.ZERO, this.meshInstance.node.getRotation(), xm.copy(this.emitterExtents).mul(this.meshInstance.node.localScale)));
            d = null === this.meshInstance.node ? z.ONE : this.meshInstance.node.localScale;
            this.emitterScaleUniform[0] = d.x;
            this.emitterScaleUniform[1] = d.y;
            this.emitterScaleUniform[2] = d.z;
            this.material.setParameter("emitterScale", this.emitterScaleUniform);
            if (this.localSpace && this.meshInstance.node) {
                var e = this.meshInstance.node.getPosition();
                this.emitterPosUniform[0] = e.x;
                this.emitterPosUniform[1] = e.y;
                this.emitterPosUniform[2] = e.z;
                this.material.setParameter("emitterPos", this.emitterPosUniform)
            }
            this._compParticleFaceParams();
            this.useCpu ? (c = new Float32Array(this.vertexBuffer.lock()),
            this._cpuUpdater.update(c, this.vbToSort, this.particleTex, je, Wc, e, a, b)) : this._gpuUpdater.update(c, je, Wc, a, b);
            if (!this.loop && Date.now() > this.endTime) {
                if (this.onFinished)
                    this.onFinished();
                this.meshInstance.visible = !1
            }
            this.meshInstance && (this.meshInstance.drawOrder = this.drawOrder)
        },
        _destroyResources: function() {
            this.particleTexIN && (this.particleTexIN.destroy(),
            this.particleTexIN = null);
            this.particleTexOUT && (this.particleTexOUT.destroy(),
            this.particleTexOUT = null);
            this.particleTexStart && this.particleTexStart.destroy && (this.particleTexStart.destroy(),
            this.particleTexStart = null);
            this.rtParticleTexIN && (this.rtParticleTexIN.destroy(),
            this.rtParticleTexIN = null);
            this.rtParticleTexOUT && (this.rtParticleTexOUT.destroy(),
            this.rtParticleTexOUT = null);
            this.internalTex0 && (this.internalTex0.destroy(),
            this.internalTex0 = null);
            this.internalTex1 && (this.internalTex1.destroy(),
            this.internalTex1 = null);
            this.internalTex2 && (this.internalTex2.destroy(),
            this.internalTex2 = null);
            this.internalTex3 && (this.internalTex3.destroy(),
            this.internalTex3 = null);
            this.colorParam && (this.colorParam.destroy(),
            this.colorParam = null);
            this.vertexBuffer && (this.vertexBuffer.destroy(),
            this.vertexBuffer = void 0);
            this.indexBuffer && (this.indexBuffer.destroy(),
            this.indexBuffer = void 0);
            this.material && (this.material.destroy(),
            this.material = null)
        },
        destroy: function() {
            this.camera = null;
            this._destroyResources()
        }
    });
    sa.prototype = Object.create(M.prototype);
    sa.prototype.constructor = sa;
    sa.prototype.destroy = function() {
        this.root = null;
        this.defaultMaterial.destroy();
        this.defaultMaterial = null;
        this.off()
    }
    ;
    Object.defineProperty(sa.prototype, "fog", {
        get: function() {
            return this._fog
        },
        set: function(a) {
            a !== this._fog && (this._fog = a,
            this.updateShaders = !0)
        }
    });
    Object.defineProperty(sa.prototype, "gammaCorrection", {
        get: function() {
            return this._gammaCorrection
        },
        set: function(a) {
            a !== this._gammaCorrection && (this._gammaCorrection = a,
            this.updateShaders = !0)
        }
    });
    Object.defineProperty(sa.prototype, "toneMapping", {
        get: function() {
            return this._toneMapping
        },
        set: function(a) {
            a !== this._toneMapping && (this._toneMapping = a,
            this.updateShaders = !0)
        }
    });
    Object.defineProperty(sa.prototype, "skybox", {
        get: function() {
            return this._skyboxCubeMap
        },
        set: function(a) {
            this._skyboxCubeMap = a;
            this._resetSkyboxModel();
            this.updateShaders = !0
        }
    });
    Object.defineProperty(sa.prototype, "skyboxIntensity", {
        get: function() {
            return this._skyboxIntensity
        },
        set: function(a) {
            this._skyboxIntensity = a;
            this._resetSkyboxModel();
            this.updateShaders = !0
        }
    });
    Object.defineProperty(sa.prototype, "skyboxMip", {
        get: function() {
            return this._skyboxMip
        },
        set: function(a) {
            this._skyboxMip = a;
            this._resetSkyboxModel();
            this.updateShaders = !0
        }
    });
    Object.defineProperty(sa.prototype, "skyboxPrefiltered128", {
        get: function() {
            return this._skyboxPrefiltered[0]
        },
        set: function(a) {
            this._skyboxPrefiltered[0] !== a && (this._skyboxPrefiltered[0] = a,
            this.updateShaders = !0)
        }
    });
    Object.defineProperty(sa.prototype, "skyboxPrefiltered64", {
        get: function() {
            return this._skyboxPrefiltered[1]
        },
        set: function(a) {
            this._skyboxPrefiltered[1] !== a && (this._skyboxPrefiltered[1] = a,
            this.updateShaders = !0)
        }
    });
    Object.defineProperty(sa.prototype, "skyboxPrefiltered32", {
        get: function() {
            return this._skyboxPrefiltered[2]
        },
        set: function(a) {
            this._skyboxPrefiltered[2] !== a && (this._skyboxPrefiltered[2] = a,
            this.updateShaders = !0)
        }
    });
    Object.defineProperty(sa.prototype, "skyboxPrefiltered16", {
        get: function() {
            return this._skyboxPrefiltered[3]
        },
        set: function(a) {
            this._skyboxPrefiltered[3] !== a && (this._skyboxPrefiltered[3] = a,
            this.updateShaders = !0)
        }
    });
    Object.defineProperty(sa.prototype, "skyboxPrefiltered8", {
        get: function() {
            return this._skyboxPrefiltered[4]
        },
        set: function(a) {
            this._skyboxPrefiltered[4] !== a && (this._skyboxPrefiltered[4] = a,
            this.updateShaders = !0)
        }
    });
    Object.defineProperty(sa.prototype, "skyboxPrefiltered4", {
        get: function() {
            return this._skyboxPrefiltered[5]
        },
        set: function(a) {
            this._skyboxPrefiltered[5] !== a && (this._skyboxPrefiltered[5] = a,
            this.updateShaders = !0)
        }
    });
    Object.defineProperty(sa.prototype, "drawCalls", {
        get: function() {
            var a = this.layers._meshInstances;
            a.length || (this.layers._update(),
            a = this.layers._meshInstances);
            return a
        },
        set: function(a) {}
    });
    Object.defineProperty(sa.prototype, "layers", {
        get: function() {
            return this._layers
        },
        set: function(a) {
            var b = this._layers;
            this._layers = a;
            this.fire("set:layers", b, a)
        }
    });
    sa.prototype.applySettings = function(a) {
        this._gravity.set(a.physics.gravity[0], a.physics.gravity[1], a.physics.gravity[2]);
        this.ambientLight.set(a.render.global_ambient[0], a.render.global_ambient[1], a.render.global_ambient[2]);
        this._fog = a.render.fog;
        this.fogColor.set(a.render.fog_color[0], a.render.fog_color[1], a.render.fog_color[2]);
        this.fogStart = a.render.fog_start;
        this.fogEnd = a.render.fog_end;
        this.fogDensity = a.render.fog_density;
        this._gammaCorrection = a.render.gamma_correction;
        this._toneMapping = a.render.tonemapping;
        this.lightmapSizeMultiplier = a.render.lightmapSizeMultiplier;
        this.lightmapMaxResolution = a.render.lightmapMaxResolution;
        this.lightmapMode = a.render.lightmapMode;
        this.exposure = a.render.exposure;
        this._skyboxIntensity = void 0 === a.render.skyboxIntensity ? 1 : a.render.skyboxIntensity;
        this._skyboxMip = void 0 === a.render.skyboxMip ? 0 : a.render.skyboxMip;
        this._resetSkyboxModel();
        this.updateShaders = !0
    }
    ;
    sa.prototype._updateSkybox = function(a) {
        if (!this.skyboxModel) {
            var b = [0, 1, 3, 4, 5, 6]
              , c = this._skyboxMip ? this._skyboxPrefiltered[b[this._skyboxMip]] || this._skyboxPrefiltered[0] || this._skyboxCubeMap : this._skyboxCubeMap || this._skyboxPrefiltered[0];
            if (c) {
                var d = new ka
                  , e = this;
                d.updateShader = function(k, h, l, n, p) {
                    this.shader = a.getProgramLibrary().getProgram("skybox", {
                        rgbm: "rgbm" === c.type,
                        hdr: "rgbm" === c.type || 14 === c.format,
                        useIntensity: 1 !== e.skyboxIntensity,
                        mip: c.fixCubemapSeams ? e.skyboxMip : 0,
                        fixSeams: c.fixCubemapSeams,
                        gamma: 1 === p ? e.gammaCorrection ? 3 : 0 : e.gammaCorrection,
                        toneMapping: 1 === p ? 0 : e.toneMapping
                    })
                }
                ;
                d.updateShader();
                d.setParameter("texture_cubeMap", c);
                d.cull = 2;
                d.depthWrite = !1;
                if (b = this.layers.getLayerById(2)) {
                    var f = new Z
                      , g = Eg(a);
                    d = new va(f,g,d);
                    d.cull = !1;
                    d._noDepthDrawGl1 = !0;
                    g = new sb;
                    g.graph = f;
                    g.meshInstances = [d];
                    this.skyboxModel = g;
                    b.addMeshInstances(g.meshInstances);
                    this.skyLayer = b;
                    this._firstUpdateSkybox && (b.enabled = !0,
                    this._firstUpdateSkybox = !1);
                    this.fire("set:skybox", c)
                }
            }
        }
    }
    ;
    sa.prototype._resetSkyboxModel = function() {
        this.skyboxModel && (this.skyLayer.removeMeshInstances(this.skyboxModel.meshInstances),
        this.skyboxModel.destroy());
        this.skyboxModel = null;
        this.updateSkybox = !0
    }
    ;
    sa.prototype.setSkybox = function(a) {
        var b;
        a || (a = [null, null, null, null, null, null, null]);
        var c = !1;
        this._skyboxCubeMap !== a[0] && (c = !0);
        if (!c)
            for (b = 0; 6 > b && !c; b++)
                this._skyboxPrefiltered[b] !== a[b + 1] && (c = !0);
        if (c) {
            for (b = 0; 6 > b; b++)
                this._skyboxPrefiltered[b] = a[b + 1];
            this.skybox = a[0]
        }
    }
    ;
    sa.prototype.destroy = function() {
        this.skybox = null
    }
    ;
    sa.prototype.addModel = function(a) {
        if (!this.containsModel(a)) {
            var b = this.layers.getLayerById(0);
            b && (b.addMeshInstances(a.meshInstances),
            this._models.push(a))
        }
    }
    ;
    sa.prototype.addShadowCaster = function(a) {
        var b = this.layers.getLayerById(0);
        b && b.addShadowCasters(a.meshInstances)
    }
    ;
    sa.prototype.removeModel = function(a) {
        var b = this._models.indexOf(a);
        if (-1 !== b) {
            var c = this.layers.getLayerById(0);
            c && (c.removeMeshInstances(a.meshInstances),
            this._models.splice(b, 1))
        }
    }
    ;
    sa.prototype.removeShadowCasters = function(a) {
        var b = this.layers.getLayerById(0);
        b && b.removeShadowCasters(a.meshInstances)
    }
    ;
    sa.prototype.containsModel = function(a) {
        return 0 <= this._models.indexOf(a)
    }
    ;
    sa.prototype.getModels = function(a) {
        return this._models
    }
    ;
    if (ed()) {
        var ac = function(a, b, c) {
            c = c || {};
            this.volume = void 0 === c.volume ? 1 : c.volume;
            this.loop = void 0 === c.loop ? !1 : c.loop;
            this.pitch = void 0 === c.pitch ? 1 : c.pitch;
            this.sound = b;
            this.suspended = this.paused = !1;
            this.startOffset = this.startTime = 0;
            this.manager = a;
            this.source = null;
            this.gain = a.context.createGain()
        };
        Object.assign(ac.prototype, {
            play: function() {
                if (this.source)
                    throw Error("Call stop() before calling play()");
                this._createSource();
                if (this.source && (this.startTime = this.manager.context.currentTime,
                this.source.start(0, this.startOffset % this.source.buffer.duration),
                this.setVolume(this.volume),
                this.setLoop(this.loop),
                this.setPitch(this.pitch),
                this.manager.on("volumechange", this.onManagerVolumeChange, this),
                this.manager.on("suspend", this.onManagerSuspend, this),
                this.manager.on("resume", this.onManagerResume, this),
                this.manager.suspended))
                    this.onManagerSuspend()
            },
            pause: function() {
                this.source && (this.paused = !0,
                this.startOffset += this.manager.context.currentTime - this.startTime,
                this.source.stop(0),
                this.source = null)
            },
            unpause: function() {
                this.source || !this.paused ? console.warn("Call pause() before unpausing.") : (this._createSource(),
                this.source && (this.startTime = this.manager.context.currentTime,
                this.source.start(0, this.startOffset % this.source.buffer.duration),
                this.setVolume(this.volume),
                this.setLoop(this.loop),
                this.setPitch(this.pitch),
                this.paused = !1))
            },
            stop: function() {
                this.source && (this.source.stop(0),
                this.source = null);
                this.manager.off("volumechange", this.onManagerVolumeChange, this);
                this.manager.off("suspend", this.onManagerSuspend, this);
                this.manager.off("resume", this.onManagerResume, this)
            },
            setLoop: function(a) {
                this.loop = a;
                this.source && (this.source.loop = a)
            },
            setVolume: function(a) {
                this.volume = a = N.clamp(a, 0, 1);
                this.gain && (this.gain.gain.value = a * this.manager.volume)
            },
            setPitch: function(a) {
                this.pitch = a;
                this.source && (this.source.playbackRate.value = a)
            },
            isPlaying: function() {
                return !this.paused && this.source.playbackState === this.source.PLAYING_STATE
            },
            getDuration: function() {
                return this.source ? this.source.buffer.duration : 0
            },
            _createSource: function() {
                var a = this.manager.context;
                this.sound.buffer && (this.source = a.createBufferSource(),
                this.source.buffer = this.sound.buffer,
                this.source.connect(this.gain),
                this.gain.connect(a.destination),
                this.loop || (this.source.onended = this.pause.bind(this)))
            }
        })
    } else
        ue() ? (ac = function(a, b, c) {
            this.volume = c.volume || 1;
            this.loop = c.loop || !1;
            this.sound = b;
            this.pitch = void 0 !== c.pitch ? c.pitch : 1;
            this.suspended = this.paused = !1;
            this.manager = a;
            b.audio && (this.source = b.audio.cloneNode(!1),
            this.source.pause())
        }
        ,
        Object.assign(ac.prototype, {
            play: function() {
                this.source && (this.paused = !1,
                this.setVolume(this.volume),
                this.setLoop(this.loop),
                this.setPitch(this.pitch),
                this.source.play());
                this.manager.on("volumechange", this.onManagerVolumeChange, this);
                this.manager.on("suspend", this.onManagerSuspend, this);
                this.manager.on("resume", this.onManagerResume, this);
                if (this.manager.suspended)
                    this.onManagerSuspend()
            },
            pause: function() {
                this.source && (this.paused = !0,
                this.source.pause())
            },
            unpause: function() {
                this.source && (this.paused = !1,
                this.source.play())
            },
            stop: function() {
                this.source && this.source.pause();
                this.manager.off("volumechange", this.onManagerVolumeChange, this);
                this.manager.off("suspend", this.onManagerSuspend, this);
                this.manager.off("resume", this.onManagerResume, this)
            },
            setVolume: function(a) {
                this.volume = a = N.clamp(a, 0, 1);
                this.source && (this.source.volume = a * this.manager.volume)
            },
            setLoop: function(a) {
                this.loop = a;
                this.source && (this.source.loop = a)
            },
            setPitch: function(a) {
                this.pitch = a;
                this.source && (this.source.playbackRate = a)
            },
            getDuration: function() {
                return this.source && !isNaN(this.source.duration) ? this.source.duration : 0
            },
            isPlaying: function() {
                return !this.source.paused
            }
        })) : ac = function() {}
        ;
    Object.assign(ac.prototype, {
        getVolume: function() {
            return this.volume
        },
        getLoop: function() {
            return this.loop
        },
        getPitch: function() {
            return this.pitch
        },
        onManagerVolumeChange: function() {
            this.setVolume(this.getVolume())
        },
        onManagerSuspend: function() {
            this.isPlaying() && !this.suspended && (this.suspended = !0,
            this.pause())
        },
        onManagerResume: function() {
            this.suspended && (this.suspended = !1,
            this.unpause())
        }
    });
    var Hf = "inverse";
    if (ed()) {
        var $a = function(a, b, c) {
            ac.call(this, a, b, c);
            this.position = new z;
            this.velocity = new z;
            this.panner = a.context.createPanner()
        };
        $a.prototype = Object.create(ac.prototype);
        $a.prototype.constructor = $a;
        Object.assign($a.prototype, {
            getPosition: function() {
                return this.position
            },
            setPosition: function(a) {
                this.position.copy(a);
                this.panner.setPosition(a.x, a.y, a.z)
            },
            getVelocity: function() {
                return this.velocity
            },
            setVelocity: function(a) {
                this.velocity.copy(a);
                this.panner.setVelocity(a.x, a.y, a.z)
            },
            getMaxDistance: function() {
                return this.panner.maxDistance
            },
            setMaxDistance: function(a) {
                this.panner.maxDistance = a
            },
            getMinDistance: function() {
                return this.panner.refDistance
            },
            setMinDistance: function(a) {
                this.panner.refDistance = a
            },
            getRollOffFactor: function() {
                return this.panner.rolloffFactor
            },
            setRollOffFactor: function(a) {
                this.panner.rolloffFactor = a
            },
            getDistanceModel: function() {
                return this.pannel.distanceModel
            },
            setDistanceModel: function(a) {
                this.panner.distanceModel = a
            },
            _createSource: function() {
                var a = this.manager.context;
                this.source = a.createBufferSource();
                this.source.buffer = this.sound.buffer;
                this.source.connect(this.panner);
                this.panner.connect(this.gain);
                this.gain.connect(a.destination);
                this.loop || (this.source.onended = this.pause.bind(this))
            }
        })
    } else if (ue()) {
        var Yj = new z;
        $a = function(a, b) {
            ac.call(this, a, b);
            this.position = new z;
            this.velocity = new z;
            this.maxDistance = 1E4;
            this.rollOffFactor = this.minDistance = 1;
            this.distanceModel = Hf
        }
        ;
        $a.prototype = Object.create(ac.prototype);
        $a.prototype.constructor = $a;
        Object.assign($a.prototype, {
            getPosition: function() {
                return this.position
            },
            setPosition: function(a) {
                this.position.copy(a);
                if (this.source) {
                    var b = this.manager.listener.getPosition();
                    a = this.minDistance;
                    var c = this.maxDistance
                      , d = this.rollOffFactor
                      , e = this.distanceModel;
                    Yj = Yj.sub2(b, this.position);
                    b = Yj.length();
                    if (b < a)
                        a = 1;
                    else if (b > c)
                        a = 0;
                    else {
                        var f = 0;
                        "linear" === e ? f = 1 - d * (b - a) / (c - a) : e === Hf ? f = a / (a + d * (b - a)) : "exponential" === e && (f = Math.pow(b / a, -d));
                        a = N.clamp(f, 0, 1)
                    }
                    c = this.getVolume();
                    this.source.volume = c * a
                }
            },
            getVelocity: function() {
                return this.velocity
            },
            setVelocity: function(a) {
                this.velocity.copy(a)
            },
            getMaxDistance: function() {
                return this.maxDistance
            },
            setMaxDistance: function(a) {
                this.maxDistance = a
            },
            getMinDistance: function() {
                return this.minDistance
            },
            setMinDistance: function(a) {
                this.minDistance = a
            },
            getRollOffFactor: function() {
                return this.rollOffFactor
            },
            setRollOffFactor: function(a) {
                this.rollOffFactor = a
            },
            getDistanceModel: function() {
                return this.distanceModel
            },
            setDistanceModel: function(a) {
                this.distanceModel = a
            }
        })
    } else
        $a = function() {}
        ;
    Object.assign(ri.prototype, {
        getPosition: function() {
            return this.position
        },
        setPosition: function(a) {
            this.position.copy(a);
            this.listener && this.listener.setPosition(a.x, a.y, a.z)
        },
        getVelocity: function() {
            return this.velocity
        },
        setVelocity: function(a) {
            this.velocity.copy(a);
            this.listener && this.listener.setPosition(a.x, a.y, a.z)
        },
        setOrientation: function(a) {
            this.orientation.copy(a);
            this.listener && this.listener.setOrientation(-a.data[8], -a.data[9], -a.data[10], a.data[4], a.data[5], a.data[6])
        },
        getOrientation: function() {
            return this.orientation
        }
    });
    ec.prototype = Object.create(M.prototype);
    ec.prototype.constructor = ec;
    Object.assign(ec.prototype, {
        suspend: function() {
            this.suspended = !0;
            this.fire("suspend")
        },
        resume: function() {
            this.suspended = !1;
            this.fire("resume")
        },
        destroy: function() {
            window.removeEventListener("mousedown", this.resumeContext);
            window.removeEventListener("touchend", this.resumeContext);
            this.fire("destroy");
            this.context && this.context.close && (this.context.close(),
            this.context = null)
        },
        playSound: function(a, b) {
            b = b || {};
            var c = null;
            ac && (c = new ac(this,a,b),
            c.play());
            return c
        },
        playSound3d: function(a, b, c) {
            c = c || {};
            var d = null;
            $a && (d = new $a(this,a,c),
            d.setPosition(b),
            c.volume && d.setVolume(c.volume),
            c.loop && d.setLoop(c.loop),
            c.maxDistance && d.setMaxDistance(c.maxDistance),
            c.minDistance && d.setMinDistance(c.minDistance),
            c.rollOffFactor && d.setRollOffFactor(c.rollOffFactor),
            c.distanceModel && d.setDistanceModel(c.distanceModel),
            d.play());
            return d
        }
    });
    Object.defineProperty(ec.prototype, "volume", {
        get: function() {
            return this._volume
        },
        set: function(a) {
            this._volume = a = N.clamp(a, 0, 1);
            this.fire("volumechange", a)
        }
    });
    Rb.prototype.getDuration = function() {
        return this.duration
    }
    ;
    Rb.prototype.getName = function() {
        return this.name
    }
    ;
    Rb.prototype.getNode = function(a) {
        return this._nodeDict[a]
    }
    ;
    Object.defineProperty(Rb.prototype, "nodes", {
        get: function() {
            return this._nodes
        }
    });
    Rb.prototype.getNodes = function() {
        return this._nodes
    }
    ;
    Rb.prototype.setDuration = function(a) {
        this.duration = a
    }
    ;
    Rb.prototype.setName = function(a) {
        this.name = a
    }
    ;
    Rb.prototype.addNode = function(a) {
        this._nodes.push(a);
        this._nodeDict[a._name] = a
    }
    ;
    Object.defineProperties(tf.prototype, {
        morphPositions: {
            get: function() {
                return !!this._vertexBufferPositions || !!this.texturePositions
            }
        },
        morphNormals: {
            get: function() {
                return !!this._vertexBufferNormals || !!this.textureNormals
            }
        }
    });
    Object.assign(tf.prototype, {
        _postInit: function() {
            this.options = null
        },
        _initVertexBuffers: function(a) {
            var b = this.options;
            this._vertexBufferPositions = this._createVertexBuffer(a, b.deltaPositions, b.deltaPositionsType);
            this._vertexBufferNormals = this._createVertexBuffer(a, b.deltaNormals, b.deltaNormalsType);
            this._vertexBufferPositions && (this.deltaPositions = this._vertexBufferPositions.lock())
        },
        _createVertexBuffer: function(a, b, c) {
            return b ? new ab(a,new Na(a,[{
                semantic: "ATTR0",
                components: 3,
                type: c || 6
            }]),b.length / 3,0,b) : null
        },
        _setTexture: function(a, b) {
            this[a] = b
        },
        destroy: function() {
            this._vertexBufferPositions && (this._vertexBufferPositions.destroy(),
            this._vertexBufferPositions = null);
            this._vertexBufferNormals && (this._vertexBufferNormals.destroy(),
            this._vertexBufferNormals = null);
            this.texturePositions && (this.texturePositions.destroy(),
            this.texturePositions = null);
            this.textureNormals && (this.textureNormals.destroy(),
            this.textureNormals = null)
        }
    });
    Object.assign(uf.prototype, {
        encode: function(a) {
            return uc.joinPath([uc.joinPath(a[0]), a[1], uc.joinPath(a[2])], "/")
        },
        decode: function(a) {
            a = uc.splitPath(a, "/");
            return [uc.splitPath(a[0]), a[1], uc.splitPath(a[2])]
        }
    });
    fa.prototype = Object.create(Z.prototype);
    fa.prototype.constructor = fa;
    fa.prototype.addComponent = function(a, b) {
        var c = this._app.systems[a];
        return !c || this.c[a] ? null : c.addComponent(this, b)
    }
    ;
    fa.prototype.removeComponent = function(a) {
        var b = this._app.systems[a];
        b && this.c[a] && b.removeComponent(this)
    }
    ;
    fa.prototype.findComponent = function(a) {
        var b = this.findOne(function(c) {
            return c.c && c.c[a]
        });
        return b && b.c[a]
    }
    ;
    fa.prototype.findComponents = function(a) {
        return this.find(function(b) {
            return b.c && b.c[a]
        }).map(function(b) {
            return b.c[a]
        })
    }
    ;
    fa.prototype.getGuid = function() {
        this._guid || this.setGuid(Ql.create());
        return this._guid
    }
    ;
    fa.prototype.setGuid = function(a) {
        var b = this._app._entityIndex;
        this._guid && delete b[this._guid];
        this._guid = a;
        b[this._guid] = this
    }
    ;
    fa.prototype._notifyHierarchyStateChanged = function(a, b) {
        var c = !1;
        a === this && 0 === this._app._enableList.length && (c = !0);
        a._beingEnabled = !0;
        a._onHierarchyStateChanged(b);
        a._onHierarchyStatePostChanged && this._app._enableList.push(a);
        var d, e = a._children;
        var f = 0;
        for (d = e.length; f < d; f++)
            e[f]._enabled && this._notifyHierarchyStateChanged(e[f], b);
        a._beingEnabled = !1;
        if (c) {
            for (f = 0; f < this._app._enableList.length; f++)
                this._app._enableList[f]._onHierarchyStatePostChanged();
            this._app._enableList.length = 0
        }
    }
    ;
    fa.prototype._onHierarchyStateChanged = function(a) {
        Z.prototype._onHierarchyStateChanged.call(this, a);
        var b = this.c, c;
        for (c in b)
            if (b.hasOwnProperty(c)) {
                var d = b[c];
                if (d.enabled)
                    if (a)
                        d.onEnable();
                    else
                        d.onDisable()
            }
    }
    ;
    fa.prototype._onHierarchyStatePostChanged = function() {
        var a = this.c, b;
        for (b in a)
            if (a.hasOwnProperty(b))
                a[b].onPostStateChange()
    }
    ;
    fa.prototype.findByGuid = function(a) {
        return this._guid === a ? this : (a = this._app._entityIndex[a]) && (a === this || a.isDescendantOf(this)) ? a : null
    }
    ;
    fa.prototype.destroy = function() {
        this._destroying = !0;
        for (a in this.c)
            this.c[a].enabled = !1;
        for (a in this.c)
            this.c[a].system.removeComponent(this);
        this._parent && this._parent.removeChild(this);
        var a = this._children;
        for (var b = a.shift(); b; )
            b instanceof fa && b.destroy(),
            b._parent = null,
            b = a.shift();
        this.fire("destroy", this);
        this.off();
        this._guid && delete this._app._entityIndex[this._guid];
        this._destroying = !1
    }
    ;
    fa.prototype.clone = function() {
        var a = {}
          , b = this._cloneRecursively(a);
        a[this.getGuid()] = b;
        Pk(this, this, b, a);
        return b
    }
    ;
    fa.prototype._cloneRecursively = function(a) {
        var b = new fa(this._app);
        Z.prototype._cloneInternal.call(this, b);
        for (var c in this.c)
            this.c[c].system.cloneComponent(this, b);
        for (c = 0; c < this._children.length; c++) {
            var d = this._children[c];
            if (d instanceof fa) {
                var e = d._cloneRecursively(a);
                b.addChild(e);
                a[d.getGuid()] = e
            }
        }
        return b
    }
    ;
    Object.defineProperties(vf.prototype, {
        components: {
            get: function() {
                return this._components
            }
        },
        data: {
            get: function() {
                return this._data
            }
        }
    });
    Object.assign(Qk.prototype, {
        update: function(a, b) {
            if (a < this._left || a >= this._right) {
                var c = b.length;
                c ? a < b[0] ? (this._left = -Infinity,
                this._right = b[0],
                this._p0 = this._p1 = this._recip = this._len = 0) : a >= b[c - 1] ? (this._left = b[c - 1],
                this._right = Infinity,
                this._recip = this._len = 0,
                this._p0 = this._p1 = c - 1) : (c = this._findKey(a, b),
                this._left = b[c],
                this._right = b[c + 1],
                this._len = this._right - this._left,
                b = 1 / this._len,
                this._recip = isFinite(b) ? b : 0,
                this._p0 = c,
                this._p1 = c + 1) : (this._left = -Infinity,
                this._right = Infinity,
                this._p0 = this._p1 = this._recip = this._len = 0)
            }
            this._t = 0 === this._recip ? 0 : (a - this._left) * this._recip;
            this._hermite.valid = !1
        },
        _findKey: function(a, b) {
            for (var c = 0; a >= b[c + 1]; )
                c++;
            return c
        },
        eval: function(a, b, c) {
            var d = c._data;
            c = c._components;
            var e = this._p0 * c, f;
            if (0 === b)
                for (f = 0; f < c; ++f)
                    a[f] = d[e + f];
            else {
                var g = this._t
                  , k = this._p1 * c;
                switch (b) {
                case 1:
                    for (f = 0; f < c; ++f)
                        a[f] = N.lerp(d[e + f], d[k + f], g);
                    break;
                case 2:
                    b = this._hermite;
                    b.valid || (f = g * g,
                    e = g + g,
                    k = 1 - g,
                    k *= k,
                    b.valid = !0,
                    b.p0 = (1 + e) * k,
                    b.m0 = g * k,
                    b.p1 = f * (3 - e),
                    b.m1 = f * (g - 1));
                    g = (3 * this._p0 + 1) * c;
                    e = (3 * this._p0 + 2) * c;
                    k = (3 * this._p1 + 1) * c;
                    var h = 3 * this._p1 * c;
                    for (f = 0; f < c; ++f)
                        a[f] = b.p0 * d[g + f] + b.m0 * d[e + f] * this._len + b.p1 * d[k + f] + b.m1 * d[h + f] * this._len
                }
            }
        }
    });
    Object.defineProperties(Ig.prototype, {
        paths: {
            get: function() {
                return this._paths
            }
        },
        input: {
            get: function() {
                return this._input
            }
        },
        output: {
            get: function() {
                return this._output
            }
        },
        interpolation: {
            get: function() {
                return this._interpolation
            }
        }
    });
    Object.defineProperties(Kd.prototype, {
        name: {
            get: function() {
                return this._name
            }
        },
        duration: {
            get: function() {
                return this._duration
            }
        },
        inputs: {
            get: function() {
                return this._inputs
            }
        },
        outputs: {
            get: function() {
                return this._outputs
            }
        },
        curves: {
            get: function() {
                return this._curves
            }
        }
    });
    Object.assign(Kd.prototype, {
        eval: function(a, b) {
            b._time = a;
            var c = this._inputs
              , d = this._outputs
              , e = this._curves
              , f = b._cache;
            b = b._results;
            var g;
            for (g = 0; g < c.length; ++g)
                f[g].update(a, c[g]._data);
            for (g = 0; g < e.length; ++g)
                a = e[g],
                f[a._input].eval(b[g], a._interpolation, d[a._output])
        }
    });
    Object.defineProperties(wf.prototype, {
        name: {
            get: function() {
                return this._name
            },
            set: function(a) {
                this._name = a
            }
        },
        track: {
            get: function() {
                return this._track
            }
        },
        snapshot: {
            get: function() {
                return this._snapshot
            }
        },
        time: {
            get: function() {
                return this._time
            },
            set: function(a) {
                this._time = a
            }
        },
        speed: {
            get: function() {
                return this._speed
            },
            set: function(a) {
                this._speed = a
            }
        },
        loop: {
            get: function() {
                return this._loop
            },
            set: function(a) {
                this._loop = a
            }
        },
        blendWeight: {
            get: function() {
                return this._blendWeight
            },
            set: function(a) {
                this._blendWeight = a
            }
        },
        blendOrder: {
            get: function() {
                return this._blendOrder
            },
            set: function(a) {
                this._blendOrder = a
            }
        }
    });
    Object.assign(wf.prototype, {
        _update: function(a) {
            if (this._playing) {
                var b = this._time
                  , c = this._track.duration
                  , d = this._speed
                  , e = this._loop;
                b += d * a;
                0 <= d ? b > c && (e ? b = b % c || 0 : (b = this._track.duration,
                this.pause())) : 0 > b && (e ? b = c + (b % c || 0) : (b = 0,
                this.pause()));
                this._time = b
            }
            this._time != this._snapshot._time && this._track.eval(this._time, this._snapshot)
        },
        play: function() {
            this._playing = !0;
            this._time = 0
        },
        stop: function() {
            this._playing = !1;
            this._time = 0
        },
        pause: function() {
            this._playing = !1
        },
        resume: function() {
            this._playing = !0
        },
        reset: function() {
            this._time = 0
        }
    });
    Object.defineProperties(Ic.prototype, {
        func: {
            get: function() {
                return this._func
            }
        },
        type: {
            get: function() {
                return this._type
            }
        },
        components: {
            get: function() {
                return this._components
            }
        }
    });
    uc.joinPath = function(a, b) {
        b = b || ".";
        return a.map(function(c) {
            return c.replace(/\\/g, "\\\\").replace(new RegExp("\\" + b,"g"), "\\" + b)
        }).join(b)
    }
    ;
    uc.splitPath = function(a, b) {
        b = b || ".";
        for (var c = [], d = "", e = 0; e < a.length; ) {
            var f = a[e++];
            "\\" === f && e < a.length ? (f = a[e++],
            d = "\\" === f || f === b ? d + f : d + ("\\" + f)) : f === b ? (c.push(d),
            d = "") : d += f
        }
        0 < d.length && c.push(d);
        return c
    }
    ;
    Object.assign(uc.prototype, {
        resolve: function(a) {
            return null
        },
        unresolve: function(a) {},
        update: function(a) {}
    });
    Object.assign(xf.prototype, {
        resolve: function(a) {
            var b = this.propertyLocator.decode(a);
            a = this.nodes[b[0][0] || ""];
            if (!a)
                return null;
            b = this.handlers[b[2][0]];
            if (!b)
                return null;
            b = b(a.node);
            if (!b)
                return null;
            0 === a.count && this.activeNodes.push(a.node);
            a.count++;
            return b
        },
        unresolve: function(a) {
            a = this.propertyLocator.decode(a);
            if ("graph" === a[1]) {
                var b = this.nodes[a[0][0]];
                b.count--;
                if (0 === b.count) {
                    a = this.activeNodes;
                    b = a.indexOf(b.node);
                    var c = a.length;
                    b < c - 1 && (a[b] = a[c - 1]);
                    a.pop()
                }
            }
        },
        update: function(a) {
            a = this.activeNodes;
            for (var b = 0; b < a.length; ++b)
                a[b]._dirtifyLocal()
        }
    });
    Object.defineProperties(Ja.prototype, {
        clips: {
            get: function() {
                return this._clips
            }
        }
    });
    Ja._dot = function(a, b) {
        for (var c = a.length, d = 0, e = 0; e < c; ++e)
            d += a[e] * b[e];
        return d
    }
    ;
    Ja._normalize = function(a) {
        var b = Ja._dot(a, a);
        if (0 < b) {
            b = 1 / Math.sqrt(b);
            for (var c = a.length, d = 0; d < c; ++d)
                a[d] *= b
        }
    }
    ;
    Ja._set = function(a, b, c) {
        var d = a.length;
        if ("quaternion" === c) {
            var e = Ja._dot(b, b);
            0 < e && (e = 1 / Math.sqrt(e));
            for (c = 0; c < d; ++c)
                a[c] = b[c] * e
        } else
            for (c = 0; c < d; ++c)
                a[c] = b[c]
    }
    ;
    Ja._blendVec = function(a, b, c) {
        for (var d = 1 - c, e = a.length, f = 0; f < e; ++f)
            a[f] = a[f] * d + b[f] * c
    }
    ;
    Ja._blendQuat = function(a, b, c) {
        var d = a.length
          , e = 1 - c;
        0 > Ja._dot(a, b) && (c = -c);
        for (var f = 0; f < d; ++f)
            a[f] = a[f] * e + b[f] * c;
        Ja._normalize(a)
    }
    ;
    Ja._blend = function(a, b, c, d) {
        "quaternion" === d ? Ja._blendQuat(a, b, c) : Ja._blendVec(a, b, c)
    }
    ;
    Ja._stableSort = function(a, b) {
        for (var c = a.length, d = 0; d < c - 1; ++d)
            for (var e = d + 1; e < c; ++e)
                if (b(a[e], a[d])) {
                    var f = a[d];
                    a[d] = a[e];
                    a[e] = f
                }
    }
    ;
    Object.assign(Ja.prototype, {
        addClip: function(a) {
            for (var b = this._targets, c = a.track.curves, d = a.snapshot, e = [], f = [], g = 0; g < c.length; ++g)
                for (var k = c[g].paths, h = 0; h < k.length; ++h) {
                    var l = k[h]
                      , n = b[l];
                    if (!n) {
                        var p = this._binder.resolve(l);
                        if (p) {
                            n = {
                                target: p,
                                value: [],
                                curves: 0,
                                blendCounter: 0
                            };
                            for (p = 0; p < n.target.components; ++p)
                                n.value.push(0);
                            b[l] = n
                        }
                    }
                    n && (n.curves++,
                    e.push(d._results[g]),
                    f.push(n))
                }
            this._clips.push(a);
            this._inputs.push(e);
            this._outputs.push(f)
        },
        removeClip: function(a) {
            for (var b = this._targets, c = this._clips, d = c[a].track.curves, e = 0; e < d.length; ++e)
                for (var f = d[e].paths, g = 0; g < f.length; ++g) {
                    var k = f[g]
                      , h = b[k];
                    h && (h.curves--,
                    0 === h.curves && (this._binder.unresolve(k),
                    delete b[k]))
                }
            c.splice(a, 1);
            this._inputs.splice(a, 1);
            this._outputs.splice(a, 1)
        },
        removeClips: function() {
            for (; 0 < this._clips.length; )
                this.removeClip(0)
        },
        findClip: function(a) {
            for (var b = this._clips, c = 0; c < b.length; ++c) {
                var d = b[c];
                if (d.name === a)
                    return d
            }
            return null
        },
        update: function(a) {
            var b = this._clips
              , c = b.map(function(q, r) {
                return r
            });
            Ja._stableSort(c, function(q, r) {
                return b[q].blendOrder < b[r].blendOrder
            });
            var d;
            for (d = 0; d < b.length; ++d) {
                var e = c[d];
                var f = b[e];
                var g = this._inputs[e];
                e = this._outputs[e];
                var k = f.blendWeight;
                0 < k && f._update(a);
                if (1 <= k)
                    for (f = 0; f < g.length; ++f) {
                        var h = g[f];
                        var l = e[f];
                        var n = l.value;
                        Ja._set(n, h, l.target.type);
                        l.blendCounter++
                    }
                else if (0 < k)
                    for (f = 0; f < g.length; ++f)
                        h = g[f],
                        l = e[f],
                        n = l.value,
                        0 === l.blendCounter ? Ja._set(n, h, l.target.type) : Ja._blend(n, h, k, l.target.type),
                        l.blendCounter++
            }
            c = this._targets;
            for (var p in c)
                c.hasOwnProperty(p) && (d = c[p],
                d.target.func(d.value),
                d.blendCounter = 0);
            this._binder.update(a)
        }
    });
    si.prototype._validate = function(a) {
        if (!a.header)
            throw Error('pc.I18n#addData: Missing "header" field');
        if (!a.header.version)
            throw Error('pc.I18n#addData: Missing "header.version" field');
        if (1 !== a.header.version)
            throw Error('pc.I18n#addData: Invalid "header.version" field');
        if (!a.data)
            throw Error('pc.I18n#addData: Missing "data" field');
        if (!Array.isArray(a.data))
            throw Error('pc.I18n#addData: "data" field must be an array');
        for (var b = 0, c = a.data.length; b < c; b++) {
            var d = a.data[b];
            if (!d.info)
                throw Error('pc.I18n#addData: missing "data[' + b + '].info" field');
            if (!d.info.locale)
                throw Error('pc.I18n#addData: missing "data[' + b + '].info.locale" field');
            if ("string" !== typeof d.info.locale)
                throw Error('pc.I18n#addData: "data[' + b + '].info.locale" must be a string');
            if (!d.messages)
                throw Error('pc.I18n#addData: missing "data[' + b + '].messages" field');
        }
    }
    ;
    si.prototype.parse = function(a) {
        return a.data
    }
    ;
    var $f = {}
      , ud = function(a, b) {
        for (var c = 0, d = a.length; c < d; c++)
            $f[a[c]] = b
    }
      , vd = function(a) {
        var b = a.indexOf("-");
        return -1 !== b ? a.substring(0, b) : a
    }
      , Jg = "en-US"
      , Ah = {
        en: "en-US",
        es: "en-ES",
        zh: "zh-CN",
        "zh-HK": "zh-TW",
        "zh-TW": "zh-HK",
        "zh-MO": "zh-HK",
        fr: "fr-FR",
        de: "de-DE",
        it: "it-IT",
        ru: "ru-RU",
        ja: "ja-JP"
    };
    ud("ja ko th vi zh id".split(" "), function(a) {
        return 0
    });
    ud(["fa", "hi"], function(a) {
        return 0 <= a && 1 >= a ? 0 : 1
    });
    ud(["fr", "pt"], function(a) {
        return 0 <= a && 2 > a ? 0 : 1
    });
    ud(["da"], function(a) {
        return 1 === a || !Number.isInteger(a) && 0 <= a && 1 >= a ? 0 : 1
    });
    ud("de en it el es tr fi sv nb no ur".split(" "), function(a) {
        return 1 === a ? 0 : 1
    });
    ud(["ru", "uk"], function(a) {
        if (Number.isInteger(a)) {
            var b = a % 10;
            a %= 100;
            if (1 === b && 11 !== a)
                return 0;
            if (2 <= b && 4 >= b && (12 > a || 14 < a))
                return 1;
            if (0 === b || 5 <= b && 9 >= b || 11 <= a && 14 >= a)
                return 2
        }
        return 3
    });
    ud(["pl"], function(a) {
        if (Number.isInteger(a)) {
            if (1 === a)
                return 0;
            var b = a % 10;
            a %= 100;
            if (2 <= b && 4 >= b && (12 > a || 14 < a))
                return 1;
            if (0 <= b && 1 >= b || 5 <= b && 9 >= b || 12 <= a && 14 >= a)
                return 2
        }
        return 3
    });
    ud(["ar"], function(a) {
        if (0 === a)
            return 0;
        if (1 === a)
            return 1;
        if (2 === a)
            return 2;
        if (Number.isInteger(a)) {
            a %= 100;
            if (3 <= a && 10 >= a)
                return 3;
            if (11 <= a && 99 >= a)
                return 4
        }
        return 5
    });
    var Zj = $f[vd(Jg)];
    Oa.prototype = Object.create(M.prototype);
    Oa.prototype.constructor = Oa;
    Oa.findAvailableLocale = function(a, b) {
        if (b[a])
            return a;
        var c = Ah[a];
        if (c && b[c])
            return c;
        a = vd(a);
        c = Ah[a];
        return b[c] ? c : b[a] ? a : Jg
    }
    ;
    Oa.prototype.getText = function(a, b) {
        var c = a;
        if (!b) {
            b = this._locale;
            var d = this._lang
        }
        var e = this._translations[b];
        e || (d || (d = vd(b)),
        b = this._findFallbackLocale(b, d),
        e = this._translations[b]);
        e && e.hasOwnProperty(a) && (c = e[a],
        Array.isArray(c) && (c = c[0]),
        null === c || void 0 === c) && (c = a);
        return c
    }
    ;
    Oa.prototype.getPluralText = function(a, b, c) {
        var d = a;
        if (c) {
            var e = vd(c);
            var f = $f[e] || Zj
        } else
            c = this._locale,
            e = this._lang,
            f = this._pluralFn;
        var g = this._translations[c];
        g || (c = this._findFallbackLocale(c, e),
        e = vd(c),
        f = $f[e] || Zj,
        g = this._translations[c]);
        g && g[a] && f && (b = f(b),
        d = g[a][b],
        null === d || void 0 === d) && (d = a);
        return d
    }
    ;
    Oa.prototype.addData = function(a) {
        try {
            var b = this._parser.parse(a)
        } catch (g) {
            console.error(g);
            return
        }
        a = 0;
        for (var c = b.length; a < c; a++) {
            var d = b[a]
              , e = d.info.locale;
            d = d.messages;
            if (!this._translations[e]) {
                this._translations[e] = {};
                var f = vd(e);
                this._availableLangs[f] || (this._availableLangs[f] = e)
            }
            Object.assign(this._translations[e], d);
            this.fire("data:add", e, d)
        }
    }
    ;
    Oa.prototype.removeData = function(a) {
        var b;
        try {
            var c = this._parser.parse(a)
        } catch (h) {
            console.error(h);
            return
        }
        a = 0;
        for (var d = c.length; a < d; a++) {
            var e = c[a]
              , f = e.info.locale
              , g = this._translations[f];
            if (g) {
                e = e.messages;
                for (b in e)
                    delete g[b];
                var k = !1;
                for (b in g) {
                    k = !0;
                    break
                }
                k || (delete this._translations[f],
                delete this._availableLangs[vd(f)]);
                this.fire("data:remove", f, e)
            }
        }
    }
    ;
    Oa.prototype.destroy = function() {
        this._parser = this._assets = this._availableLangs = this._translations = null;
        this.off()
    }
    ;
    Object.defineProperty(Oa.prototype, "locale", {
        get: function() {
            return this._locale
        },
        set: function(a) {
            if (this._locale !== a) {
                var b = vd(a);
                if ("in" === b) {
                    b = "id";
                    var c = b
                      , d = a.indexOf("-");
                    a = -1 !== d ? c + a.substring(d) : c;
                    if (this._locale === a)
                        return
                }
                c = this._locale;
                this._locale = a;
                this._lang = b;
                this._pluralFn = $f[this._lang] || Zj;
                this.fire("set:locale", a, c)
            }
        }
    });
    Object.defineProperty(Oa.prototype, "assets", {
        get: function() {
            return this._assets
        },
        set: function(a) {
            var b, c = {};
            var d = 0;
            for (b = a.length; d < b; d++) {
                var e = a[d]instanceof aa ? a[d].id : a[d];
                c[e] = !0
            }
            for (d = this._assets.length; d--; )
                e = this._assets[d],
                c[e] || (this._app.assets.off("add:" + e, this._onAssetAdd, this),
                (a = this._app.assets.get(e)) && this._onAssetRemove(a),
                this._assets.splice(d, 1));
            for (e in c)
                if (e = parseInt(e, 10),
                -1 === this._assets.indexOf(e))
                    if (this._assets.push(e),
                    a = this._app.assets.get(e))
                        this._onAssetAdd(a);
                    else
                        this._app.assets.once("add:" + e, this._onAssetAdd, this)
        }
    });
    Oa.prototype._findFallbackLocale = function(a, b) {
        return (a = Ah[a]) && this._translations[a] || (a = Ah[b]) && this._translations[a] ? a : (a = this._availableLangs[b]) && this._translations[a] ? a : Jg
    }
    ;
    Oa.prototype._onAssetAdd = function(a) {
        a.on("load", this._onAssetLoad, this);
        a.on("change", this._onAssetChange, this);
        a.on("remove", this._onAssetRemove, this);
        a.on("unload", this._onAssetUnload, this);
        a.resource && this._onAssetLoad(a)
    }
    ;
    Oa.prototype._onAssetLoad = function(a) {
        this.addData(a.resource)
    }
    ;
    Oa.prototype._onAssetChange = function(a) {
        a.resource && this.addData(a.resource)
    }
    ;
    Oa.prototype._onAssetRemove = function(a) {
        a.off("load", this._onAssetLoad, this);
        a.off("change", this._onAssetChange, this);
        a.off("remove", this._onAssetRemove, this);
        a.off("unload", this._onAssetUnload, this);
        a.resource && this.removeData(a.resource);
        this._app.assets.once("add:" + a.id, this._onAssetAdd, this)
    }
    ;
    Oa.prototype._onAssetUnload = function(a) {
        a.resource && this.removeData(a.resource)
    }
    ;
    var ff = /^\s*(?:(?:[a-z]+[a-z0-9\-\+\.]*:)?\/\/|data:|blob:)/i
      , ak = []
      , ag = function(a) {
        var b = "_" + a;
        ak.push(b);
        Object.defineProperty(ti.prototype, a, {
            get: function() {
                return this[b] || null
            },
            set: function(c) {
                if (!!this[b] !== !!c || this[b] && c && this[b].hash !== c.hash)
                    this[b] = c ? {
                        url: c.url,
                        filename: c.filename,
                        size: c.size,
                        hash: c.hash,
                        opt: c.opt || 0
                    } : null,
                    this.asset.file && (this.asset.fire("change", this.asset, "file", this.asset._file, this.asset._file),
                    this.asset.reload())
            }
        })
    };
    ag("dxt");
    ag("pvr");
    ag("etc1");
    ag("etc2");
    ag("basis");
    ti.prototype.clear = function() {
        for (var a = 0; a < ak.length; a++)
            this[ak[a]] = null
    }
    ;
    var Rn = -1
      , fp = {
        pvr: "extCompressedTexturePVRTC",
        dxt: "extCompressedTextureS3TC",
        etc2: "extCompressedTextureETC",
        etc1: "extCompressedTextureETC1",
        basis: "canvas"
    }
      , ym = ["pvr", "dxt", "etc2", "etc1", "basis"];
    aa.prototype = Object.create(M.prototype);
    aa.prototype.constructor = aa;
    Object.assign(aa.prototype, {
        getFileUrl: function() {
            var a = this.getPreferredFile();
            if (!a || !a.url)
                return null;
            var b = a.url;
            this.registry && this.registry.prefix && !ff.test(b) && (b = this.registry.prefix + b);
            if ("script" !== this.type && a.hash) {
                var c = -1 !== b.indexOf("?") ? "&" : "?";
                b += c + "t=" + a.hash
            }
            return b
        },
        getPreferredFile: function() {
            if (!this.file)
                return null;
            if ("texture" === this.type || "textureatlas" === this.type || "bundle" === this.type)
                for (var a = this.registry._loader._app, b = a.graphicsDevice, c = 0, d = ym.length; c < d; c++) {
                    var e = ym[c];
                    if (b[fp[e]]) {
                        if (this.file.variants[e])
                            return this.file.variants[e];
                        if (a.enableBundles) {
                            var f = a.bundles.listBundlesForAsset(this);
                            if (f)
                                for (var g = 0, k = f.length; g < k; g++)
                                    if (f[g].file && f[g].file.variants && f[g].file.variants[e])
                                        return this.file
                        }
                    }
                }
            return this.file
        },
        getAbsoluteUrl: function(a) {
            var b = ca.getDirectory(this.file.url);
            return ca.join(b, a)
        },
        getLocalizedAssetId: function(a) {
            a = Oa.findAvailableLocale(a, this._i18n);
            return this._i18n[a] || null
        },
        addLocalizedAssetId: function(a, b) {
            this._i18n[a] = b;
            this.fire("add:localized", a, b)
        },
        removeLocalizedAssetId: function(a) {
            var b = this._i18n[a];
            b && (delete this._i18n[a],
            this.fire("remove:localized", a, b))
        },
        ready: function(a, b) {
            b = b || this;
            if (this.resource)
                a.call(b, this);
            else
                this.once("load", function(c) {
                    a.call(b, c)
                })
        },
        reload: function() {
            this.loaded && (this.loaded = !1,
            this.registry.load(this))
        },
        unload: function() {
            if (this.loaded || 0 !== this._resources.length) {
                this.fire("unload", this);
                this.registry.fire("unload:" + this.id, this);
                var a = this._resources;
                this.resources = [];
                this.loaded = !1;
                this.file && this.registry._loader.clearCache(this.getFileUrl(), this.type);
                for (var b = 0; b < a.length; ++b) {
                    var c = a[b];
                    c && c.destroy && c.destroy()
                }
            }
        }
    });
    Object.defineProperty(aa.prototype, "id", {
        get: function() {
            return this._id
        },
        set: function(a) {
            this._id = a
        }
    });
    Object.defineProperty(aa.prototype, "file", {
        get: function() {
            return this._file
        },
        set: function(a) {
            var b;
            if (!!a !== !!this._file || a && this._file && a.hash !== this._file)
                if (a) {
                    this._file || (this._file = {});
                    this._file.url = a.url;
                    this._file.filename = a.filename;
                    this._file.hash = a.hash;
                    this._file.size = a.size;
                    this._file.variants = this.variants;
                    this._file.contents = a.contents;
                    if (a.hasOwnProperty("variants") && (this.variants.clear(),
                    a.variants))
                        for (b in a.variants)
                            a.variants[b] && (this.variants[b] = a.variants[b]);
                    this.fire("change", this, "file", this._file, this._file);
                    this.reload()
                } else
                    this._file = null,
                    this.variants.clear();
            else if (a && this._file && a.hasOwnProperty("variants") && (this.variants.clear(),
            a.variants))
                for (b in a.variants)
                    a.variants[b] && (this.variants[b] = a.variants[b])
        }
    });
    Object.defineProperty(aa.prototype, "data", {
        get: function() {
            return this._data
        },
        set: function(a) {
            var b = this._data;
            this._data = a;
            a !== b && (this.fire("change", this, "data", a, b),
            this.loaded && this.registry._loader.patch(this, this.registry))
        }
    });
    Object.defineProperty(aa.prototype, "resource", {
        get: function() {
            return this._resources[0]
        },
        set: function(a) {
            var b = this._resources[0];
            this._resources[0] = a;
            this.fire("change", this, "resource", a, b)
        }
    });
    Object.defineProperty(aa.prototype, "resources", {
        get: function() {
            return this._resources
        },
        set: function(a) {
            var b = this._resources;
            this._resources = a;
            this.fire("change", this, "resources", a, b)
        }
    });
    Object.defineProperty(aa.prototype, "preload", {
        get: function() {
            return this._preload
        },
        set: function(a) {
            a = !!a;
            this._preload !== a && (this._preload = a) && !this.loaded && !this.loading && this.registry && this.registry.load(this)
        }
    });
    Object.defineProperty(aa.prototype, "loadFaces", {
        get: function() {
            return this._loadFaces
        },
        set: function(a) {
            a = !!a;
            this.hasOwnProperty("_loadFaces") && a === this._loadFaces || (this._loadFaces = a,
            this.loaded && this.registry._loader.patch(this, this.registry))
        }
    });
    var Bh = function(a) {
        switch (a) {
        case "SCALAR":
            return 1;
        case "VEC2":
            return 2;
        case "VEC3":
            return 3;
        case "VEC4":
            return 4;
        case "MAT2":
            return 4;
        case "MAT3":
            return 9;
        case "MAT4":
            return 16;
        default:
            return 3
        }
    }
      , bk = function(a) {
        switch (a) {
        case 5120:
            return 0;
        case 5121:
            return 1;
        case 5122:
            return 2;
        case 5123:
            return 3;
        case 5124:
            return 4;
        case 5125:
            return 5;
        case 5126:
            return 6;
        default:
            return 0
        }
    }
      , gp = function(a) {
        switch (a) {
        case 5120:
            return 1;
        case 5121:
            return 1;
        case 5122:
            return 2;
        case 5123:
            return 2;
        case 5124:
            return 4;
        case 5125:
            return 4;
        case 5126:
            return 4;
        default:
            return 0
        }
    }
      , hp = function(a) {
        switch (a) {
        case 5120:
            return Int8Array;
        case 5121:
            return Uint8Array;
        case 5122:
            return Int16Array;
        case 5123:
            return Uint16Array;
        case 5124:
            return Int32Array;
        case 5125:
            return Uint32Array;
        case 5126:
            return Float32Array;
        default:
            return null
        }
    }
      , Ch = {
        POSITION: "POSITION",
        NORMAL: "NORMAL",
        TANGENT: "TANGENT",
        COLOR_0: "COLOR",
        JOINTS_0: "BLENDINDICES",
        WEIGHTS_0: "BLENDWEIGHT",
        TEXCOORD_0: "TEXCOORD0",
        TEXCOORD_1: "TEXCOORD1"
    }
      , Xc = function(a, b) {
        var c = Bh(a.type)
          , d = hp(a.componentType);
        if (!d)
            return null;
        if (a.sparse) {
            var e = a.sparse
              , f = Xc(Object.assign({
                count: e.count,
                type: "SCALAR"
            }, e.indices), b)
              , g = Xc(Object.assign({
                count: e.count,
                type: a.scalar,
                componentType: a.componentType
            }, e.values), b);
            a = a.hasOwnProperty("bufferView") ? Xc({
                bufferView: a.bufferView,
                byteOffset: a.byteOffset,
                componentType: a.componentType,
                count: a.count,
                type: a.type
            }, b).slice() : new d(a.count * c);
            for (d = 0; d < e.count; ++d) {
                b = f[d];
                for (var k = 0; k < c; ++k)
                    a[b * c + k] = g[d * c + k]
            }
        } else
            e = b[a.bufferView],
            a = new d(e.buffer,e.byteOffset + (a.hasOwnProperty("byteOffset") ? a.byteOffset : 0),a.count * c);
        return a
    }
      , ip = function(a) {
        if (!a.hasOwnProperty("mode"))
            return 4;
        switch (a.mode) {
        case 0:
            return 0;
        case 1:
            return 1;
        case 2:
            return 2;
        case 3:
            return 3;
        case 4:
            return 4;
        case 5:
            return 5;
        case 6:
            return 6;
        default:
            return 4
        }
    }
      , zm = function(a, b) {
        var c = a.POSITION;
        if (c && 3 === c.components) {
            if (c.size !== c.stride) {
                var d = c.stride / qf[c.type]
                  , e = new Dd[c.type](c.buffer,c.offset,c.count * d);
                var f = new Dd[c.type](3 * c.count);
                for (var g = 0; g < c.count; ++g)
                    f[3 * g] = e[g * d],
                    f[3 * g + 1] = e[g * d + 1],
                    f[3 * g + 2] = e[g * d + 2]
            } else
                f = new Dd[c.type](c.buffer,c.offset,3 * c.count);
            c = c.count;
            if (!b)
                for (b = new Uint16Array(c),
                d = 0; d < c; d++)
                    b[d] = d;
            f = Mk(f, b);
            b = new Float32Array(f.length);
            b.set(f);
            a.NORMAL = {
                buffer: b.buffer,
                size: 12,
                offset: 0,
                stride: 12,
                count: c,
                components: 3,
                type: 6
            }
        }
    }
      , jp = function(a) {
        var b, c, d = [], e = [], f = [];
        for (b = 0; b < a.format.elements.length; ++b) {
            var g = a.format.elements[b];
            if ("TEXCOORD0" === g.name || "TEXCOORD1" === g.name)
                switch (g.dataType) {
                case 6:
                    d.push({
                        offset: g.offset / 4 + 1,
                        stride: g.stride / 4
                    });
                    break;
                case 3:
                    e.push({
                        offset: g.offset / 2 + 1,
                        stride: g.stride / 2
                    });
                    break;
                case 1:
                    f.push({
                        offset: g.offset + 1,
                        stride: g.stride
                    })
                }
        }
        g = function(k, h, l) {
            h = new h(a.storage);
            for (b = 0; b < k.length; ++b) {
                var n = k[b].offset
                  , p = k[b].stride;
                for (c = 0; c < a.numVertices; ++c)
                    h[n] = l - h[n],
                    n += p
            }
        }
        ;
        0 < d.length && g(d, Float32Array, 1);
        0 < e.length && g(e, Uint16Array, 65535);
        0 < f.length && g(f, Uint8Array, 255)
    }
      , Am = function(a, b, c) {
        var d = b.POSITION
          , e = d.count
          , f = [];
        for (p in b)
            b.hasOwnProperty(p) && f.push({
                semantic: p,
                components: b[p].components,
                type: b[p].type,
                normalize: !!b[p].normalize
            });
        var g = "POSITION NORMAL TANGENT COLOR BLENDINDICES BLENDWEIGHT TEXCOORD0 TEXCOORD1".split(" ");
        f.sort(function(u, x) {
            u = g.indexOf(u.semantic);
            x = g.indexOf(x.semantic);
            return u < x ? -1 : x < u ? 1 : 0
        });
        var k, h = new Na(a,f), l = !0;
        for (f = 0; f < h.elements.length; ++f) {
            var n = h.elements[f];
            var p = b[n.name];
            var q = p.offset - d.offset;
            if (p.buffer !== d.buffer || p.stride !== n.stride || p.size !== n.size || q !== n.offset) {
                l = !1;
                break
            }
        }
        a = new ab(a,h,e,0);
        f = a.lock();
        q = new Uint32Array(f);
        if (l)
            d = new Uint32Array(d.buffer,d.offset,e * a.format.size / 4),
            q.set(d);
        else
            for (f = 0; f < a.format.elements.length; ++f) {
                n = a.format.elements[f];
                l = n.stride / 4;
                p = b[n.name];
                d = new Uint32Array(p.buffer,p.offset,p.count * p.stride / 4);
                h = p.stride / 4;
                var r = 0;
                n = n.offset / 4;
                var t = Math.floor((p.size + 3) / 4);
                for (p = 0; p < e; ++p) {
                    for (k = 0; k < t; ++k)
                        q[n + k] = d[r + k];
                    r += h;
                    n += l
                }
            }
        c || jp(a);
        a.unlock();
        return a
    }
      , kp = function(a, b, c, d, e, f) {
        var g = {}, k;
        for (k in b)
            if (b.hasOwnProperty(k) && Ch.hasOwnProperty(k)) {
                var h = d[b[k]]
                  , l = Xc(h, e)
                  , n = e[h.bufferView]
                  , p = Ch[k]
                  , q = Bh(h.type) * gp(h.componentType);
                n = n.hasOwnProperty("byteStride") ? n.byteStride : q;
                g[p] = {
                    buffer: l.buffer,
                    size: q,
                    offset: l.byteOffset,
                    stride: n,
                    count: h.count,
                    components: Bh(h.type),
                    type: bk(h.componentType),
                    normalize: h.normalized
                }
            }
        g.hasOwnProperty("NORMAL") || zm(g, c);
        return Am(a, g, f)
    }
      , lp = function(a, b, c, d, e, f, g) {
        var k, h = b.num_points(), l = {};
        c = c.attributes;
        for (var n in c)
            if (c.hasOwnProperty(n) && Ch.hasOwnProperty(n)) {
                var p = Ch[n];
                var q = d.GetAttributeByUniqueId(b, c[n]);
                var r = h * q.num_components();
                switch (q.data_type()) {
                case e.DT_UINT8:
                    var t = k = 1;
                    var u = e._malloc(r * t);
                    d.GetAttributeDataArrayForAllPoints(b, q, e.DT_UINT8, r * t, u);
                    r = (new Uint8Array(e.HEAPU8.buffer,u,r)).slice();
                    break;
                case e.DT_UINT16:
                    k = 3;
                    t = 2;
                    u = e._malloc(r * t);
                    d.GetAttributeDataArrayForAllPoints(b, q, e.DT_UINT16, r * t, u);
                    r = (new Uint16Array(e.HEAPU16.buffer,u,r)).slice();
                    break;
                default:
                    k = 6,
                    t = 4,
                    u = e._malloc(r * t),
                    d.GetAttributeDataArrayForAllPoints(b, q, e.DT_FLOAT32, r * t, u),
                    r = (new Float32Array(e.HEAPF32.buffer,u,r)).slice()
                }
                e._free(u);
                u = r;
                r = q.num_components();
                q = q.normalized();
                t *= r;
                l[p] = {
                    values: u,
                    buffer: u.buffer,
                    size: t,
                    offset: 0,
                    stride: t,
                    count: h,
                    components: r,
                    type: k,
                    normalize: q
                }
            }
        l.hasOwnProperty("NORMAL") || zm(l, f);
        return Am(a, l, g)
    }
      , Dh = new K
      , gf = new z
      , mp = function(a, b, c, d, e, f) {
        var g = [];
        b.primitives.forEach(function(k) {
            var h = null
              , l = new rb(a)
              , n = !0;
            if (k.hasOwnProperty("extensions")) {
                var p = k.extensions;
                if (p.hasOwnProperty("KHR_draco_mesh_compression")) {
                    var q = window.DracoDecoderModule;
                    if (q && (p = p.KHR_draco_mesh_compression,
                    p.hasOwnProperty("attributes"))) {
                        var r = d[p.bufferView];
                        n = new q.DecoderBuffer;
                        n.Init(r, r.length);
                        r = new q.Decoder;
                        var t = r.GetEncodedGeometryType(n);
                        switch (t) {
                        case q.POINT_CLOUD:
                            var u = 0;
                            var x = new q.PointCloud;
                            var v = r.DecodeBufferToPointCloud(n, x);
                            break;
                        case q.TRIANGULAR_MESH:
                            u = 4,
                            x = new q.Mesh,
                            v = r.DecodeBufferToMesh(n, x)
                        }
                        if (!v || !v.ok() || 0 == x.ptr) {
                            e("Failed to decode draco compressed asset: " + (v ? v.error_msg() : "Mesh asset - invalid draco compressed geometry type: " + t));
                            return
                        }
                        v = x.num_faces();
                        if (t == q.TRIANGULAR_MESH) {
                            h = 65535 < x.num_points();
                            t = 3 * v;
                            var w = t * (h ? 4 : 2);
                            v = q._malloc(w);
                            h ? (r.GetTrianglesUInt32Array(x, w, v),
                            h = (new Uint32Array(q.HEAPU32.buffer,v,t)).slice()) : (r.GetTrianglesUInt16Array(x, w, v),
                            h = (new Uint16Array(q.HEAPU16.buffer,v,t)).slice());
                            q._free(v)
                        }
                        t = lp(a, x, p, r, q, h, f);
                        q.destroy(x);
                        q.destroy(r);
                        q.destroy(n);
                        n = !1
                    }
                }
            }
            t || (h = k.hasOwnProperty("indices") ? Xc(c[k.indices], d) : null,
            t = kp(a, k.attributes, h, c, d, f),
            u = ip(k));
            l.vertexBuffer = t;
            l.primitive[0].type = u;
            l.primitive[0].base = 0;
            l.primitive[0].indexed = null !== h;
            null !== h ? (u = h instanceof Uint8Array ? 0 : h instanceof Uint16Array ? 1 : 2,
            2 !== u || a.extUintElement || (u = 1,
            h = new Uint16Array(h)),
            u = new dc(a,u,h.length,0,h),
            l.indexBuffer[0] = u,
            l.primitive[0].count = h.length) : l.primitive[0].count = t.numVertices;
            l.materialIndex = k.material;
            var y = c[k.attributes.POSITION];
            u = y.min;
            q = y.max;
            u = new oa(new z((q[0] + u[0]) / 2,(q[1] + u[1]) / 2,(q[2] + u[2]) / 2),new z((q[0] - u[0]) / 2,(q[1] - u[1]) / 2,(q[2] - u[2]) / 2));
            l.aabb = u;
            if (n && k.hasOwnProperty("targets")) {
                var A = [];
                k.targets.forEach(function(B, E) {
                    var C = {};
                    B.hasOwnProperty("POSITION") && (y = c[B.POSITION],
                    C.deltaPositions = Xc(y, d),
                    C.deltaPositionsType = bk(y.componentType),
                    y.hasOwnProperty("min") && y.hasOwnProperty("max") && (C.aabb = new oa,
                    C.aabb.setMinMax(new z(y.min), new z(y.max))));
                    B.hasOwnProperty("NORMAL") && (y = c[B.NORMAL],
                    C.deltaNormals = Xc(y, d),
                    C.deltaNormalsType = bk(y.componentType));
                    b.hasOwnProperty("extras") && b.extras.hasOwnProperty("targetNames") ? C.name = b.extras.targetNames[E] : C.name = A.length.toString(10);
                    A.push(new tf(a,C))
                });
                l.morph = new Db(A);
                if (b.hasOwnProperty("weights"))
                    for (k = 0; k < b.weights.length; ++k)
                        A[k].defaultWeight = b.weights[k]
            }
            g.push(l)
        });
        return g
    }
      , np = function(a, b, c) {
        var d = [1, 1]
          , e = [0, 0]
          , f = function(n, p, q) {
            var r, t = n.texCoord;
            if (t)
                for (r = 0; r < q.length; ++r)
                    p[q[r] + "MapUv"] = t;
            t = d;
            var u = e;
            if (n = n.extensions)
                if (n = n.KHR_texture_transform)
                    n.scale && (t = n.scale),
                    n.offset && (u = n.offset);
            for (r = 0; r < q.length; ++r)
                p[q[r] + "MapTiling"] = new P(t[0],t[1]),
                p[q[r] + "MapOffset"] = new P(u[0],c ? u[1] : 1 - t[1] - u[1])
        }
          , g = new la;
        g.occludeSpecular = !0;
        g.diffuseTint = !0;
        g.diffuseVertexColor = !0;
        g.specularTint = !0;
        g.specularVertexColor = !0;
        a.hasOwnProperty("name") && (g.name = a.name);
        if (a.hasOwnProperty("extensions") && a.extensions.hasOwnProperty("KHR_materials_pbrSpecularGlossiness")) {
            var k = a.extensions.KHR_materials_pbrSpecularGlossiness;
            if (k.hasOwnProperty("diffuseFactor")) {
                var h = k.diffuseFactor;
                g.diffuse.set(Math.pow(h[0], 1 / 2.2), Math.pow(h[1], 1 / 2.2), Math.pow(h[2], 1 / 2.2));
                g.opacity = null != h[3] ? h[3] : 1
            } else
                g.diffuse.set(1, 1, 1),
                g.opacity = 1;
            if (k.hasOwnProperty("diffuseTexture")) {
                var l = k.diffuseTexture;
                h = b[l.index];
                g.diffuseMap = h;
                g.diffuseMapChannel = "rgb";
                g.opacityMap = h;
                g.opacityMapChannel = "a";
                f(l, g, ["diffuse", "opacity"])
            }
            g.useMetalness = !1;
            k.hasOwnProperty("specularFactor") ? (h = k.specularFactor,
            g.specular.set(Math.pow(h[0], 1 / 2.2), Math.pow(h[1], 1 / 2.2), Math.pow(h[2], 1 / 2.2))) : g.specular.set(1, 1, 1);
            k.hasOwnProperty("glossinessFactor") ? g.shininess = 100 * k.glossinessFactor : g.shininess = 100;
            k.hasOwnProperty("specularGlossinessTexture") && (h = k.specularGlossinessTexture,
            g.specularMap = g.glossMap = b[h.index],
            g.specularMapChannel = "rgb",
            g.glossMapChannel = "a",
            f(h, g, ["gloss", "metalness"]));
            g.chunks.specularPS = "#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_specularMap;\n#endif\n\nvoid getSpecularity() {\n\tdSpecularity = vec3(1.0);\n\n\t#ifdef MAPCOLOR\n\t\tdSpecularity *= material_specular;\n\t#endif\n\n\t#ifdef MAPTEXTURE\n\t\tvec3 srgb = texture2D(texture_specularMap, $UV).$CH;\n\t\tdSpecularity *= vec3(pow(srgb.r, 2.2), pow(srgb.g, 2.2), pow(srgb.b, 2.2));\n\t#endif\n\n\t#ifdef MAPVERTEX\n\t\tdSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n}"
        } else
            a.hasOwnProperty("pbrMetallicRoughness") && (k = a.pbrMetallicRoughness,
            k.hasOwnProperty("baseColorFactor") ? (h = k.baseColorFactor,
            g.diffuse.set(Math.pow(h[0], 1 / 2.2), Math.pow(h[1], 1 / 2.2), Math.pow(h[2], 1 / 2.2)),
            g.opacity = h[3]) : (g.diffuse.set(1, 1, 1),
            g.opacity = 1),
            k.hasOwnProperty("baseColorTexture") && (l = k.baseColorTexture,
            h = b[l.index],
            g.diffuseMap = h,
            g.diffuseMapChannel = "rgb",
            g.opacityMap = h,
            g.opacityMapChannel = "a",
            f(l, g, ["diffuse", "opacity"])),
            g.useMetalness = !0,
            k.hasOwnProperty("metallicFactor") ? g.metalness = k.metallicFactor : g.metalness = 1,
            k.hasOwnProperty("roughnessFactor") ? g.shininess = 100 * k.roughnessFactor : g.shininess = 100,
            k.hasOwnProperty("metallicRoughnessTexture") && (h = k.metallicRoughnessTexture,
            g.metalnessMap = g.glossMap = b[h.index],
            g.metalnessMapChannel = "b",
            g.glossMapChannel = "g",
            f(h, g, ["gloss", "metalness"])),
            g.chunks.glossPS = "#ifdef MAPFLOAT\nuniform float material_shininess;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_glossMap;\n#endif\n\nvoid getGlossiness() {\n\tdGlossiness = 1.0;\n\n#ifdef MAPFLOAT\n\tdGlossiness *= material_shininess;\n#endif\n\n#ifdef MAPTEXTURE\n\tdGlossiness *= texture2D(texture_glossMap, $UV).$CH;\n#endif\n\n#ifdef MAPVERTEX\n\tdGlossiness *= saturate(vVertexColor.$VC);\n#endif\n\n\tdGlossiness = 1.0 - dGlossiness;\n\n\tdGlossiness += 0.0000001;\n}");
        a.hasOwnProperty("normalTexture") && (h = a.normalTexture,
        g.normalMap = b[h.index],
        f(h, g, ["normal"]),
        h.hasOwnProperty("scale") && (g.bumpiness = h.scale));
        a.hasOwnProperty("occlusionTexture") && (h = a.occlusionTexture,
        g.aoMap = b[h.index],
        g.aoMapChannel = "r",
        f(h, g, ["ao"]));
        a.hasOwnProperty("emissiveFactor") ? (h = a.emissiveFactor,
        g.emissive.set(Math.pow(h[0], 1 / 2.2), Math.pow(h[1], 1 / 2.2), Math.pow(h[2], 1 / 2.2)),
        g.emissiveTint = !0) : (g.emissive.set(0, 0, 0),
        g.emissiveTint = !1);
        a.hasOwnProperty("emissiveTexture") && (h = a.emissiveTexture,
        g.emissiveMap = b[h.index],
        f(h, g, ["emissive"]));
        if (a.hasOwnProperty("alphaMode"))
            switch (a.alphaMode) {
            case "MASK":
                g.blendType = 3;
                a.hasOwnProperty("alphaCutoff") ? g.alphaTest = a.alphaCutoff : g.alphaTest = .5;
                break;
            case "BLEND":
                g.blendType = 2;
                break;
            default:
            case "OPAQUE":
                g.blendType = 3
            }
        else
            g.blendType = 3;
        a.hasOwnProperty("doubleSided") ? (g.twoSidedLighting = a.doubleSided,
        g.cull = a.doubleSided ? 0 : 1) : (g.twoSidedLighting = !1,
        g.cull = 1);
        a.hasOwnProperty("extensions") && a.extensions.hasOwnProperty("KHR_materials_clearcoat") && (h = a.extensions.KHR_materials_clearcoat,
        h.hasOwnProperty("clearcoatFactor") ? g.clearCoat = .25 * h.clearcoatFactor : g.clearCoat = 0,
        h.hasOwnProperty("clearcoatTexture") && (k = h.clearcoatTexture,
        g.clearCoatMap = b[k.index],
        g.clearCoatMapChannel = "r",
        f(k, g, ["clearCoat"])),
        h.hasOwnProperty("clearcoatRoughnessFactor") ? g.clearCoatGlossiness = h.clearcoatRoughnessFactor : g.clearCoatGlossiness = 0,
        h.hasOwnProperty("clearcoatRoughnessTexture") && (k = h.clearcoatRoughnessTexture,
        g.clearCoatGlossMap = b[k.index],
        g.clearCoatGlossMapChannel = "g",
        f(k, g, ["clearCoatGloss"])),
        h.hasOwnProperty("clearcoatNormalTexture") && (h = h.clearcoatNormalTexture,
        g.clearCoatNormalMap = b[h.index],
        f(h, g, ["clearCoatNormal"]),
        h.hasOwnProperty("scale") && (g.clearCoatBumpiness = h.scale)),
        g.chunks.clearCoatGlossPS = "#ifdef MAPFLOAT\nuniform float material_clearCoatGlossiness;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatGlossMap;\n#endif\n\nvoid getClearCoatGlossiness() {\n\tccGlossiness = 1.0;\n\n#ifdef MAPFLOAT\n\tccGlossiness *= material_clearCoatGlossiness;\n#endif\n\n#ifdef MAPTEXTURE\n\tccGlossiness *= texture2D(texture_clearCoatGlossMap, $UV).$CH;\n#endif\n\n#ifdef MAPVERTEX\n\tccGlossiness *= saturate(vVertexColor.$VC);\n#endif\n\n\tccGlossiness = 1.0 - ccGlossiness;\n\n\tccGlossiness += 0.0000001;\n}");
        a.hasOwnProperty("extensions") && a.extensions.hasOwnProperty("KHR_materials_unlit") && (g.useLighting = !1,
        g.emissive.copy(g.diffuse),
        g.emissiveTint = g.diffuseTint,
        g.emissiveMap = g.diffuseMap,
        g.emissiveMapUv = g.diffuseMapUv,
        g.emissiveMapTiling.copy(g.diffuseMapTiling),
        g.emissiveMapOffset.copy(g.diffuseMapOffset),
        g.emissiveMapChannel = g.diffuseMapChannel,
        g.emissiveVertexColor = g.diffuseVertexColor,
        g.emissiveVertexColorChannel = g.diffuseVertexColorChannel,
        g.diffuse.set(0, 0, 0),
        g.diffuseTint = !1,
        g.diffuseMap = null,
        g.diffuseVertexColor = !1);
        g.update();
        return g
    }
      , op = function(a, b, c, d, e) {
        var f = function(u) {
            var x = Xc(u, d);
            return new vf(Bh(u.type),new x.constructor(x))
        }, g = {
            STEP: 0,
            LINEAR: 1,
            CUBICSPLINE: 2
        }, k = {}, h = [], l = {}, n = [], p = [], q;
        for (q = 0; q < a.samplers.length; ++q) {
            var r = a.samplers[q];
            k.hasOwnProperty(r.input) || (k[r.input] = h.length,
            h.push(f(c[r.input])));
            l.hasOwnProperty(r.output) || (l[r.output] = n.length,
            n.push(f(c[r.output])));
            var t = r.hasOwnProperty("interpolation") && g.hasOwnProperty(r.interpolation) ? g[r.interpolation] : 1;
            p.push(new Ig([],k[r.input],l[r.output],t))
        }
        c = [];
        f = new uf;
        g = {
            translation: "localPosition",
            rotation: "localRotation",
            scale: "localScale",
            weights: "weights"
        };
        for (q = 0; q < a.channels.length; ++q)
            l = a.channels[q],
            k = l.target,
            l = p[l.sampler],
            l._paths.push(f.encode([[e[k.node].name], "graph", [g[k.path]]])),
            k.path.startsWith("rotation") && 2 !== l.interpolation ? c.push(l.output) : k.path.startsWith("weights") && (n[l.output]._components = n[l.output].data.length / h[l.input].data.length);
        c.sort();
        f = null;
        for (q = 0; q < c.length; ++q)
            if (e = c[q],
            0 === q || e !== f) {
                f = n[e];
                if (4 === f.components)
                    for (f = f.data,
                    g = f.length - 4,
                    k = 0; k < g; k += 4)
                        0 > f[k + 0] * f[k + 4] + f[k + 1] * f[k + 5] + f[k + 2] * f[k + 6] + f[k + 3] * f[k + 7] && (f[k + 4] *= -1,
                        f[k + 5] *= -1,
                        f[k + 6] *= -1,
                        f[k + 7] *= -1);
                f = e
            }
        for (q = e = 0; q < h.length; q++)
            f = h[q]._data,
            e = Math.max(e, 0 === f.length ? 0 : f[f.length - 1]);
        return new Kd(a.hasOwnProperty("name") ? a.name : "animation_" + b,e,h,n,p)
    }
      , pp = function(a, b) {
        var c = new Z;
        a.hasOwnProperty("name") && 0 < a.name.length ? c.name = a.name : c.name = "node_" + b;
        a.hasOwnProperty("matrix") && (Dh.data.set(a.matrix),
        Dh.getTranslation(gf),
        c.setLocalPosition(gf),
        Dh.getEulerAngles(gf),
        c.setLocalEulerAngles(gf),
        Dh.getScale(gf),
        c.setLocalScale(gf));
        a.hasOwnProperty("rotation") && (b = a.rotation,
        c.setLocalRotation(b[0], b[1], b[2], b[3]));
        a.hasOwnProperty("translation") && (b = a.translation,
        c.setLocalPosition(b[0], b[1], b[2]));
        a.hasOwnProperty("scale") && (a = a.scale,
        c.setLocalScale(a[0], a[1], a[2]));
        return c
    }
      , qp = function(a, b, c, d) {
        return b.hasOwnProperty("skins") && 0 !== b.skins.length ? b.skins.map(function(e) {
            var f = b.accessors, g, k = e.joints, h = k.length, l = [];
            if (e.hasOwnProperty("inverseBindMatrices")) {
                var n = Xc(f[e.inverseBindMatrices], d)
                  , p = [];
                for (f = 0; f < h; f++) {
                    for (g = 0; 16 > g; g++)
                        p[g] = n[16 * f + g];
                    g = new K;
                    g.set(p);
                    l.push(g)
                }
            } else
                for (f = 0; f < h; f++)
                    g = new K,
                    l.push(g);
            n = [];
            for (f = 0; f < h; f++)
                n[f] = c[k[f]].name;
            e = e.skeleton;
            l = new Hg(a,l,n);
            l.skeleton = c[e];
            l.bones = [];
            for (f = 0; f < k.length; f++)
                l.bones[f] = c[k[f]];
            return l
        }) : []
    }
      , rp = function(a, b, c, d, e) {
        return b.hasOwnProperty("meshes") && 0 !== b.meshes.length && b.hasOwnProperty("accessors") && 0 !== b.accessors.length && b.hasOwnProperty("bufferViews") && 0 !== b.bufferViews.length ? b.meshes.map(function(f) {
            return mp(a, f, b.accessors, c, d, e)
        }) : []
    }
      , sp = function(a, b, c, d) {
        if (!a.hasOwnProperty("materials") || 0 === a.materials.length)
            return [];
        var e = c && c.material && c.material.preprocess
          , f = c && c.material && c.material.process || np
          , g = c && c.material && c.material.postprocess;
        return a.materials.map(function(k) {
            e && e(k);
            var h = f(k, b, d);
            g && g(k, h);
            return h
        })
    }
      , tp = function(a, b, c, d) {
        if (!a.hasOwnProperty("animations") || 0 === a.animations.length)
            return [];
        var e = d && d.animation && d.animation.preprocess
          , f = d && d.animation && d.animation.postprocess;
        return a.animations.map(function(g, k) {
            e && e(g);
            k = op(g, k, a.accessors, c, b);
            f && f(g, k);
            return k
        })
    }
      , up = function(a, b) {
        if (!a.hasOwnProperty("nodes") || 0 === a.nodes.length)
            return [];
        var c = b && b.node && b.node.preprocess
          , d = b && b.node && b.node.process || pp
          , e = b && b.node && b.node.postprocess;
        b = a.nodes.map(function(n, p) {
            c && c(n);
            p = d(n, p);
            e && e(n, p);
            return p
        });
        for (var f = 0; f < a.nodes.length; ++f) {
            var g = a.nodes[f];
            if (g.hasOwnProperty("children"))
                for (var k = 0; k < g.children.length; ++k) {
                    var h = b[f]
                      , l = b[g.children[k]];
                    l.parent || h.addChild(l)
                }
        }
        return b
    }
      , vp = function(a, b) {
        var c = []
          , d = a.scenes.length;
        if (1 === d && 1 === a.scenes[0].nodes.length)
            c.push(b[a.scenes[0].nodes[0]]);
        else
            for (var e = 0; e < d; e++) {
                for (var f = a.scenes[e], g = new Z(f.name), k = 0; k < f.nodes.length; k++)
                    g.addChild(b[f.nodes[k]]);
                c.push(g)
            }
        return c
    }
      , Bm = function(a, b, c, d, e, f) {
        var g = e && e.global && e.global.preprocess
          , k = e && e.global && e.global.postprocess;
        g && g(b);
        var h = b.asset && "PlayCanvas" === b.asset.generator;
        g = up(b, e);
        var l = vp(b, g)
          , n = tp(b, g, c, e);
        e = sp(b, d.map(function(p) {
            return p.resource
        }), e, h);
        h = rp(a, b, c, f, h);
        a = qp(a, b, g, c);
        d = {
            gltf: b,
            nodes: g,
            scenes: l,
            animations: n,
            textures: d,
            materials: e,
            meshes: h,
            skins: a
        };
        k && k(b, d);
        f(null, d)
    }
      , wp = function(a, b) {
        var c = {
            magFilter: 9729,
            minFilter: 9987,
            wrapS: 10497,
            wrapT: 10497
        }
          , d = function(f) {
            switch (f) {
            case 9728:
                return 0;
            case 9729:
                return 1;
            case 9984:
                return 2;
            case 9985:
                return 4;
            case 9986:
                return 3;
            case 9987:
                return 5;
            default:
                return 1
            }
        }
          , e = function(f) {
            switch (f) {
            case 33071:
                return 1;
            case 33648:
                return 2;
            case 10497:
                return 0;
            default:
                return 0
            }
        };
        a && (b = b || c,
        a.minFilter = d(b.minFilter),
        a.magFilter = d(b.magFilter),
        a.addressU = e(b.wrapS),
        a.addressV = e(b.wrapT))
    }
      , xp = function(a, b, c, d, e, f, g) {
        var k = f && f.image && f.image.preprocess
          , h = f && f.image && f.image.processAsync || function(p, q) {
            q(null, null)
        }
          , l = f && f.image && f.image.postprocess
          , n = function(p, q, r, t) {
            var u = {
                "image/png": "png",
                "image/jpeg": "jpg",
                "image/basis": "basis",
                "image/ktx": "ktx",
                "image/vnd-ms.dds": "dds"
            }
              , x = {
                url: p
            };
            q && (q = u[q]) && (x.filename = "glb-texture-" + b + "." + q);
            var v = new aa("texture_" + b,"texture",x,null,{
                crossOrigin: r
            });
            v.on("load", function() {
                t && URL.revokeObjectURL(p);
                l && l(a, v);
                g(null, v)
            });
            v.on("error", function(w, y) {
                g(w)
            });
            e.add(v);
            e.load(v)
        };
        k && k(a);
        h(a, function(p, q) {
            p ? g(p) : q ? (l && l(a, q),
            g(null, q)) : a.hasOwnProperty("uri") ? /^data:.*,.*$/i.test(a.uri) ? (q = p = a.uri,
            q = q.substring(q.indexOf(":") + 1, q.indexOf(";")),
            n(p, q)) : n(ca.join(d, a.uri), null, "anonymous") : a.hasOwnProperty("bufferView") && a.hasOwnProperty("mimeType") ? (p = new Blob([c[a.bufferView]],{
                type: a.mimeType
            }),
            n(URL.createObjectURL(p), a.mimeType, null, !0)) : g("Invalid image found in gltf (neither uri or bufferView found). index=" + b)
        })
    }
      , yp = function(a, b, c, d, e, f) {
        if (a.hasOwnProperty("images") && 0 !== a.images.length && a.hasOwnProperty("textures") && 0 !== a.textures.length)
            for (var g = e && e.texture && e.texture.preprocess, k = e && e.texture && e.texture.processAsync || function(u, x, v) {
                v(null, null)
            }
            , h = e && e.texture && e.texture.postprocess, l = [], n = [], p = a.textures.length, q = function(u, x) {
                n[x] || (n[x] = []);
                n[x].push(u);
                if (0 === --p) {
                    var v = [];
                    n.forEach(function(w, y) {
                        w.forEach(function(A, B) {
                            if (0 === B)
                                var E = l[y];
                            else {
                                E = l[y];
                                var C = new pc.Asset(E.name + "_clone",E.type,E.file,E.data,E.options);
                                C.loaded = !0;
                                for (var D = E.resource, G = new pc.Texture(D.device,D), J = [], R = 0; R < D._levels.length; ++R) {
                                    var I = [];
                                    if (D.cubemap)
                                        for (var T = 0; 6 > T; ++T)
                                            I.push(D._levels[R][T]);
                                    else
                                        I = D._levels[R];
                                    J.push(I)
                                }
                                G._levels = J;
                                C.resource = G;
                                E.registry.add(C);
                                E = C
                            }
                            wp(E.resource, (a.samplers || [])[a.textures[A].sampler]);
                            v[A] = E;
                            h && h(a.textures[B], E)
                        })
                    });
                    f(null, v)
                }
            }, r = 0; r < a.textures.length; ++r) {
                var t = a.textures[r];
                g && g(t);
                k(t, a.images, function(u, x, v, w) {
                    if (v)
                        f(v);
                    else {
                        if (void 0 === w || null === w)
                            w = x.source;
                        l[w] ? q(u, w) : xp(a.images[w], u, b, c, d, e, function(y, A) {
                            y ? f(y) : (l[w] = A,
                            q(u, w))
                        })
                    }
                }
                .bind(null, r, t))
            }
        else
            f(null, [])
    }
      , zp = function(a, b, c, d, e) {
        var f = [];
        if (null === a.buffers || 0 === a.buffers.length)
            e(null, f);
        else {
            var g = d && d.buffer && d.buffer.preprocess
              , k = d && d.buffer && d.buffer.processAsync || function(q, r) {
                r(null, null)
            }
              , h = d && d.buffer && d.buffer.postprocess
              , l = a.buffers.length
              , n = function(q, r) {
                f[q] = r;
                h && h(a.buffers[q], r);
                0 === --l && e(null, f)
            };
            for (d = 0; d < a.buffers.length; ++d) {
                var p = a.buffers[d];
                g && g(p);
                k(p, function(q, r, t, u) {
                    if (t)
                        e(t);
                    else if (u)
                        n(q, new Uint8Array(u));
                    else if (r.hasOwnProperty("uri"))
                        if (/^data:.*,.*$/i.test(r.uri)) {
                            r = atob(r.uri.split(",")[1]);
                            t = new Uint8Array(r.length);
                            for (u = 0; u < r.length; u++)
                                t[u] = r.charCodeAt(u);
                            n(q, t)
                        } else
                            wa.get(ca.join(c, r.uri), {
                                cache: !0,
                                responseType: "arraybuffer",
                                retry: !1
                            }, function(x, v, w) {
                                v ? e(v) : n(x, new Uint8Array(w))
                            }
                            .bind(null, q));
                    else
                        n(q, b)
                }
                .bind(null, d, p))
            }
        }
    }
      , Cm = function(a, b) {
        a = JSON.parse(function(c) {
            if ("undefined" !== typeof TextDecoder)
                return (new TextDecoder).decode(c);
            for (var d = "", e = 0; e < c.length; e++)
                d += String.fromCharCode(c[e]);
            return decodeURIComponent(escape(d))
        }(a));
        a.asset && a.asset.version && 2 > parseFloat(a.asset.version) ? b("Invalid gltf version. Expected version 2.0 or above but found version '" + a.asset.version + "'.") : b(null, a)
    }
      , Dm = function(a, b, c) {
        if (a && a.toLowerCase().endsWith(".glb")) {
            a = new DataView(b);
            var d = a.getUint32(0, !0)
              , e = a.getUint32(4, !0)
              , f = a.getUint32(8, !0);
            if (1179937895 !== d)
                c("Invalid magic number found in glb header. Expected 0x46546C67, found 0x" + d.toString(16));
            else if (2 !== e)
                c("Invalid version number found in glb header. Expected 2, found " + e);
            else if (0 >= f || f > b.byteLength)
                c("Invalid length found in glb header. Found " + f);
            else {
                d = [];
                for (e = 12; e < f; ) {
                    var g = a.getUint32(e, !0);
                    if (e + g + 8 > b.byteLength)
                        throw Error("Invalid chunk length found in glb. Found " + g);
                    var k = a.getUint32(e + 4, !0)
                      , h = new Uint8Array(b,e + 8,g);
                    d.push({
                        length: g,
                        type: k,
                        data: h
                    });
                    e += g + 8
                }
                1 !== d.length && 2 !== d.length ? c("Invalid number of chunks found in glb file.") : 1313821514 !== d[0].type ? c("Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x" + d[0].type.toString(16)) : 1 < d.length && 5130562 !== d[1].type ? c("Invalid chunk type found in glb file. Expected 0x004E4942, found 0x" + d[1].type.toString(16)) : c(null, {
                    gltfChunk: d[0].data,
                    binaryChunk: 2 === d.length ? d[1].data : null
                })
            }
        } else
            c(null, {
                gltfChunk: b,
                binaryChunk: null
            })
    }
      , Em = function(a, b, c, d) {
        var e = []
          , f = c && c.bufferView && c.bufferView.preprocess
          , g = c && c.bufferView && c.bufferView.processAsync || function(p, q, r) {
            r(null, null)
        }
          , k = c && c.bufferView && c.bufferView.postprocess
          , h = a.bufferViews.length
          , l = function(p, q) {
            var r = a.bufferViews[p];
            r.hasOwnProperty("byteStride") && (q.byteStride = r.byteStride);
            e[p] = q;
            k && k(r, q);
            0 === --h && d(null, e)
        };
        for (c = 0; c < a.bufferViews.length; ++c) {
            var n = a.bufferViews[c];
            f && f(n);
            g(n, b, function(p, q, r, t) {
                r ? d(r) : t ? l(p, t) : (r = b[q.buffer],
                q = new Uint8Array(r.buffer,r.byteOffset + (q.hasOwnProperty("byteOffset") ? q.byteOffset : 0),q.byteLength),
                l(p, q))
            }
            .bind(null, c, n))
        }
    };
    fd.parseAsync = function(a, b, c, d, e, f, g) {
        Dm(a, c, function(k, h) {
            k ? g(k) : Cm(h.gltfChunk, function(l, n) {
                l ? g(l) : zp(n, h.binaryChunk, b, f, function(p, q) {
                    p ? g(p) : Em(n, q, f, function(r, t) {
                        r ? g(r) : yp(n, t, b, e, f, function(u, x) {
                            u ? g(u) : Bm(d, n, t, x, f, g)
                        })
                    })
                })
            })
        })
    }
    ;
    fd.parse = function(a, b, c, d) {
        var e = null;
        d = d || {};
        Dm(a, b, function(f, g) {
            f ? console.error(f) : Cm(g.gltfChunk, function(k, h) {
                k ? console.error(k) : Em(h, [g.binaryChunk], d, function(l, n) {
                    l ? console.error(l) : Bm(c, h, n, [], d, function(p, q) {
                        p ? console.error(p) : e = q
                    })
                })
            })
        });
        return e
    }
    ;
    fd.createModel = function(a, b) {
        var c = new sb, d, e = [];
        for (d = 0; d < a.skins.length; d++) {
            var f = new Hc(a.skins[d]);
            f.bones = a.skins[d].bones;
            e.push(f)
        }
        if (1 === a.scenes.length)
            c.graph = a.scenes[0];
        else
            for (c.graph = new Z("SceneGroup"),
            d = 0; d < a.scenes.length; d++)
                c.graph.addChild(a.scenes[d]);
        for (d = 0; d < a.nodes.length; d++)
            if (f = a.nodes[d],
            f.root === c.graph) {
                var g = a.gltf.nodes[d];
                if (g.hasOwnProperty("mesh"))
                    for (var k = a.meshes[g.mesh], h = 0; h < k.length; h++) {
                        var l = c
                          , n = k[h]
                          , p = a.skins
                          , q = e
                          , r = g
                          , t = new va(f,n,void 0 === n.materialIndex ? b : a.materials[n.materialIndex]);
                        if (n.morph) {
                            var u = new sf(n.morph);
                            if (n.weights)
                                for (var x = 0; x < n.weights.length; x++)
                                    u.setWeight(x, n.weights[x]);
                            t.morphInstance = u;
                            l.morphInstances.push(u)
                        }
                        r.hasOwnProperty("skin") && (r = r.skin,
                        n.skin = p[r],
                        n = q[r],
                        t.skinInstance = n,
                        l.skinInstances.push(n));
                        l.meshInstances.push(t)
                    }
            }
        return c
    }
    ;
    Object.assign(ui.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = {
                retry: this.retryRequests
            };
            a.load.startsWith("blob:") && (".glb" === ca.getExtension(a.original).toLowerCase() ? c.responseType = da.ResponseType.ARRAY_BUFFER : c.responseType = da.ResponseType.JSON);
            wa.get(a.load, c, function(d, e) {
                d ? b("Error loading animation resource: " + a.original + " [" + d + "]") : b(null, e)
            })
        },
        open: function(a, b) {
            return ".glb" === ca.getExtension(a).toLowerCase() ? (a = fd.parse("filename.glb", b, null)) ? a.animations : null : this["_parseAnimationV" + b.animation.version](b)
        },
        _parseAnimationV3: function(a) {
            a = a.animation;
            var b = new Rb;
            b.setName(a.name);
            b.duration = a.duration;
            for (var c = 0; c < a.nodes.length; c++) {
                var d = new Gg
                  , e = a.nodes[c];
                d._name = e.name;
                for (var f = 0; f < e.keys.length; f++) {
                    var g = e.keys[f]
                      , k = g.time
                      , h = g.pos
                      , l = g.rot;
                    g = g.scale;
                    h = new z(h[0],h[1],h[2]);
                    l = (new Y).setFromEulerAngles(l[0], l[1], l[2]);
                    g = new z(g[0],g[1],g[2]);
                    k = new Fg(k,h,l,g);
                    d._keys.push(k)
                }
                b.addNode(d)
            }
            return b
        },
        _parseAnimationV4: function(a) {
            a = a.animation;
            var b = new Rb;
            b.setName(a.name);
            b.duration = a.duration;
            for (var c = 0; c < a.nodes.length; c++) {
                var d = new Gg
                  , e = a.nodes[c];
                d._name = e.name;
                for (var f = e.defaults.p, g = e.defaults.r, k = e.defaults.s, h = 0; h < e.keys.length; h++) {
                    var l = e.keys[h]
                      , n = l.t
                      , p = f ? f : l.p
                      , q = g ? g : l.r;
                    l = k ? k : l.s;
                    p = new z(p[0],p[1],p[2]);
                    q = (new Y).setFromEulerAngles(q[0], q[1], q[2]);
                    l = new z(l[0],l[1],l[2]);
                    n = new Fg(n,p,q,l);
                    d._keys.push(n)
                }
                b.addNode(d)
            }
            return b
        }
    });
    Object.assign(vi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = {
                retry: this.retryRequests
            };
            a.load.startsWith("blob:") && (c.responseType = da.ResponseType.JSON);
            wa.get(a.load, c, function(d, e) {
                d ? b("Error loading animation clip resource: " + a.original + " [" + d + "]") : b(null, e)
            })
        },
        open: function(a, b) {
            a = b.name;
            var c = b.duration
              , d = b.inputs.map(function(f) {
                return new vf(1,f)
            })
              , e = b.outputs.map(function(f) {
                return new vf(f.components,f.data)
            });
            b = b.curves.map(function(f) {
                return new Ig([f.path],f.inputIndex,f.outputIndex,f.interpolation)
            });
            return new Kd(a,c,d,e,b)
        }
    });
    Object.defineProperties(yf.prototype, {
        parameters: {
            get: function() {
                return Object.assign({}, this._parameters)
            }
        },
        layers: {
            get: function() {
                return this._layers
            }
        }
    });
    Object.assign(wi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = {
                retry: this.retryRequests
            };
            a.load.startsWith("blob:") && (c.responseType = da.ResponseType.JSON);
            wa.get(a.load, c, function(d, e) {
                d ? b("Error loading animation state graph resource: " + a.original + " [" + d + "]") : b(null, e)
            })
        },
        open: function(a, b) {
            return new yf(b)
        }
    });
    Object.defineProperty(Kg.prototype, "duration", {
        get: function() {
            var a = 0;
            this.buffer ? a = this.buffer.duration : this.audio && (a = this.audio.duration);
            return a || 0
        }
    });
    var ck = function() {
        if ("undefined" === typeof window)
            return !1;
        var a = window.navigator.userAgent
          , b = a.indexOf("MSIE ");
        return 0 < b ? parseInt(a.substring(b + 5, a.indexOf(".", b)), 10) : 0 < a.indexOf("Trident/") ? (b = a.indexOf("rv:"),
        parseInt(a.substring(b + 3, a.indexOf(".", b)), 10)) : !1
    }();
    Object.assign(zf.prototype, {
        _isSupported: function(a) {
            return {
                ".ogg": "audio/ogg",
                ".mp3": "audio/mpeg",
                ".wav": "audio/x-wav",
                ".mp4a": "audio/mp4",
                ".m4a": "audio/mp4",
                ".mp4": "audio/mp4",
                ".aac": "audio/aac"
            }[ca.getExtension(a)] ? !0 : !1
        },
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = function(e) {
                b(null, new Kg(e))
            }
              , d = function(e) {
                var f = "Error loading audio url: " + a.original;
                e && (f += ": " + (e.message || e));
                console.warn(f);
                b(f)
            };
            this._createSound ? this._isSupported(a.original) ? this._createSound(a.load, c, d) : d("Audio format for " + a.original + " not supported") : d(null)
        },
        open: function(a, b) {
            return b
        }
    });
    ed() ? zf.prototype._createSound = function(a, b, c) {
        var d = this.manager;
        if (d.context) {
            var e = {
                retry: this.retryRequests
            };
            a.startsWith("blob:") && (e.responseType = da.ResponseType.ARRAY_BUFFER);
            wa.get(a, e, function(f, g) {
                f ? c(f) : d.context.decodeAudioData(g, b, c)
            })
        } else
            c("Audio manager has no audio context")
    }
    : ue() && (zf.prototype._createSound = function(a, b, c) {
        var d = null;
        try {
            d = new Audio
        } catch (f) {
            c("No support for Audio element");
            return
        }
        ck && document.body.appendChild(d);
        var e = function() {
            d.removeEventListener("canplaythrough", e);
            ck && document.body.removeChild(d);
            b(d)
        };
        d.onerror = function() {
            d.onerror = null;
            ck && document.body.removeChild(d);
            c()
        }
        ;
        d.addEventListener("canplaythrough", e);
        d.src = a
    }
    );
    Object.assign(xi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            wa.get(a.load, {
                responseType: da.ResponseType.ARRAY_BUFFER,
                retry: this.retryRequests
            }, function(c, d) {
                c ? b("Error loading binary resource: " + a.original + " [" + c + "]") : b(null, d)
            })
        },
        open: function(a, b) {
            return b
        },
        patch: function(a, b) {}
    });
    Af.prototype.hasBlobUrl = function(a) {
        return !!this._blobUrls[a]
    }
    ;
    Af.prototype.getBlobUrl = function(a) {
        return this._blobUrls[a]
    }
    ;
    Af.prototype.destroy = function() {
        for (var a in this._blobUrls)
            URL.revokeObjectURL(this._blobUrls[a]);
        this._blobUrls = null
    }
    ;
    var Tk, yi = null;
    Bf.prototype._onMessage = function(a) {
        var b = a.data.id;
        if (this._pendingRequests[b]) {
            var c = this._pendingRequests[b];
            delete this._pendingRequests[b];
            if (a.data.error)
                c(a.data.error);
            else {
                b = a.data.arrayBuffer;
                for (var d = 0, e = a.data.files.length; d < e; d++) {
                    var f = a.data.files[d]
                      , g = new Blob([b.slice(f.start, f.start + f.size)]);
                    f.url = URL.createObjectURL(g)
                }
                c(null, a.data.files)
            }
        }
    }
    ;
    Bf.prototype.untar = function(a, b) {
        var c = this._requestId++;
        this._pendingRequests[c] = b;
        this._worker.postMessage({
            id: c,
            prefix: this._filenamePrefix,
            arrayBuffer: a
        }, [a])
    }
    ;
    Bf.prototype.hasPendingRequests = function() {
        for (var a in this._pendingRequests)
            return !0;
        return !1
    }
    ;
    Bf.prototype.destroy = function() {
        this._worker && (this._worker.terminate(),
        this._pendingRequests = this._worker = null)
    }
    ;
    Sk();
    Object.assign(zi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = this;
            wa.get(a.load, {
                responseType: da.ResponseType.ARRAY_BUFFER,
                retry: this.retryRequests
            }, function(d, e) {
                if (d)
                    b("Error loading bundle resource " + a.original + ": " + d);
                else
                    try {
                        c._untar(e, b)
                    } catch (f) {
                        b("Error loading bundle resource " + a.original + ": " + f)
                    }
            })
        },
        _untar: function(a, b) {
            var c = this;
            Ca.workers ? (c._worker || (c._worker = new Bf(c._assets.prefix)),
            c._worker.untar(a, function(d, e) {
                b(d, e);
                c._worker.hasPendingRequests() || (c._worker.destroy(),
                c._worker = null)
            })) : (a = (new Tk(a)).untar(c._assets.prefix),
            b(null, a))
        },
        open: function(a, b) {
            return new Af(b)
        },
        patch: function(a, b) {}
    });
    Object.assign(Ai.prototype, {
        destroy: function() {
            var a = this.registry
              , b = function(d) {
                a.remove(d);
                d.unload()
            }
              , c = function(d) {
                d.forEach(function(e) {
                    b(e)
                })
            };
            this.animations && (c(this.animations),
            this.animations = null);
            this.textures && (c(this.textures),
            this.textures = null);
            this.materials && (c(this.materials),
            this.materials = null);
            this.model && (b(this.model),
            this.model = null);
            this.assets = this.data = null
        }
    });
    Object.assign(Bi.prototype, {
        _getUrlWithoutParams: function(a) {
            return 0 <= a.indexOf("?") ? a.split("?")[0] : a
        },
        load: function(a, b, c) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var d = {
                responseType: da.ResponseType.ARRAY_BUFFER,
                retry: !1
            }
              , e = this
              , f = function(g) {
                fd.parseAsync(e._getUrlWithoutParams(a.original), ca.extractPath(a.load), g, e._device, c.registry, c.options, function(k, h) {
                    k ? b(k) : b(null, new Ai(h))
                })
            };
            c && c.file && c.file.contents ? f(c.file.contents) : wa.get(a.load, d, function(g, k) {
                b && (g ? b("Error loading model: " + a.original + " [" + g + "]") : f(k))
            })
        },
        open: function(a, b, c) {
            return b
        },
        patch: function(a, b) {
            var c = a.resource
              , d = c && c.data;
            if (d) {
                var e = function(l, n, p) {
                    l = new aa(a.name + "/" + l + "/" + p,l,{
                        url: ""
                    });
                    l.resource = n;
                    l.loaded = !0;
                    b.add(l);
                    return l
                }, f, g = e("model", fd.createModel(d, this._defaultMaterial), 0), k = [];
                for (f = 0; f < d.materials.length; ++f)
                    k.push(e("material", d.materials[f], f));
                var h = [];
                for (f = 0; f < d.animations.length; ++f)
                    h.push(e("animation", d.animations[f], f));
                c.data = null;
                c.model = g;
                c.materials = k;
                c.textures = d.textures;
                c.animations = h;
                c.registry = b
            }
        }
    });
    Object.assign(Ci.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            wa.get(a.load, {
                retry: this.retryRequests
            }, function(c, d) {
                c ? b("Error loading css resource: " + a.original + " [" + c + "]") : b(null, d)
            })
        },
        open: function(a, b) {
            return b
        },
        patch: function(a, b) {}
    });
    Object.assign(Di.prototype, {
        load: function(a, b, c) {
            this.loadAssets(c, b)
        },
        open: function(a, b, c) {
            return c ? c.resource : null
        },
        patch: function(a, b) {
            this.loadAssets(a, function(c, d) {
                c && (b.fire("error", a),
                b.fire("error:" + a.id, c, a),
                a.fire("error", a))
            })
        },
        getAssetIds: function(a) {
            var b = [];
            b[0] = a.file;
            if ((a.loadFaces || !a.file) && a.data && a.data.textures)
                for (var c = 0; 6 > c; ++c)
                    b[c + 1] = a.data.textures[c];
            else
                b[1] = b[2] = b[3] = b[4] = b[5] = b[6] = null;
            return b
        },
        compareAssetIds: function(a, b) {
            return a && b ? parseInt(a, 10) === a || "string" === typeof a ? a === b : a.url === b.url : null !== a === (null !== b)
        },
        update: function(a, b, c) {
            var d = a.data || {}, e = a._handlerState.assets, f = a._resources, g, k, h = [null, null, null, null, null, null, null], l = function() {
                return d.hasOwnProperty("type") ? d.type : d.hasOwnProperty("rgbm") ? d.rgbm ? "rgbm" : "default" : null
            };
            if (a.loaded && c[0] === e[0])
                h[1] = f[1] || null,
                h[2] = f[2] || null,
                h[3] = f[3] || null,
                h[4] = f[4] || null,
                h[5] = f[5] || null,
                h[6] = f[6] || null;
            else if (c[0]) {
                var n = c[0].resource;
                for (k = 0; 6 > k; ++k) {
                    var p = [n._levels[k]];
                    if (0 === k && this._device.useTexCubeLod)
                        for (g = 1; g < n._levels.length; ++g)
                            p[g] = n._levels[g];
                    p = new V(this._device,{
                        name: a.name + "_prelitCubemap" + (n.width >> k),
                        cubemap: !0,
                        type: l() || n.type,
                        width: n.width >> k,
                        height: n.height >> k,
                        format: n.format,
                        levels: p,
                        fixCubemapSeams: !0,
                        addressU: 1,
                        addressV: 1
                    });
                    h[k + 1] = p
                }
            }
            n = c.slice(1);
            if (a.loaded && this.cmpArrays(n, e.slice(1)))
                h[0] = f[0] || null;
            else if (-1 === n.indexOf(null)) {
                n = n.map(function(q) {
                    return q.resource
                });
                k = [];
                for (g = 0; g < n[0]._levels.length; ++g)
                    k.push(n.map(function(q) {
                        return q._levels[g]
                    }));
                l = new V(this._device,{
                    name: a.name + "_faces",
                    cubemap: !0,
                    type: l() || n[0].type,
                    width: n[0].width,
                    height: n[0].height,
                    format: n[0].format,
                    levels: k,
                    minFilter: d.hasOwnProperty("minFilter") ? d.minFilter : n[0].minFilter,
                    magFilter: d.hasOwnProperty("magFilter") ? d.magFilter : n[0].magFilter,
                    anisotropy: d.hasOwnProperty("anisotropy") ? d.anisotropy : 1,
                    addressU: 1,
                    addressV: 1,
                    fixCubemapSeams: !!c[0]
                });
                h[0] = l
            }
            if (!this.cmpArrays(h, f))
                for (a.resources = h,
                a._handlerState.assetIds = b,
                a._handlerState.assets = c,
                k = 0; k < f.length; ++k)
                    null !== f[k] && -1 === h.indexOf(f[k]) && f[k].destroy();
            for (k = 0; k < e.length; ++k)
                null !== e[k] && -1 === c.indexOf(e[k]) && e[k].unload()
        },
        cmpArrays: function(a, b) {
            if (a.length !== b.length)
                return !1;
            for (var c = 0; c < a.length; ++c)
                if (a[c] !== b[c])
                    return !1;
            return !0
        },
        loadAssets: function(a, b) {
            a.hasOwnProperty("_handlerState") || (a._handlerState = {
                assetIds: [null, null, null, null, null, null, null],
                assets: [null, null, null, null, null, null, null]
            });
            for (var c = this, d = c.getAssetIds(a), e = [null, null, null, null, null, null, null], f = a._handlerState.assetIds, g = a._handlerState.assets, k = c._registry, h = 7, l = function(x, v) {
                e[x] = v;
                h--;
                0 === h && (c.update(a, d, e),
                b(null, a.resources))
            }, n = function(x, v) {
                var w = v && v.resource && v.resource._levels[0];
                w && "undefined" !== typeof ImageBitmap && w instanceof ImageBitmap ? createImageBitmap(w, {
                    premultiplyAlpha: "none",
                    imageOrientation: "flipY"
                }).then(function(y) {
                    v.resource._levels[0] = y;
                    l(x, v)
                }).catch(function(y) {
                    b(y)
                }) : l(x, v)
            }, p = function(x, v, w) {
                b(v)
            }, q = function(x, v) {
                v.loaded ? n(x, v) : (k.once("load:" + v.id, n.bind(c, x)),
                k.once("error:" + v.id, p.bind(c, x)),
                v.loading || k.load(v))
            }, r, t = 0; 7 > t; ++t) {
                var u = d[t];
                u ? c.compareAssetIds(u, f[t]) ? l(t, g[t]) : parseInt(u, 10) === u ? (r = k.get(u)) ? q(t, r) : setTimeout(function(x, v) {
                    var w = k.get(v);
                    w ? q(x, w) : b("failed to find dependent cubemap asset=" + v)
                }
                .bind(null, t, u)) : (r = new aa(a.name + "_part_" + t,"texture","string" === typeof u ? {
                    url: u,
                    filename: u
                } : u),
                k.add(r),
                k.once("load:" + r.id, n.bind(c, t)),
                k.once("error:" + r.id, p.bind(c, t)),
                k.load(r)) : l(t, null)
            }
        }
    });
    Object.assign(Ei.prototype, {
        load: function(a, b) {
            b(null, null)
        },
        open: function(a, b) {
            return b
        }
    });
    Object.defineProperty(Lg.prototype, "data", {
        get: function() {
            return this._data
        },
        set: function(a) {
            if (this._data = a)
                if (void 0 !== this._data.intensity && (this.intensity = this._data.intensity),
                this._data.info || (this._data.info = {}),
                !this._data.version || 2 > this._data.version)
                    if (this._data.info.maps = [{
                        width: this._data.info.width,
                        height: this._data.info.height
                    }],
                    this._data.chars)
                        for (var b in this._data.chars)
                            this._data.chars[b].map = 0
        }
    });
    Object.assign(Gi.prototype, {
        load: function(a, b, c) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var d = this;
            ".json" === ca.getExtension(a.original) ? wa.get(a.load, {
                retry: this.retryRequests
            }, function(e, f) {
                var g = Fi(f);
                e ? b("Error loading font resource: " + a.original + " [" + e + "]") : d._loadTextures(a.load.replace(".json", ".png"), g, function(k, h) {
                    if (k)
                        return b(k);
                    b(null, {
                        data: g,
                        textures: h
                    })
                })
            }) : (c && c.data && (c.data = Fi(c.data)),
            this._loadTextures(a.load, c && c.data, b))
        },
        _loadTextures: function(a, b, c) {
            var d = b.info.maps.length
              , e = 0
              , f = null
              , g = Array(d)
              , k = this._loader;
            b = function(l) {
                var n = function(p, q) {
                    if (!f) {
                        if (p)
                            return f = p,
                            c(p);
                        q.upload();
                        g[l] = q;
                        e++;
                        e === d && c(null, g)
                    }
                };
                0 === l ? k.load(a, "texture", n) : k.load(a.replace(".png", l + ".png"), "texture", n)
            }
            ;
            for (var h = 0; h < d; h++)
                b(h)
        },
        open: function(a, b, c) {
            return b.textures ? new Lg(b.textures,b.data) : new Lg(b,null)
        },
        patch: function(a, b) {
            b = a.resource;
            !b.data && a.data ? b.data = a.data : !a.data && b.data && (a.data = b.data);
            a.data && (a.data = Fi(a.data))
        }
    });
    Eb.prototype = Object.create(M.prototype);
    Eb.prototype.constructor = Eb;
    Eb.prototype.destroy = function() {
        var a = this;
        this._registry.off("load", this._onLoad);
        this._registry.off("error", this._onError);
        this._waitingAssets.forEach(function(b) {
            a._registry.off("add:" + b, this._onAddAsset)
        });
        this.off("progress");
        this.off("load")
    }
    ;
    Eb.prototype.load = function(a, b) {
        var c = this._assets.length;
        this._count = 0;
        this._failed = [];
        this._callback = a;
        this._scope = b;
        this._registry.on("load", this._onLoad, this);
        this._registry.on("error", this._onError, this);
        for (a = 0; a < c; a++)
            b = this._assets[a],
            b.loading || b.loaded || (this._registry.load(b),
            this._total++)
    }
    ;
    Eb.prototype.ready = function(a, b) {
        b = b || this;
        if (this._loaded)
            a.call(b, this._assets);
        else
            this.once("load", function(c) {
                a.call(b, c)
            })
    }
    ;
    Eb.prototype._loadingComplete = function() {
        this._loaded = !0;
        this._registry.off("load", this._onLoad, this);
        this._registry.off("error", this._onError, this);
        this._failed && this._failed.length ? (this._callback && this._callback.call(this._scope, "Failed to load some assets", this._failed),
        this.fire("error", this._failed)) : (this._callback && this._callback.call(this._scope),
        this.fire("load", this._assets))
    }
    ;
    Eb.prototype._onLoad = function(a) {
        var b = this;
        0 <= this._assets.indexOf(a) && (this._count++,
        this.fire("progress", a));
        this._count === this._total && setTimeout(function() {
            b._loadingComplete(b._failed)
        }, 0)
    }
    ;
    Eb.prototype._onError = function(a, b) {
        var c = this;
        0 <= this._assets.indexOf(b) && (this._count++,
        this._failed.push(b));
        this._count === this._total && setTimeout(function() {
            c._loadingComplete(c._failed)
        }, 0)
    }
    ;
    Eb.prototype._onAddAsset = function(a) {
        var b = this._waitingAssets.indexOf(a);
        0 <= b && this._waitingAssets.splice(b, 1);
        this._assets.push(a);
        var c = this._assets.length;
        for (b = 0; b < c; b++)
            a = this._assets[b],
            a.loading || a.loaded || this._registry.load(a)
    }
    ;
    Eb.prototype._waitForAsset = function(a) {
        this._waitingAssets.push(a);
        this._registry.once("add:" + a, this._onAddAsset, this)
    }
    ;
    var Yc = {
        waitForTemplatesInScene: function(a, b, c) {
            if (a.collapsedInstances) {
                var d = Yc._getAllCollapsedEntities(a);
                Yc.waitForTemplateAssets(d, b, c, a)
            } else
                c(null, a)
        },
        waitForTemplateAssets: function(a, b, c, d) {
            a = Yc._extractTemplateIds(a);
            (new Eb(a,b)).load(function(e) {
                c(e, d)
            })
        },
        _getAllCollapsedEntities: function(a) {
            var b = {};
            a.collapsedInstances.forEach(function(c) {
                Object.assign(b, c.instanceEntities)
            });
            return b
        },
        _extractTemplateIds: function(a) {
            var b = [], c;
            for (c in a) {
                var d = a[c].template_id;
                d && b.push(d)
            }
            return b
        },
        expandTemplateEntities: function(a, b) {
            var c = {}, d;
            for (d in b) {
                var e = b[d];
                c[d] = e.collapsed_entity ? Yc.expandEntity(a, e) : e
            }
            return c
        },
        expandEntity: function(a, b) {}
    }
      , dk = {
        setCompressedPRS: function(a, b, c) {
            var d = c.singleVecs
              , e = b.___1;
            if (!e) {
                var f = c.tripleVecs;
                var g = b.___2
            }
            b = e ? e[0] : f[g];
            a.setLocalPosition(d[b], d[b + 1], d[b + 2]);
            b = e ? e[1] : f[g + 1];
            a.setLocalEulerAngles(d[b], d[b + 1], d[b + 2]);
            b = e ? e[2] : f[g + 2];
            a.setLocalScale(d[b], d[b + 1], d[b + 2])
        },
        oneCharToKey: function(a, b) {
            a = a.charCodeAt(0) - b.fieldFirstCode;
            return b.fieldArray[a]
        },
        multCharToKey: function(a, b) {
            for (var c = 0, d = 0; d < a.length; d++)
                c = c * b.fieldCodeBase + a.charCodeAt(d) - b.fieldFirstCode;
            return b.fieldArray[c]
        }
    };
    Object.assign(Mg.prototype, {
        run: function() {
            var a = Object.prototype.toString.call(this._node);
            "[object Object]" === a ? this._handleMap() : "[object Array]" === a ? this._handleArray() : this._result = this._node;
            return this._result
        },
        _handleMap: function() {
            this._result = {};
            Object.keys(this._node).forEach(this._handleKey, this)
        },
        _handleKey: function(a) {
            var b = a
              , c = a.length;
            1 === c ? b = dk.oneCharToKey(a, this._data) : 2 === c && (b = dk.multCharToKey(a, this._data));
            this._result[b] = (new Mg(this._node[a],this._data)).run()
        },
        _handleArray: function() {
            this._result = [];
            this._node.forEach(this._handleArElt, this)
        },
        _handleArElt: function(a) {
            a = (new Mg(a,this._data)).run();
            this._result.push(a)
        }
    });
    Object.assign(Ng.prototype, {
        parse: function(a) {
            var b = {}, c, d, e = null;
            if (d = a.compressedFormat)
                a.entities = (new Mg(a.entities,d)).run();
            a.collapsedInstances && this._addCollapsedToEntities(this._app, a);
            for (c in a.entities) {
                var f = a.entities[c];
                var g = this._createEntity(f, d);
                b[c] = g;
                null === f.parent && (e = g)
            }
            for (c in a.entities) {
                g = b[c];
                f = a.entities[c].children;
                var k = f.length;
                for (d = 0; d < k; d++) {
                    var h = b[f[d]];
                    h && g.addChild(h)
                }
            }
            this._openComponentData(e, a.entities);
            delete a.compressedFormat;
            return e
        },
        _createEntity: function(a, b) {
            var c = new fa;
            c.name = a.name;
            c.setGuid(a.resource_id);
            this._setPosRotScale(c, a, b);
            c._enabled = void 0 !== a.enabled ? a.enabled : !0;
            this._isTemplate ? c._template = !0 : c._enabledInHierarchy = c._enabled;
            c.template = a.template;
            if (a.tags)
                for (b = 0; b < a.tags.length; b++)
                    c.tags.add(a.tags[b]);
            a.labels && a.labels.forEach(function(d) {
                c.addLabel(d)
            });
            return c
        },
        _setPosRotScale: function(a, b, c) {
            if (c)
                dk.setCompressedPRS(a, b, c);
            else {
                c = b.position;
                var d = b.rotation;
                b = b.scale;
                a.setLocalPosition(c[0], c[1], c[2]);
                a.setLocalEulerAngles(d[0], d[1], d[2]);
                a.setLocalScale(b[0], b[1], b[2])
            }
        },
        _openComponentData: function(a, b) {
            var c = this._app.systems.list, d, e = c.length, f = b[a.getGuid()];
            for (d = 0; d < e; d++) {
                var g = c[d]
                  , k = f.components[g.id];
                k && g.addComponent(a, k)
            }
            e = f.children.length;
            c = a._children;
            for (d = 0; d < e; d++)
                c[d] = this._openComponentData(c[d], b);
            return a
        },
        _addCollapsedToEntities: function(a, b) {
            b.collapsedInstances.forEach(function(c) {
                c = Yc.expandTemplateEntities(a, c.instanceEntities);
                Object.assign(b.entities, c)
            })
        }
    });
    Object.assign(Hi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = this._app.assets;
            wa.get(a.load, {
                retry: this.retryRequests
            }, function(d, e) {
                d ? (e = "Error while loading scene " + a.original,
                d.message ? (e += ": " + d.message,
                d.stack && (e += "\n" + d.stack)) : e += ": " + d,
                b(e)) : Yc.waitForTemplatesInScene(e, c, b)
            })
        },
        open: function(a, b) {
            this._app.systems.script.preloading = !0;
            a = (new Ng(this._app,!1)).parse(b);
            this._app.systems.script.preloading = !1;
            return a
        }
    });
    Object.assign(Ii.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            wa.get(a.load, {
                retry: this.retryRequests
            }, function(c, d) {
                c ? b("Error loading html resource: " + a.original + " [" + c + "]") : b(null, d)
            })
        },
        open: function(a, b) {
            return b
        },
        patch: function(a, b) {}
    });
    Object.assign(Ji.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = {
                retry: this.retryRequests
            };
            a.load.startsWith("blob:") && (c.responseType = da.ResponseType.JSON);
            wa.get(a.load, c, function(d, e) {
                d ? b("Error loading JSON resource: " + a.original + " [" + d + "]") : b(null, e)
            })
        },
        open: function(a, b) {
            return b
        },
        patch: function(a, b) {}
    });
    var hf = {
        name: "string",
        chunks: "chunks",
        mappingFormat: "string",
        _engine: "boolean",
        ambient: "rgb",
        ambientTint: "boolean",
        aoVertexColor: "boolean",
        aoVertexColorChannel: "string",
        aoMap: "texture",
        aoMapChannel: "string",
        aoMapUv: "number",
        aoMapTiling: "vec2",
        aoMapOffset: "vec2",
        diffuse: "rgb",
        diffuseTint: "boolean",
        diffuseVertexColor: "boolean",
        diffuseVertexColorChannel: "string",
        diffuseMap: "texture",
        diffuseMapChannel: "string",
        diffuseMapUv: "number",
        diffuseMapTiling: "vec2",
        diffuseMapOffset: "vec2",
        diffuseDetailMap: "texture",
        diffuseDetailMapChannel: "string",
        diffuseDetailMapUv: "number",
        diffuseDetailMapTiling: "vec2",
        diffuseDetailMapOffset: "vec2",
        diffuseDetailMode: "string",
        specular: "rgb",
        specularTint: "boolean",
        specularVertexColor: "boolean",
        specularVertexColorChannel: "string",
        specularMap: "texture",
        specularMapChannel: "string",
        specularMapUv: "number",
        specularMapTiling: "vec2",
        specularMapOffset: "vec2",
        specularAntialias: "boolean",
        occludeSpecular: "enum:occludeSpecular",
        useMetalness: "boolean",
        metalness: "number",
        enableGGXSpecular: "boolean",
        anisotropy: "number",
        metalnessTint: "boolean",
        metalnessVertexColor: "boolean",
        metalnessVertexColorChannel: "string",
        metalnessMap: "texture",
        metalnessMapChannel: "string",
        metalnessMapUv: "number",
        metalnessMapTiling: "vec2",
        metalnessMapOffset: "vec2",
        conserveEnergy: "boolean",
        shininess: "number",
        glossVertexColor: "boolean",
        glossVertexColorChannel: "string",
        glossMap: "texture",
        glossMapChannel: "string",
        glossMapUv: "number",
        glossMapTiling: "vec2",
        glossMapOffset: "vec2",
        clearCoat: "number",
        clearCoatVertexColor: "boolean",
        clearCoatVertexColorChannel: "string",
        clearCoatMap: "texture",
        clearCoatMapChannel: "string",
        clearCoatMapUv: "number",
        clearCoatMapTiling: "vec2",
        clearCoatMapOffset: "vec2",
        clearCoatGlossiness: "number",
        clearCoatGlossVertexColor: "boolean",
        clearCoatGlossVertexColorChannel: "string",
        clearCoatGlossMap: "texture",
        clearCoatGlossMapChannel: "string",
        clearCoatGlossMapUv: "number",
        clearCoatGlossMapTiling: "vec2",
        clearCoatGlossMapOffset: "vec2",
        clearCoatBumpiness: "number",
        clearCoatNormalMap: "texture",
        clearCoatNormalMapUv: "number",
        clearCoatNormalMapTiling: "vec2",
        clearCoatNormalMapOffset: "vec2",
        fresnelModel: "number",
        emissive: "rgb",
        emissiveTint: "boolean",
        emissiveVertexColor: "boolean",
        emissiveVertexColorChannel: "string",
        emissiveMap: "texture",
        emissiveMapChannel: "string",
        emissiveMapUv: "number",
        emissiveMapTiling: "vec2",
        emissiveMapOffset: "vec2",
        emissiveIntensity: "number",
        normalMap: "texture",
        normalMapTiling: "vec2",
        normalMapOffset: "vec2",
        normalMapUv: "number",
        bumpiness: "number",
        normalDetailMap: "texture",
        normalDetailMapTiling: "vec2",
        normalDetailMapOffset: "vec2",
        normalDetailMapUv: "number",
        normalDetailMapBumpiness: "number",
        heightMap: "texture",
        heightMapChannel: "string",
        heightMapUv: "number",
        heightMapTiling: "vec2",
        heightMapOffset: "vec2",
        heightMapFactor: "number",
        alphaToCoverage: "boolean",
        alphaTest: "number",
        opacity: "number",
        opacityVertexColor: "boolean",
        opacityVertexColorChannel: "string",
        opacityMap: "texture",
        opacityMapChannel: "string",
        opacityMapUv: "number",
        opacityMapTiling: "vec2",
        opacityMapOffset: "vec2",
        reflectivity: "number",
        refraction: "number",
        refractionIndex: "number",
        sphereMap: "texture",
        cubeMap: "cubemap",
        cubeMapProjection: "number",
        cubeMapProjectionBox: "boundingbox",
        lightVertexColor: "boolean",
        lightVertexColorChannel: "string",
        lightMap: "texture",
        lightMapChannel: "string",
        lightMapUv: "number",
        lightMapTiling: "vec2",
        lightMapOffset: "vec2",
        depthTest: "boolean",
        depthWrite: "boolean",
        depthBias: "number",
        slopeDepthBias: "number",
        cull: "enum:cull",
        blendType: "enum:blendType",
        shadingModel: "enum:shadingModel",
        useFog: "boolean",
        useLighting: "boolean",
        useSkybox: "boolean",
        useGammaTonemap: "boolean",
        prefilteredCubeMap128: "texture",
        prefilteredCubeMap64: "texture",
        prefilteredCubeMap32: "texture",
        prefilteredCubeMap16: "texture",
        prefilteredCubeMap8: "texture",
        prefilteredCubeMap4: "texture"
    }, jf, kf = [];
    for (jf in hf) {
        var ek = hf[jf];
        "texture" === ek && kf.push(jf)
    }
    var Eh = [];
    for (jf in hf)
        ek = hf[jf],
        "cubemap" === ek && Eh.push(jf);
    wc.prototype._bind = function() {
        if (this.id) {
            if (this._onAssetLoad)
                this._registry.on("load:" + this.id, this._onLoad, this);
            if (this._onAssetAdd)
                this._registry.once("add:" + this.id, this._onAdd, this);
            if (this._onAssetRemove)
                this._registry.on("remove:" + this.id, this._onRemove, this)
        }
        if (this.url) {
            if (this._onAssetLoad)
                this._registry.on("load:url:" + this.url, this._onLoad, this);
            if (this._onAssetAdd)
                this._registry.once("add:url:" + this.url, this._onAdd, this);
            if (this._onAssetRemove)
                this._registry.on("remove:url:" + this.url, this._onRemove, this)
        }
    }
    ;
    wc.prototype._unbind = function() {
        this.id && (this._onAssetLoad && this._registry.off("load:" + this.id, this._onLoad, this),
        this._onAssetAdd && this._registry.off("add:" + this.id, this._onAdd, this),
        this._onAssetRemove && this._registry.off("remove:" + this.id, this._onRemove, this));
        this.url && (this._onAssetLoad && this._registry.off("load:" + this.url, this._onLoad, this),
        this._onAssetAdd && this._registry.off("add:" + this.url, this._onAdd, this),
        this._onAssetRemove && this._registry.off("remove:" + this.url, this._onRemove, this))
    }
    ;
    wc.prototype._onLoad = function(a) {
        this._onAssetLoad.call(this._scope, this.propertyName, this.parent, a)
    }
    ;
    wc.prototype._onAdd = function(a) {
        this._onAssetAdd.call(this._scope, this.propertyName, this.parent, a)
    }
    ;
    wc.prototype._onRemove = function(a) {
        this._onAssetRemove.call(this._scope, this.propertyName, this.parent, a)
    }
    ;
    Object.defineProperty(wc.prototype, "id", {
        get: function() {
            return this._id
        },
        set: function(a) {
            if (this.url)
                throw Error("Can't set id and url");
            this._unbind();
            this._id = a;
            this.asset = this._registry.get(this._id);
            this._bind()
        }
    });
    Object.defineProperty(wc.prototype, "url", {
        get: function() {
            return this._url
        },
        set: function(a) {
            if (this.id)
                throw Error("Can't set id and url");
            this._unbind();
            this._url = a;
            this.asset = this._registry.getByUrl(this._url);
            this._bind()
        }
    });
    Cf.prototype.setInvalid = function(a, b) {
        this.valid = !1;
        this.removeInvalid && delete b[a]
    }
    ;
    Cf.prototype.validate = function(a) {
        var b, c = "path" === a.mappingFormat, d;
        for (d in a)
            if (b = hf[d])
                if (b.startsWith("enum"))
                    b = b.split(":")[1],
                    this.enumValidators[b] && (this.enumValidators[b](a[d]) || this.setInvalid(d, a));
                else if ("number" === b)
                    "number" !== typeof a[d] && this.setInvalid(d, a);
                else if ("boolean" === b)
                    "boolean" !== typeof a[d] && this.setInvalid(d, a);
                else if ("string" === b)
                    "string" !== typeof a[d] && this.setInvalid(d, a);
                else if ("vec2" === b)
                    a[d]instanceof Array && 2 === a[d].length || this.setInvalid(d, a);
                else if ("rgb" === b)
                    a[d]instanceof Array && 3 === a[d].length || this.setInvalid(d, a);
                else if ("texture" === b)
                    c ? "string" === typeof a[d] || a[null === d] || a[d]instanceof V || this.setInvalid(d, a) : "number" !== typeof a[d] && null !== a[d] && (a[d]instanceof V || this.setInvalid(d, a));
                else if ("boundingbox" === b)
                    a[d].center && a[d].center instanceof Array && 3 === a[d].center.length || this.setInvalid(d, a),
                    a[d].halfExtents && a[d].halfExtents instanceof Array && 3 === a[d].halfExtents.length || this.setInvalid(d, a);
                else if ("cubemap" === b)
                    "number" !== typeof a[d] && null !== a[d] && void 0 !== a[d] && (a[d]instanceof V && a[d].cubemap || this.setInvalid(d, a));
                else if ("chunks" === b) {
                    var e = Object.keys(a[d]);
                    for (b = 0; b < e.length; b++)
                        "string" !== typeof a[d][e[b]] && this.setInvalid(e[b], a[d])
                } else
                    console.error("Unknown material type: " + b);
            else
                this.valid = !1;
        a.validated = !0;
        return this.valid
    }
    ;
    Cf.prototype._createEnumValidator = function(a) {
        return function(b) {
            return 0 <= a.indexOf(b)
        }
    }
    ;
    ve.prototype.parse = function(a) {
        a = this.migrate(a);
        a = this._validate(a);
        var b = new la;
        this.initialize(b, a);
        return b
    }
    ;
    ve.prototype.initialize = function(a, b) {
        b.validated || (this._validator || (this._validator = new Cf),
        this._validator.validate(b));
        b.chunks && a.chunks.copy(b.chunks);
        for (var c in b) {
            var d = hf[c]
              , e = b[c];
            "vec2" === d ? a[c] = new P(e[0],e[1]) : "rgb" === d ? a[c] = new L(e[0],e[1],e[2]) : "texture" === d ? e instanceof V ? a[c] = e : a[c]instanceof V && "number" === typeof e && 0 < e || (a[c] = null) : "cubemap" === d ? e instanceof V ? a[c] = e : a[c]instanceof V && "number" === typeof e && 0 < e || (a[c] = null) : "boundingbox" === d ? (d = new z(e.center[0],e.center[1],e.center[2]),
            e = new z(e.halfExtents[0],e.halfExtents[1],e.halfExtents[2]),
            a[c] = new oa(d,e)) : a[c] = b[c]
        }
        a.update()
    }
    ;
    ve.prototype.migrate = function(a) {
        void 0 === a.shadingModel && (a.shadingModel = "blinn" === a.shader ? 1 : 0);
        a.shader && delete a.shader;
        a.mapping_format && (a.mappingFormat = a.mapping_format,
        delete a.mapping_format);
        var b, c = [["bumpMapFactor", "bumpiness"], ["aoUvSet", "aoMapUv"], ["aoMapVertexColor", "aoVertexColor"], ["diffuseMapVertexColor", "diffuseVertexColor"], ["emissiveMapVertexColor", "emissiveVertexColor"], ["specularMapVertexColor", "specularVertexColor"], ["metalnessMapVertexColor", "metalnessVertexColor"], ["opacityMapVertexColor", "opacityVertexColor"], ["glossMapVertexColor", "glossVertexColor"], ["lightMapVertexColor", "lightVertexColor"], ["diffuseMapTint", "diffuseTint"], ["specularMapTint", "specularTint"], ["emissiveMapTint", "emissiveTint"], ["metalnessMapTint", "metalnessTint"]];
        for (b = 0; b < c.length; b++) {
            var d = c[b][0]
              , e = c[b][1];
            void 0 !== a[d] && void 0 === a[e] && (a[e] = a[d],
            delete a[d])
        }
        c = ["fresnelFactor", "shadowSampleType"];
        for (b = 0; b < c.length; b++)
            d = c[b],
            a.hasOwnProperty(d) && delete a[d];
        return a
    }
    ;
    ve.prototype._validate = function(a) {
        this._validator || (this._validator = new Cf);
        this._validator.validate(a);
        return a
    }
    ;
    var Ap = {
        aoMap: "white",
        diffuseMap: "gray",
        specularMap: "gray",
        metalnessMap: "black",
        glossMap: "gray",
        emissiveMap: "gray",
        normalMap: "normal",
        heightMap: "gray",
        opacityMap: "gray",
        sphereMap: "gray",
        lightMap: "white"
    };
    Object.assign(Ki.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            wa.get(a.load, {
                retry: this.retryRequests
            }, function(c, d) {
                c ? b && b("Error loading material: " + a.original + " [" + c + "]") : b && (d._engine = !0,
                b(null, d))
            })
        },
        open: function(a, b) {
            a = this._parser.parse(b);
            b._engine && (a._data = b,
            delete b._engine);
            return a
        },
        _createPlaceholders: function() {
            this._placeholderTextures = {};
            var a = {
                white: [255, 255, 255, 255],
                gray: [128, 128, 128, 255],
                black: [0, 0, 0, 255],
                normal: [128, 128, 255, 255]
            }, b;
            for (b in a)
                if (a.hasOwnProperty(b)) {
                    this._placeholderTextures[b] = new V(this._device,{
                        width: 2,
                        height: 2,
                        format: 7
                    });
                    this._placeholderTextures[b].name = "placeholder";
                    for (var c = this._placeholderTextures[b].lock(), d = 0; 4 > d; d++)
                        for (var e = 0; 4 > e; e++)
                            c[4 * d + e] = a[b][e];
                    this._placeholderTextures[b].unlock()
                }
        },
        patch: function(a, b) {
            a.resource._data && (a._data = a.resource._data,
            delete a.resource._data);
            a.data.name = a.name;
            a.resource.name = a.name;
            this._bindAndAssignAssets(a, b);
            a.off("unload", this._onAssetUnload, this);
            a.on("unload", this._onAssetUnload, this)
        },
        _onAssetUnload: function(a) {
            delete a.data.parameters;
            delete a.data.chunks;
            delete a.data.name
        },
        _assignTexture: function(a, b, c) {
            b.data[a] = c;
            b.resource[a] = c
        },
        _assignPlaceholderTexture: function(a, b) {
            this._placeholderTextures || this._createPlaceholders();
            b.resource[a] = this._placeholderTextures[Ap[a]]
        },
        _onTextureLoad: function(a, b, c) {
            this._assignTexture(a, b, c.resource);
            b.resource.update()
        },
        _onTextureAdd: function(a, b, c) {
            this._assets.load(c)
        },
        _onTextureRemove: function(a, b, c) {
            var d = b.resource;
            d[a] === c.resource && (this._assignTexture(a, b, null),
            d.update())
        },
        _assignCubemap: function(a, b, c) {
            b.data[a] = c[0];
            7 === c.length && (b.data.prefilteredCubeMap128 = c[1],
            b.data.prefilteredCubeMap64 = c[2],
            b.data.prefilteredCubeMap32 = c[3],
            b.data.prefilteredCubeMap16 = c[4],
            b.data.prefilteredCubeMap8 = c[5],
            b.data.prefilteredCubeMap4 = c[6])
        },
        _onCubemapLoad: function(a, b, c) {
            this._assignCubemap(a, b, c.resources);
            this._parser.initialize(b.resource, b.data)
        },
        _onCubemapAdd: function(a, b, c) {
            0 === b.data.shadingModel && (b.loadFaces = !0);
            this._assets.load(c)
        },
        _onCubemapRemove: function(a, b, c) {
            var d = b.resource;
            d[a] === c.resource && (this._assignCubemap(a, b, [null, null, null, null, null, null, null]),
            d.update())
        },
        _bindAndAssignAssets: function(a, b) {
            var c = this._parser.migrate(a.data), d = a.resource, e = "path" === c.mappingFormat, f;
            for (f = 0; f < kf.length; f++) {
                var g = kf[f];
                var k = d._assetReferences[g];
                !c[g] || c[g]instanceof V ? k && (e ? k.url = null : k.id = null) : (k || (k = new wc(g,a,b,{
                    load: this._onTextureLoad,
                    add: this._onTextureAdd,
                    remove: this._onTextureRemove
                },this),
                d._assetReferences[g] = k),
                e ? k.url = a.getAbsoluteUrl(c[g]) : k.id = c[g],
                k.asset && (k.asset.resource ? this._assignTexture(g, a, k.asset.resource) : this._assignPlaceholderTexture(g, a),
                b.load(k.asset)))
            }
            for (f = 0; f < Eh.length; f++)
                g = Eh[f],
                k = d._assetReferences[g],
                !c[g] || c[g]instanceof V || (k || (k = new wc(g,a,b,{
                    load: this._onCubemapLoad,
                    add: this._onCubemapAdd,
                    remove: this._onCubemapRemove
                },this),
                d._assetReferences[g] = k),
                e ? k.url = c[g] : k.id = c[g],
                k.asset && (k.asset.loaded && this._assignCubemap(g, a, k.asset.resources),
                b.load(k.asset)));
            this._parser.initialize(d, c)
        }
    });
    Object.assign(Uk.prototype, {
        parse: function(a) {
            return (a = fd.parse("filename.glb", a, this._device)) ? fd.createModel(a, this._defaultMaterial) : null
        }
    });
    Object.assign(Vk.prototype, {
        addVertex: function(a, b, c) {
            if (void 0 !== this.indexMap[b])
                c = this.indexMap[b],
                this.indices.push(c);
            else {
                for (var d = 0; 4 > d; d++)
                    0 !== c.blendWeight.data[4 * b + d] && (a.boneIndices[d] = this.getBoneRemap(c.blendIndices.data[4 * a.index + d]));
                c = this.vertices.length;
                this.indices.push(c);
                this.vertices.push(a);
                this.indexMap[b] = c
            }
        },
        addPrimitive: function(a, b, c, d) {
            var e, f, g = [], k = 0, h = a.length;
            for (e = 0; e < h; e++)
                for (var l = a[e].index, n = 0; 4 > n; n++)
                    if (0 < c.blendWeight.data[4 * l + n]) {
                        var p = c.blendIndices.data[4 * l + n]
                          , q = !0;
                        for (f = 0; f < k; f++)
                            if (g[f] == p) {
                                q = !1;
                                break
                            }
                        q && (g[k] = p,
                        f = this.getBoneRemap(p),
                        k += -1 === f ? 1 : 0)
                    }
            if (this.boneIndices.length + k > d)
                return !1;
            for (e = 0; e < k; e++)
                this.boneIndices.push(g[e]);
            for (e = 0; e < h; e++)
                this.addVertex(a[e], b[e], c);
            return !0
        },
        getBoneRemap: function(a) {
            for (var b = 0; b < this.boneIndices.length; b++)
                if (this.boneIndices[b] === a)
                    return b;
            return -1
        }
    });
    var Bp = {
        points: 0,
        lines: 1,
        lineloop: 2,
        linestrip: 3,
        triangles: 4,
        trianglestrip: 5,
        trianglefan: 6
    }
      , Cp = {
        int8: 0,
        uint8: 1,
        int16: 2,
        uint16: 3,
        int32: 4,
        uint32: 5,
        float32: 6
    };
    Object.assign(Xk.prototype, {
        parse: function(a) {
            var b = a.model;
            if (!b || 1 >= b.version)
                return null;
            b = this._parseNodes(a);
            var c = this._parseSkins(a, b)
              , d = this._parseVertexBuffers(a)
              , e = this._parseIndexBuffers(a, d)
              , f = this._parseMorphs(a, b, d);
            d = this._parseMeshes(a, c.skins, f.morphs, d, e.buffer, e.data);
            a = this._parseMeshInstances(a, b, d, c.skins, c.instances, f.morphs, f.instances);
            d = new sb;
            d.graph = b[0];
            d.meshInstances = a;
            d.skinInstances = c.instances;
            d.morphInstances = f.instances;
            d.getGraph().syncHierarchy();
            return d
        },
        _parseNodes: function(a) {
            a = a.model;
            var b = [], c;
            for (c = 0; c < a.nodes.length; c++) {
                var d = a.nodes[c]
                  , e = new Z(d.name);
                e.setLocalPosition(d.position[0], d.position[1], d.position[2]);
                e.setLocalEulerAngles(d.rotation[0], d.rotation[1], d.rotation[2]);
                e.setLocalScale(d.scale[0], d.scale[1], d.scale[2]);
                e.scaleCompensation = !!d.scaleCompensation;
                b.push(e)
            }
            for (c = 1; c < a.parents.length; c++)
                b[a.parents[c]].addChild(b[c]);
            return b
        },
        _parseSkins: function(a, b) {
            a = a.model;
            var c = [], d = [], e;
            if (!this._device.supportsBoneTextures && 0 < a.skins.length) {
                var f = this._device.getBoneLimit();
                Wk(a, null, f)
            }
            for (f = 0; f < a.skins.length; f++) {
                var g = a.skins[f]
                  , k = [];
                for (e = 0; e < g.inverseBindMatrices.length; e++) {
                    var h = g.inverseBindMatrices[e];
                    k[e] = (new K).set(h)
                }
                g = new Hg(this._device,k,g.boneNames);
                c.push(g);
                k = new Hc(g);
                h = [];
                for (e = 0; e < g.boneNames.length; e++) {
                    var l = b[0].findByName(g.boneNames[e]);
                    h.push(l)
                }
                k.bones = h;
                d.push(k)
            }
            return {
                skins: c,
                instances: d
            }
        },
        _getMorphVertexCount: function(a, b, c) {
            for (var d = 0; d < a.meshes.length; d++) {
                var e = a.meshes[d];
                if (e.morph === b)
                    return c[e.vertices].numVertices
            }
        },
        _parseMorphs: function(a, b, c) {
            a = a.model;
            b = [];
            var d = [], e, f;
            if (a.morphs) {
                var g = function(t, u, x) {
                    x = new Float32Array(3 * x);
                    for (var v = 0; v < u.length; v++) {
                        var w = 3 * u[v];
                        x[w] = t[3 * v];
                        x[w + 1] = t[3 * v + 1];
                        x[w + 2] = t[3 * v + 2]
                    }
                    return x
                };
                for (e = 0; e < a.morphs.length; e++) {
                    var k = a.morphs[e].targets;
                    var h = [];
                    var l = this._getMorphVertexCount(a, e, c);
                    for (f = 0; f < k.length; f++) {
                        var n = k[f].aabb;
                        var p = n.min;
                        n = n.max;
                        p = new oa(new z(.5 * (n[0] + p[0]),.5 * (n[1] + p[1]),.5 * (n[2] + p[2])),new z(.5 * (n[0] - p[0]),.5 * (n[1] - p[1]),.5 * (n[2] - p[2])));
                        n = k[f].indices;
                        var q = k[f].deltaPositions
                          , r = k[f].deltaNormals;
                        n && (q = g(q, n, l),
                        r = g(r, n, l));
                        p = new tf({
                            deltaPositions: q,
                            deltaNormals: r,
                            name: k[f].name,
                            aabb: p
                        });
                        h.push(p)
                    }
                    f = new Db(h,this._device);
                    b.push(f);
                    f = new sf(f);
                    d.push(f)
                }
            }
            return {
                morphs: b,
                instances: d
            }
        },
        _parseVertexBuffers: function(a) {
            a = a.model;
            var b = [], c, d = {
                position: "POSITION",
                normal: "NORMAL",
                tangent: "TANGENT",
                blendWeight: "BLENDWEIGHT",
                blendIndices: "BLENDINDICES",
                color: "COLOR",
                texCoord0: "TEXCOORD0",
                texCoord1: "TEXCOORD1",
                texCoord2: "TEXCOORD2",
                texCoord3: "TEXCOORD3",
                texCoord4: "TEXCOORD4",
                texCoord5: "TEXCOORD5",
                texCoord6: "TEXCOORD6",
                texCoord7: "TEXCOORD7"
            }, e, f;
            for (e = 0; e < a.vertices.length; e++) {
                var g = a.vertices[e]
                  , k = [];
                for (c in g) {
                    var h = g[c];
                    k.push({
                        semantic: d[c],
                        components: h.components,
                        type: Cp[h.type],
                        normalize: "COLOR" === d[c]
                    })
                }
                h = new Na(this._device,k);
                k = g.position.data.length / g.position.components;
                var l = new ab(this._device,h,k)
                  , n = new Pb(l);
                for (f = 0; f < k; f++) {
                    for (c in g)
                        switch (h = g[c],
                        h.components) {
                        case 1:
                            n.element[d[c]].set(h.data[f]);
                            break;
                        case 2:
                            n.element[d[c]].set(h.data[2 * f], h.data[2 * f + 1]);
                            break;
                        case 3:
                            n.element[d[c]].set(h.data[3 * f], h.data[3 * f + 1], h.data[3 * f + 2]);
                            break;
                        case 4:
                            n.element[d[c]].set(h.data[4 * f], h.data[4 * f + 1], h.data[4 * f + 2], h.data[4 * f + 3])
                        }
                    n.next()
                }
                n.end();
                b.push(l)
            }
            return b
        },
        _parseIndexBuffers: function(a, b) {
            var c = a.model, d = a = null, e, f = 0;
            for (e = 0; e < c.meshes.length; e++) {
                var g = c.meshes[e];
                void 0 !== g.indices && (f += g.indices.length)
            }
            for (e = c = 0; e < b.length; e++)
                c = Math.max(c, b[e].numVertices);
            0 < f && (65535 < c && this._device.extUintElement ? (a = new dc(this._device,2,f),
            d = new Uint32Array(a.lock())) : (a = new dc(this._device,1,f),
            d = new Uint16Array(a.lock())));
            return {
                buffer: a,
                data: d
            }
        },
        _parseMeshes: function(a, b, c, d, e, f) {
            a = a.model;
            var g = [], k = 0, h;
            for (h = 0; h < a.meshes.length; h++) {
                var l = a.meshes[h]
                  , n = l.aabb
                  , p = n.min;
                n = n.max;
                p = new oa(new z(.5 * (n[0] + p[0]),.5 * (n[1] + p[1]),.5 * (n[2] + p[2])),new z(.5 * (n[0] - p[0]),.5 * (n[1] - p[1]),.5 * (n[2] - p[2])));
                n = void 0 !== l.indices;
                var q = new rb(this._device);
                q.vertexBuffer = d[l.vertices];
                q.indexBuffer[0] = n ? e : null;
                q.primitive[0].type = Bp[l.type];
                q.primitive[0].base = n ? l.base + k : l.base;
                q.primitive[0].count = l.count;
                q.primitive[0].indexed = n;
                q.skin = void 0 !== l.skin ? b[l.skin] : null;
                q.morph = void 0 !== l.morph ? c[l.morph] : null;
                q.aabb = p;
                n && (f.set(l.indices, k),
                k += l.indices.length);
                g.push(q)
            }
            null !== e && e.unlock();
            return g
        },
        _parseMeshInstances: function(a, b, c, d, e, f, g) {
            a = a.model;
            var k = [], h;
            for (h = 0; h < a.meshInstances.length; h++) {
                var l = a.meshInstances[h]
                  , n = c[l.mesh];
                l = new va(b[l.node],n,this._defaultMaterial);
                if (n.skin) {
                    var p = d.indexOf(n.skin);
                    l.skinInstance = e[p]
                }
                n.morph && (n = f.indexOf(n.morph),
                l.morphInstance = g[n]);
                k.push(l)
            }
            return k
        }
    });
    Object.assign(Li.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = {
                retry: this.retryRequests
            };
            a.load.startsWith("blob:") && (".glb" === ca.getExtension(a.original).toLowerCase() ? c.responseType = da.ResponseType.ARRAY_BUFFER : c.responseType = da.ResponseType.JSON);
            wa.get(a.load, c, function(d, e) {
                b && (d ? b("Error loading model: " + a.original + " [" + d + "]") : b(null, e))
            })
        },
        open: function(a, b) {
            for (var c = 0; c < this._parsers.length; c++) {
                var d = this._parsers[c];
                if (d.decider(a, b))
                    return d.parser.parse(b)
            }
            return null
        },
        patch: function(a, b) {
            if (a.resource) {
                var c = a.data
                  , d = this;
                a.resource.meshInstances.forEach(function(e, f) {
                    if (c.mapping) {
                        var g = function(l) {
                            l.resource ? e.material = l.resource : (l.once("load", g),
                            b.load(l));
                            l.once("remove", function(n) {
                                e.material === n.resource && (e.material = d._defaultMaterial)
                            })
                        };
                        if (c.mapping[f]) {
                            var k = c.mapping[f].material
                              , h = c.mapping[f].path;
                            if (void 0 !== k)
                                if (k)
                                    if (f = b.get(k))
                                        g(f);
                                    else
                                        b.once("add:" + k, g);
                                else
                                    e.material = d._defaultMaterial;
                            else if (h)
                                if (k = a.getAbsoluteUrl(c.mapping[f].path),
                                f = b.getByUrl(k))
                                    g(f);
                                else
                                    b.once("add:url:" + k, g)
                        } else
                            e.material = d._defaultMaterial
                    }
                })
            }
        },
        addParser: function(a, b) {
            this._parsers.push({
                parser: a,
                decider: b
            })
        }
    });
    Object.assign(Mi.prototype, {
        addHandler: function(a, b) {
            this._handlers[a] = b;
            b._loader = this
        },
        removeHandler: function(a) {
            delete this._handlers[a]
        },
        getHandler: function(a) {
            return this._handlers[a]
        },
        load: function(a, b, c, d) {
            var e = this._handlers[b];
            if (e)
                if (a) {
                    var f = a + b;
                    if (void 0 !== this._cache[f])
                        c(null, this._cache[f]);
                    else if (this._requests[f])
                        this._requests[f].push(c);
                    else {
                        this._requests[f] = [c];
                        var g = this
                          , k = function(l, n) {
                            l ? g._onFailure(f, l) : e.load(n, function(p, q, r) {
                                if (g._requests[f])
                                    if (p)
                                        g._onFailure(f, p);
                                    else
                                        try {
                                            g._onSuccess(f, e.open(n.original, q, d), r)
                                        } catch (t) {
                                            g._onFailure(f, t)
                                        }
                            }, d)
                        }
                          , h = a.split("?")[0];
                        this._app.enableBundles && this._app.bundles.hasUrl(h) ? this._app.bundles.canLoadUrl(h) ? this._app.bundles.loadUrl(h, function(l, n) {
                            k(l, {
                                load: n,
                                original: h
                            })
                        }) : k("Bundle for " + a + " not loaded yet") : k(null, {
                            load: a,
                            original: d && d.getPreferredFile().filename || a
                        })
                    }
                } else
                    this._loadNull(e, c, d);
            else
                c("No handler for asset type: " + b)
        },
        _loadNull: function(a, b, c) {
            a.load(null, function(d, e, f) {
                if (d)
                    b(d);
                else
                    try {
                        b(null, a.open(null, e, c), f)
                    } catch (g) {
                        b(g)
                    }
            }, c)
        },
        _onSuccess: function(a, b, c) {
            this._cache[a] = b;
            for (var d = 0; d < this._requests[a].length; d++)
                this._requests[a][d](null, b, c);
            delete this._requests[a]
        },
        _onFailure: function(a, b) {
            console.error(b);
            if (this._requests[a]) {
                for (var c = 0; c < this._requests[a].length; c++)
                    this._requests[a][c](b);
                delete this._requests[a]
            }
        },
        open: function(a, b) {
            var c = this._handlers[a];
            return c ? c.open(null, b) : (console.warn("No resource handler found for: " + a),
            b)
        },
        patch: function(a, b) {
            var c = this._handlers[a.type];
            c ? c.patch && c.patch(a, b) : console.warn("No resource handler found for: " + a.type)
        },
        clearCache: function(a, b) {
            delete this._cache[a + b]
        },
        getFromCache: function(a, b) {
            if (this._cache[a + b])
                return this._cache[a + b]
        },
        enableRetry: function() {
            for (var a in this._handlers)
                this._handlers[a].retryRequests = !0
        },
        disableRetry: function() {
            for (var a in this._handlers)
                this._handlers[a].retryRequests = !1
        },
        destroy: function() {
            this._handlers = {};
            this._requests = {};
            this._cache = {}
        }
    });
    Object.assign(Ni.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = this._app.assets;
            wa.get(a.load, {
                retry: this.retryRequests
            }, function(d, e) {
                d ? (e = "Error while loading scene " + a.original,
                d.message ? (e += ": " + d.message,
                d.stack && (e += "\n" + d.stack)) : e += ": " + d,
                b(e)) : Yc.waitForTemplatesInScene(e, c, b)
            })
        },
        open: function(a, b) {
            this._app.systems.script.preloading = !0;
            a = (new Ng(this._app,!1)).parse(b);
            var c = this._app.scene;
            c.root = a;
            this._app.applySceneSettings(b.settings);
            this._app.systems.script.preloading = !1;
            return c
        },
        patch: function(a, b) {}
    });
    Object.assign(Oi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            wa.get(a.load, {
                retry: this.retryRequests
            }, function(c, d) {
                c ? (d = "Error while loading scene settings " + a.original,
                c.message ? (d += ": " + c.message,
                c.stack && (d += "\n" + c.stack)) : d += ": " + c,
                b(d)) : b(null, d)
            })
        },
        open: function(a, b) {
            return b.settings
        }
    });
    var fk = !1
      , Fm = !1
      , ub = {
        app: null,
        create: function(a, b) {
            if (fk) {
                var c = b(ub.app);
                c._pcScriptName = a;
                tb._push(c);
                this.fire("created", a, b)
            }
        },
        attribute: function(a, b, c, d) {},
        createLoadingScreen: function(a) {
            if (!Fm) {
                Fm = !0;
                var b = ea.getApplication();
                a(b)
            }
        }
    };
    Object.defineProperty(ub, "legacy", {
        get: function() {
            return fk
        },
        set: function(a) {
            fk = a
        }
    });
    Of.attach(ub);
    tb._types = [];
    tb._push = function(a) {
        ub.legacy && 0 < tb._types.length ? console.assert("Script Ordering Error. Contact support@playcanvas.com") : tb._types.push(a)
    }
    ;
    Object.assign(tb.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = this;
            ub.app = this._app;
            this._loadScript(a.load, function(d, e, f) {
                if (d)
                    b(d);
                else if (ub.legacy)
                    d = null,
                    tb._types.length && (d = tb._types.pop()),
                    d ? this._scripts[e] = d : d = null,
                    b(null, d, f);
                else {
                    d = {};
                    for (var g = 0; g < tb._types.length; g++)
                        d[tb._types[g].name] = tb._types[g];
                    tb._types.length = 0;
                    b(null, d, f);
                    delete c._loader._cache[e + "script"]
                }
            }
            .bind(this))
        },
        open: function(a, b) {
            return b
        },
        patch: function(a, b) {},
        _loadScript: function(a, b) {
            var c = document.head
              , d = document.createElement("script");
            this._cache[a] = d;
            d.async = !1;
            d.addEventListener("error", function(f) {
                b("Script: " + f.target.src + " failed to load")
            }, !1);
            var e = !1;
            d.onload = d.onreadystatechange = function() {
                e || this.readyState && "loaded" != this.readyState && "complete" != this.readyState || (e = !0,
                b(null, a, d))
            }
            ;
            d.src = a;
            c.appendChild(d)
        }
    });
    Object.assign(Pi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            wa.get(a.load, {
                retry: this.retryRequests
            }, function(c, d) {
                c ? b("Error loading shader resource: " + a.original + " [" + c + "]") : b(null, d)
            })
        },
        open: function(a, b) {
            return b
        },
        patch: function(a, b) {}
    });
    var Dp = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]
      , Ep = [0, 1, 3, 2, 3, 1];
    Sa.prototype = Object.create(M.prototype);
    Sa.prototype.constructor = Sa;
    Sa.prototype._createMeshes = function() {
        var a;
        var b = 0;
        for (a = this._meshes.length; b < a; b++) {
            var c = this._meshes[b];
            if (c) {
                c.vertexBuffer.destroy();
                for (var d = 0, e = c.indexBuffer.length; d < e; d++)
                    c.indexBuffer[d].destroy()
            }
        }
        a = this._frameKeys.length;
        this._meshes = Array(a);
        c = 1 === this.renderMode || 2 === this._renderMode ? this._create9SliceMesh : this._createSimpleMesh;
        for (b = 0; b < a; b++)
            d = this._atlas.frames[this._frameKeys[b]],
            this._meshes[b] = d ? c.call(this, d) : null;
        this.fire("set:meshes")
    }
    ;
    Sa.prototype._createSimpleMesh = function(a) {
        var b = a.rect
          , c = this._atlas.texture.width
          , d = this._atlas.texture.height
          , e = b.z / this._pixelsPerUnit
          , f = b.w / this._pixelsPerUnit
          , g = a.pivot.x;
        a = a.pivot.y;
        var k = b.x / c
          , h = b.y / d;
        c = (b.x + b.z) / c;
        b = (b.y + b.w) / d;
        return Qb(this._device, [-g * e, -a * f, 0, (1 - g) * e, -a * f, 0, (1 - g) * e, (1 - a) * f, 0, -g * e, (1 - a) * f, 0], {
            uvs: [k, h, c, h, c, b, k, b],
            normals: Dp,
            indices: Ep
        })
    }
    ;
    Sa.prototype._create9SliceMesh = function() {
        var a = P.ONE, b, c, d = [], e = [], f = [], g = [], k = 0;
        for (b = 0; 3 >= b; b++) {
            var h = 0 === b || 3 === b ? 0 : 1;
            for (c = 0; 3 >= c; c++) {
                var l = -a.x + 2 * a.x * (1 >= b ? 0 : 3) / 3;
                var n = -(-a.y + 2 * a.y * (1 >= c ? 0 : 3) / 3);
                var p = 0 === c || 3 === c ? 0 : 1;
                d.push(-l, 0, n);
                e.push(0, 1, 0);
                f.push(h, p);
                3 > b && 3 > c && (g.push(k + 3 + 1, k + 1, k),
                g.push(k + 3 + 1, k + 3 + 2, k + 1));
                k++
            }
        }
        return Qb(this._device, d, {
            normals: e,
            uvs: f,
            indices: g
        })
    }
    ;
    Sa.prototype._onSetFrames = function(a) {
        this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes()
    }
    ;
    Sa.prototype._onFrameChanged = function(a, b) {
        a = this._frameKeys.indexOf(a);
        0 > a || (b ? 0 === this.renderMode && (this._meshes[a] = this._createSimpleMesh(b)) : this._meshes[a] = null,
        this.fire("set:meshes"))
    }
    ;
    Sa.prototype._onFrameRemoved = function(a) {
        a = this._frameKeys.indexOf(a);
        0 > a || (this._meshes[a] = null,
        this.fire("set:meshes"))
    }
    ;
    Sa.prototype.startUpdate = function() {
        this._updatingProperties = !0;
        this._meshesDirty = !1
    }
    ;
    Sa.prototype.endUpdate = function() {
        this._updatingProperties = !1;
        this._meshesDirty && this._atlas && this._frameKeys && this._createMeshes();
        this._meshesDirty = !1
    }
    ;
    Sa.prototype.destroy = function() {
        var a;
        var b = 0;
        for (a = this._meshes.length; b < a; b++) {
            var c = this._meshes[b];
            if (c) {
                c.vertexBuffer.destroy();
                for (var d = 0, e = c.indexBuffer.length; d < e; d++)
                    c.indexBuffer[d].destroy()
            }
        }
        this._meshes.length = 0
    }
    ;
    Object.defineProperty(Sa.prototype, "frameKeys", {
        get: function() {
            return this._frameKeys
        },
        set: function(a) {
            this._frameKeys = a;
            this._atlas && this._frameKeys && (this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes());
            this.fire("set:frameKeys", a)
        }
    });
    Object.defineProperty(Sa.prototype, "atlas", {
        get: function() {
            return this._atlas
        },
        set: function(a) {
            a !== this._atlas && (this._atlas && (this._atlas.off("set:frames", this._onSetFrames, this),
            this._atlas.off("set:frame", this._onFrameChanged, this),
            this._atlas.off("remove:frame", this._onFrameRemoved, this)),
            (this._atlas = a) && this._frameKeys && (this._atlas.on("set:frames", this._onSetFrames, this),
            this._atlas.on("set:frame", this._onFrameChanged, this),
            this._atlas.on("remove:frame", this._onFrameRemoved, this),
            this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes()),
            this.fire("set:atlas", a))
        }
    });
    Object.defineProperty(Sa.prototype, "pixelsPerUnit", {
        get: function() {
            return this._pixelsPerUnit
        },
        set: function(a) {
            this._pixelsPerUnit !== a && (this._pixelsPerUnit = a,
            this.fire("set:pixelsPerUnit", a),
            this._atlas && this._frameKeys && 0 === this.renderMode && (this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes()))
        }
    });
    Object.defineProperty(Sa.prototype, "renderMode", {
        get: function() {
            return this._renderMode
        },
        set: function(a) {
            if (this._renderMode !== a) {
                var b = this._renderMode;
                this._renderMode = a;
                this.fire("set:renderMode", a);
                (0 === b || 0 === a) && this._atlas && this._frameKeys && (this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes())
            }
        }
    });
    Object.defineProperty(Sa.prototype, "meshes", {
        get: function() {
            return this._meshes
        }
    });
    Object.assign(Qi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            ".json" === ca.getExtension(a.original) && wa.get(a.load, {
                retry: this.retryRequests
            }, function(c, d) {
                c ? b(c) : b(null, d)
            })
        },
        open: function(a, b) {
            var c = new Sa(this._device);
            a && (c.__data = b);
            return c
        },
        patch: function(a, b) {
            var c = a.resource;
            c.__data && (a.data.pixelsPerUnit = c.__data.pixelsPerUnit,
            a.data.renderMode = c.__data.renderMode,
            a.data.frameKeys = c.__data.frameKeys,
            c.__data.textureAtlasAsset && ((b = b.getByUrl(c.__data.textureAtlasAsset)) ? a.data.textureAtlasAsset = b.id : console.warn("Could not find textureatlas with url: " + c.__data.textureAtlasAsset)));
            c.startUpdate();
            c.renderMode = a.data.renderMode;
            c.pixelsPerUnit = a.data.pixelsPerUnit;
            c.frameKeys = a.data.frameKeys;
            this._updateAtlas(a);
            c.endUpdate();
            a.off("change", this._onAssetChange, this);
            a.on("change", this._onAssetChange, this)
        },
        _updateAtlas: function(a) {
            var b = a.resource;
            if (a.data.textureAtlasAsset) {
                this._assets.off("load:" + a.data.textureAtlasAsset, Ri, a);
                this._assets.on("load:" + a.data.textureAtlasAsset, Ri, a);
                var c = this._assets.get(a.data.textureAtlasAsset);
                c && c.resource ? b.atlas = c.resource : c ? this._assets.load(c) : (this._assets.off("add:" + a.data.textureAtlasAsset, Si, a),
                this._assets.on("add:" + a.data.textureAtlasAsset, Si, a))
            } else
                b.atlas = null
        },
        _onAssetChange: function(a, b, c, d) {
            "data" === b && c && c.textureAtlasAsset && d && c.textureAtlasAsset !== d.textureAtlasAsset && (this._assets.off("load:" + d.textureAtlasAsset, Ri, a),
            this._assets.off("add:" + d.textureAtlasAsset, Si, a))
        }
    });
    Og.prototype.instantiate = function() {
        this._templateRoot || this._parseTemplate();
        return this._templateRoot.clone()
    }
    ;
    Og.prototype._parseTemplate = function() {
        this._templateRoot = (new Ng(this._app,!0)).parse(this._data)
    }
    ;
    Object.assign(Ti.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = this._app.assets;
            wa.get(a.load, function(d, e) {
                d ? b("Error requesting template: " + a.original) : Yc.waitForTemplateAssets(e.entities, c, b, e)
            })
        },
        open: function(a, b) {
            return new Og(this._app,b)
        }
    });
    Object.assign(Ui.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            wa.get(a.load, {
                retry: this.retryRequests
            }, function(c, d) {
                c ? b("Error loading text resource: " + a.original + " [" + c + "]") : b(null, d)
            })
        },
        open: function(a, b) {
            return b
        },
        patch: function(a, b) {}
    });
    xc.prototype = Object.create(M.prototype);
    xc.prototype.constructor = xc;
    xc.prototype.setFrame = function(a, b) {
        var c = this._frames[a];
        c ? (c.rect.copy(b.rect),
        c.pivot.copy(b.pivot),
        c.border.copy(b.border)) : (c = {
            rect: b.rect.clone(),
            pivot: b.pivot.clone(),
            border: b.border.clone()
        },
        this._frames[a] = c);
        this.fire("set:frame", a.toString(), c)
    }
    ;
    xc.prototype.removeFrame = function(a) {
        var b = this._frames[a];
        b && (delete this._frames[a],
        this.fire("remove:frame", a.toString(), b))
    }
    ;
    xc.prototype.destroy = function() {
        this._texture && this._texture.destroy()
    }
    ;
    Object.defineProperty(xc.prototype, "texture", {
        get: function() {
            return this._texture
        },
        set: function(a) {
            this._texture = a;
            this.fire("set:texture", a)
        }
    });
    Object.defineProperty(xc.prototype, "frames", {
        get: function() {
            return this._frames
        },
        set: function(a) {
            this._frames = a;
            this.fire("set:frames", a)
        }
    });
    var Fh = {
        repeat: 0,
        clamp: 1,
        mirror: 2
    }
      , Gh = {
        nearest: 0,
        linear: 1,
        nearest_mip_nearest: 2,
        linear_mip_nearest: 4,
        nearest_mip_linear: 3,
        linear_mip_linear: 5
    }
      , Fp = /^data\.frames\.(\d+)$/;
    Object.assign(Vi.prototype, {
        load: function(a, b) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            var c = this
              , d = this._loader.getHandler("texture");
            if (".json" === ca.getExtension(a.original))
                wa.get(a.load, {
                    retry: this.retryRequests
                }, function(e, f) {
                    e ? b(e) : (e = a.original.replace(".json", ".png"),
                    c._loader.load(e, "texture", function(g, k) {
                        g ? b(g) : b(null, {
                            data: f,
                            texture: k
                        })
                    }))
                });
            else
                return d.load(a, b)
        },
        open: function(a, b) {
            var c = new xc;
            if (b.texture && b.data)
                c.texture = b.texture,
                c.__data = b.data;
            else {
                a = this._loader.getHandler("texture").open(a, b);
                if (!a)
                    return null;
                c.texture = a
            }
            return c
        },
        patch: function(a, b) {
            a.resource.__data && (void 0 !== a.resource.__data.minfilter && (a.data.minfilter = a.resource.__data.minfilter),
            void 0 !== a.resource.__data.magfilter && (a.data.magfilter = a.resource.__data.magfilter),
            void 0 !== a.resource.__data.addressu && (a.data.addressu = a.resource.__data.addressu),
            void 0 !== a.resource.__data.addressv && (a.data.addressv = a.resource.__data.addressv),
            void 0 !== a.resource.__data.mipmaps && (a.data.mipmaps = a.resource.__data.mipmaps),
            void 0 !== a.resource.__data.anisotropy && (a.data.anisotropy = a.resource.__data.anisotropy),
            void 0 !== a.resource.__data.rgbm && (a.data.rgbm = !!a.resource.__data.rgbm),
            a.data.frames = a.resource.__data.frames,
            delete a.resource.__data);
            if (b = a.resource.texture)
                if (b.name = a.name,
                a.data.hasOwnProperty("minfilter") && b.minFilter !== Gh[a.data.minfilter] && (b.minFilter = Gh[a.data.minfilter]),
                a.data.hasOwnProperty("magfilter") && b.magFilter !== Gh[a.data.magfilter] && (b.magFilter = Gh[a.data.magfilter]),
                a.data.hasOwnProperty("addressu") && b.addressU !== Fh[a.data.addressu] && (b.addressU = Fh[a.data.addressu]),
                a.data.hasOwnProperty("addressv") && b.addressV !== Fh[a.data.addressv] && (b.addressV = Fh[a.data.addressv]),
                a.data.hasOwnProperty("mipmaps") && b.mipmaps !== a.data.mipmaps && (b.mipmaps = a.data.mipmaps),
                a.data.hasOwnProperty("anisotropy") && b.anisotropy !== a.data.anisotropy && (b.anisotropy = a.data.anisotropy),
                a.data.hasOwnProperty("rgbm")) {
                    var c = a.data.rgbm ? "rgbm" : "default";
                    b.type !== c && (b.type = c)
                }
            a.resource.texture = b;
            b = {};
            for (var d in a.data.frames)
                c = a.data.frames[d],
                b[d] = {
                    rect: new X(c.rect),
                    pivot: new P(c.pivot),
                    border: new X(c.border)
                };
            a.resource.frames = b;
            a.off("change", this._onAssetChange, this);
            a.on("change", this._onAssetChange, this)
        },
        _onAssetChange: function(a, b, c) {
            if ("data" === b || "data.frames" === b) {
                var d = {};
                for (e in c.frames)
                    b = c.frames[e],
                    d[e] = {
                        rect: new X(b.rect),
                        pivot: new P(b.pivot),
                        border: new X(b.border)
                    };
                a.resource.frames = d
            } else if (b = b.match(Fp)) {
                var e = b[1];
                c ? (a.resource.frames[e] ? (b = a.resource.frames[e],
                b.rect.set(c.rect[0], c.rect[1], c.rect[2], c.rect[3]),
                b.pivot.set(c.pivot[0], c.pivot[1]),
                b.border.set(c.border[0], c.border[1], c.border[2], c.border[3])) : a.resource.frames[e] = {
                    rect: new X(c.rect),
                    pivot: new P(c.pivot),
                    border: new X(c.border)
                },
                a.resource.fire("set:frame", e, a.resource.frames[e])) : a.resource.frames[e] && (delete a.resource.frames[e],
                a.resource.fire("remove:frame", e))
            }
        }
    });
    var Xn = function() {
        try {
            if ("object" === typeof WebAssembly && "function" === typeof WebAssembly.instantiate) {
                var a = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0));
                if (a instanceof WebAssembly.Module)
                    return new WebAssembly.Instance(a)instanceof WebAssembly.Instance
            }
        } catch (b) {}
        return !1
    }()
      , aj = !1
      , Ef = null
      , Df = {}
      , Xi = null
      , Zi = []
      , Ff = null;
    Object.assign(bj.prototype, {
        load: function(a, b, c) {
            wa.get(a.load, {
                cache: !0,
                responseType: "arraybuffer",
                retry: this.retryRequests
            }, function(d, e) {
                if (d)
                    b(d, e);
                else {
                    if (d = "pvr" === Wi() && c && c.file && c.file.variants && c.file.variants.basis && 0 !== (c.file.variants.basis.opt & 8))
                        c.file.variants.basis.opt &= -9;
                    $k(a.load, e, b, {
                        unswizzleGGGR: d
                    })
                }
            })
        },
        open: function(a, b, c) {
            a = new V(c,{
                name: a,
                addressU: b.cubemap ? 1 : 0,
                addressV: b.cubemap ? 1 : 0,
                width: b.width,
                height: b.height,
                format: b.format,
                cubemap: b.cubemap,
                levels: b.levels
            });
            a.upload();
            return a
        }
    });
    Object.assign(cj.prototype, {
        load: function(a, b, c) {
            if (c && c.options && c.options.hasOwnProperty("crossOrigin"))
                var d = c.options.crossOrigin;
            else
                ff.test(a.load) && (d = this.crossOrigin);
            this.useImageBitmap ? this._loadImageBitmap(a.load, a.original, d, b) : this._loadImage(a.load, a.original, d, b)
        },
        open: function(a, b, c) {
            var d = ca.getExtension(a).toLowerCase();
            a = new V(c,{
                name: a,
                width: b.width,
                height: b.height,
                format: ".jpg" === d || ".jpeg" === d ? 6 : 7
            });
            a.setSource(b);
            return a
        },
        _loadImage: function(a, b, c, d) {
            var e = new Image;
            c && (e.crossOrigin = c);
            var f = 0, g, k = this.retryRequests;
            e.onload = function() {
                d(null, e)
            }
            ;
            e.onerror = function() {
                if (!g)
                    if (k && 5 >= ++f) {
                        var h = 100 * Math.pow(2, f);
                        console.log("Error loading Texture from: '" + b + "' - Retrying in " + h + "ms...");
                        var l = 0 <= a.indexOf("?") ? "&" : "?";
                        g = setTimeout(function() {
                            e.src = a + l + "retry=" + Date.now();
                            g = null
                        }, h)
                    } else
                        d("Error loading Texture from: '" + b + "'")
            }
            ;
            e.src = a
        },
        _loadImageBitmap: function(a, b, c, d) {
            wa.get(a, {
                cache: !0,
                responseType: "blob",
                retry: this.retryRequests
            }, function(e, f) {
                e ? d(e) : createImageBitmap(f, {
                    premultiplyAlpha: "none",
                    imageOrientation: "flipY"
                }).then(function(g) {
                    d(null, g)
                }).catch(function(g) {
                    d(g)
                })
            })
        }
    });
    var gk = [1481919403, 3140563232, 169478669]
      , Gm = {
        33776: 8,
        33778: 9,
        33779: 10,
        36196: 21,
        37492: 22,
        37496: 23,
        35840: 26,
        35841: 24,
        35842: 27,
        35843: 25
    };
    Object.assign(dj.prototype, {
        load: function(a, b, c) {
            wa.get(a.load, {
                cache: !0,
                responseType: "arraybuffer",
                retry: this.retryRequests
            }, b)
        },
        open: function(a, b, c) {
            b = this.parse(b);
            if (!b)
                return null;
            a = new V(c,{
                name: a,
                addressU: b.cubemap ? 1 : 0,
                addressV: b.cubemap ? 1 : 0,
                width: b.width,
                height: b.height,
                format: b.format,
                cubemap: b.cubemap,
                levels: b.levels
            });
            a.upload();
            return a
        },
        parse: function(a) {
            var b = new Uint32Array(a,0,16);
            if (gk[0] !== b[0] || gk[1] !== b[1] || gk[2] !== b[2])
                return null;
            var c = b[6]
              , d = b[7]
              , e = b[9]
              , f = b[10]
              , g = b[12]
              , k = b[13]
              , h = b[14];
            if (1 < b[11] || 1 < g || 0 !== c || !Gm[d])
                return null;
            b = 64 + b[15];
            c = [];
            g = !1;
            for (var l = 0; l < (h || 1); l++) {
                var n = (new Uint32Array(a.slice(b, b + 4)))[0];
                b += 4;
                n /= k || 1;
                1 < k && (g = !0,
                c.push([]));
                for (var p = 0; p < k; p++) {
                    var q = new Uint8Array(a,b,n);
                    1 < k ? c[l].push(q) : c.push(q);
                    b += n
                }
                b += 3 - (b + 3) % 4
            }
            return {
                format: Gm[d],
                width: e,
                height: f,
                levels: c,
                cubemap: g
            }
        }
    });
    Object.assign(ej.prototype, {
        load: function(a, b, c) {
            wa.get(a.load, {
                cache: !0,
                responseType: "arraybuffer",
                retry: this.retryRequests
            }, b)
        },
        open: function(a, b, c) {
            var d = new Uint32Array(b,0,32)
              , e = d[4]
              , f = d[3]
              , g = Math.max(d[7], 1)
              , k = d[21]
              , h = d[22]
              , l = 65024 === d[28]
              , n = !1
              , p = !1
              , q = !1
              , r = !1
              , t = !1
              , u = null;
            if (4 === d[20])
                if (827611204 === k)
                    u = 8,
                    n = !0;
                else if (894720068 === k)
                    u = 10,
                    n = !0;
                else if (116 === k)
                    u = 14,
                    p = !0;
                else if (826496069 === k)
                    u = 21,
                    q = n = !0;
                else if (825438800 === k || 825504336 === k)
                    u = 825438800 === k ? 24 : 25,
                    r = n = !0;
                else {
                    if (825439312 === k || 825504848 === k)
                        u = 825439312 === k ? 26 : 27,
                        t = n = !0
                }
            else
                32 === h && (u = 7);
            if (!u)
                return a = new V(c,{
                    width: 4,
                    height: 4,
                    format: 6
                }),
                a.name = "dds-legacy-empty",
                a;
            a = new V(c,{
                name: a,
                addressU: l ? 1 : 0,
                addressV: l ? 1 : 0,
                width: e,
                height: f,
                format: u,
                cubemap: l
            });
            c = 128;
            d = l ? 6 : 1;
            k = 827611204 === k ? 8 : 16;
            for (h = 0; h < d; h++) {
                u = e;
                for (var x = f, v = 0; v < g; v++) {
                    if (n)
                        if (q)
                            var w = Math.floor((u + 3) / 4) * Math.floor((x + 3) / 4) * 8;
                        else if (r)
                            w = Math.max(u, 16) * Math.max(x, 8) / 4;
                        else if (t)
                            w = Math.max(u, 8) * Math.max(x, 8) / 2;
                        else {
                            w = Math.floor((u + 4 - 1) / 4);
                            var y = Math.floor((x + 4 - 1) / 4);
                            w *= y;
                            w *= k
                        }
                    else
                        w = u * x * 4;
                    y = p ? new Float32Array(b,c,w) : new Uint8Array(b,c,w);
                    l ? (a._levels[v] || (a._levels[v] = []),
                    a._levels[v][h] = y) : a._levels[v] = y;
                    c += p ? 4 * w : w;
                    u = Math.max(.5 * u, 1);
                    x = Math.max(.5 * x, 1)
                }
            }
            a.upload();
            return a
        }
    });
    var Hm = {
        repeat: 0,
        clamp: 1,
        mirror: 2
    }
      , Im = {
        nearest: 0,
        linear: 1,
        nearest_mip_nearest: 2,
        linear_mip_nearest: 4,
        nearest_mip_linear: 3,
        linear_mip_linear: 5
    }
      , Gp = {
        "default": "default",
        rgbm: "rgbm",
        rgbe: "rgbe",
        swizzleGGGR: "swizzleGGGR"
    };
    Object.assign(al.prototype, {
        load: function(a, b, c) {
            throw Error("not implemented");
        },
        open: function(a, b, c) {
            throw Error("not implemented");
        }
    });
    var Hp = function(a) {
        var b = Math.log2(Math.max(a._width, a._height)) + 1
          , c = function(h) {
            return h instanceof HTMLCanvasElement || h instanceof HTMLImageElement || h instanceof HTMLVideoElement
        };
        if (!(7 !== a._format && 14 !== a._format || a._volume || a._compressed || 1 === a._levels.length || a._levels.length === b || c(a._cubemap ? a._levels[0][0] : a._levels[0]))) {
            c = function(h, l, n) {
                var p = Math.max(1, h >> 1)
                  , q = Math.max(1, l >> 1)
                  , r = new n.constructor(p * q * 4)
                  , t = Math.floor(h / p);
                l = Math.floor(l / q);
                for (var u = t * l, x = 0; x < q; ++x)
                    for (var v = 0; v < p; ++v)
                        for (var w = 0; 4 > w; ++w) {
                            for (var y = 0, A = 0; A < l; ++A)
                                for (var B = 0; B < t; ++B)
                                    y += n[4 * (v * t + B + (x * l + A) * h) + w];
                            r[4 * (v + x * p) + w] = y / u
                        }
                return r
            }
            ;
            for (var d = a._levels.length; d < b; ++d) {
                var e = Math.max(1, a._width >> d - 1)
                  , f = Math.max(1, a._height >> d - 1);
                if (a._cubemap) {
                    for (var g = [], k = 0; 6 > k; ++k)
                        g.push(c(e, f, a._levels[d - 1][k]));
                    a._levels.push(g)
                } else
                    a._levels.push(c(e, f, a._levels[d - 1]))
            }
            a._levelsUpdated = a._cubemap ? [[!0, !0, !0, !0, !0, !0]] : [!0]
        }
    };
    Object.defineProperties(Pg.prototype, {
        crossOrigin: {
            get: function() {
                return this.imgParser.crossOrigin
            },
            set: function(a) {
                this.imgParser.crossOrigin = a
            }
        },
        retryRequests: {
            get: function() {
                return this.imgParser.retryRequests
            },
            set: function(a) {
                this.imgParser.retryRequests = a;
                for (var b in this.parsers)
                    this.parsers.hasOwnProperty(b) && (this.parsers[b].retryRequests = a)
            }
        }
    });
    Object.assign(Pg.prototype, {
        _getUrlWithoutParams: function(a) {
            return 0 <= a.indexOf("?") ? a.split("?")[0] : a
        },
        _getParser: function(a) {
            a = ca.getExtension(this._getUrlWithoutParams(a)).toLowerCase().replace(".", "");
            return this.parsers[a] || this.imgParser
        },
        load: function(a, b, c) {
            "string" === typeof a && (a = {
                load: a,
                original: a
            });
            this._getParser(a.original).load(a, b, c)
        },
        open: function(a, b, c) {
            if (a)
                return a = this._getParser(a).open(a, b, this._device),
                null === a ? a = new V(this._device,{
                    width: 4,
                    height: 4,
                    format: 6
                }) : Hp(a),
                a
        },
        patch: function(a, b) {
            if (b = a.resource) {
                a.name && 0 < a.name.length && (b.name = a.name);
                var c = a.data;
                c.hasOwnProperty("minfilter") && (b.minFilter = Im[c.minfilter]);
                c.hasOwnProperty("magfilter") && (b.magFilter = Im[c.magfilter]);
                b.cubemap || (c.hasOwnProperty("addressu") && (b.addressU = Hm[c.addressu]),
                c.hasOwnProperty("addressv") && (b.addressV = Hm[c.addressv]));
                c.hasOwnProperty("mipmaps") && (b.mipmaps = c.mipmaps);
                c.hasOwnProperty("anisotropy") && (b.anisotropy = c.anisotropy);
                c.hasOwnProperty("flipY") && (b.flipY = !!c.flipY);
                c.hasOwnProperty("type") ? b.type = Gp[c.type] : c.hasOwnProperty("rgbm") && c.rgbm ? b.type = "rgbm" : a.file && a.getPreferredFile && (a = a.getPreferredFile()) && a.opt && 0 !== (a.opt & 8) && (b.type = "swizzleGGGR")
            }
        }
    });
    Ld.prototype = Object.create(M.prototype);
    Ld.prototype.constructor = Ld;
    Object.assign(Ld.prototype, {
        list: function(a) {
            a = a || {};
            return this._assets.filter(function(b) {
                var c = !0;
                void 0 !== a.preload && (c = b.preload === a.preload);
                return c
            })
        },
        add: function(a) {
            var b = this._assets.push(a) - 1;
            this._cache[a.id] = b;
            this._names[a.name] || (this._names[a.name] = []);
            this._names[a.name].push(b);
            if (a.file) {
                var c = a.file.url;
                this._urls[c] = b
            }
            a.registry = this;
            this._tags.addItem(a);
            a.tags.on("add", this._onTagAdd, this);
            a.tags.on("remove", this._onTagRemove, this);
            this.fire("add", a);
            this.fire("add:" + a.id, a);
            c && this.fire("add:url:" + c, a);
            a.preload && this.load(a)
        },
        remove: function(a) {
            var b = this._cache[a.id]
              , c = a.file ? a.file.url : null;
            if (void 0 !== b) {
                this._assets.splice(b, 1);
                delete this._cache[a.id];
                this._names = {};
                this._urls = [];
                b = 0;
                for (var d = this._assets.length; b < d; b++) {
                    var e = this._assets[b];
                    this._cache[e.id] = b;
                    this._names[e.name] || (this._names[e.name] = []);
                    this._names[e.name].push(b);
                    e.file && (this._urls[e.file.url] = b)
                }
                this._tags.removeItem(a);
                a.tags.off("add", this._onTagAdd, this);
                a.tags.off("remove", this._onTagRemove, this);
                a.fire("remove", a);
                this.fire("remove", a);
                this.fire("remove:" + a.id, a);
                c && this.fire("remove:url:" + c, a);
                return !0
            }
            return !1
        },
        get: function(a) {
            return this._assets[this._cache[a]]
        },
        getByUrl: function(a) {
            return this._assets[this._urls[a]]
        },
        load: function(a) {
            if (!a.loading && !a.loaded) {
                var b = this
                  , c = a.getPreferredFile()
                  , d = function(f) {
                    f instanceof Array ? a.resources = f : a.resource = f;
                    b._loader.patch(a, b);
                    b.fire("load", a);
                    b.fire("load:" + a.id, a);
                    c && c.url && b.fire("load:url:" + c.url, a);
                    a.fire("load", a)
                }
                  , e = function(f, g, k) {
                    a.loaded = !0;
                    a.loading = !1;
                    f ? (b.fire("error", f, a),
                    b.fire("error:" + a.id, f, a),
                    a.fire("error", f, a)) : (ub.legacy || "script" !== a.type || (f = b._loader.getHandler("script"),
                    f._cache[a.id] && f._cache[a.id].parentNode === document.head && document.head.removeChild(f._cache[a.id]),
                    f._cache[a.id] = k),
                    d(g))
                };
                c || "cubemap" === a.type ? (this.fire("load:start", a),
                this.fire("load:" + a.id + ":start", a),
                a.loading = !0,
                b._loader.load(a.getFileUrl(), a.type, e, a)) : (e = b._loader.open(a.type, a.data),
                a.loaded = !0,
                d(e))
            }
        },
        loadFromUrl: function(a, b, c) {
            this.loadFromUrlAndFilename(a, null, b, c)
        },
        loadFromUrlAndFilename: function(a, b, c, d) {
            var e = this
              , f = ca.getBasename(b || a);
            b = {
                filename: b || f,
                url: a
            };
            a = e.getByUrl(a);
            a || (a = new aa(f,c,b),
            e.add(a));
            f = function(g) {
                g.once("load", function(k) {
                    "material" === c ? e._loadTextures(k, function(h, l) {
                        d(h, k)
                    }) : d(null, k)
                });
                g.once("error", function(k) {
                    d(k)
                });
                e.load(g)
            }
            ;
            a.resource ? d(null, a) : "model" === c ? e._loadModel(a, f) : f(a)
        },
        _loadModel: function(a, b) {
            var c = this
              , d = a.getFileUrl()
              , e = ca.getExtension(d);
            if (".json" === e || ".glb" === e) {
                var f = ca.getDirectory(d);
                d = ca.getBasename(d);
                e = ca.join(f, d.replace(e, ".mapping.json"));
                this._loader.load(e, "json", function(g, k) {
                    g ? (a.data = {
                        mapping: []
                    },
                    b(a)) : c._loadMaterials(a, k, function(h, l) {
                        a.data = k;
                        b(a)
                    })
                })
            } else
                b(a)
        },
        _loadMaterials: function(a, b, c) {
            for (var d = this, e = [], f = 0, g = function(l, n) {
                d._loadTextures(n, function(p, q) {
                    e.push(n);
                    e.length === f && c(null, e)
                })
            }, k = 0; k < b.mapping.length; k++) {
                var h = b.mapping[k].path;
                h && (f++,
                d.loadFromUrl(a.getAbsoluteUrl(h), "material", g))
            }
            0 === f && c(null, e)
        },
        _loadTextures: function(a, b) {
            var c = []
              , d = 0
              , e = a.data;
            if ("path" !== e.mappingFormat)
                b(null, c);
            else {
                for (var f = function(h, l) {
                    h && console.error(h);
                    c.push(l);
                    c.length === d && b(null, c)
                }, g = 0; g < kf.length; g++) {
                    var k = e[kf[g]];
                    k && "string" === typeof k && (d++,
                    this.loadFromUrl(a.getAbsoluteUrl(k), "texture", f))
                }
                0 === d && b(null, c)
            }
        },
        findAll: function(a, b) {
            var c = this;
            return (a = this._names[a]) ? (a = a.map(function(d) {
                return c._assets[d]
            }),
            b ? a.filter(function(d) {
                return d.type === b
            }) : a) : []
        },
        _onTagAdd: function(a, b) {
            this._tags.add(a, b)
        },
        _onTagRemove: function(a, b) {
            this._tags.remove(a, b)
        },
        findByTag: function() {
            return this._tags.find(arguments)
        },
        filter: function(a) {
            for (var b = [], c = 0, d = this._assets.length; c < d; c++)
                a(this._assets[c]) && b.push(this._assets[c]);
            return b
        },
        find: function(a, b) {
            return (a = this.findAll(a, b)) ? a[0] : null
        }
    });
    Object.assign(fj.prototype, {
        _onAssetAdded: function(a) {
            if ("bundle" === a.type) {
                this._bundleAssets[a.id] = a;
                this._registerBundleEventListeners(a.id);
                for (var b = 0, c = a.data.assets.length; b < c; b++)
                    this._indexAssetInBundle(a.data.assets[b], a)
            } else
                this._assetsInBundles[a.id] && this._indexAssetFileUrls(a)
        },
        _registerBundleEventListeners: function(a) {
            this._assets.on("load:" + a, this._onBundleLoaded, this);
            this._assets.on("error:" + a, this._onBundleError, this)
        },
        _unregisterBundleEventListeners: function(a) {
            this._assets.off("load:" + a, this._onBundleLoaded, this);
            this._assets.off("error:" + a, this._onBundleError, this)
        },
        _indexAssetInBundle: function(a, b) {
            if (this._assetsInBundles[a]) {
                var c = this._assetsInBundles[a];
                -1 === c.indexOf(b) && c.push(b)
            } else
                this._assetsInBundles[a] = [b];
            (a = this._assets.get(a)) && this._indexAssetFileUrls(a)
        },
        _indexAssetFileUrls: function(a) {
            var b = this._getAssetFileUrls(a);
            if (b)
                for (var c = 0, d = b.length; c < d; c++)
                    this._urlsInBundles[b[c]] = this._assetsInBundles[a.id]
        },
        _getAssetFileUrls: function(a) {
            var b = a.getFileUrl();
            if (!b)
                return null;
            b = this._normalizeUrl(b);
            var c = [b];
            if ("font" === a.type) {
                a = a.data.info.maps.length;
                for (var d = 1; d < a; d++)
                    c.push(b.replace(".png", d + ".png"))
            }
            return c
        },
        _normalizeUrl: function(a) {
            return a && a.split("?")[0]
        },
        _onAssetRemoved: function(a) {
            if ("bundle" === a.type) {
                delete this._bundleAssets[a.id];
                this._unregisterBundleEventListeners(a.id);
                var b;
                for (b in this._assetsInBundles) {
                    var c = this._assetsInBundles[b];
                    var d = c.indexOf(a);
                    if (-1 !== d && (c.splice(d, 1),
                    !c.length)) {
                        delete this._assetsInBundles[b];
                        for (var e in this._urlsInBundles)
                            this._urlsInBundles[e] === c && delete this._urlsInBundles[e]
                    }
                }
                this._onBundleError("Bundle " + a.id + " was removed", a)
            } else if (this._assetsInBundles[a.id])
                for (delete this._assetsInBundles[a.id],
                a = this._getAssetFileUrls(a),
                d = 0,
                b = a.length; d < b; d++)
                    delete this._urlsInBundles[a[d]]
        },
        _onBundleLoaded: function(a) {
            a.resource ? requestAnimationFrame(function() {
                if (this._fileRequests)
                    for (var b in this._fileRequests) {
                        var c = this._urlsInBundles[b];
                        if (c && -1 !== c.indexOf(a)) {
                            c = decodeURIComponent(b);
                            var d = null;
                            a.resource.hasBlobUrl(c) || (d = "Bundle " + a.id + " does not contain URL " + b);
                            for (var e = this._fileRequests[b], f = 0, g = e.length; f < g; f++)
                                if (d)
                                    e[f](d);
                                else
                                    e[f](null, a.resource.getBlobUrl(c));
                            delete this._fileRequests[b]
                        }
                    }
            }
            .bind(this)) : this._onBundleError("Bundle " + a.id + " failed to load", a)
        },
        _onBundleError: function(a, b) {
            for (var c in this._fileRequests)
                if (!this._findLoadedOrLoadingBundleForUrl(c)) {
                    b = this._fileRequests[c];
                    for (var d = 0, e = b.length; d < e; d++)
                        b[d](a);
                    delete this._fileRequests[c]
                }
        },
        _findLoadedOrLoadingBundleForUrl: function(a) {
            a = this._urlsInBundles[a];
            if (!a)
                return null;
            var b = a.length, c;
            for (c = 0; c < b; c++)
                if (a[c].loaded && a[c].resource)
                    return a[c];
            for (c = 0; c < b; c++)
                if (a[c].loading)
                    return a[c];
            return null
        },
        listBundlesForAsset: function(a) {
            return this._assetsInBundles[a.id] || null
        },
        list: function() {
            var a = [], b;
            for (b in this._bundleAssets)
                a.push(this._bundleAssets[b]);
            return a
        },
        hasUrl: function(a) {
            return !!this._urlsInBundles[a]
        },
        canLoadUrl: function(a) {
            return !!this._findLoadedOrLoadingBundleForUrl(a)
        },
        loadUrl: function(a, b) {
            var c = this._findLoadedOrLoadingBundleForUrl(a);
            if (c)
                if (c.loaded) {
                    var d = decodeURIComponent(a);
                    c.resource.hasBlobUrl(d) ? b(null, c.resource.getBlobUrl(d)) : b("Bundle " + c.id + " does not contain URL " + a)
                } else
                    this._fileRequests.hasOwnProperty(a) ? this._fileRequests[a].push(b) : this._fileRequests[a] = [b];
            else
                b("URL " + a + " not found in any bundles")
        },
        destroy: function() {
            this._assets.off("add", this._onAssetAdded, this);
            this._assets.off("remove", this._onAssetRemoved, this);
            for (var a in this._bundleAssets)
                this._unregisterBundleEventListeners(a);
            this._fileRequests = this._urlsInBundles = this._assetsInBundles = this._bundleAssets = this._assets = null
        }
    });
    fc.prototype = Object.create(M.prototype);
    fc.prototype.constructor = fc;
    fc.prototype.destroy = function() {
        this.app = null;
        this.off()
    }
    ;
    fc.prototype.add = function(a) {
        var b = this
          , c = a.__name;
        if (this._scripts.hasOwnProperty(c))
            return setTimeout(function() {
                if (a.prototype.swap) {
                    var d = b._list.indexOf(b._scripts[c]);
                    b._list[d] = a;
                    b._scripts[c] = a;
                    b.fire("swap", c, a);
                    b.fire("swap:" + c, a)
                } else
                    console.warn("script registry already has '" + c + "' script, define 'swap' method for new script type to enable code hot swapping")
            }),
            !1;
        this._scripts[c] = a;
        this._list.push(a);
        this.fire("add", c, a);
        this.fire("add:" + c, a);
        setTimeout(function() {
            if (b._scripts.hasOwnProperty(c) && b.app && b.app.systems && b.app.systems.script) {
                var d = b.app.systems.script._components
                  , e = []
                  , f = [];
                for (d.loopIndex = 0; d.loopIndex < d.length; d.loopIndex++) {
                    var g = d.items[d.loopIndex];
                    if (g._scriptsIndex[c] && g._scriptsIndex[c].awaiting) {
                        if (g._scriptsData && g._scriptsData[c])
                            var k = g._scriptsData[c].attributes;
                        (g = g.create(c, {
                            preloading: !0,
                            ind: g._scriptsIndex[c].ind,
                            attributes: k
                        })) && e.push(g)
                    }
                }
                for (d = 0; d < e.length; d++)
                    e[d].__initializeAttributes();
                for (d = 0; d < e.length; d++)
                    e[d].enabled && (e[d]._initialized = !0,
                    f.push(e[d]),
                    e[d].initialize && e[d].initialize());
                for (d = 0; d < f.length; d++)
                    f[d].enabled && !f[d]._postInitialized && (f[d]._postInitialized = !0,
                    f[d].postInitialize && f[d].postInitialize())
            }
        });
        return !0
    }
    ;
    fc.prototype.remove = function(a) {
        var b = a;
        "string" !== typeof a ? a = b.__name : b = this.get(a);
        if (this.get(a) !== b)
            return !1;
        delete this._scripts[a];
        var c = this._list.indexOf(b);
        this._list.splice(c, 1);
        this.fire("remove", a, b);
        this.fire("remove:" + a, b);
        return !0
    }
    ;
    fc.prototype.get = function(a) {
        return this._scripts[a] || null
    }
    ;
    fc.prototype.has = function(a) {
        return "string" === typeof a ? this._scripts.hasOwnProperty(a) : a ? this._scripts[a.__name] === a : !1
    }
    ;
    fc.prototype.list = function() {
        return this._list
    }
    ;
    var Yg = "KEEP_ASPECT"
      , tj = "FIXED";
    Md.prototype = Object.create(M.prototype);
    Md.prototype.constructor = Md;
    Object.assign(Md.prototype, {
        destroy: function() {
            window.removeEventListener("vrdisplaypresentchange", self._presentChange);
            this._camera && (this._camera.vrDisplay = null);
            this._camera = null
        },
        poll: function() {
            if (this.display) {
                this.display.getFrameData(this._frameData);
                this.leftProj.data = this._frameData.leftProjectionMatrix;
                this.rightProj.data = this._frameData.rightProjectionMatrix;
                var a = this.display.stageParameters;
                a ? (this.sitToStandInv.set(a.sittingToStandingTransform).invert(),
                this.combinedView.set(this._frameData.leftViewMatrix),
                this.leftView.mul2(this.combinedView, this.sitToStandInv),
                this.combinedView.set(this._frameData.rightViewMatrix),
                this.rightView.mul2(this.combinedView, this.sitToStandInv)) : (this.leftView.set(this._frameData.leftViewMatrix),
                this.rightView.set(this._frameData.rightViewMatrix));
                var b = this.leftProj.data[3] + this.leftProj.data[0]
                  , c = this.leftProj.data[11] + this.leftProj.data[8]
                  , d = 1 / Math.sqrt(b * b + c * c);
                a = -Math.atan2(c * d, b * d);
                b = this.rightProj.data[3] + this.rightProj.data[0];
                c = this.rightProj.data[11] + this.rightProj.data[8];
                d = 1 / Math.sqrt(b * b + c * c);
                a = Math.max(a, -Math.atan2(c * d, b * d));
                this.combinedFov = a *= 2;
                this.combinedAspect = b = this.rightProj.data[5] / this.rightProj.data[0];
                c = this.combinedView;
                c.copy(this.leftView);
                c.invert();
                this.leftViewInv.copy(c);
                d = this.combinedPos;
                d.x = this.leftPos.x = c.data[12];
                d.y = this.leftPos.y = c.data[13];
                d.z = this.leftPos.z = c.data[14];
                c.copy(this.rightView);
                c.invert();
                this.rightViewInv.copy(c);
                var e = d.x - c.data[12]
                  , f = d.y - c.data[13]
                  , g = d.z - c.data[14];
                e = Math.sqrt(e * e + f * f + g * g);
                this.rightPos.x = c.data[12];
                this.rightPos.y = c.data[13];
                this.rightPos.z = c.data[14];
                d.x += c.data[12];
                d.y += c.data[13];
                d.z += c.data[14];
                d.x *= .5;
                d.y *= .5;
                d.z *= .5;
                e = .5 * e * Math.sin(Math.PI - (.5 * Math.PI + .5 * a));
                f = c.data[9];
                g = c.data[10];
                c.data[12] = d.x + c.data[8] * e;
                c.data[13] = d.y + f * e;
                c.data[14] = d.z + g * e;
                this.combinedViewInv.copy(c);
                c.invert();
                this.combinedProj.setPerspective(a * N.RAD_TO_DEG, b, this.display.depthNear + e, this.display.depthFar + e, !0)
            }
        },
        requestPresent: function(a) {
            this.display ? this.presenting ? a && a(Error("VrDisplay already presenting")) : this.display.requestPresent([{
                source: this._device.canvas
            }]).then(function() {
                a && a()
            }, function(b) {
                a && a(b)
            }) : a && a(Error("No VrDisplay to requestPresent"))
        },
        exitPresent: function(a) {
            this.display || a && a(Error("No VrDisplay to exitPresent"));
            this.presenting ? this.display.exitPresent().then(function() {
                a && a()
            }, function() {
                a && a(Error("exitPresent failed"))
            }) : a && a(Error("VrDisplay not presenting"))
        },
        requestAnimationFrame: function(a) {
            this.display && this.display.requestAnimationFrame(a)
        },
        submitFrame: function() {
            this.display && this.display.submitFrame()
        },
        reset: function() {
            this.display && this.display.resetPose()
        },
        setClipPlanes: function(a, b) {
            this.display && (this.display.depthNear = a,
            this.display.depthFar = b)
        },
        getFrameData: function() {
            if (this.display)
                return this._frameData
        }
    });
    Object.defineProperty(Md.prototype, "capabilities", {
        get: function() {
            return this.display ? this.display.capabilities : {}
        }
    });
    gd.prototype = Object.create(M.prototype);
    gd.prototype.constructor = gd;
    gd.isSupported = "undefined" !== typeof navigator ? !!navigator.getVRDisplays : !1;
    Object.assign(gd.prototype, {
        _attach: function() {
            window.addEventListener("vrdisplayconnect", this._onDisplayConnect);
            window.addEventListener("vrdisplaydisconnect", this._onDisplayDisconnect)
        },
        _detach: function() {
            window.removeEventListener("vrdisplayconnect", this._onDisplayConnect);
            window.removeEventListener("vrdisplaydisconnect", this._onDisplayDisconnect)
        },
        destroy: function() {
            this._detach()
        },
        poll: function() {
            var a = this.displays.length;
            if (a)
                for (var b = 0; b < a; b++)
                    this.displays[b]._camera && this.displays[b].poll()
        },
        _getDisplays: function(a) {
            navigator.getVRDisplays ? navigator.getVRDisplays().then(function(b) {
                a && a(null, b)
            }) : a && a(Error("WebVR not supported"))
        },
        _addDisplay: function(a) {
            this._index[a.displayId] || (a = new Md(this._app,a),
            this._index[a.id] = a,
            this.displays.push(a),
            this.display || (this.display = a),
            this.fire("displayconnect", a))
        },
        _onDisplayConnect: function(a) {
            a.detail && a.detail.display ? this._addDisplay(a.detail.display) : this._addDisplay(a.display)
        },
        _onDisplayDisconnect: function(a) {
            if (a = this._index[a.detail && a.detail.display ? a.detail.display.displayId : a.display.displayId]) {
                a.destroy();
                delete this._index[a.id];
                var b = this.displays.indexOf(a);
                this.displays.splice(b, 1);
                this.display === a && (this.display = this.displays.length ? this.displays[0] : null);
                this.fire("displaydisconnect", a)
            }
        }
    });
    var cl = "inline"
      , gj = "immersive-vr"
      , Nd = "immersive-ar"
      , Jm = []
      , Km = [];
    Jc.prototype = Object.create(M.prototype);
    Jc.prototype.constructor = Jc;
    Jc.prototype.remove = function() {
        if (this._xrHitTestSource) {
            var a = this.manager.hitTest.sources
              , b = a.indexOf(this);
            -1 !== b && a.splice(b, 1);
            this.onStop()
        }
    }
    ;
    Jc.prototype.onStop = function() {
        this._xrHitTestSource.cancel();
        this._xrHitTestSource = null;
        this.fire("remove");
        this.manager.hitTest.fire("remove", this)
    }
    ;
    Jc.prototype.update = function(a) {
        if (this._transient) {
            a = a.getHitTestResultsForTransientInput(this._xrHitTestSource);
            for (var b = 0; b < a.length; b++) {
                var c = a[b], d;
                c.inputSource && (d = this.manager.input._getByInputSource(c.inputSource));
                this.updateHitResults(c.results, d)
            }
        } else
            this.updateHitResults(a.getHitTestResults(this._xrHitTestSource))
    }
    ;
    Jc.prototype.updateHitResults = function(a, b) {
        for (var c = 0; c < a.length; c++) {
            var d = a[c].getPose(this.manager._referenceSpace)
              , e = Jm.pop();
            e || (e = new z);
            e.copy(d.transform.position);
            var f = Km.pop();
            f || (f = new Y);
            f.copy(d.transform.orientation);
            this.fire("result", e, f, b);
            this.manager.hitTest.fire("result", this, e, f, b);
            Jm.push(e);
            Km.push(f)
        }
    }
    ;
    Sb.prototype = Object.create(M.prototype);
    Sb.prototype.constructor = Sb;
    Sb.prototype._onSessionStart = function() {
        this.manager.type === Nd && (this._session = this.manager.session)
    }
    ;
    Sb.prototype._onSessionEnd = function() {
        if (this._session) {
            this._session = null;
            for (var a = 0; a < this.sources.length; a++)
                this.sources[a].onStop();
            this.sources = []
        }
    }
    ;
    Sb.prototype.isAvailable = function(a, b) {
        var c;
        this._supported || (c = Error("XR HitTest is not supported"));
        this._session || (c = Error("XR Session is not started (1)"));
        this.manager.type !== Nd && (c = Error("XR HitTest is available only for AR"));
        return c ? (a && a(c),
        b && b.fire("error", c),
        !1) : !0
    }
    ;
    Sb.prototype.start = function(a) {
        var b = this;
        a = a || {};
        if (this.isAvailable(a.callback, this)) {
            a.profile || a.spaceType || (a.spaceType = "viewer");
            var c, d = a.offsetRay;
            d && (c = new XRRay(new DOMPoint(d.origin.x,d.origin.y,d.origin.z),new DOMPoint(d.direction.x,d.direction.y,d.direction.z)));
            var e = a.callback;
            a.spaceType ? this._session.requestReferenceSpace(a.spaceType).then(function(f) {
                b._session ? b._session.requestHitTestSource({
                    space: f,
                    entityTypes: a.entityTypes || void 0,
                    offsetRay: c
                }).then(function(g) {
                    b._onHitTestSource(g, !1, e)
                }).catch(function(g) {
                    e && e(g);
                    b.fire("error", g)
                }) : (f = Error("XR Session is not started (2)"),
                e && e(f),
                b.fire("error", f))
            }).catch(function(f) {
                e && e(f);
                b.fire("error", f)
            }) : this._session.requestHitTestSourceForTransientInput({
                profile: a.profile,
                entityTypes: a.entityTypes || void 0,
                offsetRay: c
            }).then(function(f) {
                b._onHitTestSource(f, !0, e)
            }).catch(function(f) {
                e && e(f);
                b.fire("error", f)
            })
        }
    }
    ;
    Sb.prototype._onHitTestSource = function(a, b, c) {
        this._session ? (a = new Jc(this.manager,a,b),
        this.sources.push(a),
        c && c(null, a),
        this.fire("add", a)) : (a.cancel(),
        a = Error("XR Session is not started (3)"),
        c && c(a),
        this.fire("error", a))
    }
    ;
    Sb.prototype.update = function(a) {
        for (var b = 0; b < this.sources.length; b++)
            this.sources[b].update(a)
    }
    ;
    Object.defineProperty(Sb.prototype, "supported", {
        get: function() {
            return this._supported
        }
    });
    Object.defineProperty(Gf.prototype, "index", {
        get: function() {
            return this._index
        }
    });
    Object.defineProperty(Gf.prototype, "hand", {
        get: function() {
            return this._hand
        }
    });
    Object.defineProperty(Gf.prototype, "joints", {
        get: function() {
            return this._joints
        }
    });
    Object.defineProperty(Gf.prototype, "tip", {
        get: function() {
            return this._tip
        }
    });
    for (var Lm = window.XRHand ? [XRHand.THUMB_PHALANX_TIP, XRHand.INDEX_PHALANX_TIP, XRHand.MIDDLE_PHALANX_TIP, XRHand.RING_PHALANX_TIP, XRHand.LITTLE_PHALANX_TIP] : [], bl = {}, hk = 0; hk < Lm.length; hk++)
        bl[Lm[hk]] = !0;
    Tb.prototype.update = function(a) {
        this._dirtyLocal = !0;
        this._radius = a.radius;
        this._localPosition.copy(a.transform.position);
        this._localRotation.copy(a.transform.orientation)
    }
    ;
    Tb.prototype._updateTransforms = function() {
        this._dirtyLocal && (this._dirtyLocal = !1,
        this._localTransform.setTRS(this._localPosition, this._localRotation, z.ONE));
        var a = this._hand._manager.camera.parent;
        a ? this._worldTransform.mul2(a.getWorldTransform(), this._localTransform) : this._worldTransform.copy(this._localTransform)
    }
    ;
    Tb.prototype.getPosition = function() {
        this._updateTransforms();
        this._worldTransform.getTranslation(this._position);
        return this._position
    }
    ;
    Tb.prototype.getRotation = function() {
        this._updateTransforms();
        this._rotation.setFromMat4(this._worldTransform);
        return this._rotation
    }
    ;
    Object.defineProperty(Tb.prototype, "index", {
        get: function() {
            return this._index
        }
    });
    Object.defineProperty(Tb.prototype, "hand", {
        get: function() {
            return this._hand
        }
    });
    Object.defineProperty(Tb.prototype, "finger", {
        get: function() {
            return this._finger
        }
    });
    Object.defineProperty(Tb.prototype, "wrist", {
        get: function() {
            return this._wrist
        }
    });
    Object.defineProperty(Tb.prototype, "tip", {
        get: function() {
            return this._tip
        }
    });
    Object.defineProperty(Tb.prototype, "radius", {
        get: function() {
            return this._radius || .005
        }
    });
    var Qg = []
      , ke = new z
      , Mm = new z
      , Nm = new z;
    window.XRHand && (Qg = [[XRHand.THUMB_METACARPAL, XRHand.THUMB_PHALANX_PROXIMAL, XRHand.THUMB_PHALANX_DISTAL, XRHand.THUMB_PHALANX_TIP], [XRHand.INDEX_METACARPAL, XRHand.INDEX_PHALANX_PROXIMAL, XRHand.INDEX_PHALANX_INTERMEDIATE, XRHand.INDEX_PHALANX_DISTAL, XRHand.INDEX_PHALANX_TIP], [XRHand.MIDDLE_METACARPAL, XRHand.MIDDLE_PHALANX_PROXIMAL, XRHand.MIDDLE_PHALANX_INTERMEDIATE, XRHand.MIDDLE_PHALANX_DISTAL, XRHand.MIDDLE_PHALANX_TIP], [XRHand.RING_METACARPAL, XRHand.RING_PHALANX_PROXIMAL, XRHand.RING_PHALANX_INTERMEDIATE, XRHand.RING_PHALANX_DISTAL, XRHand.RING_PHALANX_TIP], [XRHand.LITTLE_METACARPAL, XRHand.LITTLE_PHALANX_PROXIMAL, XRHand.LITTLE_PHALANX_INTERMEDIATE, XRHand.LITTLE_PHALANX_DISTAL, XRHand.LITTLE_PHALANX_TIP]]);
    gc.prototype = Object.create(M.prototype);
    gc.prototype.constructor = gc;
    gc.prototype.update = function(a) {
        for (var b = this._inputSource._xrInputSource, c = 0; c < this._joints.length; c++) {
            var d = this._joints[c]
              , e = b.hand[d._id];
            if (e)
                if (e = a.getJointPose(e, this._manager._referenceSpace))
                    d.update(e),
                    d.wrist && !this._tracking && (this._tracking = !0,
                    this.fire("tracking"));
                else if (d.wrist) {
                    this._tracking && (this._tracking = !1,
                    this.fire("trackinglost"));
                    break
                }
        }
        e = this._jointsById[XRHand.THUMB_METACARPAL];
        a = this._jointsById[XRHand.THUMB_PHALANX_TIP];
        b = this._jointsById[XRHand.INDEX_PHALANX_PROXIMAL];
        c = this._jointsById[XRHand.INDEX_PHALANX_TIP];
        d = this._jointsById[XRHand.RING_PHALANX_PROXIMAL];
        var f = this._jointsById[XRHand.LITTLE_PHALANX_PROXIMAL];
        if (e && a && b && c && d && f) {
            this._inputSource._dirtyRay = !0;
            this._inputSource._rayLocal.origin.lerp(a._localPosition, c._localPosition, .5);
            if ("left" === this._inputSource.handedness) {
                var g = e;
                e = f;
                f = g
            }
            ke.sub2(e._localPosition, this._wrist._localPosition);
            Mm.sub2(f._localPosition, this._wrist._localPosition);
            Nm.cross(ke, Mm).normalize();
            ke.lerp(b._localPosition, d._localPosition, .5);
            ke.sub(this._wrist._localPosition).normalize();
            this._inputSource._rayLocal.direction.lerp(Nm, ke, .5).normalize()
        }
        a && c && (ke.copy(a._localPosition),
        .015 > ke.distance(c._localPosition) ? this._inputSource._selecting || (this._inputSource._selecting = !0,
        this._inputSource.fire("selectstart"),
        this._manager.input.fire("selectstart", this._inputSource)) : this._inputSource._selecting && (this._inputSource._selecting = !1,
        this._inputSource.fire("select"),
        this._manager.input.fire("select", this._inputSource),
        this._inputSource.fire("selectend"),
        this._manager.input.fire("selectend", this._inputSource)))
    }
    ;
    gc.prototype.getJointById = function(a) {
        return this._jointsById[a] || null
    }
    ;
    Object.defineProperty(gc.prototype, "fingers", {
        get: function() {
            return this._fingers
        }
    });
    Object.defineProperty(gc.prototype, "joints", {
        get: function() {
            return this._joints
        }
    });
    Object.defineProperty(gc.prototype, "tips", {
        get: function() {
            return this._tips
        }
    });
    Object.defineProperty(gc.prototype, "wrist", {
        get: function() {
            return this._wrist
        }
    });
    Object.defineProperty(gc.prototype, "tracking", {
        get: function() {
            return this._tracking
        }
    });
    var Om = new Y
      , Yn = 0;
    ta.prototype = Object.create(M.prototype);
    ta.prototype.constructor = ta;
    ta.prototype.update = function(a) {
        if (this._hand)
            this._hand.update(a);
        else {
            if (this._xrInputSource.gripSpace) {
                var b = a.getPose(this._xrInputSource.gripSpace, this._manager._referenceSpace);
                b && (this._grip || (this._grip = !0,
                this._localTransform = new K,
                this._worldTransform = new K,
                this._localPosition = new z,
                this._localRotation = new Y),
                this._dirtyLocal = !0,
                this._localPosition.copy(b.transform.position),
                this._localRotation.copy(b.transform.orientation))
            }
            if (a = a.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace))
                this._dirtyRay = !0,
                this._rayLocal.origin.copy(a.transform.position),
                this._rayLocal.direction.set(0, 0, -1),
                Om.copy(a.transform.orientation),
                Om.transformVector(this._rayLocal.direction, this._rayLocal.direction)
        }
    }
    ;
    ta.prototype._updateTransforms = function() {
        this._dirtyLocal && (this._dirtyLocal = !1,
        this._localTransform.setTRS(this._localPosition, this._localRotation, z.ONE));
        var a = this._manager.camera.parent;
        a ? this._worldTransform.mul2(a.getWorldTransform(), this._localTransform) : this._worldTransform.copy(this._localTransform)
    }
    ;
    ta.prototype._updateRayTransforms = function() {
        var a = this._dirtyRay;
        this._dirtyRay = !1;
        this._manager.camera.parent ? (a = this._manager.camera.parent.getWorldTransform(),
        a.getTranslation(this._position),
        this._rotation.setFromMat4(a),
        this._rotation.transformVector(this._rayLocal.origin, this._ray.origin),
        this._ray.origin.add(this._position),
        this._rotation.transformVector(this._rayLocal.direction, this._ray.direction)) : a && (this._ray.origin.copy(this._rayLocal.origin),
        this._ray.direction.copy(this._rayLocal.direction))
    }
    ;
    ta.prototype.getPosition = function() {
        if (!this._position)
            return null;
        this._updateTransforms();
        this._worldTransform.getTranslation(this._position);
        return this._position
    }
    ;
    ta.prototype.getLocalPosition = function() {
        return this._localPosition
    }
    ;
    ta.prototype.getRotation = function() {
        if (!this._rotation)
            return null;
        this._updateTransforms();
        this._rotation.setFromMat4(this._worldTransform);
        return this._rotation
    }
    ;
    ta.prototype.getLocalRotation = function() {
        return this._localRotation
    }
    ;
    ta.prototype.getOrigin = function() {
        this._updateRayTransforms();
        return this._ray.origin
    }
    ;
    ta.prototype.getDirection = function() {
        this._updateRayTransforms();
        return this._ray.direction
    }
    ;
    ta.prototype.hitTestStart = function(a) {
        var b = this;
        a = a || {};
        a.profile = this._xrInputSource.profiles[0];
        var c = a.callback;
        a.callback = function(d, e) {
            if (e)
                b.onHitTestSourceAdd(e);
            c && c(d, e)
        }
        ;
        this._manager.hitTest.start(a)
    }
    ;
    ta.prototype.onHitTestSourceAdd = function(a) {
        this._hitTestSources.push(a);
        this.fire("hittest:add", a);
        a.on("result", function(b, c, d) {
            d === this && this.fire("hittest:result", a, b, c)
        }, this);
        a.once("remove", function() {
            this.onHitTestSourceRemove(a);
            this.fire("hittest:remove", a)
        }, this)
    }
    ;
    ta.prototype.onHitTestSourceRemove = function(a) {
        a = this._hitTestSources.indexOf(a);
        -1 !== a && this._hitTestSources.splice(a, 1)
    }
    ;
    Object.defineProperty(ta.prototype, "id", {
        get: function() {
            return this._id
        }
    });
    Object.defineProperty(ta.prototype, "inputSource", {
        get: function() {
            return this._xrInputSource
        }
    });
    Object.defineProperty(ta.prototype, "targetRayMode", {
        get: function() {
            return this._xrInputSource.targetRayMode
        }
    });
    Object.defineProperty(ta.prototype, "handedness", {
        get: function() {
            return this._xrInputSource.handedness
        }
    });
    Object.defineProperty(ta.prototype, "profiles", {
        get: function() {
            return this._xrInputSource.profiles
        }
    });
    Object.defineProperty(ta.prototype, "grip", {
        get: function() {
            return this._grip
        }
    });
    Object.defineProperty(ta.prototype, "hand", {
        get: function() {
            return this._hand
        }
    });
    Object.defineProperty(ta.prototype, "gamepad", {
        get: function() {
            return this._xrInputSource.gamepad || null
        }
    });
    Object.defineProperty(ta.prototype, "selecting", {
        get: function() {
            return this._selecting
        }
    });
    Object.defineProperty(ta.prototype, "elementInput", {
        get: function() {
            return this._elementInput
        },
        set: function(a) {
            this._elementInput !== a && (this._elementInput = a,
            this._elementInput || (this._elementEntity = null))
        }
    });
    Object.defineProperty(ta.prototype, "elementEntity", {
        get: function() {
            return this._elementEntity
        }
    });
    Object.defineProperty(ta.prototype, "hitTestSources", {
        get: function() {
            return this._hitTestSources
        }
    });
    Fb.prototype = Object.create(M.prototype);
    Fb.prototype.constructor = Fb;
    Fb.prototype._onSessionStart = function() {
        this._session = this.manager.session;
        this._session.addEventListener("inputsourceschange", this._onInputSourcesChangeEvt);
        var a = this;
        this._session.addEventListener("select", function(d) {
            var e = a._getByInputSource(d.inputSource);
            e.update(d.frame);
            e.fire("select", d);
            a.fire("select", e, d)
        });
        this._session.addEventListener("selectstart", function(d) {
            var e = a._getByInputSource(d.inputSource);
            e.update(d.frame);
            e._selecting = !0;
            e.fire("selectstart", d);
            a.fire("selectstart", e, d)
        });
        this._session.addEventListener("selectend", function(d) {
            var e = a._getByInputSource(d.inputSource);
            e.update(d.frame);
            e._selecting = !1;
            e.fire("selectend", d);
            a.fire("selectend", e, d)
        });
        for (var b = this._session.inputSources, c = 0; c < b.length; c++)
            this._addInputSource(b[c])
    }
    ;
    Fb.prototype._onSessionEnd = function() {
        for (var a = this._inputSources.length; a--; ) {
            var b = this._inputSources[a];
            this._inputSources.splice(a, 1);
            b.fire("remove");
            this.fire("remove", b)
        }
        this._session.removeEventListener("inputsourceschange", this._onInputSourcesChangeEvt);
        this._session = null
    }
    ;
    Fb.prototype._onInputSourcesChange = function(a) {
        var b;
        for (b = 0; b < a.removed.length; b++)
            this._removeInputSource(a.removed[b]);
        for (b = 0; b < a.added.length; b++)
            this._addInputSource(a.added[b])
    }
    ;
    Fb.prototype._getByInputSource = function(a) {
        for (var b = 0; b < this._inputSources.length; b++)
            if (this._inputSources[b].inputSource === a)
                return this._inputSources[b];
        return null
    }
    ;
    Fb.prototype._addInputSource = function(a) {
        this._getByInputSource(a) || (a = new ta(this.manager,a),
        this._inputSources.push(a),
        this.fire("add", a))
    }
    ;
    Fb.prototype._removeInputSource = function(a) {
        for (var b = 0; b < this._inputSources.length; b++)
            if (this._inputSources[b].inputSource === a) {
                a = this._inputSources[b];
                this._inputSources.splice(b, 1);
                for (b = a.hitTestSources.length; b--; )
                    a.hitTestSources[b].remove();
                a.fire("remove");
                this.fire("remove", a);
                break
            }
    }
    ;
    Fb.prototype.update = function(a) {
        for (var b = 0; b < this._inputSources.length; b++)
            this._inputSources[b].update(a)
    }
    ;
    Object.defineProperty(Fb.prototype, "inputSources", {
        get: function() {
            return this._inputSources
        }
    });
    var lf = new z
      , Pm = new z
      , ik = new K
      , Qm = new K;
    hb.prototype = Object.create(M.prototype);
    hb.prototype.constructor = hb;
    hb.prototype._onSessionStart = function() {
        this._manager.session.requestLightProbe && (this._supported = !0)
    }
    ;
    hb.prototype._onSessionEnd = function() {
        this._lightProbeRequested = this._available = this._supported = !1;
        this._lightProbe = null
    }
    ;
    hb.prototype.start = function() {
        var a;
        this._manager.session || (a = Error("XR session is not running"));
        a || this._manager.type === Nd || (a = Error("XR session type is not AR"));
        a || this._supported || (a = Error("light-estimation is not supported"));
        if (!a && this._lightProbe || this._lightProbeRequested)
            a = Error("light estimation is already requested");
        if (a)
            this.fire("error", a);
        else {
            var b = this;
            this._lightProbeRequested = !0;
            this._manager.session.requestLightProbe().then(function(c) {
                var d = b._lightProbeRequested;
                b._lightProbeRequested = !1;
                b._manager.active ? d && (b._lightProbe = c) : b.fire("error", Error("XR session is not active"))
            }).catch(function(c) {
                b._lightProbeRequested = !1;
                b.fire("error", c)
            })
        }
    }
    ;
    hb.prototype.end = function() {
        this._lightProbeRequested = !1;
        this._lightProbe = null;
        this._available = !1
    }
    ;
    hb.prototype.update = function(a) {
        if (this._lightProbe && (a = a.getLightEstimate(this._lightProbe))) {
            this._available || (this._available = !0,
            this.fire("available"));
            var b = a.primaryLightIntensity;
            this._intensity = Math.max(1, Math.max(b.x, Math.max(b.y, b.z)));
            lf.copy(b).scale(1 / this._intensity);
            this._color.set(lf.x, lf.y, lf.z);
            lf.set(0, 0, 0);
            Pm.copy(a.primaryLightDirection);
            ik.setLookAt(Pm, lf, z.UP);
            Qm.setFromAxisAngle(z.RIGHT, 90);
            ik.mul(Qm);
            this._rotation.setFromMat4(ik);
            this._sphericalHarmonics.set(a.sphericalHarmonicsCoefficients)
        }
    }
    ;
    Object.defineProperty(hb.prototype, "supported", {
        get: function() {
            return this._supported
        }
    });
    Object.defineProperty(hb.prototype, "available", {
        get: function() {
            return !!this._available
        }
    });
    Object.defineProperty(hb.prototype, "intensity", {
        get: function() {
            return this._available ? this._intensity : null
        }
    });
    Object.defineProperty(hb.prototype, "color", {
        get: function() {
            return this._available ? this._color : null
        }
    });
    Object.defineProperty(hb.prototype, "rotation", {
        get: function() {
            return this._available ? this._rotation : null
        }
    });
    Object.defineProperty(hb.prototype, "sphericalHarmonics", {
        get: function() {
            return this._available ? this._sphericalHarmonics : null
        }
    });
    Pa.prototype = Object.create(M.prototype);
    Pa.prototype.constructor = Pa;
    Pa.prototype.start = function(a, b, c, d) {
        if (this._available[b])
            if (this._session)
                d && d(Error("XR session is already started"));
            else {
                var e = this;
                this._camera = a;
                this._camera.camera.xr = this;
                this._type = b;
                this._spaceType = c;
                this._setClipPlanes(a.nearClip, a.farClip);
                a = [];
                b === Nd && (a.push("light-estimation"),
                a.push("hit-test"));
                b === gj && a.push("hand-tracking");
                navigator.xr.requestSession(b, {
                    requiredFeatures: [c],
                    optionalFeatures: a
                }).then(function(f) {
                    e._onSessionStart(f, c, d)
                }).catch(function(f) {
                    e._camera.camera.xr = null;
                    e._camera = null;
                    e._type = null;
                    e._spaceType = null;
                    d && d(f);
                    e.fire("error", f)
                })
            }
        else
            d && d(Error("XR is not available"))
    }
    ;
    Pa.prototype.end = function(a) {
        if (this._session) {
            if (a)
                this.once("end", a);
            this._session.end()
        } else
            a && a(Error("XR Session is not initialized"))
    }
    ;
    Pa.prototype.isAvailable = function(a) {
        return this._available[a]
    }
    ;
    Pa.prototype._deviceAvailabilityCheck = function() {
        for (var a in this._available)
            this._sessionSupportCheck(a)
    }
    ;
    Pa.prototype._sessionSupportCheck = function(a) {
        var b = this;
        navigator.xr.isSessionSupported(a).then(function(c) {
            b._available[a] !== c && (b._available[a] = c,
            b.fire("available", a, c),
            b.fire("available:" + a, c))
        }).catch(function(c) {
            b.fire("error", c)
        })
    }
    ;
    Pa.prototype._onSessionStart = function(a, b, c) {
        var d = this
          , e = !1;
        this._session = a;
        var f = function() {
            d.fire("visibility:change", a.visibilityState)
        }
          , g = function() {
            d._setClipPlanes(d._camera.nearClip, d._camera.farClip)
        }
          , k = function() {
            d._session = null;
            d._referenceSpace = null;
            d.views = [];
            d._width = 0;
            d._height = 0;
            d._type = null;
            d._spaceType = null;
            d._camera && (d._camera.off("set_nearClip", g),
            d._camera.off("set_farClip", g),
            d._camera.camera.xr = null,
            d._camera = null);
            a.removeEventListener("end", k);
            a.removeEventListener("visibilitychange", f);
            e || d.fire("end");
            d.app.tick()
        };
        a.addEventListener("end", k);
        a.addEventListener("visibilitychange", f);
        this._camera.on("set_nearClip", g);
        this._camera.on("set_farClip", g);
        this._baseLayer = new XRWebGLLayer(a,this.app.graphicsDevice.gl);
        a.updateRenderState({
            baseLayer: this._baseLayer,
            depthNear: this._depthNear,
            depthFar: this._depthFar
        });
        a.requestReferenceSpace(b).then(function(h) {
            d._referenceSpace = h;
            d.app.tick();
            c && c(null);
            d.fire("start")
        }).catch(function(h) {
            e = !0;
            a.end();
            c && c(h);
            d.fire("error", h)
        })
    }
    ;
    Pa.prototype._setClipPlanes = function(a, b) {
        if (this._depthNear !== a || this._depthFar !== b)
            this._depthNear = a,
            this._depthFar = b,
            this._session && this._session.updateRenderState({
                depthNear: this._depthNear,
                depthFar: this._depthFar
            })
    }
    ;
    Pa.prototype.update = function(a) {
        if (this._session) {
            var b, c = a.session.renderState.baseLayer.framebufferWidth;
            var d = a.session.renderState.baseLayer.framebufferHeight;
            if (this._width !== c || this._height !== d)
                this._width = c,
                this._height = d,
                this.app.graphicsDevice.setResolution(c, d);
            var e = (c = a.getViewerPose(this._referenceSpace)) ? c.views.length : 0;
            if (e > this.views.length)
                for (d = 0; d <= e - this.views.length; d++)
                    (b = this.viewsPool.pop()) || (b = {
                        viewport: new X,
                        projMat: new K,
                        viewMat: new K,
                        viewOffMat: new K,
                        viewInvMat: new K,
                        viewInvOffMat: new K,
                        projViewOffMat: new K,
                        viewMat3: new xb,
                        position: new Float32Array(3),
                        rotation: new Y
                    }),
                    this.views.push(b);
            else if (e <= this.views.length)
                for (d = 0; d < this.views.length - e; d++)
                    this.viewsPool.push(this.views.pop());
            if (c) {
                d = c.transform.position;
                b = c.transform.orientation;
                this._localPosition.set(d.x, d.y, d.z);
                this._localRotation.set(b.x, b.y, b.z, b.w);
                var f = a.session.renderState.baseLayer;
                for (d = 0; d < c.views.length; d++) {
                    e = c.views[d];
                    b = this.views[d];
                    var g = f.getViewport(e);
                    b.viewport.x = g.x;
                    b.viewport.y = g.y;
                    b.viewport.z = g.width;
                    b.viewport.w = g.height;
                    b.projMat.set(e.projectionMatrix);
                    b.viewMat.set(e.transform.inverse.matrix);
                    b.viewInvMat.set(e.transform.matrix)
                }
            }
            this._camera.camera._node.setLocalPosition(this._localPosition);
            this._camera.camera._node.setLocalRotation(this._localRotation);
            this.input.update(a);
            this._type === Nd && (this.hitTest.supported && this.hitTest.update(a),
            this.lightEstimation.supported && this.lightEstimation.update(a));
            this.fire("update", a)
        }
    }
    ;
    Object.defineProperty(Pa.prototype, "supported", {
        get: function() {
            return this._supported
        }
    });
    Object.defineProperty(Pa.prototype, "active", {
        get: function() {
            return !!this._session
        }
    });
    Object.defineProperty(Pa.prototype, "type", {
        get: function() {
            return this._type
        }
    });
    Object.defineProperty(Pa.prototype, "spaceType", {
        get: function() {
            return this._spaceType
        }
    });
    Object.defineProperty(Pa.prototype, "session", {
        get: function() {
            return this._session
        }
    });
    Object.defineProperty(Pa.prototype, "visibilityState", {
        get: function() {
            return this._session ? this._session.visibilityState : null
        }
    });
    Object.defineProperty(Pa.prototype, "camera", {
        get: function() {
            return this._camera ? this._camera.entity : null
        }
    });
    O.prototype = Object.create(M.prototype);
    O.prototype.constructor = O;
    O._buildAccessors = function(a, b) {
        b.forEach(function(c) {
            var d = "object" === typeof c ? c.name : c;
            Object.defineProperty(a, d, {
                get: function() {
                    return this.data[d]
                },
                set: function(e) {
                    var f = this.data
                      , g = f[d];
                    f[d] = e;
                    this.fire("set", d, g, e)
                },
                configurable: !0
            })
        });
        a._accessorsBuilt = !0
    }
    ;
    Object.assign(O.prototype, {
        buildAccessors: function(a) {
            O._buildAccessors(this, a)
        },
        onSetEnabled: function(a, b, c) {
            if (b !== c && this.entity.enabled)
                if (c)
                    this.onEnable();
                else
                    this.onDisable()
        },
        onEnable: function() {},
        onDisable: function() {},
        onPostStateChange: function() {}
    });
    Object.defineProperty(O.prototype, "data", {
        get: function() {
            var a = this.system.store[this.entity.getGuid()];
            return a ? a.data : null
        }
    });
    H.prototype = Object.create(M.prototype);
    H.prototype.constructor = H;
    Object.assign(H, {
        _helper: function(a, b) {
            for (var c = 0, d = a.length; c < d; c++)
                a[c].f.call(a[c].s, b)
        },
        initialize: function(a) {
            this._helper(this._init, a)
        },
        postInitialize: function(a) {
            this._helper(this._postInit, a);
            this.fire("postinitialize", a)
        },
        update: function(a, b) {
            this._helper(b ? this._toolsUpdate : this._update, a)
        },
        animationUpdate: function(a, b) {
            this._helper(this._animationUpdate, a)
        },
        fixedUpdate: function(a, b) {
            this._helper(this._fixedUpdate, a)
        },
        postUpdate: function(a, b) {
            this._helper(this._postUpdate, a)
        },
        _init: [],
        _postInit: [],
        _toolsUpdate: [],
        _update: [],
        _animationUpdate: [],
        _fixedUpdate: [],
        _postUpdate: [],
        bind: function(a, b, c) {
            switch (a) {
            case "initialize":
                this._init.push({
                    f: b,
                    s: c
                });
                break;
            case "postInitialize":
                this._postInit.push({
                    f: b,
                    s: c
                });
                break;
            case "update":
                this._update.push({
                    f: b,
                    s: c
                });
                break;
            case "animationUpdate":
                this._animationUpdate.push({
                    f: b,
                    s: c
                });
                break;
            case "postUpdate":
                this._postUpdate.push({
                    f: b,
                    s: c
                });
                break;
            case "fixedUpdate":
                this._fixedUpdate.push({
                    f: b,
                    s: c
                });
                break;
            case "toolsUpdate":
                this._toolsUpdate.push({
                    f: b,
                    s: c
                });
                break;
            default:
                console.error("Component System does not support event", a)
            }
        },
        _erase: function(a, b, c) {
            for (var d = 0; d < a.length; d++)
                a[d].f === b && a[d].s === c && a.splice(d--, 1)
        },
        unbind: function(a, b, c) {
            switch (a) {
            case "initialize":
                this._erase(this._init, b, c);
                break;
            case "postInitialize":
                this._erase(this._postInit, b, c);
                break;
            case "update":
                this._erase(this._update, b, c);
                break;
            case "animationUpdate":
                this._erase(this._animationUpdate, b, c);
                break;
            case "postUpdate":
                this._erase(this._postUpdate, b, c);
                break;
            case "fixedUpdate":
                this._erase(this._fixedUpdate, b, c);
                break;
            case "toolsUpdate":
                this._erase(this._toolsUpdate, b, c);
                break;
            default:
                console.error("Component System does not support event", a)
            }
        }
    });
    Object.assign(H.prototype, {
        addComponent: function(a, b) {
            var c = new this.ComponentType(this,a)
              , d = new this.DataType;
            b = b || {};
            this.store[a.getGuid()] = {
                entity: a,
                data: d
            };
            a[this.id] = c;
            a.c[this.id] = c;
            this.initializeComponentData(c, b, []);
            this.fire("add", a, c);
            return c
        },
        removeComponent: function(a) {
            var b = this.store[a.getGuid()];
            this.fire("beforeremove", a, a.c[this.id]);
            delete this.store[a.getGuid()];
            delete a[this.id];
            delete a.c[this.id];
            this.fire("remove", a, b.data)
        },
        cloneComponent: function(a, b) {
            a = this.store[a.getGuid()];
            return this.addComponent(b, a.data)
        },
        initializeComponentData: function(a, b, c) {
            b = b || {};
            for (var d, e, f, g = 0, k = c.length; g < k; g++)
                d = c[g],
                "object" === typeof d ? (e = d.name,
                d = d.type) : (e = d,
                d = void 0),
                f = b[e],
                void 0 !== f ? (void 0 !== d && (f = Zn(f, d)),
                a[e] = f) : a[e] = a.data[e];
            if (a.enabled && a.entity.enabled)
                a.onEnable()
        },
        getPropertiesOfType: function(a) {
            var b = [];
            (this.schema || []).forEach(function(c) {
                c && "object" === typeof c && c.type === a && b.push(c)
            });
            return b
        },
        destroy: function() {
            this.off()
        }
    });
    Of.attach(H);
    H.destroy = function() {
        H.off("initialize");
        H.off("postInitialize");
        H.off("toolsUpdate");
        H.off("update");
        H.off("animationUpdate");
        H.off("fixedUpdate");
        H.off("postUpdate");
        H._init = [];
        H._postInit = [];
        H._toolsUpdate = [];
        H._update = [];
        H._animationUpdate = [];
        H._fixedUpdate = [];
        H._postUpdate = []
    }
    ;
    Object.assign(dl.prototype, {
        getTarget: function() {
            return this._targetNode
        },
        setTarget: function(a) {
            this._targetNode = a
        }
    });
    Ta.prototype.addTime = function(a) {
        if (null !== this._animation) {
            var b = this._animation._nodes;
            var c = this._animation.duration;
            if (this._time !== c || this.looping) {
                this._time += a;
                if (this._time > c)
                    for (this._time = this.looping ? 0 : c,
                    c = 0; c < b.length; c++) {
                        var d = b[c];
                        var e = d._name;
                        this._currKeyIndices[e] = 0
                    }
                else if (0 > this._time)
                    for (this._time = this.looping ? c : 0,
                    c = 0; c < b.length; c++)
                        d = b[c],
                        e = d._name,
                        this._currKeyIndices[e] = d._keys.length - 2;
                a = 0 <= a ? 1 : -1;
                for (c = 0; c < b.length; c++) {
                    d = b[c];
                    e = d._name;
                    d = d._keys;
                    var f = this._interpolatedKeyDict[e];
                    if (void 0 !== f) {
                        var g = !1;
                        if (1 !== d.length)
                            for (var k = this._currKeyIndices[e]; k < d.length - 1 && 0 <= k; k += a) {
                                var h = d[k];
                                var l = d[k + 1];
                                if (h.time <= this._time && l.time >= this._time) {
                                    g = (this._time - h.time) / (l.time - h.time);
                                    f._pos.lerp(h.position, l.position, g);
                                    f._quat.slerp(h.rotation, l.rotation, g);
                                    f._scale.lerp(h.scale, l.scale, g);
                                    f._written = !0;
                                    this._currKeyIndices[e] = k;
                                    g = !0;
                                    break
                                }
                            }
                        if (1 === d.length || !g && 0 === this._time && this.looping)
                            f._pos.copy(d[0].position),
                            f._quat.copy(d[0].rotation),
                            f._scale.copy(d[0].scale),
                            f._written = !0
                    }
                }
            }
        }
    }
    ;
    Ta.prototype.blend = function(a, b, c) {
        for (var d = this._interpolatedKeys.length, e = 0; e < d; e++) {
            var f = a._interpolatedKeys[e]
              , g = b._interpolatedKeys[e]
              , k = this._interpolatedKeys[e];
            f._written && g._written ? (k._quat.slerp(f._quat, b._interpolatedKeys[e]._quat, c),
            k._pos.lerp(f._pos, b._interpolatedKeys[e]._pos, c),
            k._scale.lerp(f._scale, g._scale, c),
            k._written = !0) : f._written ? (k._quat.copy(f._quat),
            k._pos.copy(f._pos),
            k._scale.copy(f._scale),
            k._written = !0) : g._written && (k._quat.copy(g._quat),
            k._pos.copy(g._pos),
            k._scale.copy(g._scale),
            k._written = !0)
        }
    }
    ;
    Object.defineProperty(Ta.prototype, "animation", {
        get: function() {
            return this._animation
        },
        set: function(a) {
            this._animation = a;
            this.currentTime = 0
        }
    });
    Ta.prototype.getAnimation = function() {
        return this._animation
    }
    ;
    Object.defineProperty(Ta.prototype, "currentTime", {
        get: function() {
            return this._time
        },
        set: function(a) {
            this._time = a;
            a = this._interpolatedKeys.length;
            for (var b = 0; b < a; b++)
                this._currKeyIndices[this._interpolatedKeys[b]._name] = 0;
            this.addTime(0);
            this.updateGraph()
        }
    });
    Ta.prototype.getCurrentTime = function() {
        return this._time
    }
    ;
    Ta.prototype.setCurrentTime = function(a) {
        this.currentTime = a
    }
    ;
    Object.defineProperty(Ta.prototype, "numNodes", {
        get: function() {
            return this._interpolatedKeys.length
        }
    });
    Ta.prototype.getNumNodes = function() {
        return this._interpolatedKeys.length
    }
    ;
    Ta.prototype.setAnimation = function(a) {
        this.animation = a
    }
    ;
    Ta.prototype.setGraph = function(a) {
        var b;
        if (this.graph = a)
            for (b = 0; b < this._interpolatedKeys.length; b++) {
                var c = a.findByName(this._interpolatedKeys[b]._name);
                this._interpolatedKeys[b].setTarget(c)
            }
        else
            for (b = 0; b < this._interpolatedKeys.length; b++)
                this._interpolatedKeys[b].setTarget(null)
    }
    ;
    Ta.prototype.updateGraph = function() {
        if (this.graph)
            for (var a = 0; a < this._interpolatedKeys.length; a++) {
                var b = this._interpolatedKeys[a];
                if (b._written) {
                    var c = b.getTarget();
                    c.localPosition.copy(b._pos);
                    c.localRotation.copy(b._quat);
                    c.localScale.copy(b._scale);
                    c._dirtyLocal || c._dirtifyLocal();
                    b._written = !1
                }
            }
    }
    ;
    Ta.prototype.setLooping = function(a) {
        this.looping = a
    }
    ;
    Ta.prototype.getLooping = function() {
        return this.looping
    }
    ;
    hd.prototype = Object.create(O.prototype);
    hd.prototype.constructor = hd;
    Object.assign(hd.prototype, {
        play: function(a, b) {
            if (this.enabled && this.entity.enabled) {
                var c = this.data;
                if (c.animations[a]) {
                    b = b || 0;
                    c.prevAnim = c.currAnim;
                    c.currAnim = a;
                    if (c.model) {
                        c.skeleton || c.animEvaluator || this._createAnimationController();
                        a = c.animations[c.prevAnim];
                        var d = c.animations[c.currAnim];
                        c.blending = 0 < b && c.prevAnim;
                        c.blending && (c.blend = 0,
                        c.blendSpeed = 1 / b);
                        c.skeleton && (c.blending ? (c.fromSkel.animation = a,
                        c.fromSkel.addTime(c.skeleton._time),
                        c.toSkel.animation = d) : c.skeleton.animation = d);
                        if (c.animEvaluator) {
                            b = c.animEvaluator;
                            if (c.blending)
                                for (; 1 < b.clips.length; )
                                    b.removeClip(0);
                            else
                                c.animEvaluator.removeClips();
                            b = new wf(c.animations[c.currAnim],0,1,!0,c.loop);
                            b.name = c.currAnim;
                            b.blendWeight = c.blending ? 0 : 1;
                            b.reset();
                            c.animEvaluator.addClip(b)
                        }
                    }
                    c.playing = !0
                }
            }
        },
        getAnimation: function(a) {
            return this.data.animations[a]
        },
        setModel: function(a) {
            var b = this.data;
            a !== b.model && (this._resetAnimationController(),
            b.model = a,
            b.animations && b.currAnim && b.animations[b.currAnim] && this.play(b.currAnim))
        },
        _resetAnimationController: function() {
            var a = this.data;
            a.skeleton = null;
            a.fromSkel = null;
            a.toSkel = null;
            a.animEvaluator = null
        },
        _createAnimationController: function() {
            var a = this.data, b = a.model, c = a.animations, d = !1, e = !1, f;
            for (f in c)
                c.hasOwnProperty(f) && (c[f].constructor === Kd ? e = !0 : d = !0);
            b = b.getGraph();
            d ? (a.fromSkel = new Ta(b),
            a.toSkel = new Ta(b),
            a.skeleton = new Ta(b),
            a.skeleton.looping = a.loop,
            a.skeleton.setGraph(b)) : e && (a.animEvaluator = new Ja(new xf(b)))
        },
        loadAnimationAssets: function(a) {
            if (a && a.length) {
                var b = this, c = this.system.app.assets, d, e = a.length, f = function(h) {
                    if (1 < h.resources.length)
                        for (var l = 0; l < h.resources.length; l++)
                            b.animations[h.resources[l].name] = h.resources[l],
                            b.animationsIndex[h.id] = h.resources[l].name;
                    else
                        b.animations[h.name] = h.resource,
                        b.animationsIndex[h.id] = h.name;
                    b.animations = b.animations
                }, g = function(h) {
                    h.off("change", b.onAssetChanged, b);
                    h.on("change", b.onAssetChanged, b);
                    h.off("remove", b.onAssetRemoved, b);
                    h.on("remove", b.onAssetRemoved, b);
                    h.resource ? f(h) : (h.once("load", f, b),
                    b.enabled && b.entity.enabled && c.load(h))
                };
                for (d = 0; d < e; d++) {
                    var k = c.get(a[d]);
                    if (k)
                        g(k);
                    else
                        c.on("add:" + a[d], g)
                }
            }
        },
        onAssetChanged: function(a, b, c, d) {
            if ("resource" === b || "resources" === b)
                if (c) {
                    if (1 < c.length) {
                        if (d && 1 < d.length)
                            for (b = 0; b < d.length; b++)
                                delete this.animations[d[b].name];
                        else
                            delete this.animations[a.name];
                        d = !1;
                        for (b = 0; b < c.length; b++)
                            this.animations[c[b].name] = c[b],
                            !d && this.data.currAnim === c[b].name && this.data.playing && this.data.enabled && this.entity.enabled && (d = !0,
                            this.play(c[b].name, 0))
                    } else {
                        if (d && 1 < d.length)
                            for (b = 0; b < d.length; b++)
                                delete this.animations[d[b].name];
                        this.animations[a.name] = c[0] || c;
                        d = !1;
                        this.data.currAnim === a.name && this.data.playing && this.data.enabled && this.entity.enabled && (d = !0,
                        this.play(a.name, 0))
                    }
                    d || (this._stopCurrentAnimation(),
                    this.onSetAnimations());
                    this.animationsIndex[a.id] = a.name
                } else {
                    if (1 < d.length)
                        for (b = 0; b < d.length; b++)
                            delete this.animations[d[b].name];
                    else
                        delete this.animations[a.name];
                    delete this.animationsIndex[a.id]
                }
        },
        onAssetRemoved: function(a) {
            a.off("remove", this.onAssetRemoved, this);
            if (this.animations) {
                if (1 < a.resources.length)
                    for (var b = 0; b < a.resources.length; b++)
                        delete this.animations[a.resources[b].name],
                        this.data.currAnim === a.resources[b].name && this._stopCurrentAnimation();
                else
                    delete this.animations[a.name],
                    this.data.currAnim === a.name && this._stopCurrentAnimation();
                delete this.animationsIndex[a.id]
            }
        },
        _stopCurrentAnimation: function() {
            var a = this.data;
            a.currAnim = null;
            a.playing = !1;
            a.skeleton && (a.skeleton.currentTime = 0,
            a.skeleton.animation = null);
            a.animEvaluator && a.animEvaluator.removeClips()
        },
        onSetAnimations: function(a, b, c) {
            a = this.data;
            (b = this.entity.model) && (b = b.model) && b !== a.model && this.setModel(b);
            if (!a.currAnim && a.activate && a.enabled && this.entity.enabled)
                for (var d in a.animations) {
                    this.play(d, 0);
                    break
                }
        },
        onSetAssets: function(a, b, c) {
            if (b && b.length)
                for (a = 0; a < b.length; a++)
                    if (b[a]) {
                        var d = this.system.app.assets.get(b[a]);
                        if (d) {
                            d.off("change", this.onAssetChanged, this);
                            d.off("remove", this.onAssetRemoved, this);
                            var e = this.animationsIndex[d.id];
                            this.data.currAnim === e && this._stopCurrentAnimation();
                            delete this.animations[e];
                            delete this.animationsIndex[d.id]
                        }
                    }
            b = c.map(function(f) {
                return f instanceof aa ? f.id : f
            });
            this.loadAnimationAssets(b)
        },
        onSetLoop: function(a, b, c) {
            a = this.data;
            a.skeleton && (a.skeleton.looping = a.loop);
            if (a.animEvaluator)
                for (b = 0; b < a.animEvaluator.clips.length; ++b)
                    a.animEvaluator.clips[b].loop = a.loop
        },
        onSetCurrentTime: function(a, b, c) {
            a = this.data;
            a.skeleton && (b = a.skeleton,
            b.currentTime = c,
            b.addTime(0),
            b.updateGraph());
            if (a.animEvaluator)
                for (a = a.animEvaluator,
                b = 0; b < a.clips.length; ++b)
                    a.clips[b].time = c
        },
        onEnable: function() {
            O.prototype.onEnable.call(this);
            var a = this.data
              , b = a.assets
              , c = this.system.app.assets;
            if (b)
                for (var d = 0, e = b.length; d < e; d++) {
                    var f = b[d];
                    f instanceof aa || (f = c.get(f));
                    f && !f.resource && c.load(f)
                }
            if (a.activate && !a.currAnim)
                for (var g in a.animations) {
                    this.play(g, 0);
                    break
                }
        },
        onBeforeRemove: function() {
            for (var a = 0; a < this.assets.length; a++) {
                var b = this.system.app.assets.get(this.assets[a]);
                b && (b.off("change", this.onAssetChanged, this),
                b.off("remove", this.onAssetRemoved, this))
            }
            a = this.data;
            delete a.animation;
            delete a.skeleton;
            delete a.fromSkel;
            delete a.toSkel;
            delete a.animEvaluator
        }
    });
    Object.defineProperties(hd.prototype, {
        currentTime: {
            get: function() {
                var a = this.data;
                return a.skeleton ? this.data.skeleton._time : a.animEvaluator && (a = a.animEvaluator.clips,
                0 < a.length) ? a[a.length - 1].time : 0
            },
            set: function(a) {
                var b = this.data;
                if (b.skeleton) {
                    var c = b.skeleton;
                    c.currentTime = a;
                    c.addTime(0);
                    c.updateGraph()
                }
                if (b.animEvaluator)
                    for (b = b.animEvaluator,
                    c = 0; c < b.clips.length; ++c)
                        b.clips[c].time = a
            }
        },
        duration: {
            get: function() {
                return this.data.animations[this.data.currAnim].duration
            }
        }
    });
    var el = "enabled assets speed loop activate animations skeleton model prevAnim currAnim fromSkel toSkel blending blendTimeRemaining playing".split(" ");
    we.prototype = Object.create(H.prototype);
    we.prototype.constructor = we;
    O._buildAccessors(hd.prototype, el);
    Object.assign(we.prototype, {
        initializeComponentData: function(a, b, c) {
            c = ["activate", "enabled", "loop", "speed", "assets"];
            H.prototype.initializeComponentData.call(this, a, b, c)
        },
        cloneComponent: function(a, b) {
            var c;
            this.addComponent(b, {});
            b.animation.assets = a.animation.assets.slice();
            b.animation.data.speed = a.animation.speed;
            b.animation.data.loop = a.animation.loop;
            b.animation.data.activate = a.animation.activate;
            b.animation.data.enabled = a.animation.enabled;
            var d = {}
              , e = a.animation.animations;
            for (c in e)
                e.hasOwnProperty(c) && (d[c] = e[c]);
            b.animation.animations = d;
            d = {};
            a = a.animation.animationsIndex;
            for (c in a)
                a.hasOwnProperty(c) && (d[c] = a[c]);
            b.animation.animationsIndex = d
        },
        onBeforeRemove: function(a, b) {
            b.onBeforeRemove()
        },
        onUpdate: function(a) {
            var b = this.store, c;
            for (c in b)
                if (b.hasOwnProperty(c)) {
                    var d = b[c]
                      , e = d.data;
                    if (e.enabled && d.entity.enabled) {
                        e.blending && (e.blend += a * e.blendSpeed,
                        1 <= e.blend && (e.blend = 1));
                        e.playing && (d = e.skeleton,
                        null !== d && null !== e.model && (e.blending ? d.blend(e.fromSkel, e.toSkel, e.blend) : (d.addTime(a * e.speed),
                        0 < e.speed && d._time === d._animation.duration && !e.loop ? e.playing = !1 : 0 > e.speed && 0 === d._time && !e.loop && (e.playing = !1)),
                        e.blending && 1 === e.blend && (d.animation = e.toSkel._animation),
                        d.updateGraph()));
                        if (d = e.animEvaluator) {
                            for (var f = 0; f < d.clips.length; ++f) {
                                var g = d.clips[f];
                                g.speed = e.speed;
                                e.playing ? g.resume() : g.pause()
                            }
                            e.blending && (d.clips[1].blendWeight = e.blend);
                            d.update(a)
                        }
                        e.blending && 1 === e.blend && (e.blending = !1)
                    }
                }
        }
    });
    Ua.prototype = Object.create(xf.prototype);
    Ua.prototype.constructor = Ua;
    Ua._packFloat = function(a) {
        return a[0]
    }
    ;
    Ua._packBoolean = function(a) {
        return !!a[0]
    }
    ;
    Ua._packVec2 = function() {
        var a = new P;
        return function(b) {
            a.x = b[0];
            a.y = b[1];
            return a
        }
    }();
    Ua._packVec3 = function() {
        var a = new z;
        return function(b) {
            a.x = b[0];
            a.y = b[1];
            a.z = b[2];
            return a
        }
    }();
    Ua._packVec4 = function() {
        var a = new X;
        return function(b) {
            a.x = b[0];
            a.y = b[1];
            a.z = b[2];
            a.w = b[3];
            return a
        }
    }();
    Ua._packColor = function() {
        var a = new L;
        return function(b) {
            a.r = b[0];
            a.g = b[1];
            a.b = b[2];
            a.a = b[3];
            return a
        }
    }();
    Ua._packQuat = function() {
        var a = new Y;
        return function(b) {
            a.x = b[0];
            a.y = b[1];
            a.z = b[2];
            a.w = b[3];
            return a
        }
    }();
    Object.assign(Ua.prototype, {
        resolve: function(a) {
            var b = this.propertyLocator.decode(a);
            a = b[0];
            var c = b[1];
            b = b[2];
            var d = this._getEntityFromHierarchy(a);
            if (!d)
                return null;
            switch (c) {
            case "entity":
                a = d;
                break;
            case "graph":
                if (!this.nodes || !this.nodes[a[0]])
                    return null;
                a = this.nodes[a[0]].node;
                break;
            default:
                if (a = d.findComponent(c),
                !a)
                    return null
            }
            return this._createAnimTargetForProperty(a, b)
        },
        update: function(a) {
            if (a = this.activeNodes)
                for (var b = 0; b < a.length; b++)
                    a[b]._dirtifyLocal()
        },
        _getEntityFromHierarchy: function(a) {
            if (!this.animComponent.entity.name === a[0])
                return null;
            var b = this.animComponent.entity;
            return 1 === a.length ? b : b._parent.findByPath(a.join("/"))
        },
        _resolvePath: function(a, b, c) {
            c = b.length - (c ? 0 : 1);
            for (var d = 0; d < c; d++)
                a = a[b[d]];
            return a
        },
        _setter: function(a, b, c) {
            var d = this._resolvePath(a, b)
              , e = b[b.length - 1]
              , f = "set" + e.substring(0, 1).toUpperCase() + e.substring(1);
            if (d[f]) {
                var g = d[f].bind(d);
                return function(n) {
                    g(c(n))
                }
            }
            var k = d[e];
            if ("object" === typeof k && k.hasOwnProperty("copy"))
                return function(n) {
                    k.copy(c(n))
                }
                ;
            if (-1 !== [P, z, X, L, Y].indexOf(d.constructor) && 1 < b.length) {
                var h = 2 < b.length ? this._resolvePath(a, b.slice(0, -1)) : a
                  , l = b[b.length - 2];
                return function(n) {
                    d[e] = c(n);
                    h[l] = d
                }
            }
            return function(n) {
                d[e] = c(n)
            }
        },
        _createAnimTargetForProperty: function(a, b) {
            if (this.handlers && "weights" === b[0])
                return this.handlers.weights(a);
            if (this.handlers && "material" === b[0] && 2 === b.length) {
                var c = b[1];
                if (c.indexOf("Map") === c.length - 3)
                    return this.handlers.materialTexture(a, c)
            }
            c = this._resolvePath(a, b, !0);
            if ("undefined" === typeof c)
                return null;
            if ("number" === typeof c) {
                var d = this._setter(a, b, Ua._packFloat);
                var e = "vector";
                var f = 1
            } else if ("boolean" === typeof c)
                d = this._setter(a, b, Ua._packBoolean),
                e = "vector",
                f = 1;
            else if ("object" === typeof c)
                switch (c.constructor) {
                case P:
                    d = this._setter(a, b, Ua._packVec2);
                    e = "vector";
                    f = 2;
                    break;
                case z:
                    d = this._setter(a, b, Ua._packVec3);
                    e = "vector";
                    f = 3;
                    break;
                case X:
                    d = this._setter(a, b, Ua._packVec4);
                    e = "vector";
                    f = 4;
                    break;
                case L:
                    d = this._setter(a, b, Ua._packColor);
                    e = "vector";
                    f = 4;
                    break;
                case Y:
                    d = this._setter(a, b, Ua._packQuat);
                    e = "quaternion";
                    f = 4;
                    break;
                default:
                    return null
                }
            return -1 !== b.indexOf("material") ? new Ic(function(g) {
                d(g);
                a.material.update()
            }
            ,e,f) : new Ic(d,e,f)
        }
    });
    Object.assign(Rg.prototype, {
        play: function(a) {
            this._controller.play(a)
        },
        pause: function() {
            this._controller.pause()
        },
        reset: function() {
            this._controller.reset()
        },
        update: function(a) {
            this._controller.update(a)
        },
        assignAnimation: function(a, b) {
            b.constructor === Kd && (this._controller.assignAnimation(a, b),
            this._component.activate && this._component.playable && (this._component.playing = !0))
        },
        removeNodeAnimations: function(a) {
            this._controller.removeNodeAnimations(a);
            this._component.playing = !1
        }
    });
    Object.defineProperties(Rg.prototype, {
        name: {
            get: function() {
                return this._name
            }
        },
        playing: {
            get: function() {
                return this._controller.playing
            },
            set: function(a) {
                this._controller.playing = a
            }
        },
        playable: {
            get: function() {
                return this._controller.playable
            }
        },
        activeState: {
            get: function() {
                return this._controller.activeStateName
            }
        },
        previousState: {
            get: function() {
                return this._controller.previousStateName
            }
        },
        activeStateProgress: {
            get: function() {
                return this._controller.activeStateProgress
            }
        },
        activeStateDuration: {
            get: function() {
                return this._controller.activeStateDuration
            }
        },
        activeStateCurrentTime: {
            get: function() {
                return this._controller.activeStateCurrentTime
            },
            set: function(a) {
                this._controller.activeStateCurrentTime = a
            }
        },
        transitioning: {
            get: function() {
                return this._controller.transitioning
            }
        },
        transitionProgress: {
            get: function() {
                return this.transitioning ? this._controller.transitionProgress : null
            }
        },
        states: {
            get: function() {
                return this._controller.states
            }
        }
    });
    Object.defineProperties(fl.prototype, {
        name: {
            get: function() {
                return this._name
            }
        },
        animations: {
            get: function() {
                return this._animations
            },
            set: function(a) {
                this._animations = a
            }
        },
        speed: {
            get: function() {
                return this._speed
            }
        },
        loop: {
            get: function() {
                return this._loop
            }
        },
        playable: {
            get: function() {
                return 0 < this.animations.length || "START" === this.name || "END" === this.name
            }
        },
        looping: {
            get: function() {
                if (0 < this.animations.length) {
                    var a = this._controller.animEvaluator.findClip(this.name + "." + this.animations[0].animTrack.name);
                    if (a)
                        return a.loop
                }
                return !1
            }
        },
        totalWeight: {
            get: function() {
                var a = 0, b;
                for (b = 0; b < this.animations.length; b++)
                    a += this.animations[b].weight;
                return a
            }
        },
        timelineDuration: {
            get: function() {
                var a = 0, b;
                for (b = 0; b < this.animations.length; b++) {
                    var c = this.animations[b];
                    c.animTrack.duration > a && (a = c.animTrack.duration > a)
                }
                return a
            }
        }
    });
    Object.defineProperties(hj.prototype, {
        from: {
            get: function() {
                return this._from
            }
        },
        to: {
            get: function() {
                return this._to
            }
        },
        time: {
            get: function() {
                return this._time
            }
        },
        priority: {
            get: function() {
                return this._priority
            }
        },
        conditions: {
            get: function() {
                return this._conditions
            }
        },
        exitTime: {
            get: function() {
                return this._exitTime
            }
        },
        transitionOffset: {
            get: function() {
                return this._transitionOffset
            }
        },
        interruptionSource: {
            get: function() {
                return this._interruptionSource
            }
        },
        hasExitTime: {
            get: function() {
                return !!this.exitTime
            }
        },
        hasConditionsMet: {
            get: function() {
                var a = !0, b;
                for (b = 0; b < this.conditions.length; b++) {
                    var c = this.conditions[b]
                      , d = this._controller.findParameter(c.parameterName);
                    switch (c.predicate) {
                    case "GREATER_THAN":
                        a = a && d.value > c.value;
                        break;
                    case "LESS_THAN":
                        a = a && d.value < c.value;
                        break;
                    case "GREATER_THAN_EQUAL_TO":
                        a = a && d.value >= c.value;
                        break;
                    case "LESS_THAN_EQUAL_TO":
                        a = a && d.value <= c.value;
                        break;
                    case "EQUAL_TO":
                        a = a && d.value === c.value;
                        break;
                    case "NOT_EQUAL_TO":
                        a = a && d.value !== c.value
                    }
                    if (!a)
                        break
                }
                return a
            }
        }
    });
    Object.defineProperties(Sg.prototype, {
        animEvaluator: {
            get: function() {
                return this._animEvaluator
            }
        },
        activeState: {
            get: function() {
                return this._findState(this._activeStateName)
            },
            set: function(a) {
                this._activeStateName = a
            }
        },
        activeStateName: {
            get: function() {
                return this._activeStateName
            }
        },
        activeStateAnimations: {
            get: function() {
                return this.activeState.animations
            }
        },
        previousState: {
            get: function() {
                return this._findState(this._previousStateName)
            },
            set: function(a) {
                this._previousStateName = a
            }
        },
        previousStateName: {
            get: function() {
                return this._previousStateName
            }
        },
        playable: {
            get: function() {
                var a = !0, b;
                for (b = 0; b < this._stateNames.length; b++)
                    this._states[this._stateNames[b]].playable || (a = !1);
                return a
            }
        },
        playing: {
            get: function() {
                return this._playing
            },
            set: function(a) {
                this._playing = a
            }
        },
        activeStateProgress: {
            get: function() {
                return this._getActiveStateProgressForTime(this._timeInState)
            }
        },
        activeStateDuration: {
            get: function() {
                if ("START" === this.activeStateName || "END" === this.activeStateName)
                    return 0;
                for (var a = 0, b = 0; b < this.activeStateAnimations.length; b++) {
                    var c = this._animEvaluator.findClip(this.activeStateAnimations[b].name);
                    a = Math.max(a, c.track.duration)
                }
                return a
            }
        },
        activeStateCurrentTime: {
            get: function() {
                return this._timeInState
            },
            set: function(a) {
                this._timeInState = this._timeInStateBefore = a;
                for (var b = 0; b < this.activeStateAnimations.length; b++) {
                    var c = this.animEvaluator.findClip(this.activeStateAnimations[b].name);
                    c && (c.time = a)
                }
            }
        },
        transitioning: {
            get: function() {
                return this._isTransitioning
            }
        },
        transitionProgress: {
            get: function() {
                return this._currTransitionTime / this._totalTransitionTime
            }
        },
        states: {
            get: function() {
                return this._stateNames
            }
        }
    });
    Object.assign(Sg.prototype, {
        _findState: function(a) {
            return this._states[a]
        },
        _getActiveStateProgressForTime: function(a) {
            if ("START" === this.activeStateName || "END" === this.activeStateName)
                return 1;
            var b = this._animEvaluator.findClip(this.activeStateAnimations[0].name);
            return b ? a / b.track.duration : null
        },
        _findTransitionsFromState: function(a) {
            var b = this._findTransitionsFromStateCache[a];
            b || (b = this._transitions.filter(function(c) {
                return c.from === a
            }),
            b.sort(function(c, d) {
                return c.priority < d.priority
            }),
            this._findTransitionsFromStateCache[a] = b);
            return b
        },
        _findTransitionsBetweenStates: function(a, b) {
            var c = this._findTransitionsBetweenStatesCache[a + "->" + b];
            c || (c = this._transitions.filter(function(d) {
                return d.from === a && d.to === b
            }),
            c.sort(function(d, e) {
                return d.priority < e.priority
            }),
            this._findTransitionsBetweenStatesCache[a + "->" + b] = c);
            return c
        },
        _findTransition: function(a, b) {
            var c = [];
            if (a && b)
                c.concat(this._findTransitionsBetweenStates(a, b));
            else if (this._isTransitioning)
                switch (this._transitionInterruptionSource) {
                case "PREV_STATE":
                    c = c.concat(this._findTransitionsFromState(this._previousStateName));
                    c = c.concat(this._findTransitionsFromState("ANY"));
                    break;
                case "NEXT_STATE":
                    c = c.concat(this._findTransitionsFromState(this._activeStateName));
                    c = c.concat(this._findTransitionsFromState("ANY"));
                    break;
                case "PREV_STATE_NEXT_STATE":
                    c = c.concat(this._findTransitionsFromState(this._previousStateName));
                    c = c.concat(this._findTransitionsFromState(this._activeStateName));
                    c = c.concat(this._findTransitionsFromState("ANY"));
                    break;
                case "NEXT_STATE_PREV_STATE":
                    c = c.concat(this._findTransitionsFromState(this._activeStateName)),
                    c = c.concat(this._findTransitionsFromState(this._previousStateName)),
                    c = c.concat(this._findTransitionsFromState("ANY"))
                }
            else
                c = c.concat(this._findTransitionsFromState(this._activeStateName)),
                c = c.concat(this._findTransitionsFromState("ANY"));
            c = c.filter(function(d) {
                if (d.to === this.activeStateName)
                    return !1;
                if (d.hasExitTime) {
                    var e = this._getActiveStateProgressForTime(this._timeInStateBefore)
                      , f = this._getActiveStateProgressForTime(this._timeInState);
                    1 > d.exitTime && this.activeState.looping && (e -= Math.floor(e),
                    f -= Math.floor(f));
                    if (!(d.exitTime > e && d.exitTime <= f))
                        return null
                }
                return d.hasConditionsMet
            }
            .bind(this));
            return 0 < c.length ? c[0] : null
        },
        _updateStateFromTransition: function(a) {
            var b, c;
            this.previousState = a.from;
            this.activeState = a.to;
            for (b = 0; b < a.conditions.length; b++) {
                var d = this.findParameter(a.conditions[b].parameterName);
                "TRIGGER" === d.type && (d.value = !1)
            }
            if (this.previousState) {
                this._isTransitioning || (this._transitionPreviousStates = []);
                this._transitionPreviousStates.push({
                    name: this._previousStateName,
                    weight: 1
                });
                var e = this._currTransitionTime / this._totalTransitionTime;
                for (b = 0; b < this._transitionPreviousStates.length; b++) {
                    this._transitionPreviousStates[b].weight = this._isTransitioning ? b !== this._transitionPreviousStates.length - 1 ? this._transitionPreviousStates[b].weight * (1 - e) : e : 1;
                    var f = this._findState(this._transitionPreviousStates[b].name);
                    for (c = 0; c < f.animations.length; c++) {
                        var g = f.animations[c];
                        d = this._animEvaluator.findClip(g.name + ".previous." + b);
                        d || (d = this._animEvaluator.findClip(g.name),
                        d.name = g.name + ".previous." + b);
                        b !== this._transitionPreviousStates.length - 1 && d.pause()
                    }
                }
            }
            0 < a.time && (this._isTransitioning = !0,
            this._totalTransitionTime = a.time,
            this._currTransitionTime = 0,
            this._transitionInterruptionSource = a.interruptionSource);
            c = a.transitionOffset && 0 < a.transitionOffset && 1 > a.transitionOffset;
            f = this.activeState;
            for (b = 0; b < f.animations.length; b++)
                (d = this._animEvaluator.findClip(f.animations[b].name)) ? d.reset() : (d = new wf(f.animations[b].animTrack,0,f.speed,!0,f.loop),
                d.name = f.animations[b].name,
                this._animEvaluator.addClip(d)),
                d.blendWeight = 0 < a.time ? 0 : 1 / f.totalWeight,
                d.play(),
                d.time = c ? f.timelineDuration * a.transitionOffset : 0 <= f.speed ? 0 : this.activeStateDuration;
            d = b = 0;
            c && (d = b = a = f.timelineDuration * a.transitionOffset);
            this._timeInState = b;
            this._timeInStateBefore = d
        },
        _transitionToState: function(a) {
            if (a !== this._activeStateName && this._findState(a)) {
                var b = this._findTransition(this._activeStateName, a);
                b || (this._animEvaluator.removeClips(),
                b = new hj(this,null,a,0,0));
                this._updateStateFromTransition(b)
            }
        },
        assignAnimation: function(a, b) {
            var c = this._findState(a);
            c && (a = {
                name: a + "." + b.name,
                animTrack: b,
                weight: 1
            },
            0 < c.animations.length && (c.animations = [],
            this.reset()),
            c.animations.push(a),
            !this._playing && this._activate && this.playable && this.play())
        },
        removeNodeAnimations: function(a) {
            if (a = this._findState(a))
                a.animations = []
        },
        play: function(a) {
            a && this._transitionToState(a);
            this._playing = !0
        },
        pause: function() {
            this._playing = !1
        },
        reset: function() {
            this._previousStateName = null;
            this._activeStateName = "START";
            this._playing = !1;
            this._totalTransitionTime = this._currTransitionTime = 1;
            this._isTransitioning = !1;
            this._timeInStateBefore = this._timeInState = 0;
            this._animEvaluator.removeClips()
        },
        update: function(a) {
            if (this._playing) {
                var b, c, d;
                this._timeInStateBefore = this._timeInState;
                this._timeInState += a;
                (b = this._findTransition(this._activeStateName)) && this._updateStateFromTransition(b);
                if (this._isTransitioning)
                    if (this._currTransitionTime += a,
                    this._currTransitionTime <= this._totalTransitionTime) {
                        var e = this._currTransitionTime / this._totalTransitionTime;
                        for (b = 0; b < this._transitionPreviousStates.length; b++) {
                            var f = this._findState(this._transitionPreviousStates[b].name);
                            var g = this._transitionPreviousStates[b].weight;
                            for (c = 0; c < f.animations.length; c++) {
                                var k = f.animations[c];
                                if (d = this._animEvaluator.findClip(k.name + ".previous." + b))
                                    d.blendWeight = (1 - e) * k.weight / f.totalWeight * g
                            }
                        }
                        f = this.activeState;
                        for (b = 0; b < f.animations.length; b++)
                            k = f.animations[b],
                            this._animEvaluator.findClip(k.name).blendWeight = e * k.weight / f.totalWeight
                    } else {
                        this._isTransitioning = !1;
                        c = this.activeStateAnimations.length;
                        f = this._animEvaluator.clips.length;
                        for (b = 0; b < f - c; b++)
                            this._animEvaluator.removeClip(0);
                        this._transitionPreviousStates = [];
                        f = this.activeState;
                        for (b = 0; b < f.animations.length; b++)
                            if (k = f.animations[b],
                            d = this._animEvaluator.findClip(k.name))
                                d.blendWeight = k.weight / f.totalWeight
                    }
                this._animEvaluator.update(a)
            }
        },
        findParameter: function(a) {
            return this._parameters[a]
        }
    });
    id.prototype = Object.create(O.prototype);
    id.prototype.constructor = id;
    Object.assign(id.prototype, {
        loadStateGraph: function(a) {
            function b(g, k, h, l) {
                var n = new Ua(this,d);
                n = new Ja(n);
                k = new Sg(n,k,h,c.parameters,c.activate);
                c.layers.push(new Rg(g,k,this));
                c.layerIndices[g] = l
            }
            var c = this.data;
            c.stateGraph = a;
            c.parameters = a.parameters;
            c.layers = [];
            var d, e = this.entity.model;
            e && (e = e.model) && (d = e.getGraph());
            for (e = 0; e < a.layers.length; e++) {
                var f = a.layers[e];
                b.bind(this)(f.name, f.states, f.transitions, e)
            }
            this.setupAnimationAssets()
        },
        setupAnimationAssets: function() {
            for (var a = 0; a < this.data.layers.length; a++)
                for (var b = this.data.layers[a], c = b.name, d = 0; d < b.states.length; d++) {
                    var e = b.states[d];
                    "START" !== e && "END" !== e && (e = c + ":" + e,
                    this.data.animationAssets[e] || (this.data.animationAssets[e] = {
                        asset: null
                    }))
                }
            this.loadAnimationAssets()
        },
        loadAnimationAssets: function() {
            for (var a = 0; a < this.data.layers.length; a++)
                for (var b = this.data.layers[a], c = 0; c < b.states.length; c++) {
                    var d = b.states[c]
                      , e = this.data.animationAssets[b.name + ":" + d];
                    e && e.asset ? (e = this.system.app.assets.get(e.asset),
                    e.resource ? this.assignAnimation(d, e.resource, b.name) : (e.once("load", function(f, g) {
                        return function(k) {
                            this.assignAnimation(g, k.resource, f)
                        }
                        .bind(this)
                    }
                    .call(this, b.name, d)),
                    this.system.app.assets.load(e))) : this.removeNodeAnimations(d, b.name)
                }
        },
        removeStateGraph: function() {
            this.data.stateGraph = null;
            this.data.stateGraphAsset = null;
            this.data.animationAssets = {};
            this.data.layers = [];
            this.data.layerIndices = {};
            this.data.parameters = {};
            this.data.playing = !1
        },
        resetStateGraph: function() {
            if (this.stateGraphAsset) {
                var a = this.system.app.assets.get(this.stateGraphAsset).resource;
                this.loadStateGraph(a)
            } else
                this.removeStateGraph()
        },
        reset: function() {
            this.data.parameters = Object.assign({}, this.data.stateGraph.parameters);
            for (var a = 0; a < this.data.layers.length; a++) {
                var b = this.data.layers[a].playing;
                this.data.layers[a].reset();
                this.data.layers[a].playing = b
            }
        },
        findAnimationLayer: function(a) {
            return this.data.layers[this.data.layerIndices[a]] || null
        },
        assignAnimation: function(a, b, c) {
            this.data.stateGraph && (c = c ? this.findAnimationLayer(c) : this.baseLayer) && c.assignAnimation(a, b)
        },
        removeNodeAnimations: function(a, b) {
            (b = b ? this.findAnimationLayer(b) : this.baseLayer) && b.removeNodeAnimations(a)
        },
        getParameterValue: function(a, b) {
            if ((a = this.data.parameters[a]) && a.type === b)
                return a.value
        },
        setParameterValue: function(a, b, c) {
            (a = this.data.parameters[a]) && a.type === b && (a.value = c)
        },
        getFloat: function(a) {
            return this.getParameterValue(a, "FLOAT")
        },
        setFloat: function(a, b) {
            this.setParameterValue(a, "FLOAT", b)
        },
        getInteger: function(a) {
            return this.getParameterValue(a, "INTEGER")
        },
        setInteger: function(a, b) {
            "number" === typeof b && 0 === b % 1 && this.setParameterValue(a, "INTEGER", b)
        },
        getBoolean: function(a) {
            return this.getParameterValue(a, "BOOLEAN")
        },
        setBoolean: function(a, b) {
            this.setParameterValue(a, "BOOLEAN", !!b)
        },
        getTrigger: function(a) {
            return this.getParameterValue(a, "TRIGGER")
        },
        setTrigger: function(a) {
            this.setParameterValue(a, "TRIGGER", !0)
        },
        resetTrigger: function(a) {
            this.setParameterValue(a, "TRIGGER", !1)
        }
    });
    Object.defineProperties(id.prototype, {
        stateGraphAsset: {
            get: function() {
                return this.data.stateGraphAsset
            },
            set: function(a) {
                if (null === a)
                    this.removeStateGraph();
                else {
                    if (a instanceof aa) {
                        var b = a.id;
                        var c = this.system.app.assets.get(b);
                        c || (this.system.app.assets.add(a),
                        c = this.system.app.assets.get(b))
                    } else
                        b = a,
                        c = this.system.app.assets.get(b);
                    c && this.data.stateGraphAsset !== b && (c.resource ? (this.data.stateGraph = c.resource,
                    this.loadStateGraph(this.data.stateGraph),
                    c.on("change", function(d) {
                        this.data.stateGraph = new yf(d._data);
                        this.loadStateGraph(this.data.stateGraph)
                    }
                    .bind(this))) : (c.once("load", function(d) {
                        this.data.stateGraph = d.resource;
                        this.loadStateGraph(this.data.stateGraph)
                    }
                    .bind(this)),
                    c.on("change", function(d) {
                        this.data.stateGraph = new yf(d._data);
                        this.loadStateGraph(this.data.stateGraph)
                    }
                    .bind(this)),
                    this.system.app.assets.load(c)),
                    this.data.stateGraphAsset = b)
                }
            }
        },
        animationAssets: {
            get: function() {
                return this.data.animationAssets
            },
            set: function(a) {
                this.data.animationAssets = a;
                this.loadAnimationAssets()
            }
        },
        playable: {
            get: function() {
                for (var a = 0; a < this.data.layers.length; a++)
                    if (!this.data.layers[a].playable)
                        return !1;
                return !0
            }
        },
        baseLayer: {
            get: function() {
                return 0 < this.data.layers.length ? this.data.layers[0] : null
            }
        }
    });
    var gl = ["enabled", "speed", "activate", "playing"];
    xe.prototype = Object.create(H.prototype);
    xe.prototype.constructor = xe;
    O._buildAccessors(id.prototype, gl);
    Object.assign(xe.prototype, {
        initializeComponentData: function(a, b, c) {
            c = ["activate", "enabled", "speed", "playing"];
            H.prototype.initializeComponentData.call(this, a, b, c);
            b.stateGraphAsset && (a.stateGraphAsset = b.stateGraphAsset);
            b.animationAssets && (a.animationAssets = Object.assign(a.data.animationAssets, b.animationAssets))
        },
        onAnimationUpdate: function(a) {
            var b = this.store, c;
            for (c in b)
                if (b.hasOwnProperty(c)) {
                    var d = b[c]
                      , e = d.data;
                    if (e.enabled && d.entity.enabled && e.playing)
                        for (d = 0; d < e.layers.length; d++)
                            e.layers[d].update(a * e.speed)
                }
        }
    });
    Od.prototype = Object.create(O.prototype);
    Od.prototype.constructor = Od;
    Object.assign(Od.prototype, {
        setCurrentListener: function() {
            if (this.enabled && this.entity.audiolistener && this.entity.enabled) {
                this.system.current = this.entity;
                var a = this.system.current.getPosition();
                this.system.manager.listener.setPosition(a)
            }
        },
        onEnable: function() {
            this.setCurrentListener()
        },
        onDisable: function() {
            this.system.current === this.entity && (this.system.current = null)
        }
    });
    var hl = ["enabled"];
    ye.prototype = Object.create(H.prototype);
    ye.prototype.constructor = ye;
    O._buildAccessors(Od.prototype, hl);
    Object.assign(ye.prototype, {
        initializeComponentData: function(a, b, c) {
            c = ["enabled"];
            H.prototype.initializeComponentData.call(this, a, b, c)
        },
        onUpdate: function(a) {
            this.current && (a = this.current.getPosition(),
            this.manager.listener.setPosition(a),
            a = this.current.getWorldTransform(),
            this.manager.listener.setOrientation(a))
        }
    });
    Pd.prototype = Object.create(O.prototype);
    Pd.prototype.constructor = Pd;
    Object.assign(Pd.prototype, {
        play: function(a) {
            if (this.enabled && this.entity.enabled) {
                this.channel && this.stop();
                var b = this.data;
                if (b.sources[a]) {
                    if (b["3d"]) {
                        var c = this.entity.getPosition();
                        c = this.system.manager.playSound3d(b.sources[a], c, b)
                    } else
                        c = this.system.manager.playSound(b.sources[a], b);
                    b.currentSource = a;
                    b.channel = c
                }
            }
        },
        pause: function() {
            this.channel && this.channel.pause()
        },
        unpause: function() {
            this.channel && this.channel.paused && this.channel.unpause()
        },
        stop: function() {
            this.channel && (this.channel.stop(),
            this.channel = null)
        },
        onSetAssets: function(a, b, c) {
            a = [];
            var d, e = c.length;
            if (b && b.length)
                for (d = 0; d < b.length; d++)
                    if (b[d]) {
                        var f = this.system.app.assets.get(b[d]);
                        f && (f.off("change", this.onAssetChanged, this),
                        f.off("remove", this.onAssetRemoved, this),
                        this.currentSource === f.name && this.stop())
                    }
            if (e)
                for (d = 0; d < e; d++)
                    0 > b.indexOf(c[d]) && (c[d]instanceof aa ? a.push(c[d].id) : a.push(c[d]));
            !this.system._inTools && a.length && this.loadAudioSourceAssets(a)
        },
        onAssetChanged: function(a, b, c, d) {
            "resource" === b && this.data.sources && (this.data.sources[a.name] = c,
            this.data.currentSource === a.name && this.channel && (this.channel.paused ? (this.play(a.name),
            this.pause()) : this.play(a.name)))
        },
        onAssetRemoved: function(a) {
            a.off("remove", this.onAssetRemoved, this);
            this.data.sources[a.name] && (delete this.data.sources[a.name],
            this.data.currentSource === a.name && (this.stop(),
            this.data.currentSource = null))
        },
        onSetLoop: function(a, b, c) {
            b != c && this.channel && this.channel.setLoop(c)
        },
        onSetVolume: function(a, b, c) {
            b != c && this.channel && this.channel.setVolume(c)
        },
        onSetPitch: function(a, b, c) {
            b != c && this.channel && this.channel.setPitch(c)
        },
        onSetMaxDistance: function(a, b, c) {
            b != c && this.channel instanceof $a && this.channel.setMaxDistance(c)
        },
        onSetMinDistance: function(a, b, c) {
            b != c && this.channel instanceof $a && this.channel.setMinDistance(c)
        },
        onSetRollOffFactor: function(a, b, c) {
            b != c && this.channel instanceof $a && this.channel.setRollOffFactor(c)
        },
        onSetDistanceModel: function(a, b, c) {
            b !== c && this.channel instanceof $a && this.channel.setDistanceModel(c)
        },
        onSet3d: function(a, b, c) {
            b !== c && this.system.initialized && this.currentSource && (b = a = !1,
            this.channel && (a = this.channel.paused,
            b = this.channel.suspended),
            this.play(this.currentSource),
            this.channel && (this.channel.paused = a,
            this.channel.suspended = b))
        },
        onEnable: function() {
            var a = this.data.assets;
            if (a)
                for (var b = this.system.app.assets, c = 0, d = a.length; c < d; c++) {
                    var e = a[c];
                    e instanceof aa || (e = b.get(e));
                    e && !e.resource && b.load(e)
                }
            this.system.initialized && (this.data.activate && !this.channel ? this.play(this.currentSource) : this.unpause())
        },
        onDisable: function() {
            this.pause()
        },
        loadAudioSourceAssets: function(a) {
            var b = this
              , c = a.map(function(h) {
                return this.system.app.assets.get(h)
            }, this)
              , d = {}
              , e = null
              , f = c.length
              , g = function(h) {
                f--
            }
              , k = function() {
                this.data.sources = d;
                this.data.currentSource = e;
                if (this.enabled && this.activate && e)
                    this.onEnable()
            }
            .bind(this);
            c.forEach(function(h, l) {
                h ? (e = e || h.name,
                h.off("change", this.onAssetChanged, this),
                h.on("change", this.onAssetChanged, this),
                h.off("remove", this.onAssetRemoved, this),
                h.on("remove", this.onAssetRemoved, this),
                h.off("error", g, this),
                h.on("error", g, this),
                h.ready(function(n) {
                    d[n.name] = n.resource;
                    f--;
                    0 === f && k()
                }),
                !h.resource && b.enabled && b.entity.enabled && this.system.app.assets.load(h)) : (f--,
                0 === f && k(),
                this.system.app.assets.on("add:" + a[l], function(n) {
                    n.ready(function(p) {
                        b.data.sources[p.name] = p.resource
                    });
                    n.resource || b.system.app.assets.load(n)
                }))
            }, this)
        }
    });
    var il = "enabled assets volume pitch loop activate 3d minDistance maxDistance rollOffFactor distanceModel sources currentSource channel".split(" ");
    ze.prototype = Object.create(H.prototype);
    ze.prototype.constructor = ze;
    O._buildAccessors(Pd.prototype, il);
    Object.assign(ze.prototype, {
        initializeComponentData: function(a, b, c) {
            c = "activate volume pitch loop 3d minDistance maxDistance rollOffFactor distanceModel enabled assets".split(" ");
            H.prototype.initializeComponentData.call(this, a, b, c);
            a.paused = !(a.enabled && a.activate)
        },
        onInitialize: function(a) {
            a.audiosource && a.enabled && a.audiosource.enabled && a.audiosource.activate && a.audiosource.play(a.audiosource.currentSource);
            a = a._children;
            var b, c = a.length;
            for (b = 0; b < c; b++)
                if (a[b]instanceof fa)
                    this.onInitialize(a[b]);
            this.initialized = !0
        },
        onUpdate: function(a) {
            a = this.store;
            for (var b in a)
                if (a.hasOwnProperty(b)) {
                    var c = a[b]
                      , d = c.entity;
                    c = c.data;
                    c.enabled && d.enabled && c.channel instanceof $a && (d = d.getPosition(),
                    c.channel.setPosition(d))
                }
        },
        onRemove: function(a, b) {
            b.channel && (b.channel.stop(),
            b.channel = null)
        },
        setVolume: function(a) {
            this.manager.setVolume(a)
        }
    });
    Object.assign(Kc.prototype, {
        _configureEventListeners: function(a, b) {
            a = this._parseEventListenerConfig(a, "external", this._parentComponent);
            b = this._parseEventListenerConfig(b, "internal", this);
            this._eventListenerConfigs = a.concat(b);
            this._listenerStatusFlags = {};
            this._gainListeners = {};
            this._loseListeners = {}
        },
        _parseEventListenerConfig: function(a, b, c) {
            return Object.keys(a).map(function(d, e) {
                var f = d.split("#")
                  , g = f[0]
                  , k = f[1]
                  , h = a[d];
                if (2 !== f.length || "string" !== typeof g || 0 === g.length || "string" !== typeof k || 0 === k.length)
                    throw Error("Invalid event listener description: `" + d + "`");
                if ("function" !== typeof h)
                    throw Error("Invalid or missing callback for event listener `" + d + "`");
                return {
                    id: b + "_" + e + "_" + d,
                    sourceName: g,
                    eventName: k,
                    callback: h,
                    scope: c
                }
            }, this)
        },
        _toggleLifecycleListeners: function(a) {
            this._parentComponent[a]("set_" + this._entityPropertyName, this._onSetEntity, this);
            this._parentComponent.system[a]("beforeremove", this._onParentComponentRemove, this);
            H[a]("postinitialize", this._onPostInitialize, this);
            this._app[a]("tools:sceneloaded", this._onSceneLoaded, this);
            for (var b = [], c = 0; c < this._eventListenerConfigs.length; ++c) {
                var d = this._eventListenerConfigs[c]
                  , e = this._app.systems[d.sourceName];
                e && (-1 === b.indexOf(e) && b.push(e),
                e && "gain" === d.eventName && (this._gainListeners[d.sourceName] = d),
                e && "lose" === d.eventName && (this._loseListeners[d.sourceName] = d))
            }
            for (c = 0; c < b.length; ++c)
                b[c][a]("add", this._onComponentAdd, this),
                b[c][a]("beforeremove", this._onComponentRemove, this)
        },
        _onSetEntity: function(a, b, c) {
            c instanceof fa ? this._updateEntityReference() : null !== c && void 0 !== c && "string" !== typeof c ? console.warn("Entity field `" + this._entityPropertyName + "` was set to unexpected type '" + typeof c + "'") : b !== c && this._updateEntityReference()
        },
        _onPostInitialize: function() {
            this._updateEntityReference()
        },
        onParentComponentEnable: function() {
            this._entity || this._updateEntityReference()
        },
        _onSceneLoaded: function() {
            this._updateEntityReference()
        },
        _updateEntityReference: function() {
            var a = this._parentComponent.data[this._entityPropertyName];
            if (a instanceof fa) {
                var b = a;
                a = b.getGuid();
                this._parentComponent.data[this._entityPropertyName] = a
            } else
                b = this._parentComponent.system.app.root,
                b = this._parentComponent.entity.isDescendantOf(b) && a ? b.findByGuid(a) : null;
            this._entity !== b && (this._entity && this._onBeforeEntityChange(),
            (this._entity = b) && this._onAfterEntityChange())
        },
        _onBeforeEntityChange: function() {
            this._toggleEntityListeners("off");
            this._callAllGainOrLoseListeners(this._loseListeners)
        },
        _onAfterEntityChange: function() {
            this._toggleEntityListeners("on");
            this._callAllGainOrLoseListeners(this._gainListeners)
        },
        _onComponentAdd: function(a, b) {
            b = b.system.id;
            a === this._entity && (this._callGainOrLoseListener(b, this._gainListeners),
            this._toggleComponentListeners("on", b))
        },
        _onComponentRemove: function(a, b) {
            b = b.system.id;
            a === this._entity && (this._callGainOrLoseListener(b, this._loseListeners),
            this._toggleComponentListeners("off", b, !0))
        },
        _callAllGainOrLoseListeners: function(a) {
            for (var b in this._entity.c)
                this._callGainOrLoseListener(b, a)
        },
        _callGainOrLoseListener: function(a, b) {
            this._entity.c.hasOwnProperty(a) && b[a] && (a = b[a],
            a.callback.call(a.scope))
        },
        _toggleEntityListeners: function(a, b) {
            if (this._entity)
                for (var c = 0; c < this._eventListenerConfigs.length; ++c)
                    this._safeToggleListener(a, this._eventListenerConfigs[c], b)
        },
        _toggleComponentListeners: function(a, b, c) {
            for (var d = 0; d < this._eventListenerConfigs.length; ++d) {
                var e = this._eventListenerConfigs[d];
                e.sourceName === b && this._safeToggleListener(a, e, c)
            }
        },
        _safeToggleListener: function(a, b, c) {
            var d = "on" === a;
            if (!d || !this._listenerStatusFlags[b.id])
                if (c = this._getEventSource(b.sourceName, c))
                    c[a](b.eventName, b.callback, b.scope),
                    this._listenerStatusFlags[b.id] = d
        },
        _getEventSource: function(a, b) {
            if ("entity" === a)
                return this._entity;
            var c = this._entity[a];
            if (c)
                return c;
            b || console.warn("Entity has no component with name " + a);
            return null
        },
        _onEntityDestroy: function(a) {
            this._entity === a && (this._toggleEntityListeners("off", !0),
            this._entity = null)
        },
        _onParentComponentRemove: function(a, b) {
            b === this._parentComponent && (this._toggleLifecycleListeners("off"),
            this._toggleEntityListeners("off", !0))
        },
        hasComponent: function(a) {
            return this._entity && this._entity.c ? !!this._entity.c[a] : !1
        }
    });
    Object.defineProperty(Kc.prototype, "entity", {
        get: function() {
            return this._entity
        }
    });
    var Tg = 0
      , Ma = {
        DEFAULT: "DEFAULT",
        HOVER: "HOVER",
        PRESSED: "PRESSED",
        INACTIVE: "INACTIVE"
    }
      , bg = {};
    bg[Ma.DEFAULT] = "_defaultTint";
    bg[Ma.HOVER] = "hoverTint";
    bg[Ma.PRESSED] = "pressedTint";
    bg[Ma.INACTIVE] = "inactiveTint";
    var cg = {};
    cg[Ma.DEFAULT] = "_defaultSpriteAsset";
    cg[Ma.HOVER] = "hoverSpriteAsset";
    cg[Ma.PRESSED] = "pressedSpriteAsset";
    cg[Ma.INACTIVE] = "inactiveSpriteAsset";
    var dg = {};
    dg[Ma.DEFAULT] = "_defaultSpriteFrame";
    dg[Ma.HOVER] = "hoverSpriteFrame";
    dg[Ma.PRESSED] = "pressedSpriteFrame";
    dg[Ma.INACTIVE] = "inactiveSpriteFrame";
    Qd.prototype = Object.create(O.prototype);
    Qd.prototype.constructor = Qd;
    Object.assign(Qd.prototype, {
        _toggleLifecycleListeners: function(a, b) {
            this[a]("set_active", this._onSetActive, this);
            this[a]("set_transitionMode", this._onSetTransitionMode, this);
            this[a]("set_hoverTint", this._onSetTransitionValue, this);
            this[a]("set_pressedTint", this._onSetTransitionValue, this);
            this[a]("set_inactiveTint", this._onSetTransitionValue, this);
            this[a]("set_hoverSpriteAsset", this._onSetTransitionValue, this);
            this[a]("set_hoverSpriteFrame", this._onSetTransitionValue, this);
            this[a]("set_pressedSpriteAsset", this._onSetTransitionValue, this);
            this[a]("set_pressedSpriteFrame", this._onSetTransitionValue, this);
            this[a]("set_inactiveSpriteAsset", this._onSetTransitionValue, this);
            this[a]("set_inactiveSpriteFrame", this._onSetTransitionValue, this);
            b.app.systems.element[a]("add", this._onElementComponentAdd, this);
            b.app.systems.element[a]("beforeremove", this._onElementComponentRemove, this)
        },
        _onSetActive: function(a, b, c) {
            b !== c && this._updateVisualState()
        },
        _onSetTransitionMode: function(a, b, c) {
            b !== c && (this._cancelTween(),
            this._resetToDefaultVisualState(b),
            this._forceReapplyVisualState())
        },
        _onSetTransitionValue: function(a, b, c) {
            b !== c && this._forceReapplyVisualState()
        },
        _onElementComponentRemove: function(a) {
            this.entity === a && this._toggleHitElementListeners("off")
        },
        _onElementComponentAdd: function(a) {
            this.entity === a && this._toggleHitElementListeners("on")
        },
        _onImageElementLose: function() {
            this._cancelTween();
            this._resetToDefaultVisualState(this.transitionMode)
        },
        _onImageElementGain: function() {
            this._storeDefaultVisualState();
            this._forceReapplyVisualState()
        },
        _toggleHitElementListeners: function(a) {
            if (this.entity.element) {
                var b = "on" === a;
                b && this._hasHitElementListeners || (this.entity.element[a]("mouseenter", this._onMouseEnter, this),
                this.entity.element[a]("mouseleave", this._onMouseLeave, this),
                this.entity.element[a]("mousedown", this._onMouseDown, this),
                this.entity.element[a]("mouseup", this._onMouseUp, this),
                this.entity.element[a]("touchstart", this._onTouchStart, this),
                this.entity.element[a]("touchend", this._onTouchEnd, this),
                this.entity.element[a]("touchleave", this._onTouchLeave, this),
                this.entity.element[a]("touchcancel", this._onTouchCancel, this),
                this.entity.element[a]("selectstart", this._onSelectStart, this),
                this.entity.element[a]("selectend", this._onSelectEnd, this),
                this.entity.element[a]("selectenter", this._onSelectEnter, this),
                this.entity.element[a]("selectleave", this._onSelectLeave, this),
                this.entity.element[a]("click", this._onClick, this),
                this._hasHitElementListeners = b)
            }
        },
        _storeDefaultVisualState: function() {
            this._imageReference.hasComponent("element") && (this._storeDefaultColor(this._imageReference.entity.element.color),
            this._storeDefaultOpacity(this._imageReference.entity.element.opacity),
            this._storeDefaultSpriteAsset(this._imageReference.entity.element.spriteAsset),
            this._storeDefaultSpriteFrame(this._imageReference.entity.element.spriteFrame))
        },
        _storeDefaultColor: function(a) {
            this._defaultTint.r = a.r;
            this._defaultTint.g = a.g;
            this._defaultTint.b = a.b
        },
        _storeDefaultOpacity: function(a) {
            this._defaultTint.a = a
        },
        _storeDefaultSpriteAsset: function(a) {
            this._defaultSpriteAsset = a
        },
        _storeDefaultSpriteFrame: function(a) {
            this._defaultSpriteFrame = a
        },
        _onSetColor: function(a) {
            this._isApplyingTint || (this._storeDefaultColor(a),
            this._forceReapplyVisualState())
        },
        _onSetOpacity: function(a) {
            this._isApplyingTint || (this._storeDefaultOpacity(a),
            this._forceReapplyVisualState())
        },
        _onSetSpriteAsset: function(a) {
            this._isApplyingSprite || (this._storeDefaultSpriteAsset(a),
            this._forceReapplyVisualState())
        },
        _onSetSpriteFrame: function(a) {
            this._isApplyingSprite || (this._storeDefaultSpriteFrame(a),
            this._forceReapplyVisualState())
        },
        _onMouseEnter: function(a) {
            this._isHovering = !0;
            this._updateVisualState();
            this._fireIfActive("mouseenter", a)
        },
        _onMouseLeave: function(a) {
            this._isPressed = this._isHovering = !1;
            this._updateVisualState();
            this._fireIfActive("mouseleave", a)
        },
        _onMouseDown: function(a) {
            this._isPressed = !0;
            this._updateVisualState();
            this._fireIfActive("mousedown", a)
        },
        _onMouseUp: function(a) {
            this._isPressed = !1;
            this._updateVisualState();
            this._fireIfActive("mouseup", a)
        },
        _onTouchStart: function(a) {
            this._isPressed = !0;
            this._updateVisualState();
            this._fireIfActive("touchstart", a)
        },
        _onTouchEnd: function(a) {
            a.event.preventDefault();
            this._isPressed = !1;
            this._updateVisualState();
            this._fireIfActive("touchend", a)
        },
        _onTouchLeave: function(a) {
            this._isPressed = !1;
            this._updateVisualState();
            this._fireIfActive("touchleave", a)
        },
        _onTouchCancel: function(a) {
            this._isPressed = !1;
            this._updateVisualState();
            this._fireIfActive("touchcancel", a)
        },
        _onSelectStart: function(a) {
            this._isPressed = !0;
            this._updateVisualState();
            this._fireIfActive("selectstart", a)
        },
        _onSelectEnd: function(a) {
            this._isPressed = !1;
            this._updateVisualState();
            this._fireIfActive("selectend", a)
        },
        _onSelectEnter: function(a) {
            this._hoveringCounter++;
            1 === this._hoveringCounter && (this._isHovering = !0,
            this._updateVisualState());
            this._fireIfActive("selectenter", a)
        },
        _onSelectLeave: function(a) {
            this._hoveringCounter--;
            0 === this._hoveringCounter && (this._isPressed = this._isHovering = !1,
            this._updateVisualState());
            this._fireIfActive("selectleave", a)
        },
        _onClick: function(a) {
            this._fireIfActive("click", a)
        },
        _fireIfActive: function(a, b) {
            this.data.active && this.fire(a, b)
        },
        _updateVisualState: function(a) {
            var b = this._visualState
              , c = this._determineVisualState();
            if ((b !== c || a) && this.enabled)
                switch (this._visualState = c,
                b === Ma.HOVER && this._fireIfActive("hoverend"),
                b === Ma.PRESSED && this._fireIfActive("pressedend"),
                c === Ma.HOVER && this._fireIfActive("hoverstart"),
                c === Ma.PRESSED && this._fireIfActive("pressedstart"),
                this.transitionMode) {
                case Tg:
                    this._applyTint(this[bg[this._visualState]]);
                    break;
                case 1:
                    this._applySprite(this[cg[this._visualState]], this[dg[this._visualState]])
                }
        },
        _forceReapplyVisualState: function() {
            this._updateVisualState(!0)
        },
        _resetToDefaultVisualState: function(a) {
            if (this._imageReference.hasComponent("element"))
                switch (a) {
                case Tg:
                    this._cancelTween();
                    this._applyTintImmediately(this._defaultTint);
                    break;
                case 1:
                    this._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame)
                }
        },
        _determineVisualState: function() {
            if (this.active) {
                if (this._isPressed)
                    return Ma.PRESSED;
                if (this._isHovering)
                    return Ma.HOVER
            } else
                return Ma.INACTIVE;
            return Ma.DEFAULT
        },
        _applySprite: function(a, b) {
            b = b || 0;
            this._imageReference.hasComponent("element") && (this._isApplyingSprite = !0,
            this._imageReference.entity.element.spriteAsset = a,
            this._imageReference.entity.element.spriteFrame = b,
            this._isApplyingSprite = !1)
        },
        _applyTint: function(a) {
            this._cancelTween();
            0 === this.fadeDuration ? this._applyTintImmediately(a) : this._applyTintWithTween(a)
        },
        _applyTintImmediately: function(a) {
            this._imageReference.hasComponent("element") && a && (this._isApplyingTint = !0,
            this._imageReference.entity.element.color = new L(a.r,a.g,a.b),
            this._imageReference.entity.element.opacity = a.a,
            this._isApplyingTint = !1)
        },
        _applyTintWithTween: function(a) {
            if (this._imageReference.hasComponent("element") && a) {
                var b = this._imageReference.entity.element.color
                  , c = this._imageReference.entity.element.opacity;
                this._tweenInfo = {
                    startTime: Lb(),
                    from: new L(b.r,b.g,b.b,c),
                    to: a.clone(),
                    lerpColor: new L
                }
            }
        },
        _updateTintTween: function() {
            var a = Lb() - this._tweenInfo.startTime;
            a = 0 === this.fadeDuration ? 1 : a / this.fadeDuration;
            a = N.clamp(a, 0, 1);
            if (1E-5 < Math.abs(a - 1)) {
                var b = this._tweenInfo.lerpColor;
                b.lerp(this._tweenInfo.from, this._tweenInfo.to, a);
                this._applyTintImmediately(new L(b.r,b.g,b.b,b.a))
            } else
                this._applyTintImmediately(this._tweenInfo.to),
                this._cancelTween()
        },
        _cancelTween: function() {
            delete this._tweenInfo
        },
        onUpdate: function() {
            this._tweenInfo && this._updateTintTween()
        },
        onEnable: function() {
            this._isHovering = !1;
            this._hoveringCounter = 0;
            this._isPressed = !1;
            this._imageReference.onParentComponentEnable();
            this._toggleHitElementListeners("on");
            this._forceReapplyVisualState()
        },
        onDisable: function() {
            this._toggleHitElementListeners("off");
            this._resetToDefaultVisualState(this.transitionMode)
        },
        onRemove: function() {
            this._toggleLifecycleListeners("off", this.system);
            this.onDisable()
        }
    });
    var ij = ["enabled", "active", {
        name: "imageEntity",
        type: "entity"
    }, {
        name: "hitPadding",
        type: "vec4"
    }, "transitionMode", {
        name: "hoverTint",
        type: "rgba"
    }, {
        name: "pressedTint",
        type: "rgba"
    }, {
        name: "inactiveTint",
        type: "rgba"
    }, "fadeDuration", "hoverSpriteAsset", "hoverSpriteFrame", "pressedSpriteAsset", "pressedSpriteFrame", "inactiveSpriteAsset", "inactiveSpriteFrame"];
    Ae.prototype = Object.create(H.prototype);
    Ae.prototype.constructor = Ae;
    O._buildAccessors(Qd.prototype, ij);
    Object.assign(Ae.prototype, {
        initializeComponentData: function(a, b, c) {
            H.prototype.initializeComponentData.call(this, a, b, ij)
        },
        onUpdate: function(a) {
            a = this.store;
            for (var b in a) {
                var c = a[b].entity
                  , d = c.button;
                if (d.enabled && c.enabled)
                    d.onUpdate()
            }
        },
        _onRemoveComponent: function(a, b) {
            b.onRemove()
        }
    });
    var mf;
    Object.assign(Ug.prototype, {
        _createOffscreenTarget: function(a, b) {
            var c = this.camera.rect
              , d = Math.floor(c.z * this.app.graphicsDevice.width * this.renderTargetScale);
            c = Math.floor(c.w * this.app.graphicsDevice.height * this.renderTargetScale);
            var e = this.app.graphicsDevice
              , f = b ? e.getHdrFormat() : 7;
            b = this.app.graphicsDevice.supportsStencil;
            var g = a ? e.samples : 1;
            d = new V(e,{
                format: f,
                width: d,
                height: c
            });
            d.name = "posteffect #" + this.effects.length;
            d.minFilter = 0;
            d.magFilter = 0;
            d.addressU = 1;
            d.addressV = 1;
            return new ra(this.app.graphicsDevice,d,{
                depth: a,
                stencil: b,
                samples: g
            })
        },
        _resizeOffscreenTarget: function(a) {
            var b = this.camera.rect
              , c = Math.floor(b.z * this.app.graphicsDevice.width * this.renderTargetScale);
            b = Math.floor(b.w * this.app.graphicsDevice.height * this.renderTargetScale);
            var d = this.app.graphicsDevice
              , e = a.colorBuffer.format;
            a._colorBuffer.destroy();
            c = new V(d,{
                format: e,
                width: c,
                height: b
            });
            c.name = "posteffect";
            c.minFilter = 0;
            c.magFilter = 0;
            c.addressU = 1;
            c.addressV = 1;
            a._colorBuffer = c;
            a.destroy()
        },
        _destroyOffscreenTarget: function(a) {
            a._colorBuffer && a._colorBuffer.destroy();
            a._depthBuffer && a._depthBuffer.destroy();
            a.destroy()
        },
        setRenderTargetScale: function(a) {
            this.renderTargetScale = a;
            this.resizeRenderTargets()
        },
        addEffect: function(a) {
            var b = this.effects
              , c = {
                effect: a,
                inputTarget: this._createOffscreenTarget(0 === this.effects.length, a.hdr),
                outputTarget: null
            };
            if (!this.layer) {
                this.layer = new ma({
                    opaqueSortMode: 0,
                    transparentSortMode: 0,
                    passThrough: !0,
                    name: "PostEffectQueue",
                    renderTarget: this.camera.renderTarget,
                    clear: !1,
                    onPostRender: function() {
                        for (var l = 0; l < this._commandList.length; l++)
                            this._commandList[l]()
                    }
                });
                var d = this.app.scene.layers.layerList, e = 0, f, g = d.length - 1;
                for (f = g; 0 <= f; f--)
                    if (4 === d[f].id) {
                        g = f - 1;
                        this._origOverrideClear = d[f].overrideClear;
                        this._origClearColorBuffer = d[f].clearColorBuffer;
                        this._origDepthColorBuffer = d[f].clearDepthBuffer;
                        this._origStencilColorBuffer = d[f].clearStencilBuffer;
                        d[f].overrideClear = !0;
                        d[f].clearColorBuffer = !1;
                        d[f].clearDepthBuffer = this.camera.clearDepthBuffer;
                        d[f].clearStencilBuffer = this.camera.clearStencilBuffer;
                        break
                    }
                this._sourceLayers = [];
                for (f = 0; f < this.camera.layers.length; f++) {
                    d = this.camera.layers[f];
                    var k = this.app.scene.layers.getLayerById(d)
                      , h = this.app.scene.layers.layerList.indexOf(k);
                    h <= g && (1 != d && (k.renderTarget = c.inputTarget,
                    this._sourceLayers.push(k)),
                    h > e && (e = h))
                }
                this.app.scene.layers.insertOpaque(this.layer, e + 1);
                this._sourceTarget = c.inputTarget;
                this.layer._commandList = [];
                this.layer.isPostEffect = !0
            }
            b.push(c);
            e = b.length;
            1 < e && (b[e - 2].outputTarget = c.inputTarget);
            this._newPostEffect = a;
            a.needsDepthBuffer && this._requestDepthMap();
            this.enable();
            this._newPostEffect = void 0
        },
        removeEffect: function(a) {
            var b, c = -1;
            var d = 0;
            for (b = this.effects.length; d < b; d++)
                if (this.effects[d].effect === a) {
                    c = d;
                    break
                }
            if (0 <= c) {
                if (0 < c)
                    this.effects[c - 1].outputTarget = c + 1 < this.effects.length ? this.effects[c + 1].inputTarget : null;
                else if (1 < this.effects.length)
                    for (this.effects[1].inputTarget._depth || (this._destroyOffscreenTarget(this.effects[1].inputTarget),
                    this.effects[1].inputTarget = this._createOffscreenTarget(!0, this.effects[1].hdr),
                    this._sourceTarget = this.effects[1].inputTarget),
                    d = 0; d < this._sourceLayers.length; d++)
                        this._sourceLayers[d].renderTarget = this.effects[1].inputTarget;
                this._destroyOffscreenTarget(this.effects[c].inputTarget);
                this.effects.splice(c, 1)
            }
            this.enabled && a.needsDepthBuffer && this._releaseDepthMap();
            0 === this.effects.length && this.disable()
        },
        _requestDepthMaps: function() {
            for (var a = 0, b = this.effects.length; a < b; a++) {
                var c = this.effects[a].effect;
                this._newPostEffect !== c && c.needsDepthBuffer && this._requestDepthMap()
            }
        },
        _releaseDepthMaps: function() {
            for (var a = 0, b = this.effects.length; a < b; a++)
                this.effects[a].effect.needsDepthBuffer && this._releaseDepthMap()
        },
        _requestDepthMap: function() {
            mf || (mf = this.app.scene.layers.getLayerById(1));
            mf && mf.incrementCounter()
        },
        _releaseDepthMap: function() {
            mf && mf.decrementCounter()
        },
        destroy: function() {
            for (var a = 0, b = this.effects.length; a < b; a++)
                this.effects[a].inputTarget.destroy();
            this.effects.length = 0;
            this.disable()
        },
        enable: function() {
            if (!this.enabled && this.effects.length) {
                this.enabled = !0;
                var a = this;
                this._requestDepthMaps();
                this.app.graphicsDevice.on("resizecanvas", this._onCanvasResized, this);
                this.command = function() {
                    if (a.enabled) {
                        var b = null
                          , c = a.effects.length;
                        if (c) {
                            a.layer.renderTarget = a.effects[0].inputTarget;
                            for (var d = 0; d < c; d++) {
                                var e = a.effects[d];
                                d === c - 1 && (b = a.camera.rect);
                                e.effect.render(e.inputTarget, e.outputTarget, b)
                            }
                        }
                    }
                }
                ;
                this.layer._commandList.push(this.command)
            }
        },
        disable: function() {
            if (this.enabled) {
                this.enabled = !1;
                this.app.graphicsDevice.off("resizecanvas", this._onCanvasResized, this);
                this._releaseDepthMaps();
                this._destroyOffscreenTarget(this._sourceTarget);
                var a = this.layer._commandList.indexOf(this.command);
                0 <= a && this.layer._commandList.splice(a, 1);
                var b = this.app.scene.layers.layerList
                  , c = b.length - 1;
                for (a = 0; a <= b.length; a++)
                    if (4 === b[a].id) {
                        c = a - 1;
                        b[a].overrideClear = this._origOverrideClear;
                        b[a].clearColorBuffer = this._origClearColorBuffer;
                        b[a].clearDepthBuffer = this._origDepthColorBuffer;
                        b[a].clearStencilBuffer = this._origStencilColorBuffer;
                        break
                    }
                for (a = c; 0 <= a; a--)
                    0 <= b[a].cameras.indexOf(this.camera) && (b[a].renderTarget = void 0);
                this.app.scene.layers.removeOpaque(this.layer);
                this.layer = null
            }
        },
        _onCanvasResized: function(a, b) {
            a = this.camera.rect;
            b = this.app.graphicsDevice;
            this.camera.camera.aspectRatio = b.width * a.z / (b.height * a.w);
            this.resizeTimeout || (100 < Lb() - this.resizeLast ? this.resizeRenderTargets() : this.resizeTimeout = setTimeout(this._resizeTimeoutCallback, 100))
        },
        resizeRenderTargets: function() {
            this.resizeTimeout && (clearTimeout(this.resizeTimeout),
            this.resizeTimeout = null);
            this.resizeLast = Lb();
            var a = this.camera.rect
              , b = Math.floor(a.z * this.app.graphicsDevice.width * this.renderTargetScale);
            a = Math.floor(a.w * this.app.graphicsDevice.height * this.renderTargetScale);
            for (var c = this.effects, d = 0, e = c.length; d < e; d++) {
                var f = c[d];
                f.inputTarget.width === b && f.inputTarget.height === a || this._resizeOffscreenTarget(f.inputTarget)
            }
        },
        onCameraRectChanged: function(a, b, c) {
            this.enabled && this.resizeRenderTargets()
        }
    });
    var Ob = function(a, b) {
        O.call(this, a, b);
        this._camera = new pa;
        this._camera.node = b;
        this._priority = 0;
        this._postEffects = new Ug(a.app,this)
    };
    Ob.prototype = Object.create(O.prototype);
    Ob.prototype.constructor = Ob;
    [{
        name: "aspectRatio",
        readonly: !1
    }, {
        name: "aspectRatioMode",
        readonly: !1
    }, {
        name: "calculateProjection",
        readonly: !1
    }, {
        name: "calculateTransform",
        readonly: !1
    }, {
        name: "clearColor",
        readonly: !1
    }, {
        name: "clearColorBuffer",
        readonly: !1
    }, {
        name: "clearDepthBuffer",
        readonly: !1
    }, {
        name: "clearStencilBuffer",
        readonly: !1
    }, {
        name: "cullFaces",
        readonly: !1
    }, {
        name: "farClip",
        readonly: !1
    }, {
        name: "flipFaces",
        readonly: !1
    }, {
        name: "fov",
        readonly: !1
    }, {
        name: "frustum",
        readonly: !0
    }, {
        name: "frustumCulling",
        readonly: !1
    }, {
        name: "horizontalFov",
        readonly: !1
    }, {
        name: "nearClip",
        readonly: !1
    }, {
        name: "orthoHeight",
        readonly: !1
    }, {
        name: "projection",
        readonly: !1
    }, {
        name: "projectionMatrix",
        readonly: !0
    }, {
        name: "rect",
        readonly: !1
    }, {
        name: "renderTarget",
        readonly: !1
    }, {
        name: "scissorRect",
        readonly: !1
    }, {
        name: "viewMatrix",
        readonly: !0
    }, {
        name: "vrDisplay",
        readonly: !1
    }].forEach(function(a) {
        var b = a.name
          , c = {
            get: function() {
                return this._camera[b]
            }
        };
        a.readonly || (c.set = function(d) {
            this._camera[b] = d
        }
        );
        Object.defineProperty(Ob.prototype, b, c)
    });
    Object.defineProperty(Ob.prototype, "camera", {
        get: function() {
            return this._camera
        }
    });
    Object.defineProperty(Ob.prototype, "layers", {
        get: function() {
            return this._camera.layers
        },
        set: function(a) {
            var b, c, d = this._camera.layers;
            for (b = 0; b < d.length; b++)
                (c = this.system.app.scene.layers.getLayerById(d[b])) && c.removeCamera(this);
            this._camera.layers = a;
            if (this.enabled && this.entity.enabled)
                for (b = 0; b < a.length; b++)
                    (c = this.system.app.scene.layers.getLayerById(a[b])) && c.addCamera(this)
        }
    });
    Object.defineProperty(Ob.prototype, "postEffects", {
        get: function() {
            return this._postEffects
        }
    });
    Object.defineProperty(Ob.prototype, "priority", {
        get: function() {
            return this._priority
        },
        set: function(a) {
            this._priority = a;
            a = this.layers;
            for (var b = 0; b < a.length; b++) {
                var c = this.system.app.scene.layers.getLayerById(a[b]);
                c && c._sortCameras()
            }
        }
    });
    Object.assign(Ob.prototype, {
        screenToWorld: function(a, b, c, d) {
            var e = this.system.app.graphicsDevice;
            return this._camera.screenToWorld(a, b, c, e.clientRect.width, e.clientRect.height, d)
        },
        worldToScreen: function(a, b) {
            var c = this.system.app.graphicsDevice;
            return this._camera.worldToScreen(a, c.clientRect.width, c.clientRect.height, b)
        },
        onPrerender: function() {
            this._camera._viewMatDirty = !0;
            this._camera._viewProjMatDirty = !0
        },
        addCameraToLayers: function() {
            for (var a = this.layers, b = 0; b < a.length; b++) {
                var c = this.system.app.scene.layers.getLayerById(a[b]);
                c && c.addCamera(this)
            }
        },
        removeCameraFromLayers: function() {
            for (var a = this.layers, b = 0; b < a.length; b++) {
                var c = this.system.app.scene.layers.getLayerById(a[b]);
                c && c.removeCamera(this)
            }
        },
        onLayersChanged: function(a, b) {
            this.addCameraToLayers();
            a.off("add", this.onLayerAdded, this);
            a.off("remove", this.onLayerRemoved, this);
            b.on("add", this.onLayerAdded, this);
            b.on("remove", this.onLayerRemoved, this)
        },
        onLayerAdded: function(a) {
            0 > this.layers.indexOf(a.id) || a.addCamera(this)
        },
        onLayerRemoved: function(a) {
            0 > this.layers.indexOf(a.id) || a.removeCamera(this)
        },
        onEnable: function() {
            var a = this.system
              , b = a.app.scene
              , c = b.layers;
            a.addCamera(this);
            b.on("set:layers", this.onLayersChanged, this);
            c && (c.on("add", this.onLayerAdded, this),
            c.on("remove", this.onLayerRemoved, this));
            this.enabled && this.entity.enabled && this.addCameraToLayers();
            this.postEffects.enable()
        },
        onDisable: function() {
            var a = this.system
              , b = a.app.scene
              , c = b.layers;
            this.postEffects.disable();
            this.removeCameraFromLayers();
            b.off("set:layers", this.onLayersChanged, this);
            c && (c.off("add", this.onLayerAdded, this),
            c.off("remove", this.onLayerRemoved, this));
            a.removeCamera(this)
        },
        onRemove: function() {
            this.onDisable();
            this.off()
        },
        calculateAspectRatio: function(a) {
            a = a ? a : this.system.app.graphicsDevice;
            var b = this.rect;
            return a.width * b.z / (a.height * b.w)
        },
        frameBegin: function(a) {
            0 === this.aspectRatioMode && (this.aspectRatio = this.calculateAspectRatio(a))
        },
        frameEnd: function() {},
        enterVr: function(a, b) {
            a instanceof Function && !b && (b = a,
            a = null);
            if (this.system.app.vr)
                if (a || (a = this.system.app.vr.display),
                a) {
                    var c = this;
                    a.capabilities.canPresent ? a.requestPresent(function(d) {
                        d || (c.vrDisplay = a,
                        c.vrDisplay.once("beforepresentchange", function(e) {
                            e.presenting || (c.vrDisplay = null)
                        }));
                        b(d)
                    }) : (c.vrDisplay = a,
                    b())
                } else
                    b("No pc.VrDisplay to present");
            else
                b("VrManager not created. Enable VR in project settings.")
        },
        exitVr: function(a) {
            if (this.vrDisplay)
                if (this.vrDisplay.capabilities.canPresent) {
                    var b = this.vrDisplay;
                    this.vrDisplay = null;
                    b.exitPresent(a)
                } else
                    this.vrDisplay = null,
                    a();
            else
                a("Not presenting VR")
        },
        startXr: function(a, b, c) {
            this.system.app.xr.start(this, a, b, c)
        },
        endXr: function(a) {
            this._camera.xr ? this._camera.xr.end(a) : a && a(Error("Camera is not in XR"))
        }
    });
    var Rm = ["enabled"]
      , Me = function(a) {
        H.call(this, a);
        this.id = "camera";
        this.ComponentType = Ob;
        this.DataType = fo;
        this.schema = Rm;
        this.cameras = [];
        this.on("beforeremove", this.onBeforeRemove, this);
        this.app.on("prerender", this.onPrerender, this);
        H.bind("update", this.onUpdate, this)
    };
    Me.prototype = Object.create(H.prototype);
    Me.prototype.constructor = Me;
    O._buildAccessors(Ob.prototype, Rm);
    Object.assign(Me.prototype, {
        initializeComponentData: function(a, b, c) {
            c = "aspectRatio aspectRatioMode calculateProjection calculateTransform clearColor clearColorBuffer clearDepthBuffer clearStencilBuffer cullFaces farClip flipFaces fov frustumCulling horizontalFov layers renderTarget nearClip orthoHeight projection priority rect scissorRect".split(" ");
            for (var d = 0; d < c.length; d++) {
                var e = c[d];
                if (b.hasOwnProperty(e)) {
                    var f = b[e];
                    switch (e) {
                    case "rect":
                    case "scissorRect":
                        Array.isArray(f) ? a[e] = new X(f[0],f[1],f[2],f[3]) : a[e] = f;
                        break;
                    case "clearColor":
                        Array.isArray(f) ? a[e] = new L(f[0],f[1],f[2],f[3]) : a[e] = f;
                        break;
                    default:
                        a[e] = f
                    }
                }
            }
            H.prototype.initializeComponentData.call(this, a, b, ["enabled"])
        },
        cloneComponent: function(a, b) {
            a = a.camera;
            this.addComponent(b, {
                aspectRatio: a.aspectRatio,
                aspectRatioMode: a.aspectRatioMode,
                calculateProjection: a.calculateProjection,
                calculateTransform: a.calculateTransform,
                clearColor: a.clearColor,
                clearColorBuffer: a.clearColorBuffer,
                clearDepthBuffer: a.clearDepthBuffer,
                clearStencilBuffer: a.clearStencilBuffer,
                cullFaces: a.cullFaces,
                farClip: a.farClip,
                flipFaces: a.flipFaces,
                fov: a.fov,
                frustumCulling: a.frustumCulling,
                horizontalFov: a.horizontalFov,
                layers: a.layers,
                renderTarget: a.renderTarget,
                nearClip: a.nearClip,
                orthoHeight: a.orthoHeight,
                projection: a.projection,
                priority: a.priority,
                rect: a.rect,
                scissorRect: a.scissorRect
            })
        },
        onBeforeRemove: function(a, b) {
            this.removeCamera(b)
        },
        onUpdate: function(a) {
            if (this.app.vr) {
                a = this.store;
                for (var b in a) {
                    var c = a[b];
                    if (c.enabled && c.entity.enabled) {
                        var d = c.vrDisplay;
                        d && (d.setClipPlanes(c.nearClip, c.farClip),
                        c.entity && (c.entity.localTransform.copy(d.combinedViewInv),
                        c.entity._dirtyLocal = !1,
                        c.entity._dirtifyWorld()))
                    }
                }
            }
        },
        onPrerender: function() {
            for (var a = 0, b = this.cameras.length; a < b; a++)
                this.cameras[a].onPrerender()
        },
        addCamera: function(a) {
            this.cameras.push(a);
            this.sortCamerasByPriority()
        },
        removeCamera: function(a) {
            a = this.cameras.indexOf(a);
            0 <= a && (this.cameras.splice(a, 1),
            this.sortCamerasByPriority())
        },
        sortCamerasByPriority: function() {
            this.cameras.sort(function(a, b) {
                return a.priority - b.priority
            })
        }
    });
    var le = function(a, b) {
        O.call(this, a, b);
        this._compoundParent = null;
        this.entity.on("insert", this._onInsert, this);
        this.on("set_type", this.onSetType, this);
        this.on("set_halfExtents", this.onSetHalfExtents, this);
        this.on("set_radius", this.onSetRadius, this);
        this.on("set_height", this.onSetHeight, this);
        this.on("set_axis", this.onSetAxis, this);
        this.on("set_asset", this.onSetAsset, this);
        this.on("set_model", this.onSetModel, this)
    };
    le.prototype = Object.create(O.prototype);
    le.prototype.constructor = le;
    Object.assign(le.prototype, {
        onSetType: function(a, b, c) {
            b !== c && this.system.changeType(this, b, c)
        },
        onSetHalfExtents: function(a, b, c) {
            a = this.data.type;
            this.data.initialized && "box" === a && this.system.recreatePhysicalShapes(this)
        },
        onSetRadius: function(a, b, c) {
            a = this.data.type;
            !this.data.initialized || "sphere" !== a && "capsule" !== a && "cylinder" !== a && "cone" !== a || this.system.recreatePhysicalShapes(this)
        },
        onSetHeight: function(a, b, c) {
            a = this.data.type;
            !this.data.initialized || "capsule" !== a && "cylinder" !== a && "cone" !== a || this.system.recreatePhysicalShapes(this)
        },
        onSetAxis: function(a, b, c) {
            a = this.data.type;
            !this.data.initialized || "capsule" !== a && "cylinder" !== a && "cone" !== a || this.system.recreatePhysicalShapes(this)
        },
        onSetAsset: function(a, b, c) {
            a = this.system.app.assets;
            b && (b = a.get(b)) && b.off("remove", this.onAssetRemoved, this);
            c && (c instanceof aa && (this.data.asset = c.id),
            b = a.get(this.data.asset)) && (b.off("remove", this.onAssetRemoved, this),
            b.on("remove", this.onAssetRemoved, this));
            this.data.initialized && "mesh" === this.data.type && (c || (this.data.model = null),
            this.system.recreatePhysicalShapes(this))
        },
        onSetModel: function(a, b, c) {
            this.data.initialized && "mesh" === this.data.type && this.system.implementations.mesh.doRecreatePhysicalShape(this)
        },
        onAssetRemoved: function(a) {
            a.off("remove", this.onAssetRemoved, this);
            this.data.asset === a.id && (this.asset = null)
        },
        _getCompoundChildShapeIndex: function(a) {
            for (var b = this.data.shape, c = b.getNumChildShapes(), d = 0; d < c; d++)
                if (b.getChildShape(d).ptr === a.ptr)
                    return d;
            return null
        },
        _onInsert: function(a) {
            if ("undefined" !== typeof Ammo)
                if (this._compoundParent)
                    this.system.recreatePhysicalShapes(this);
                else if (!this.entity.rigidbody)
                    for (a = this.entity.parent; a; ) {
                        if (a.collision && "compound" === a.collision.type) {
                            0 === a.collision.shape.getNumChildShapes() ? this.system.recreatePhysicalShapes(a.collision) : this.system.recreatePhysicalShapes(this);
                            break
                        }
                        a = a.parent
                    }
        },
        _updateCompound: function() {
            var a = this.entity;
            if (a._dirtyWorld) {
                for (var b = a._dirtyLocal, c = a; c && !b && (!c.collision || c.collision !== this._compoundParent); )
                    c._dirtyLocal && (b = !0),
                    c = c.parent;
                b && (a.forEach(this.system.implementations.compound._updateEachDescendantTransform, a),
                (a = this._compoundParent.entity.rigidbody) && a.activate())
            }
        },
        onEnable: function() {
            if ("mesh" === this.data.type && this.data.asset && this.data.initialized) {
                var a = this.system.app.assets.get(this.data.asset);
                if (a && (!a.resource || !this.data.shape)) {
                    this.system.recreatePhysicalShapes(this);
                    return
                }
            }
            this.entity.rigidbody ? this.entity.rigidbody.enabled && this.entity.rigidbody.enableSimulation() : this._compoundParent && this !== this._compoundParent ? 0 === this._compoundParent.shape.getNumChildShapes() ? this.system.recreatePhysicalShapes(this._compoundParent) : (a = this.system._getNodeTransform(this.entity, this._compoundParent.entity),
            this._compoundParent.shape.addChildShape(a, this.data.shape),
            Ammo.destroy(a),
            this._compoundParent.entity.rigidbody && this._compoundParent.entity.rigidbody.activate()) : this.entity.trigger && this.entity.trigger.enable()
        },
        onDisable: function() {
            this.entity.rigidbody ? this.entity.rigidbody.disableSimulation() : this._compoundParent && this !== this._compoundParent ? this._compoundParent.entity._destroying || (this.system._removeCompoundChild(this._compoundParent, this.data.shape),
            this._compoundParent.entity.rigidbody && this._compoundParent.entity.rigidbody.activate()) : this.entity.trigger && this.entity.trigger.disable()
        },
        onBeforeRemove: function() {
            this.entity.off("insert", this._onInsert, this)
        }
    });
    var He = "static", qj = 2, Wg = 65533, Lc, If, Be;
    Object.assign(jj.prototype, {
        initialize: function(a) {
            var b = this.entity;
            if ((a = a.shape) && "undefined" !== typeof Ammo) {
                b.trigger && b.trigger.destroy();
                var c = b.getPosition()
                  , d = b.getRotation();
                Lc.setValue(c.x, c.y, c.z);
                If.setValue(d.x, d.y, d.z, d.w);
                Be.setOrigin(Lc);
                Be.setRotation(If);
                a = this.app.systems.rigidbody.createBody(1, a, Be);
                a.setRestitution(0);
                a.setFriction(0);
                a.setDamping(0, 0);
                Lc.setValue(0, 0, 0);
                a.setLinearFactor(Lc);
                a.setAngularFactor(Lc);
                a.setCollisionFlags(a.getCollisionFlags() | 4);
                a.entity = b;
                this.body = a;
                this.component.enabled && b.enabled && this.enable()
            }
        },
        destroy: function() {
            var a = this.body;
            a && (this.disable(),
            this.app.systems.rigidbody.destroyBody(a))
        },
        _getEntityTransform: function(a) {
            var b = this.entity.getPosition()
              , c = this.entity.getRotation();
            Lc.setValue(b.x, b.y, b.z);
            If.setValue(c.x, c.y, c.z, c.w);
            a.setOrigin(Lc);
            a.setRotation(If)
        },
        updateTransform: function() {
            this._getEntityTransform(Be);
            var a = this.body;
            a.setWorldTransform(Be);
            a.activate()
        },
        enable: function() {
            var a = this.body;
            if (a) {
                var b = this.app.systems;
                b.rigidbody.addBody(a, 16, Wg ^ 16);
                b.rigidbody._triggers.push(this);
                a.forceActivationState(1);
                this.updateTransform()
            }
        },
        disable: function() {
            var a = this.body;
            if (a) {
                var b = this.app.systems
                  , c = b.rigidbody._triggers.indexOf(this);
                -1 < c && b.rigidbody._triggers.splice(c, 1);
                b.rigidbody.removeBody(a);
                a.forceActivationState(5)
            }
        }
    });
    var Hh = new K
      , Ip = new z
      , Jp = new Y
      , Sm = "enabled type halfExtents radius axis height asset shape model".split(" ")
      , Ec = function(a) {
        this.system = a
    };
    Object.assign(Ec.prototype, {
        beforeInitialize: function(a, b) {
            b.shape = null;
            b.model = new sb;
            b.model.graph = new Z
        },
        afterInitialize: function(a, b) {
            this.recreatePhysicalShapes(a);
            a.data.initialized = !0
        },
        reset: function(a, b) {
            this.beforeInitialize(a, b);
            this.afterInitialize(a, b)
        },
        recreatePhysicalShapes: function(a) {
            var b = a.entity
              , c = a.data;
            if ("undefined" !== typeof Ammo) {
                b.trigger && (b.trigger.destroy(),
                delete b.trigger);
                c.shape && (a._compoundParent && (this.system._removeCompoundChild(a._compoundParent, c.shape),
                a._compoundParent.entity.rigidbody && a._compoundParent.entity.rigidbody.activate()),
                Ammo.destroy(c.shape),
                c.shape = null);
                c.shape = this.createPhysicalShape(a.entity, c);
                var d = !a._compoundParent;
                if ("compound" === c.type && (!a._compoundParent || a === a._compoundParent))
                    a._compoundParent = a,
                    b.forEach(this._addEachDescendant, a);
                else if ("compound" !== c.type && (a._compoundParent && a === a._compoundParent && b.forEach(this.system.implementations.compound._updateEachDescendant, a),
                !a.rigidbody)) {
                    a._compoundParent = null;
                    for (var e = b.parent; e; ) {
                        if (e.collision && "compound" === e.collision.type) {
                            a._compoundParent = e.collision;
                            break
                        }
                        e = e.parent
                    }
                }
                a._compoundParent && a !== a._compoundParent && (d && 0 === a._compoundParent.shape.getNumChildShapes() ? this.system.recreatePhysicalShapes(a._compoundParent) : (this.system.updateCompoundChildTransform(b),
                a._compoundParent.entity.rigidbody && a._compoundParent.entity.rigidbody.activate()));
                b.rigidbody ? (b.rigidbody.disableSimulation(),
                b.rigidbody.createBody(),
                b.enabled && b.rigidbody.enabled && b.rigidbody.enableSimulation()) : a._compoundParent || (b.trigger ? b.trigger.initialize(c) : b.trigger = new jj(this.system.app,a,c))
            }
        },
        createPhysicalShape: function(a, b) {},
        updateTransform: function(a, b, c, d) {
            a.entity.trigger && a.entity.trigger.updateTransform()
        },
        beforeRemove: function(a, b) {
            b.data.shape && (b._compoundParent && !b._compoundParent.entity._destroying && (this.system._removeCompoundChild(b._compoundParent, b.data.shape),
            b._compoundParent.entity.rigidbody && b._compoundParent.entity.rigidbody.activate()),
            b._compoundParent = null,
            Ammo.destroy(b.data.shape),
            b.data.shape = null)
        },
        remove: function(a, b) {
            var c = this.system.app;
            a.rigidbody && a.rigidbody.body && (c.systems.rigidbody.removeBody(a.rigidbody.body),
            a.rigidbody.disableSimulation());
            a.trigger && (a.trigger.destroy(),
            delete a.trigger);
            c.scene.containsModel(b.model) && (c.root.removeChild(b.model.graph),
            c.scene.removeModel(b.model))
        },
        clone: function(a, b) {
            a = this.system.store[a.getGuid()];
            return this.system.addComponent(b, {
                enabled: a.data.enabled,
                type: a.data.type,
                halfExtents: [a.data.halfExtents.x, a.data.halfExtents.y, a.data.halfExtents.z],
                radius: a.data.radius,
                axis: a.data.axis,
                height: a.data.height,
                asset: a.data.asset,
                model: a.data.model
            })
        }
    });
    var eg = function(a) {
        this.system = a
    };
    eg.prototype = Object.create(Ec.prototype);
    eg.prototype.constructor = eg;
    Object.assign(eg.prototype, {
        createPhysicalShape: function(a, b) {
            if ("undefined" !== typeof Ammo)
                return a = b.halfExtents,
                a = new Ammo.btVector3(a ? a.x : .5,a ? a.y : .5,a ? a.z : .5),
                b = new Ammo.btBoxShape(a),
                Ammo.destroy(a),
                b
        }
    });
    var fg = function(a) {
        this.system = a
    };
    fg.prototype = Object.create(Ec.prototype);
    fg.prototype.constructor = fg;
    Object.assign(fg.prototype, {
        createPhysicalShape: function(a, b) {
            if ("undefined" !== typeof Ammo)
                return new Ammo.btSphereShape(b.radius)
        }
    });
    var gg = function(a) {
        this.system = a
    };
    gg.prototype = Object.create(Ec.prototype);
    gg.prototype.constructor = gg;
    Object.assign(gg.prototype, {
        createPhysicalShape: function(a, b) {
            a = null;
            var c = void 0 !== b.axis ? b.axis : 1
              , d = b.radius || .5;
            b = Math.max((b.height || 2) - 2 * d, 0);
            if ("undefined" !== typeof Ammo)
                switch (c) {
                case 0:
                    a = new Ammo.btCapsuleShapeX(d,b);
                    break;
                case 1:
                    a = new Ammo.btCapsuleShape(d,b);
                    break;
                case 2:
                    a = new Ammo.btCapsuleShapeZ(d,b)
                }
            return a
        }
    });
    var hg = function(a) {
        this.system = a
    };
    hg.prototype = Object.create(Ec.prototype);
    hg.prototype.constructor = hg;
    Object.assign(hg.prototype, {
        createPhysicalShape: function(a, b) {
            var c = a = null
              , d = void 0 !== b.axis ? b.axis : 1
              , e = void 0 !== b.radius ? b.radius : .5;
            b = void 0 !== b.height ? b.height : 1;
            if ("undefined" !== typeof Ammo)
                switch (d) {
                case 0:
                    a = new Ammo.btVector3(.5 * b,e,e);
                    c = new Ammo.btCylinderShapeX(a);
                    break;
                case 1:
                    a = new Ammo.btVector3(e,.5 * b,e);
                    c = new Ammo.btCylinderShape(a);
                    break;
                case 2:
                    a = new Ammo.btVector3(e,e,.5 * b),
                    c = new Ammo.btCylinderShapeZ(a)
                }
            a && Ammo.destroy(a);
            return c
        }
    });
    var ig = function(a) {
        this.system = a
    };
    ig.prototype = Object.create(Ec.prototype);
    ig.prototype.constructor = ig;
    Object.assign(ig.prototype, {
        createPhysicalShape: function(a, b) {
            a = null;
            var c = void 0 !== b.axis ? b.axis : 1
              , d = void 0 !== b.radius ? b.radius : .5;
            b = void 0 !== b.height ? b.height : 1;
            if ("undefined" !== typeof Ammo)
                switch (c) {
                case 0:
                    a = new Ammo.btConeShapeX(d,b);
                    break;
                case 1:
                    a = new Ammo.btConeShape(d,b);
                    break;
                case 2:
                    a = new Ammo.btConeShapeZ(d,b)
                }
            return a
        }
    });
    var jg = function(a) {
        this.system = a
    };
    jg.prototype = Object.create(Ec.prototype);
    jg.prototype.constructor = jg;
    Object.assign(jg.prototype, {
        beforeInitialize: function(a, b) {},
        createPhysicalShape: function(a, b) {
            if ("undefined" !== typeof Ammo && b.model) {
                var c = b.model;
                b = new Ammo.btCompoundShape;
                var d, e;
                for (d = 0; d < c.meshInstances.length; d++) {
                    var f = c.meshInstances[d]
                      , g = f.mesh;
                    if (this.system._triMeshCache[g.id])
                        var k = this.system._triMeshCache[g.id];
                    else {
                        k = g.indexBuffer[0];
                        var h = g.vertexBuffer, l = h.getFormat(), n = l.size / 4, p;
                        for (e = 0; e < l.elements.length; e++) {
                            var q = l.elements[e];
                            "POSITION" === q.name && (p = new Float32Array(h.lock(),q.offset))
                        }
                        h = new Uint16Array(k.lock());
                        l = g.primitive[0].count / 3;
                        q = new Ammo.btVector3;
                        var r = new Ammo.btVector3
                          , t = new Ammo.btVector3
                          , u = g.primitive[0].base;
                        k = new Ammo.btTriangleMesh;
                        this.system._triMeshCache[g.id] = k;
                        for (e = 0; e < l; e++) {
                            g = h[u + 3 * e] * n;
                            var x = h[u + 3 * e + 1] * n;
                            var v = h[u + 3 * e + 2] * n;
                            q.setValue(p[g], p[g + 1], p[g + 2]);
                            r.setValue(p[x], p[x + 1], p[x + 2]);
                            t.setValue(p[v], p[v + 1], p[v + 2]);
                            k.addTriangle(q, r, t, !0)
                        }
                        Ammo.destroy(q);
                        Ammo.destroy(r);
                        Ammo.destroy(t)
                    }
                    e = new Ammo.btBvhTriangleMeshShape(k,!0);
                    n = this.system._getNodeScaling(f.node);
                    e.setLocalScaling(n);
                    Ammo.destroy(n);
                    f = this.system._getNodeTransform(f.node);
                    b.addChildShape(f, e);
                    Ammo.destroy(f)
                }
                a = a.getWorldTransform().getScale();
                a = new Ammo.btVector3(a.x,a.y,a.z);
                b.setLocalScaling(a);
                Ammo.destroy(a);
                return b
            }
        },
        recreatePhysicalShapes: function(a) {
            null !== a.data.asset && a.enabled && a.entity.enabled ? this.loadModelAsset(a) : this.doRecreatePhysicalShape(a)
        },
        loadModelAsset: function(a) {
            var b = this
              , c = a.data.asset
              , d = a.data
              , e = this.system.app.assets
              , f = e.get(c);
            if (f)
                f.ready(function(g) {
                    d.model = g.resource;
                    b.doRecreatePhysicalShape(a)
                }),
                e.load(f);
            else
                e.once("add:" + c, function(g) {
                    g.ready(function(k) {
                        d.model = k.resource;
                        b.doRecreatePhysicalShape(a)
                    });
                    e.load(g)
                })
        },
        doRecreatePhysicalShape: function(a) {
            var b = a.entity
              , c = a.data;
            c.model ? (this.destroyShape(c),
            c.shape = this.createPhysicalShape(b, c),
            b.rigidbody ? (b.rigidbody.disableSimulation(),
            b.rigidbody.createBody(),
            b.enabled && b.rigidbody.enabled && b.rigidbody.enableSimulation()) : b.trigger ? b.trigger.initialize(c) : b.trigger = new jj(this.system.app,a,c)) : (this.beforeRemove(b, a),
            this.remove(b, c))
        },
        updateTransform: function(a, b, c, d) {
            if (a.shape) {
                var e = a.entity.getWorldTransform().getScale()
                  , f = a.shape.getLocalScaling();
                e.x === f.x() && e.y === f.y() && e.z === f.z() || this.doRecreatePhysicalShape(a)
            }
            Ec.prototype.updateTransform.call(this, a, b, c, d)
        },
        destroyShape: function(a) {
            if (a.shape) {
                for (var b = a.shape.getNumChildShapes(), c = 0; c < b; c++) {
                    var d = a.shape.getChildShape(c);
                    Ammo.destroy(d)
                }
                Ammo.destroy(a.shape);
                a.shape = null
            }
        },
        remove: function(a, b) {
            this.destroyShape(b);
            Ec.prototype.remove.call(this, a, b)
        }
    });
    var kg = function(a) {
        this.system = a
    };
    kg.prototype = Object.create(Ec.prototype);
    kg.prototype.constructor = kg;
    Object.assign(kg.prototype, {
        createPhysicalShape: function(a, b) {
            if ("undefined" !== typeof Ammo)
                return new Ammo.btCompoundShape
        },
        _addEachDescendant: function(a) {
            a.collision && !a.rigidbody && (a.collision._compoundParent = this,
            a !== this.entity && a.collision.system.recreatePhysicalShapes(a.collision))
        },
        _updateEachDescendant: function(a) {
            a.collision && a.collision._compoundParent === this && (a.collision._compoundParent = null,
            a === this.entity || a.rigidbody || a.collision.system.recreatePhysicalShapes(a.collision))
        },
        _updateEachDescendantTransform: function(a) {
            a.collision && a.collision._compoundParent === this.collision._compoundParent && this.collision.system.updateCompoundChildTransform(a)
        }
    });
    var Le = function(a) {
        H.call(this, a);
        this.id = "collision";
        this.ComponentType = le;
        this.DataType = go;
        this.schema = Sm;
        this.implementations = {};
        this._triMeshCache = {};
        this.on("beforeremove", this.onBeforeRemove, this);
        this.on("remove", this.onRemove, this)
    };
    Le.prototype = Object.create(H.prototype);
    Le.prototype.constructor = Le;
    O._buildAccessors(le.prototype, Sm);
    Object.assign(Le.prototype, {
        initializeComponentData: function(a, b, c) {
            c = "type halfExtents radius axis height shape model asset enabled".split(" ");
            for (var d = {}, e = 0, f = c.length; e < f; e++) {
                var g = c[e];
                d[g] = b[g]
            }
            b.hasOwnProperty("asset") ? (b = c.indexOf("model"),
            -1 !== b && c.splice(b, 1)) : b.hasOwnProperty("model") && (b = c.indexOf("asset"),
            -1 !== b && c.splice(b, 1));
            d.type || (d.type = a.data.type);
            a.data.type = d.type;
            d.halfExtents && Array.isArray(d.halfExtents) && (d.halfExtents = new z(d.halfExtents[0],d.halfExtents[1],d.halfExtents[2]));
            b = this._createImplementation(d.type);
            b.beforeInitialize(a, d);
            H.prototype.initializeComponentData.call(this.system, a, d, c);
            b.afterInitialize(a, d)
        },
        _createImplementation: function(a) {
            if (void 0 === this.implementations[a]) {
                switch (a) {
                case "box":
                    var b = new eg(this);
                    break;
                case "sphere":
                    b = new fg(this);
                    break;
                case "capsule":
                    b = new gg(this);
                    break;
                case "cylinder":
                    b = new hg(this);
                    break;
                case "cone":
                    b = new ig(this);
                    break;
                case "mesh":
                    b = new jg(this);
                    break;
                case "compound":
                    b = new kg(this)
                }
                this.implementations[a] = b
            }
            return this.implementations[a]
        },
        _getImplementation: function(a) {
            return this.implementations[a.collision.data.type]
        },
        cloneComponent: function(a, b) {
            return this._getImplementation(a).clone(a, b)
        },
        onBeforeRemove: function(a, b) {
            this.implementations[b.data.type].beforeRemove(a, b);
            b.onBeforeRemove()
        },
        onRemove: function(a, b) {
            this.implementations[b.type].remove(a, b)
        },
        updateCompoundChildTransform: function(a) {
            this._removeCompoundChild(a.collision._compoundParent, a.collision.data.shape);
            if (a.enabled && a.collision.enabled) {
                var b = this._getNodeTransform(a, a.collision._compoundParent.entity);
                a.collision._compoundParent.shape.addChildShape(b, a.collision.data.shape);
                Ammo.destroy(b)
            }
        },
        _removeCompoundChild: function(a, b) {
            a.shape.removeChildShape ? a.shape.removeChildShape(b) : (b = a._getCompoundChildShapeIndex(b),
            null !== b && a.shape.removeChildShapeByIndex(b))
        },
        onTransformChanged: function(a, b, c, d) {
            this.implementations[a.data.type].updateTransform(a, b, c, d)
        },
        changeType: function(a, b, c) {
            this.implementations[b].beforeRemove(a.entity, a);
            this.implementations[b].remove(a.entity, a.data);
            this._createImplementation(c).reset(a, a.data)
        },
        recreatePhysicalShapes: function(a) {
            this.implementations[a.data.type].recreatePhysicalShapes(a)
        },
        _calculateNodeRelativeTransform: function(a, b) {
            a === b ? (a = a.getWorldTransform().getScale(),
            Hh.setScale(a.x, a.y, a.z)) : (this._calculateNodeRelativeTransform(a.parent, b),
            Hh.mul(a.getLocalTransform()))
        },
        _getNodeScaling: function(a) {
            a = a.getWorldTransform().getScale();
            return new Ammo.btVector3(a.x,a.y,a.z)
        },
        _getNodeTransform: function(a, b) {
            b ? (this._calculateNodeRelativeTransform(a, b),
            b = Ip,
            a = Jp,
            Hh.getTranslation(b),
            a.setFromMat4(Hh)) : (b = a.getPosition(),
            a = a.getRotation());
            var c = new Ammo.btTransform;
            c.setIdentity();
            var d = c.getOrigin();
            d.setValue(b.x, b.y, b.z);
            b = new Ammo.btQuaternion;
            b.setValue(a.x, a.y, a.z, a.w);
            c.setRotation(b);
            Ammo.destroy(b);
            Ammo.destroy(d);
            return c
        },
        destroy: function() {
            for (var a in this._triMeshCache)
                Ammo.destroy(this._triMeshCache[a]);
            this._triMeshCache = null;
            H.prototype.destroy.call(this)
        }
    });
    Object.assign(kj.prototype, {
        add: function(a) {
            var b = a.id;
            if (this[b])
                throw Error("ComponentSystem name '" + b + "' already registered or not allowed");
            this[b] = a;
            this.list.push(a)
        },
        remove: function(a) {
            a = a.id;
            if (!this[a])
                throw Error("No ComponentSystem named '" + a + "' registered");
            delete this[a];
            a = this.list.indexOf(this[a]);
            -1 !== a && this.list.splice(a, 1)
        }
    });
    var nl = "group";
    Rd.prototype.clone = function() {
        return new Rd({
            func: this.func,
            ref: this.ref,
            readMask: this.readMask,
            writeMask: this.writeMask,
            fail: this.fail,
            zfail: this.zfail,
            zpass: this.zpass
        })
    }
    ;
    yb.prototype.destroy = function() {
        this.setMaterial(null);
        this._element.removeModelFromLayers(this.model);
        this.model.destroy();
        this._element = this._entity = this.meshInstance = this.mesh = this.node = this.model = null
    }
    ;
    yb.prototype.setMesh = function(a) {
        this.meshInstance && (this.mesh = a,
        this.meshInstance.mesh = a,
        this.meshInstance.visible = !!a,
        this.unmaskMeshInstance && (this.unmaskMeshInstance.mesh = a),
        this.forceUpdateAabb())
    }
    ;
    yb.prototype.setMask = function(a) {
        if (this.meshInstance) {
            if (a) {
                this.unmaskMeshInstance = new va(this.node,this.mesh,this.meshInstance.material);
                this.unmaskMeshInstance.name = "Unmask: " + this._entity.name;
                this.unmaskMeshInstance.castShadow = !1;
                this.unmaskMeshInstance.receiveShadow = !1;
                this.unmaskMeshInstance.pick = !1;
                this.model.meshInstances.push(this.unmaskMeshInstance);
                for (var b in this.meshInstance.parameters)
                    this.unmaskMeshInstance.setParameter(b, this.meshInstance.parameters[b].data)
            } else
                a = this.model.meshInstances.indexOf(this.unmaskMeshInstance),
                0 <= a && this.model.meshInstances.splice(a, 1),
                this.unmaskMeshInstance = null;
            this._entity.enabled && this._element.enabled && (this._element.removeModelFromLayers(this.model),
            this._element.addModelToLayers(this.model))
        }
    }
    ;
    yb.prototype.setMaterial = function(a) {
        this.meshInstance && (this.meshInstance.material = a,
        this.unmaskMeshInstance && (this.unmaskMeshInstance.material = a))
    }
    ;
    yb.prototype.setParameter = function(a, b) {
        this.meshInstance && (this.meshInstance.setParameter(a, b),
        this.unmaskMeshInstance && this.unmaskMeshInstance.setParameter(a, b))
    }
    ;
    yb.prototype.deleteParameter = function(a) {
        this.meshInstance && (this.meshInstance.deleteParameter(a),
        this.unmaskMeshInstance && this.unmaskMeshInstance.deleteParameter(a))
    }
    ;
    yb.prototype.setUnmaskDrawOrder = function() {
        if (this.meshInstance) {
            var a = function(c) {
                var d;
                c = c.children;
                var e = c.length;
                if (e) {
                    for (var f = 0; f < e; f++)
                        c[f].element && (d = c[f]);
                    return d ? (c = a(d)) ? c : d : null
                }
                return null
            };
            if (this.unmaskMeshInstance) {
                var b = a(this._entity);
                this.unmaskMeshInstance.drawOrder = b && b.element ? b.element.drawOrder + b.element.getMaskOffset() : this.meshInstance.drawOrder + this._element.getMaskOffset()
            }
        }
    }
    ;
    yb.prototype.setDrawOrder = function(a) {
        this.meshInstance && (this.meshInstance.drawOrder = a)
    }
    ;
    yb.prototype.setCull = function(a) {
        if (this.meshInstance) {
            var b = this._element
              , c = null;
            a && b._isScreenCulled() && (c = function(d) {
                return b.isVisibleForCamera(d)
            }
            );
            this.meshInstance.cull = a;
            this.meshInstance.isVisibleFunc = c;
            this.unmaskMeshInstance && (this.unmaskMeshInstance.cull = a,
            this.unmaskMeshInstance.isVisibleFunc = c)
        }
    }
    ;
    yb.prototype.setScreenSpace = function(a) {
        this.meshInstance && (this.meshInstance.screenSpace = a,
        this.unmaskMeshInstance && (this.unmaskMeshInstance.screenSpace = a))
    }
    ;
    yb.prototype.setLayer = function(a) {
        this.meshInstance && (this.meshInstance.layer = a,
        this.unmaskMeshInstance && (this.unmaskMeshInstance.layer = a))
    }
    ;
    yb.prototype.forceUpdateAabb = function(a) {
        this.meshInstance && (this.meshInstance._aabbVer = -1,
        this.unmaskMeshInstance && (this.unmaskMeshInstance._aabbVer = -1))
    }
    ;
    yb.prototype.setAabbFunc = function(a) {
        this.meshInstance && (this.meshInstance._updateAabbFunc = a,
        this.unmaskMeshInstance && (this.unmaskMeshInstance._updateAabbFunc = a))
    }
    ;
    Object.assign(cb.prototype, {
        destroy: function() {
            this.materialAsset = this.spriteAsset = this.textureAsset = null;
            this._renderable.setMesh(this._defaultMesh);
            this._renderable.destroy();
            this._defaultMesh = null;
            this._element.off("resize", this._onParentResizeOrPivotChange, this);
            this._element.off("set:pivot", this._onParentResizeOrPivotChange, this);
            this._element.off("screen:set:screenspace", this._onScreenSpaceChange, this);
            this._element.off("set:screen", this._onScreenChange, this);
            this._element.off("set:draworder", this._onDrawOrderChange, this);
            this._element.off("screen:set:resolution", this._onResolutionChange, this)
        },
        _onResolutionChange: function(a) {},
        _onParentResizeOrPivotChange: function() {
            this._renderable.mesh && this._updateMesh(this._renderable.mesh)
        },
        _onScreenSpaceChange: function(a) {
            this._updateMaterial(a)
        },
        _onScreenChange: function(a, b) {
            a ? this._updateMaterial(a.screen.screenSpace) : this._updateMaterial(!1)
        },
        _onDrawOrderChange: function(a) {
            this._renderable.setDrawOrder(a);
            if (this.mask && this._element.screen)
                this._element.screen.screen.once("syncdraworder", function() {
                    this._renderable.setUnmaskDrawOrder()
                }, this)
        },
        _hasUserMaterial: function() {
            return !!this._materialAsset || !!this._material && -1 === this._system.defaultImageMaterials.indexOf(this._material)
        },
        _use9Slicing: function() {
            return this.sprite && (1 === this.sprite.renderMode || 2 === this.sprite.renderMode)
        },
        _updateMaterial: function(a) {
            var b = !!this._mask
              , c = !(!this.sprite || 1 !== this.sprite.renderMode)
              , d = !(!this.sprite || 2 !== this.sprite.renderMode);
            this._hasUserMaterial() || (this._material = this._system.getImageElementMaterial(a, b, c, d));
            this._renderable && (this._renderable.setCull(!0),
            this._renderable.setMaterial(this._material),
            this._renderable.setScreenSpace(a),
            this._renderable.setLayer(a ? 0 : 15))
        },
        _createMesh: function() {
            var a = this._element
              , b = a.calculatedWidth;
            a = a.calculatedHeight;
            var c = this._rect
              , d = new ArrayBuffer(128)
              , e = new Float32Array(d);
            e[5] = 1;
            e[6] = c.x;
            e[7] = c.y;
            e[8] = b;
            e[13] = 1;
            e[14] = c.x + c.z;
            e[15] = c.y;
            e[16] = b;
            e[17] = a;
            e[21] = 1;
            e[22] = c.x + c.z;
            e[23] = c.y + c.w;
            e[25] = a;
            e[29] = 1;
            e[30] = c.x;
            e[31] = c.y + c.w;
            c = this._system.app.graphicsDevice;
            e = new Na(c,[{
                semantic: "POSITION",
                components: 3,
                type: 6
            }, {
                semantic: "NORMAL",
                components: 3,
                type: 6
            }, {
                semantic: "TEXCOORD0",
                components: 2,
                type: 6
            }]);
            d = new ab(c,e,4,0,d);
            c = new rb(c);
            c.vertexBuffer = d;
            c.primitive[0].type = 6;
            c.primitive[0].base = 0;
            c.primitive[0].count = 4;
            c.primitive[0].indexed = !1;
            c.aabb.setMinMax(z.ZERO, new z(b,a,0));
            this._updateMesh(c);
            return c
        },
        _updateMesh: function(a) {
            var b = this._element
              , c = b.calculatedWidth
              , d = b.calculatedHeight
              , e = b._isScreenSpace();
            this._updateMaterial(e);
            this._renderable && this._renderable.forceUpdateAabb();
            if (!this.sprite || 1 !== this.sprite.renderMode && 2 !== this.sprite.renderMode) {
                var f = a.vertexBuffer
                  , g = new Float32Array(f.lock());
                e = b.pivot.x;
                b = b.pivot.y;
                g[0] = -(e * c);
                g[1] = -(b * d);
                g[8] = c - e * c;
                g[9] = -(b * d);
                g[16] = c - e * c;
                g[17] = d - b * d;
                g[24] = -(e * c);
                g[25] = d - b * d;
                var k = 1
                  , h = 1
                  , l = this._rect;
                if (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {
                    var n = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
                    n && (l = n.rect,
                    k = this._sprite.atlas.texture.width,
                    h = this._sprite.atlas.texture.height)
                }
                g[6] = l.x / k;
                g[7] = l.y / h;
                g[14] = (l.x + l.z) / k;
                g[15] = l.y / h;
                g[22] = (l.x + l.z) / k;
                g[23] = (l.y + l.w) / h;
                g[30] = l.x / k;
                g[31] = (l.y + l.w) / h;
                f.unlock();
                f = new z(-(e * c),-(b * d),0);
                c = new z(c - e * c,d - b * d,0);
                a.aabb.setMinMax(f, c);
                this._renderable && (this._renderable.node.setLocalScale(1, 1, 1),
                this._renderable.node.setLocalPosition(0, 0, 0),
                this._renderable.setAabbFunc(null))
            } else
                a = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]],
                e = 2 / a.rect.z,
                f = 2 / a.rect.w,
                this._innerOffset.set(a.border.x * e, a.border.y * f, a.border.z * e, a.border.w * f),
                e = this.sprite.atlas.texture,
                this._atlasRect.set(a.rect.x / e.width, a.rect.y / e.height, a.rect.z / e.width, a.rect.w / e.height),
                f = null !== this._pixelsPerUnit ? this._pixelsPerUnit : this.sprite.pixelsPerUnit,
                e = a.rect.z / f,
                a = a.rect.w / f,
                this._outerScale.set(Math.max(c, this._innerOffset.x * e), Math.max(d, this._innerOffset.y * a)),
                f = a,
                this._outerScale.x /= e,
                this._outerScale.y /= a,
                e *= N.clamp(c / (this._innerOffset.x * e), 1E-4, 1),
                f *= N.clamp(d / (this._innerOffset.y * a), 1E-4, 1),
                this._renderable && (this._innerOffsetUniform[0] = this._innerOffset.x,
                this._innerOffsetUniform[1] = this._innerOffset.y,
                this._innerOffsetUniform[2] = this._innerOffset.z,
                this._innerOffsetUniform[3] = this._innerOffset.w,
                this._renderable.setParameter("innerOffset", this._innerOffsetUniform),
                this._atlasRectUniform[0] = this._atlasRect.x,
                this._atlasRectUniform[1] = this._atlasRect.y,
                this._atlasRectUniform[2] = this._atlasRect.z,
                this._atlasRectUniform[3] = this._atlasRect.w,
                this._renderable.setParameter("atlasRect", this._atlasRectUniform),
                this._outerScaleUniform[0] = this._outerScale.x,
                this._outerScaleUniform[1] = this._outerScale.y,
                this._renderable.setParameter("outerScale", this._outerScaleUniform),
                this._renderable.setAabbFunc(this._updateAabbFunc),
                this._renderable.node.setLocalScale(e, f, 1),
                this._renderable.node.setLocalPosition((.5 - b.pivot.x) * c, (.5 - b.pivot.y) * d, 0));
            this._meshDirty = !1
        },
        _updateSprite: function() {
            var a = !1
              , b = null;
            this._sprite && this._sprite.atlas && (b = this._sprite.meshes[this.spriteFrame],
            a = 1 === this._sprite.renderMode || 2 === this._sprite.renderMode);
            if (this.mesh = a ? b : this._defaultMesh)
                this._element._beingInitialized ? this._meshDirty = !0 : this._updateMesh(this.mesh)
        },
        _updateAabb: function(a) {
            a.center.set(0, 0, 0);
            a.halfExtents.set(.5 * this._outerScale.x, .5 * this._outerScale.y, .001);
            a.setFromTransformedAabb(a, this._renderable.node.getWorldTransform());
            return a
        },
        _toggleMask: function() {
            this._element._dirtifyMask();
            var a = this._element._isScreenSpace();
            this._updateMaterial(a);
            this._renderable.setMask(!!this._mask)
        },
        _onMaterialLoad: function(a) {
            this.material = a.resource
        },
        _onMaterialAdded: function(a) {
            this._system.app.assets.off("add:" + a.id, this._onMaterialAdded, this);
            this._materialAsset === a.id && this._bindMaterialAsset(a)
        },
        _bindMaterialAsset: function(a) {
            this._entity.enabled && (a.on("load", this._onMaterialLoad, this),
            a.on("change", this._onMaterialChange, this),
            a.on("remove", this._onMaterialRemove, this),
            a.resource ? this._onMaterialLoad(a) : this._system.app.assets.load(a))
        },
        _unbindMaterialAsset: function(a) {
            a.off("load", this._onMaterialLoad, this);
            a.off("change", this._onMaterialChange, this);
            a.off("remove", this._onMaterialRemove, this)
        },
        _onMaterialChange: function() {},
        _onMaterialRemove: function() {},
        _onTextureAdded: function(a) {
            this._system.app.assets.off("add:" + a.id, this._onTextureAdded, this);
            this._textureAsset === a.id && this._bindTextureAsset(a)
        },
        _bindTextureAsset: function(a) {
            this._entity.enabled && (a.on("load", this._onTextureLoad, this),
            a.on("change", this._onTextureChange, this),
            a.on("remove", this._onTextureRemove, this),
            a.resource ? this._onTextureLoad(a) : this._system.app.assets.load(a))
        },
        _unbindTextureAsset: function(a) {
            a.off("load", this._onTextureLoad, this);
            a.off("change", this._onTextureChange, this);
            a.off("remove", this._onTextureRemove, this)
        },
        _onTextureLoad: function(a) {
            this.texture = a.resource
        },
        _onTextureChange: function(a) {},
        _onTextureRemove: function(a) {},
        _onSpriteAssetAdded: function(a) {
            this._system.app.assets.off("add:" + a.id, this._onSpriteAssetAdded, this);
            this._spriteAsset === a.id && this._bindSpriteAsset(a)
        },
        _bindSpriteAsset: function(a) {
            this._entity.enabled && (a.on("load", this._onSpriteAssetLoad, this),
            a.on("change", this._onSpriteAssetChange, this),
            a.on("remove", this._onSpriteAssetRemove, this),
            a.resource ? this._onSpriteAssetLoad(a) : this._system.app.assets.load(a))
        },
        _unbindSpriteAsset: function(a) {
            a.off("load", this._onSpriteAssetLoad, this);
            a.off("change", this._onSpriteAssetChange, this);
            a.off("remove", this._onSpriteAssetRemove, this);
            a.data.textureAtlasAsset && this._system.app.assets.off("load:" + a.data.textureAtlasAsset, this._onTextureAtlasLoad, this)
        },
        _onSpriteAssetLoad: function(a) {
            if (a && a.resource)
                if (a.resource.atlas)
                    this.sprite = a.resource;
                else {
                    if (a = a.data.textureAtlasAsset) {
                        var b = this._system.app.assets;
                        b.off("load:" + a, this._onTextureAtlasLoad, this);
                        b.once("load:" + a, this._onTextureAtlasLoad, this)
                    }
                }
            else
                this.sprite = null
        },
        _onSpriteAssetChange: function(a) {
            this._onSpriteAssetLoad(a)
        },
        _onSpriteAssetRemove: function(a) {},
        _bindSprite: function(a) {
            a.on("set:meshes", this._onSpriteMeshesChange, this);
            a.on("set:pixelsPerUnit", this._onSpritePpuChange, this);
            a.on("set:atlas", this._onAtlasTextureChange, this);
            if (a.atlas)
                a.atlas.on("set:texture", this._onAtlasTextureChange, this)
        },
        _unbindSprite: function(a) {
            a.off("set:meshes", this._onSpriteMeshesChange, this);
            a.off("set:pixelsPerUnit", this._onSpritePpuChange, this);
            a.off("set:atlas", this._onAtlasTextureChange, this);
            a.atlas && a.atlas.off("set:texture", this._onAtlasTextureChange, this)
        },
        _onSpriteMeshesChange: function() {
            this._sprite && (this._spriteFrame = N.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1));
            this._updateSprite()
        },
        _onSpritePpuChange: function() {
            0 !== this.sprite.renderMode && null === this._pixelsPerUnit && this._updateSprite()
        },
        _onAtlasTextureChange: function() {
            this.sprite && this.sprite.atlas && this.sprite.atlas.texture ? (this._renderable.setParameter("texture_emissiveMap", this._sprite.atlas.texture),
            this._renderable.setParameter("texture_opacityMap", this._sprite.atlas.texture)) : (this._renderable.deleteParameter("texture_emissiveMap"),
            this._renderable.deleteParameter("texture_opacityMap"))
        },
        _onTextureAtlasLoad: function(a) {
            a = this._spriteAsset;
            a instanceof aa ? this._onSpriteAssetLoad(a) : this._onSpriteAssetLoad(this._system.app.assets.get(a))
        },
        onEnable: function() {
            var a;
            this._materialAsset && (a = this._system.app.assets.get(this._materialAsset)) && a.resource !== this._material && this._bindMaterialAsset(a);
            this._textureAsset && (a = this._system.app.assets.get(this._textureAsset)) && a.resource !== this._texture && this._bindTextureAsset(a);
            this._spriteAsset && (a = this._system.app.assets.get(this._spriteAsset)) && a.resource !== this._sprite && this._bindSpriteAsset(a);
            this._element.addModelToLayers(this._renderable.model)
        },
        onDisable: function() {
            this._element.removeModelFromLayers(this._renderable.model)
        },
        _setStencil: function(a) {
            this._renderable.meshInstance.stencilFront = a;
            this._renderable.meshInstance.stencilBack = a;
            a = 0;
            this._element.maskedBy && (a = this._element.maskedBy.element._image._maskRef);
            this._renderable.unmaskMeshInstance && (a = new Rd({
                ref: a + 1,
                func: 2,
                zpass: 5
            }),
            this._renderable.unmaskMeshInstance.stencilFront = a,
            this._renderable.unmaskMeshInstance.stencilBack = a)
        }
    });
    Object.defineProperty(cb.prototype, "color", {
        get: function() {
            return this._color
        },
        set: function(a) {
            var b = a.r
              , c = a.g;
            a = a.b;
            if (this._color.r !== b || this._color.g !== c || this._color.b !== a)
                this._color.r = b,
                this._color.g = c,
                this._color.b = a,
                this._colorUniform[0] = b,
                this._colorUniform[1] = c,
                this._colorUniform[2] = a,
                this._renderable.setParameter("material_emissive", this._colorUniform),
                this._element && this._element.fire("set:color", this._color)
        }
    });
    Object.defineProperty(cb.prototype, "opacity", {
        get: function() {
            return this._color.a
        },
        set: function(a) {
            a !== this._color.a && (this._color.a = a,
            this._renderable.setParameter("material_opacity", a),
            this._element && this._element.fire("set:opacity", a))
        }
    });
    Object.defineProperty(cb.prototype, "rect", {
        get: function() {
            return this._rect
        },
        set: function(a) {
            if (a instanceof X) {
                var b = a.x;
                var c = a.y;
                var d = a.z;
                a = a.w
            } else
                b = a[0],
                c = a[1],
                d = a[2],
                a = a[3];
            if (b !== this._rect.x || c !== this._rect.y || d !== this._rect.z || a !== this._rect.w)
                this._rect.set(b, c, d, a),
                this._renderable.mesh && (this._element._beingInitialized ? this._meshDirty = !0 : this._updateMesh(this._renderable.mesh))
        }
    });
    Object.defineProperty(cb.prototype, "material", {
        get: function() {
            return this._material
        },
        set: function(a) {
            this._material !== a && (a || (a = this._element._isScreenSpace(),
            a = this.mask ? a ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial : a ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial),
            this._material = a) && (this._renderable.setMaterial(a),
            this._hasUserMaterial() ? (this._renderable.deleteParameter("material_opacity"),
            this._renderable.deleteParameter("material_emissive")) : (this._colorUniform[0] = this._color.r,
            this._colorUniform[1] = this._color.g,
            this._colorUniform[2] = this._color.b,
            this._renderable.setParameter("material_emissive", this._colorUniform),
            this._renderable.setParameter("material_opacity", this._color.a)))
        }
    });
    Object.defineProperty(cb.prototype, "materialAsset", {
        get: function() {
            return this._materialAsset
        },
        set: function(a) {
            var b = this._system.app.assets
              , c = a;
            a instanceof aa && (c = a.id);
            this._materialAsset !== c && (this._materialAsset && (b.off("add:" + this._materialAsset, this._onMaterialAdded, this),
            a = b.get(this._materialAsset)) && (a.off("load", this._onMaterialLoad, this),
            a.off("change", this._onMaterialChange, this),
            a.off("remove", this._onMaterialRemove, this)),
            (this._materialAsset = c) ? (c = b.get(this._materialAsset)) ? this._bindMaterialAsset(c) : (this.material = null,
            b.on("add:" + this._materialAsset, this._onMaterialAdded, this)) : this.material = null)
        }
    });
    Object.defineProperty(cb.prototype, "texture", {
        get: function() {
            return this._texture
        },
        set: function(a) {
            if (this._texture !== a) {
                if (this._textureAsset) {
                    var b = this._system.app.assets.get(this._textureAsset);
                    b && b.resource !== a && (this.textureAsset = null)
                }
                (this._texture = a) ? (this._spriteAsset && (this.spriteAsset = null),
                this._renderable.setParameter("texture_emissiveMap", this._texture),
                this._renderable.setParameter("texture_opacityMap", this._texture),
                this._colorUniform[0] = this._color.r,
                this._colorUniform[1] = this._color.g,
                this._colorUniform[2] = this._color.b,
                this._renderable.setParameter("material_emissive", this._colorUniform),
                this._renderable.setParameter("material_opacity", this._color.a)) : (this._renderable.deleteParameter("texture_emissiveMap"),
                this._renderable.deleteParameter("texture_opacityMap"))
            }
        }
    });
    Object.defineProperty(cb.prototype, "textureAsset", {
        get: function() {
            return this._textureAsset
        },
        set: function(a) {
            var b = this._system.app.assets
              , c = a;
            a instanceof aa && (c = a.id);
            this._textureAsset !== c && (this._textureAsset && (b.off("add:" + this._textureAsset, this._onTextureAdded, this),
            a = b.get(this._textureAsset)) && (a.off("load", this._onTextureLoad, this),
            a.off("change", this._onTextureChange, this),
            a.off("remove", this._onTextureRemove, this)),
            (this._textureAsset = c) ? (c = b.get(this._textureAsset)) ? this._bindTextureAsset(c) : (this.texture = null,
            b.on("add:" + this._textureAsset, this._onTextureAdded, this)) : this.texture = null)
        }
    });
    Object.defineProperty(cb.prototype, "spriteAsset", {
        get: function() {
            return this._spriteAsset
        },
        set: function(a) {
            var b = this._system.app.assets
              , c = a;
            a instanceof aa && (c = a.id);
            this._spriteAsset !== c && (this._spriteAsset && (b.off("add:" + this._spriteAsset, this._onSpriteAssetAdded, this),
            (a = b.get(this._spriteAsset)) && this._unbindSpriteAsset(a)),
            (this._spriteAsset = c) ? (a = b.get(this._spriteAsset)) ? this._bindSpriteAsset(a) : (this.sprite = null,
            b.on("add:" + this._spriteAsset, this._onSpriteAssetAdded, this)) : this.sprite = null,
            this._element && this._element.fire("set:spriteAsset", c))
        }
    });
    Object.defineProperty(cb.prototype, "sprite", {
        get: function() {
            return this._sprite
        },
        set: function(a) {
            if (this._sprite !== a) {
                this._sprite && this._unbindSprite(this._sprite);
                if (this._spriteAsset) {
                    var b = this._system.app.assets.get(this._spriteAsset);
                    b && b.resource !== a && (this.spriteAsset = null)
                }
                if (this._sprite = a)
                    this._bindSprite(this._sprite),
                    this._textureAsset && (this.textureAsset = null);
                this._sprite && this._sprite.atlas && this._sprite.atlas.texture ? (this._renderable.setParameter("texture_emissiveMap", this._sprite.atlas.texture),
                this._renderable.setParameter("texture_opacityMap", this._sprite.atlas.texture)) : (this._renderable.deleteParameter("texture_emissiveMap"),
                this._renderable.deleteParameter("texture_opacityMap"));
                this._sprite && (this._spriteFrame = N.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1));
                this._updateSprite()
            }
        }
    });
    Object.defineProperty(cb.prototype, "spriteFrame", {
        get: function() {
            return this._spriteFrame
        },
        set: function(a) {
            var b = this._spriteFrame;
            this._spriteFrame = this._sprite ? N.clamp(a, 0, this._sprite.frameKeys.length - 1) : a;
            this._spriteFrame !== b && (this._updateSprite(),
            this._element && this._element.fire("set:spriteFrame", a))
        }
    });
    Object.defineProperty(cb.prototype, "mesh", {
        get: function() {
            return this._renderable.mesh
        },
        set: function(a) {
            this._renderable.setMesh(a);
            this._defaultMesh === a ? this._renderable.setAabbFunc(null) : this._renderable.setAabbFunc(this._updateAabbFunc)
        }
    });
    Object.defineProperty(cb.prototype, "mask", {
        get: function() {
            return this._mask
        },
        set: function(a) {
            this._mask !== a && (this._mask = a,
            this._toggleMask())
        }
    });
    Object.defineProperty(cb.prototype, "pixelsPerUnit", {
        get: function() {
            return this._pixelsPerUnit
        },
        set: function(a) {
            this._pixelsPerUnit !== a && (this._pixelsPerUnit = a,
            !this._sprite || 1 !== this._sprite.renderMode && 2 !== this._sprite.renderMode || this._updateSprite())
        }
    });
    Object.defineProperty(cb.prototype, "aabb", {
        get: function() {
            return this._renderable.meshInstance ? this._renderable.meshInstance.aabb : null
        }
    });
    Ga.prototype = Object.create(M.prototype);
    Ga.prototype.constructor = Ga;
    Ga.prototype._bindDefaultAsset = function() {
        var a = this._app.assets.get(this._defaultAsset);
        if (a)
            this._onDefaultAssetAdd(a);
        else
            this._app.assets.once("add:" + this._defaultAsset, this._onDefaultAssetAdd, this)
    }
    ;
    Ga.prototype._unbindDefaultAsset = function() {
        if (this._defaultAsset) {
            this._app.assets.off("add:" + this._defaultAsset, this._onDefaultAssetAdd, this);
            var a = this._app.assets.get(this._defaultAsset);
            a && (a.off("add:localized", this._onLocaleAdd, this),
            a.off("remove:localized", this._onLocaleRemove, this),
            a.off("remove", this._onDefaultAssetRemove, this))
        }
    }
    ;
    Ga.prototype._onDefaultAssetAdd = function(a) {
        this._defaultAsset === a.id && (a.on("add:localized", this._onLocaleAdd, this),
        a.on("remove:localized", this._onLocaleRemove, this),
        a.once("remove", this._onDefaultAssetRemove, this))
    }
    ;
    Ga.prototype._onDefaultAssetRemove = function(a) {
        this._defaultAsset === a.id && (a.off("add:localized", this._onLocaleAdd, this),
        a.off("remove:localized", this._onLocaleAdd, this),
        this._app.assets.once("add:" + this._defaultAsset, this._onDefaultAssetAdd, this))
    }
    ;
    Ga.prototype._bindLocalizedAsset = function() {
        if (this._autoLoad) {
            var a = this._app.assets.get(this._localizedAsset);
            a && (a.on("load", this._onLocalizedAssetLoad, this),
            a.on("change", this._onLocalizedAssetChange, this),
            a.on("remove", this._onLocalizedAssetRemove, this),
            a.resource ? this._onLocalizedAssetLoad(a) : this._app.assets.load(a))
        }
    }
    ;
    Ga.prototype._unbindLocalizedAsset = function() {
        var a = this._app.assets.get(this._localizedAsset);
        a && (a.off("load", this._onLocalizedAssetLoad, this),
        a.off("change", this._onLocalizedAssetChange, this),
        a.off("remove", this._onLocalizedAssetRemove, this))
    }
    ;
    Ga.prototype._onLocalizedAssetAdd = function(a) {
        this._localizedAsset === a.id && this._bindLocalizedAsset()
    }
    ;
    Ga.prototype._onLocalizedAssetLoad = function(a) {
        this.fire("load", a)
    }
    ;
    Ga.prototype._onLocalizedAssetChange = function(a, b, c, d) {
        this.fire("change", a, b, c, d)
    }
    ;
    Ga.prototype._onLocalizedAssetRemove = function(a) {
        this._localizedAsset === a.id && (this.localizedAsset = this._defaultAsset);
        this.fire("remove", a)
    }
    ;
    Ga.prototype._onLocaleAdd = function(a, b) {
        this._app.i18n.locale === a && this._onSetLocale(a)
    }
    ;
    Ga.prototype._onLocaleRemove = function(a, b) {
        this._app.i18n.locale === a && this._onSetLocale(a)
    }
    ;
    Ga.prototype._onSetLocale = function(a) {
        if (this._defaultAsset) {
            var b = this._app.assets.get(this._defaultAsset);
            this.localizedAsset = !b || this._disableLocalization ? this._defaultAsset : (a = b.getLocalizedAssetId(a)) ? a : this._defaultAsset
        } else
            this.localizedAsset = null
    }
    ;
    Ga.prototype.destroy = function() {
        this.defaultAsset = null;
        this._app.i18n.off("set:locale", this._onSetLocale, this);
        this.off()
    }
    ;
    Object.defineProperty(Ga.prototype, "defaultAsset", {
        get: function() {
            return this._defaultAsset
        },
        set: function(a) {
            a = a instanceof aa ? a.id : a;
            this._defaultAsset !== a && (this._defaultAsset && this._unbindDefaultAsset(),
            (this._defaultAsset = a) && this._bindDefaultAsset(),
            this._onSetLocale(this._app.i18n.locale))
        }
    });
    Object.defineProperty(Ga.prototype, "localizedAsset", {
        get: function() {
            return this._localizedAsset
        },
        set: function(a) {
            a = a instanceof aa ? a.id : a;
            if (this._localizedAsset !== a && (this._localizedAsset && (this._app.assets.off("add:" + this._localizedAsset, this._onLocalizedAssetAdd, this),
            this._unbindLocalizedAsset(),
            this._localizedAsset = null),
            this._localizedAsset = a))
                if (this._app.assets.get(this._localizedAsset))
                    this._bindLocalizedAsset();
                else
                    this._app.assets.once("add:" + this._localizedAsset, this._onLocalizedAssetAdd, this)
        }
    });
    Object.defineProperty(Ga.prototype, "autoLoad", {
        get: function() {
            return this._autoLoad
        },
        set: function(a) {
            this._autoLoad !== a && (this._autoLoad = a) && this._localizedAsset && (this._unbindLocalizedAsset(),
            this._bindLocalizedAsset())
        }
    });
    Object.defineProperty(Ga.prototype, "disableLocalization", {
        get: function() {
            return this._disableLocalization
        },
        set: function(a) {
            this._disableLocalization !== a && (this._disableLocalization = a,
            this._onSetLocale(this._app.i18n.locale))
        }
    });
    Object.assign(jl.prototype, {
        EOF_TOKEN: 0,
        ERROR_TOKEN: 1,
        TEXT_TOKEN: 2,
        OPEN_BRACKET_TOKEN: 3,
        CLOSE_BRACKET_TOKEN: 4,
        EQUALS_TOKEN: 5,
        STRING_TOKEN: 6,
        IDENTIFIER_TOKEN: 7,
        WHITESPACE_TOKEN: 8,
        WHITESPACE_CHARS: " \t\n\r\v\f",
        IDENTIFIER_REGEX: /[A-Z|a-z|0-9|_|-|/]/,
        read: function() {
            for (var a = this._read(); a === this.WHITESPACE_TOKEN; )
                a = this._read();
            a !== this.EOF_TOKEN && a !== this.ERROR_TOKEN && (this._last = this._index);
            return a
        },
        buf: function() {
            return this._buf
        },
        last: function() {
            return this._last
        },
        error: function() {
            return this._error
        },
        debugPrint: function() {
            for (var a = "EOF ERROR TEXT OPEN_BRACKET CLOSE_BRACKET EQUALS STRING IDENTIFIER WHITESPACE".split(" "), b = this.read(), c = ""; ; ) {
                c += (0 < c.length ? "\n" : "") + a[b] + " '" + this.buf().join("") + "'";
                if (b === this.EOF_TOKEN || b === this.ERROR_TOKEN)
                    break;
                b = this.read()
            }
            return c
        },
        _read: function() {
            this._buf = [];
            return this._eof() ? this.EOF_TOKEN : "text" === this._mode ? this._text() : this._tag()
        },
        _text: function() {
            for (; ; )
                switch (this._cur) {
                case null:
                    return 0 < this._buf.length ? this.TEXT_TOKEN : this.EOF_TOKEN;
                case "[":
                    return this._mode = "tag",
                    0 < this._buf.length ? this.TEXT_TOKEN : this._tag();
                case "\\":
                    this._next();
                    switch (this._cur) {
                    case "[":
                        this._store();
                        break;
                    default:
                        this._output("\\")
                    }
                    break;
                default:
                    this._store()
                }
        },
        _tag: function() {
            for (; ; )
                switch (this._cur) {
                case null:
                    return this._error = "unexpected end of input reading tag",
                    this.ERROR_TOKEN;
                case "[":
                    return this._store(),
                    this.OPEN_BRACKET_TOKEN;
                case "]":
                    return this._store(),
                    this._mode = "text",
                    this.CLOSE_BRACKET_TOKEN;
                case "=":
                    return this._store(),
                    this.EQUALS_TOKEN;
                case " ":
                case "\t":
                case "\n":
                case "\r":
                case "\v":
                case "\f":
                    return this._whitespace();
                case '"':
                    return this._string();
                default:
                    return this._isIdentifierSymbol(this._cur) ? this._identifier() : (this._error = "unrecognized character",
                    this.ERROR_TOKEN)
                }
        },
        _whitespace: function() {
            for (this._store(); -1 !== this.WHITESPACE_CHARS.indexOf(this._cur); )
                this._store();
            return this.WHITESPACE_TOKEN
        },
        _string: function() {
            for (this._next(); ; )
                switch (this._cur) {
                case null:
                    return this._error = "unexpected end of input reading string",
                    this.ERROR_TOKEN;
                case '"':
                    return this._next(),
                    this.STRING_TOKEN;
                default:
                    this._store()
                }
        },
        _identifier: function() {
            for (this._store(); null !== this._cur && this._isIdentifierSymbol(this._cur); )
                this._store();
            return this.IDENTIFIER_TOKEN
        },
        _isIdentifierSymbol: function(a) {
            return 1 === a.length && null !== a.match(this.IDENTIFIER_REGEX)
        },
        _eof: function() {
            return null === this._cur
        },
        _next: function() {
            this._eof() || (this._index++,
            this._cur = this._index < this._symbols.length ? this._symbols[this._index] : null);
            return this._cur
        },
        _store: function() {
            this._buf.push(this._cur);
            return this._next()
        },
        _output: function(a) {
            this._buf.push(a)
        }
    });
    var ll = function(a) {
        this._scanner = new jl(a);
        this._error = null
    };
    Object.assign(ll.prototype, {
        parse: function(a, b) {
            for (; ; )
                switch (this._scanner.read()) {
                case this._scanner.EOF_TOKEN:
                    return !0;
                case this._scanner.ERROR_TOKEN:
                    return !1;
                case this._scanner.TEXT_TOKEN:
                    Array.prototype.push.apply(a, this._scanner.buf());
                    break;
                case this._scanner.OPEN_BRACKET_TOKEN:
                    if (!this._parseTag(a, b))
                        return !1;
                    break;
                default:
                    return !1
                }
        },
        error: function() {
            return "Error evaluating markup at #" + this._scanner.last().toString() + " (" + (this._scanner.error() || this._error) + ")"
        },
        _parseTag: function(a, b) {
            var c = this._scanner.read();
            if (c !== this._scanner.IDENTIFIER_TOKEN)
                return this._error = "expected identifier",
                !1;
            c = this._scanner.buf().join("");
            if ("/" === c[0]) {
                for (var d = b.length - 1; 0 <= d; --d)
                    if (c === "/" + b[d].name && null === b[d].end)
                        return b[d].end = a.length,
                        c = this._scanner.read(),
                        c !== this._scanner.CLOSE_BRACKET_TOKEN ? (this._error = "expected close bracket",
                        !1) : !0;
                this._error = "failed to find matching tag";
                return !1
            }
            a = {
                name: c,
                value: null,
                attributes: {},
                start: a.length,
                end: null
            };
            c = this._scanner.read();
            if (c === this._scanner.EQUALS_TOKEN) {
                c = this._scanner.read();
                if (c !== this._scanner.STRING_TOKEN)
                    return this._error = "expected string",
                    !1;
                a.value = this._scanner.buf().join("");
                c = this._scanner.read()
            }
            for (; ; ) {
                switch (c) {
                case this._scanner.CLOSE_BRACKET_TOKEN:
                    return b.push(a),
                    !0;
                case this._scanner.IDENTIFIER_TOKEN:
                    d = this._scanner.buf().join("");
                    c = this._scanner.read();
                    if (c !== this._scanner.EQUALS_TOKEN)
                        return this._error = "expected equals",
                        !1;
                    c = this._scanner.read();
                    if (c !== this._scanner.STRING_TOKEN)
                        return this._error = "expected string",
                        !1;
                    c = this._scanner.buf().join("");
                    a.attributes[d] = c;
                    break;
                default:
                    return this._error = "expected close bracket or identifier",
                    !1
                }
                c = this._scanner.read()
            }
        }
    });
    ml.evaluate = function(a) {
        return jo(a)
    }
    ;
    var Tm = /^[\r\n]$/
      , Kp = /^[ \t]$/
      , Lp = /^[ \t\-]$/;
    Object.assign(na.prototype, {
        destroy: function() {
            this._setMaterial(null);
            this._model && (this._element.removeModelFromLayers(this._model),
            this._model.destroy(),
            this._model = null);
            this._fontAsset.destroy();
            this.font = null;
            this._element.off("resize", this._onParentResize, this);
            this._element.off("set:screen", this._onScreenChange, this);
            this._element.off("screen:set:screenspace", this._onScreenSpaceChange, this);
            this._element.off("set:draworder", this._onDrawOrderChange, this);
            this._element.off("set:pivot", this._onPivotChange, this);
            this._system.app.i18n.off("set:locale", this._onLocaleSet, this);
            this._system.app.i18n.off("data:add", this._onLocalizationData, this);
            this._system.app.i18n.off("data:remove", this._onLocalizationData, this)
        },
        _onParentResize: function(a, b) {
            this._noResize || this._font && this._updateText()
        },
        _onScreenChange: function(a) {
            a ? this._updateMaterial(a.screen.screenSpace) : this._updateMaterial(!1)
        },
        _onScreenSpaceChange: function(a) {
            this._updateMaterial(a)
        },
        _onDrawOrderChange: function(a) {
            this._drawOrder = a;
            if (this._model) {
                var b;
                var c = 0;
                for (b = this._model.meshInstances.length; c < b; c++)
                    this._model.meshInstances[c].drawOrder = a
            }
        },
        _onPivotChange: function(a) {
            this._font && this._updateText()
        },
        _onLocaleSet: function(a) {
            this._i18nKey && (this.fontAsset && (a = this._system.app.assets.get(this.fontAsset),
            a && a.resource && a.resource === this._font || (this.font = null)),
            this._resetLocalizedText())
        },
        _onLocalizationData: function(a, b) {
            this._i18nKey && b[this._i18nKey] && this._resetLocalizedText()
        },
        _resetLocalizedText: function() {
            this._setText(this._system.app.i18n.getText(this._i18nKey))
        },
        _setText: function(a) {
            if (this.unicodeConverter) {
                var b = this._system.getUnicodeConverter();
                b ? a = b(a) : console.warn("Element created with unicodeConverter option but no unicodeConverter function registered")
            }
            this._text !== a && (this._font && this._updateText(a),
            this._text = a)
        },
        _updateText: function(a) {
            var b;
            void 0 === a && (a = this._text);
            this._symbols = vc.getSymbols(a);
            0 === this._symbols.length && (this._symbols = [" "]);
            if (this._enableMarkup) {
                a = ml.evaluate(this._symbols);
                this._symbols = a.symbols;
                var c = a.tags
            }
            this._rtlReorder ? (a = this._system.app.systems.element.getRtlReorder()) ? (a = a(this._symbols),
            this._rtl = a.rtl,
            this._symbols = a.mapping.map(function(q) {
                return this._symbols[q]
            }, this),
            c && (c = a.mapping.map(function(q) {
                return c[q]
            }))) : console.warn("Element created with rtlReorder option but no rtlReorder function registered") : this._rtl = !1;
            if (c) {
                var d = {};
                this._colorPalette = [Math.round(255 * this._color.r), Math.round(255 * this._color.g), Math.round(255 * this._color.b)];
                this._symbolColors = [];
                a = d[this._color.toString(!1).toLowerCase()] = 0;
                for (b = this._symbols.length; a < b; ++a) {
                    var e = c[a]
                      , f = 0;
                    e && e.color && e.color.value && (e = e.color.value,
                    7 === e.length && "#" === e[0] && (e = e.substring(1).toLowerCase(),
                    d.hasOwnProperty(e) ? f = d[e] : /^([0-9a-f]{2}){3}$/.test(e) && (f = this._colorPalette.length / 3,
                    d[e] = f,
                    this._colorPalette.push(parseInt(e.substring(0, 2), 16)),
                    this._colorPalette.push(parseInt(e.substring(2, 4), 16)),
                    this._colorPalette.push(parseInt(e.substring(4, 6), 16)))));
                    this._symbolColors.push(f)
                }
            } else
                this._colorPalette = [],
                this._symbolColors = null;
            d = this._calculateCharsPerTexture();
            f = !1;
            var g = this._element;
            e = g._isScreenSpace();
            var k = g._isScreenCulled()
              , h = function(q) {
                return g.isVisibleForCamera(q)
            };
            a = 0;
            for (b = this._meshInfo.length; a < b; a++) {
                var l = d[a] || 0
                  , n = this._meshInfo[a];
                if (n.count !== l)
                    if (f || (g.removeModelFromLayers(this._model),
                    f = !0),
                    n.count = l,
                    n.positions.length = n.normals.length = 12 * l,
                    n.indices.length = 6 * l,
                    n.uvs.length = 8 * l,
                    n.colors.length = 16 * l,
                    n.meshInstance && this._removeMeshInstance(n.meshInstance),
                    0 === l)
                        n.meshInstance = null;
                    else {
                        for (var p = 0; p < l; p++)
                            n.indices[6 * p] = 4 * p,
                            n.indices[6 * p + 1] = 4 * p + 1,
                            n.indices[6 * p + 2] = 4 * p + 3,
                            n.indices[6 * p + 3] = 4 * p + 2,
                            n.indices[6 * p + 4] = 4 * p + 3,
                            n.indices[6 * p + 5] = 4 * p + 1,
                            n.normals[12 * p] = 0,
                            n.normals[12 * p + 1] = 0,
                            n.normals[12 * p + 2] = -1,
                            n.normals[12 * p + 3] = 0,
                            n.normals[12 * p + 4] = 0,
                            n.normals[12 * p + 5] = -1,
                            n.normals[12 * p + 6] = 0,
                            n.normals[12 * p + 7] = 0,
                            n.normals[12 * p + 8] = -1,
                            n.normals[12 * p + 9] = 0,
                            n.normals[12 * p + 10] = 0,
                            n.normals[12 * p + 11] = -1;
                        l = Qb(this._system.app.graphicsDevice, n.positions, {
                            uvs: n.uvs,
                            normals: n.normals,
                            colors: n.colors,
                            indices: n.indices
                        });
                        l = new va(this._node,l,this._material);
                        l.name = "Text Element: " + this._entity.name;
                        l.castShadow = !1;
                        l.receiveShadow = !1;
                        l.cull = !e;
                        l.screenSpace = e;
                        l.drawOrder = this._drawOrder;
                        k && (l.cull = !0,
                        l.isVisibleFunc = h);
                        this._setTextureParams(l, this._font.textures[a]);
                        this._symbolColors ? (this._colorUniform[0] = 1,
                        this._colorUniform[1] = 1,
                        this._colorUniform[2] = 1) : (this._colorUniform[0] = this._color.r,
                        this._colorUniform[1] = this._color.g,
                        this._colorUniform[2] = this._color.b);
                        l.setParameter("material_emissive", this._colorUniform);
                        l.setParameter("material_opacity", this._color.a);
                        l.setParameter("font_sdfIntensity", this._font.intensity);
                        l.setParameter("font_pxrange", this._getPxRange(this._font));
                        l.setParameter("font_textureWidth", this._font.data.info.maps[a].width);
                        this._outlineColorUniform[0] = this._outlineColor.r;
                        this._outlineColorUniform[1] = this._outlineColor.g;
                        this._outlineColorUniform[2] = this._outlineColor.b;
                        this._outlineColorUniform[3] = this._outlineColor.a;
                        l.setParameter("outline_color", this._outlineColorUniform);
                        l.setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness);
                        this._shadowColorUniform[0] = this._shadowColor.r;
                        this._shadowColorUniform[1] = this._shadowColor.g;
                        this._shadowColorUniform[2] = this._shadowColor.b;
                        this._shadowColorUniform[3] = this._shadowColor.a;
                        l.setParameter("shadow_color", this._shadowColorUniform);
                        p = this._font.data.info.maps[a].width / this._font.data.info.maps[a].height;
                        this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
                        this._shadowOffsetUniform[1] = p * this._shadowOffsetScale * this._shadowOffset.y;
                        l.setParameter("shadow_offset", this._shadowOffsetUniform);
                        n.meshInstance = l;
                        this._model.meshInstances.push(l)
                    }
            }
            this._element.maskedBy && this._element._setMaskedBy(this._element.maskedBy);
            f && this._element.enabled && this._entity.enabled && this._element.addModelToLayers(this._model);
            this._updateMeshes();
            this._rangeStart = 0;
            this._rangeEnd = this._symbols.length;
            this._updateRenderRange()
        },
        _removeMeshInstance: function(a) {
            a.material = null;
            var b = a.mesh;
            b && b.destroy();
            a = this._model.meshInstances.indexOf(a);
            -1 !== a && this._model.meshInstances.splice(a, 1)
        },
        _setMaterial: function(a) {
            var b;
            this._material = a;
            if (this._model) {
                var c = 0;
                for (b = this._model.meshInstances.length; c < b; c++)
                    this._model.meshInstances[c].material = a
            }
        },
        _updateMaterial: function(a) {
            var b = this._element
              , c = b._isScreenCulled()
              , d = function(k) {
                return b.isVisibleForCamera(k)
            };
            this._material = this._system.getTextElementMaterial(a, this._font && "msdf" === this._font.type);
            if (this._model)
                for (var e = 0, f = this._model.meshInstances.length; e < f; e++) {
                    var g = this._model.meshInstances[e];
                    g.cull = !a;
                    g.material = this._material;
                    g.screenSpace = a;
                    c ? (g.cull = !0,
                    g.isVisibleFunc = d) : g.isVisibleFunc = null
                }
        },
        _updateMeshes: function() {
            function a(qc, Tc, lg) {
                c._lineWidths.push(Math.abs(lg));
                qc = qc.slice(t > Tc ? Tc + 1 : t, t > Tc ? t + 1 : Tc);
                if (v)
                    for (lg = qc.length; lg-- && 0 < v; )
                        Tm.test(qc[lg]) && (qc.splice(lg, 1),
                        v--);
                c._lineContents.push(qc.join(""));
                k = 0;
                h -= c._scaledLineHeight;
                p++;
                q = v = x = u = 0;
                t = Tc
            }
            var b = this._font.data
              , c = this
              , d = Math.min(this._minFontSize, this._maxFontSize)
              , e = this._maxFontSize
              , f = this._shouldAutoFit();
            f && (this._fontSize = this._maxFontSize);
            var g = this._symbols.length
              , k = 0
              , h = 0
              , l = 0
              , n = 0
              , p = 1
              , q = 0
              , r = 0
              , t = 0
              , u = 0
              , x = 0
              , v = 0
              , w = 1E-4 <= Math.abs(this._element.anchor.x - this._element.anchor.z)
              , y = this._element.calculatedWidth;
            if (this.autoWidth && !w || !this._wrapLines)
                y = Number.POSITIVE_INFINITY;
            var A = 0;
            w = 0;
            for (var B = 1, E, C, D, G = !0; G; ) {
                G = !1;
                this._scaledLineHeight = f ? this._lineHeight * this._fontSize / (this._maxFontSize || 1E-4) : this._lineHeight;
                this.height = this.width = 0;
                this._lineWidths = [];
                this._lineContents = [];
                n = l = h = k = 0;
                p = 1;
                v = x = u = t = r = q = 0;
                B = this._fontSize / 32;
                A = this._fontMinY * B;
                w = this._fontMaxY * B;
                for (D = 0; D < this._meshInfo.length; D++)
                    this._meshInfo[D].quad = 0,
                    this._meshInfo[D].lines = {};
                var J = 255
                  , R = 255
                  , I = 255;
                for (D = 0; D < g; D++) {
                    E = this._symbols[D];
                    var T = 0
                      , S = 0
                      , ba = 0
                      , ha = 1;
                    C = b.chars[E];
                    if (!C)
                        if (b.chars[" "])
                            C = b.chars[" "];
                        else
                            for (var W in b.chars) {
                                C = b.chars[W];
                                break
                            }
                    if (C) {
                        var Q = 0;
                        0 < x && (ba = this._font.data.kerning) && (ba = ba[vc.getCodePoint(this._symbols[D - 1]) || 0]) && (Q = ba[vc.getCodePoint(this._symbols[D]) || 0] || 0);
                        ba = C.scale || 1;
                        var Nb = (C.width + C.height) / 2;
                        ha = B * Nb / ba;
                        ba = (C.xadvance + Q) * B;
                        T = (C.xoffset - Q) * B;
                        S = C.yoffset * B
                    } else
                        console.error("Couldn't substitute missing character: '" + E + "'");
                    if (Nb = Tm.test(E)) {
                        if (v++,
                        0 > this._maxLines || p < this._maxLines)
                            a(this._symbols, D, n),
                            r = D + 1,
                            t = D + 1
                    } else {
                        var bf = Kp.test(E);
                        Q = this._meshInfo[C && C.map || 0];
                        var Da = k + this._spacing * ba;
                        if (Da > y && 0 < x && !bf && (0 > this._maxLines || p < this._maxLines))
                            if (0 === u)
                                r = D,
                                a(this._symbols, D, n);
                            else {
                                C = Math.max(D - r, 0);
                                if (1 >= this._meshInfo.length)
                                    Q.lines[p - 1] -= C,
                                    Q.quad -= C;
                                else
                                    for (Q = D,
                                    E = r; E < Q; E++)
                                        ba = b.chars[this._symbols[E]],
                                        ba = this._meshInfo[ba && ba.map || 0],
                                        --ba.lines[p - 1],
                                        --ba.quad;
                                D -= C + 1;
                                a(this._symbols, r, q);
                                continue
                            }
                        C = Q.quad;
                        Q.lines[p - 1] = C;
                        var lb = k - T
                          , Cc = lb + ha;
                        S = h - S;
                        var Sc = S + ha;
                        this._rtl && (ha = ha - T - this._spacing * ba - T,
                        lb -= ha,
                        Cc -= ha);
                        Q.positions[12 * C] = lb;
                        Q.positions[12 * C + 1] = S;
                        Q.positions[12 * C + 2] = l;
                        Q.positions[12 * C + 3] = Cc;
                        Q.positions[12 * C + 4] = S;
                        Q.positions[12 * C + 5] = l;
                        Q.positions[12 * C + 6] = Cc;
                        Q.positions[12 * C + 7] = Sc;
                        Q.positions[12 * C + 8] = l;
                        Q.positions[12 * C + 9] = lb;
                        Q.positions[12 * C + 10] = Sc;
                        Q.positions[12 * C + 11] = l;
                        this.width = Math.max(this.width, Da);
                        if (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth && (ha = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 1E-4)),
                        ha = N.clamp(ha, d, e),
                        ha !== this._element.fontSize)) {
                            this._fontSize = ha;
                            G = !0;
                            break
                        }
                        this.height = Math.max(this.height, w - (h + A));
                        if (this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight && (ha = N.clamp(this._fontSize - 1, d, e),
                        ha !== this._element.fontSize)) {
                            this._fontSize = ha;
                            G = !0;
                            break
                        }
                        k += this._spacing * ba;
                        bf || Nb || (n = k);
                        Lp.test(E) && (u++,
                        q = n,
                        r = D + 1);
                        x++;
                        E = this._getUv(E);
                        Q.uvs[8 * C] = E[0];
                        Q.uvs[8 * C + 1] = E[1];
                        Q.uvs[8 * C + 2] = E[2];
                        Q.uvs[8 * C + 3] = E[1];
                        Q.uvs[8 * C + 4] = E[2];
                        Q.uvs[8 * C + 5] = E[3];
                        Q.uvs[8 * C + 6] = E[0];
                        Q.uvs[8 * C + 7] = E[3];
                        this._symbolColors && (I = 3 * this._symbolColors[D],
                        J = this._colorPalette[I],
                        R = this._colorPalette[I + 1],
                        I = this._colorPalette[I + 2]);
                        Q.colors[16 * C] = J;
                        Q.colors[16 * C + 1] = R;
                        Q.colors[16 * C + 2] = I;
                        Q.colors[16 * C + 3] = 255;
                        Q.colors[16 * C + 4] = J;
                        Q.colors[16 * C + 5] = R;
                        Q.colors[16 * C + 6] = I;
                        Q.colors[16 * C + 7] = 255;
                        Q.colors[16 * C + 8] = J;
                        Q.colors[16 * C + 9] = R;
                        Q.colors[16 * C + 10] = I;
                        Q.colors[16 * C + 11] = 255;
                        Q.colors[16 * C + 12] = J;
                        Q.colors[16 * C + 13] = R;
                        Q.colors[16 * C + 14] = I;
                        Q.colors[16 * C + 15] = 255;
                        Q.quad++
                    }
                }
                G || t < g && a(this._symbols, g, k)
            }
            this._noResize = !0;
            this.autoWidth = this._autoWidth;
            this.autoHeight = this._autoHeight;
            this._noResize = !1;
            b = this._element.pivot.x;
            d = this._element.pivot.y;
            e = this._alignment.x;
            f = this._alignment.y;
            for (D = 0; D < this._meshInfo.length; D++)
                if (0 !== this._meshInfo[D].count) {
                    W = 0;
                    for (var mb in this._meshInfo[D].lines) {
                        g = this._meshInfo[D].lines[mb];
                        y = this._lineWidths[parseInt(mb, 10)];
                        y = -b * this._element.calculatedWidth + e * (this._element.calculatedWidth - y) * (this._rtl ? -1 : 1);
                        l = (1 - d) * this._element.calculatedHeight - w - (1 - f) * (this._element.calculatedHeight - this.height);
                        for (C = W; C <= g; C++)
                            this._meshInfo[D].positions[12 * C] += y,
                            this._meshInfo[D].positions[12 * C + 3] += y,
                            this._meshInfo[D].positions[12 * C + 6] += y,
                            this._meshInfo[D].positions[12 * C + 9] += y,
                            this._meshInfo[D].positions[12 * C + 1] += l,
                            this._meshInfo[D].positions[12 * C + 4] += l,
                            this._meshInfo[D].positions[12 * C + 7] += l,
                            this._meshInfo[D].positions[12 * C + 10] += l;
                        if (this._rtl)
                            for (C = W; C <= g; C++) {
                                W = 12 * C;
                                for (l = 0; 4 > l; ++l)
                                    this._meshInfo[D].positions[W + 3 * l] = this._element.calculatedWidth - this._meshInfo[D].positions[W + 3 * l] + 2 * y;
                                l = this._meshInfo[D].positions[W + 3];
                                n = this._meshInfo[D].positions[W + 6];
                                this._meshInfo[D].positions[W + 3] = this._meshInfo[D].positions[W + 0];
                                this._meshInfo[D].positions[W + 6] = this._meshInfo[D].positions[W + 9];
                                this._meshInfo[D].positions[W + 0] = l;
                                this._meshInfo[D].positions[W + 9] = n
                            }
                        W = g + 1
                    }
                    g = 4 * this._meshInfo[D].count;
                    y = 4 * this._meshInfo[D].quad;
                    C = new Pb(this._meshInfo[D].meshInstance.mesh.vertexBuffer);
                    for (W = 0; W < g; W++)
                        W >= y ? (C.element.POSITION.set(0, 0, 0),
                        C.element.TEXCOORD0.set(0, 0),
                        C.element.COLOR.set(0, 0, 0, 0)) : (C.element.POSITION.set(this._meshInfo[D].positions[3 * W], this._meshInfo[D].positions[3 * W + 1], this._meshInfo[D].positions[3 * W + 2]),
                        C.element.TEXCOORD0.set(this._meshInfo[D].uvs[2 * W], this._meshInfo[D].uvs[2 * W + 1]),
                        C.element.COLOR.set(this._meshInfo[D].colors[4 * W], this._meshInfo[D].colors[4 * W + 1], this._meshInfo[D].colors[4 * W + 2], this._meshInfo[D].colors[4 * W + 3])),
                        C.next();
                    C.end();
                    this._meshInfo[D].meshInstance.mesh.aabb.compute(this._meshInfo[D].positions);
                    this._meshInfo[D].meshInstance._aabbVer = -1
                }
            this._aabbDirty = !0
        },
        _onFontRender: function() {
            this.font = this._font
        },
        _onFontLoad: function(a) {
            this.font !== a.resource && (this.font = a.resource)
        },
        _onFontChange: function(a, b, c, d) {
            if ("data" === b)
                for (this._font.data = c,
                a = this._font.data.info.maps.length,
                b = 0; b < a; b++)
                    this._meshInfo[b] && (c = this._meshInfo[b].meshInstance) && (c.setParameter("font_sdfIntensity", this._font.intensity),
                    c.setParameter("font_pxrange", this._getPxRange(this._font)),
                    c.setParameter("font_textureWidth", this._font.data.info.maps[b].width))
        },
        _onFontRemove: function(a) {},
        _setTextureParams: function(a, b) {
            this._font && ("msdf" === this._font.type ? (a.deleteParameter("texture_emissiveMap"),
            a.deleteParameter("texture_opacityMap"),
            a.setParameter("texture_msdfMap", b)) : "bitmap" === this._font.type && (a.deleteParameter("texture_msdfMap"),
            a.setParameter("texture_emissiveMap", b),
            a.setParameter("texture_opacityMap", b)))
        },
        _getPxRange: function(a) {
            a = Object.keys(this._font.data.chars);
            for (var b = 0; b < a.length; b++) {
                var c = this._font.data.chars[a[b]];
                if (c.range)
                    return (c.scale || 1) * c.range
            }
            return 2
        },
        _getUv: function(a) {
            var b = this._font.data;
            if (!b.chars[a])
                return b.chars[" "] ? this._getUv(" ") : [0, 0, 0, 0];
            var c = b.chars[a].map
              , d = b.info.maps[c].width;
            c = b.info.maps[c].height;
            var e = b.chars[a].x
              , f = b.chars[a].y
              , g = 1 - b.chars[a].height / c;
            return [e / d, g - f / c, (e + b.chars[a].width) / d, g - (f - b.chars[a].height) / c]
        },
        onEnable: function() {
            this._fontAsset.autoLoad = !0;
            this._model && this._element.addModelToLayers(this._model)
        },
        onDisable: function() {
            this._fontAsset.autoLoad = !1;
            this._model && this._element.removeModelFromLayers(this._model)
        },
        _setStencil: function(a) {
            if (this._model)
                for (var b = this._model.meshInstances, c = 0; c < b.length; c++)
                    b[c].stencilFront = a,
                    b[c].stencilBack = a
        },
        _shouldAutoFitWidth: function() {
            return this._autoFitWidth && !this._autoWidth
        },
        _shouldAutoFitHeight: function() {
            return this._autoFitHeight && !this._autoHeight
        },
        _shouldAutoFit: function() {
            return this._autoFitWidth && !this._autoWidth || this._autoFitHeight && !this._autoHeight
        },
        _calculateCharsPerTexture: function(a) {
            var b = {};
            void 0 === a && (a = this._symbols.length);
            var c;
            for (c = 0; c < a; c++) {
                var d = this._symbols[c];
                d = this._font.data.chars[d];
                d || (d = this._font.data.chars[" "]) || (d = this._font.data.chars[Object.keys(this._font.data.chars)[0]]);
                d = d.map;
                b[d] ? b[d]++ : b[d] = 1
            }
            return b
        },
        _updateRenderRange: function() {
            var a = 0 === this._rangeStart ? 0 : this._calculateCharsPerTexture(this._rangeStart), b = 0 === this._rangeEnd ? 0 : this._calculateCharsPerTexture(this._rangeEnd), c;
            var d = 0;
            for (c = this._meshInfo.length; d < c; d++) {
                var e = a[d] || 0
                  , f = b[d] || 0
                  , g = this._meshInfo[d].meshInstance;
                g && (g = g.mesh) && (g.primitive[0].base = 6 * e,
                g.primitive[0].count = 6 * (f - e))
            }
        }
    });
    Object.defineProperty(na.prototype, "text", {
        get: function() {
            return this._text
        },
        set: function(a) {
            this._i18nKey = null;
            this._setText(null != a && a.toString() || "")
        }
    });
    Object.defineProperty(na.prototype, "key", {
        get: function() {
            return this._i18nKey
        },
        set: function(a) {
            a = null !== a ? a.toString() : null;
            this._i18nKey !== a && ((this._i18nKey = a) ? (this._fontAsset.disableLocalization = !1,
            this._resetLocalizedText()) : this._fontAsset.disableLocalization = !0)
        }
    });
    Object.defineProperty(na.prototype, "color", {
        get: function() {
            return this._color
        },
        set: function(a) {
            var b = a.r
              , c = a.g;
            a = a.b;
            if (this._color.r !== b || this._color.g !== c || this._color.b !== a)
                if (this._color.r = b,
                this._color.g = c,
                this._color.b = a,
                this._symbolColors)
                    this._font && this._updateText();
                else
                    for (this._colorUniform[0] = this._color.r,
                    this._colorUniform[1] = this._color.g,
                    this._colorUniform[2] = this._color.b,
                    b = 0,
                    c = this._model.meshInstances.length; b < c; b++)
                        this._model.meshInstances[b].setParameter("material_emissive", this._colorUniform)
        }
    });
    Object.defineProperty(na.prototype, "opacity", {
        get: function() {
            return this._color.a
        },
        set: function(a) {
            if (this._color.a !== a && (this._color.a = a,
            this._model))
                for (var b = 0, c = this._model.meshInstances.length; b < c; b++)
                    this._model.meshInstances[b].setParameter("material_opacity", a)
        }
    });
    Object.defineProperty(na.prototype, "lineHeight", {
        get: function() {
            return this._lineHeight
        },
        set: function(a) {
            var b = this._lineHeight;
            this._scaledLineHeight = this._lineHeight = a;
            b !== a && this._font && this._updateText()
        }
    });
    Object.defineProperty(na.prototype, "wrapLines", {
        get: function() {
            return this._wrapLines
        },
        set: function(a) {
            var b = this._wrapLines;
            this._wrapLines = a;
            b !== a && this._font && this._updateText()
        }
    });
    Object.defineProperty(na.prototype, "lines", {
        get: function() {
            return this._lineContents
        }
    });
    Object.defineProperty(na.prototype, "spacing", {
        get: function() {
            return this._spacing
        },
        set: function(a) {
            var b = this._spacing;
            this._spacing = a;
            b !== a && this._font && this._updateText()
        }
    });
    Object.defineProperty(na.prototype, "fontSize", {
        get: function() {
            return this._fontSize
        },
        set: function(a) {
            var b = this._fontSize;
            this._originalFontSize = this._fontSize = a;
            b !== a && this._font && this._updateText()
        }
    });
    Object.defineProperty(na.prototype, "fontAsset", {
        get: function() {
            return this._fontAsset.localizedAsset
        },
        set: function(a) {
            this._fontAsset.defaultAsset = a
        }
    });
    Object.defineProperty(na.prototype, "font", {
        get: function() {
            return this._font
        },
        set: function(a) {
            if (this._font) {
                var b = this._font.type;
                this._font.off && this._font.off("render", this._onFontRender, this)
            }
            this._font = a;
            this._fontMaxY = this._fontMinY = 0;
            if (a) {
                var c = this._font.data, d;
                for (d in c.chars) {
                    var e = c.chars[d];
                    e.bounds && (this._fontMinY = Math.min(this._fontMinY, e.bounds[1]),
                    this._fontMaxY = Math.max(this._fontMaxY, e.bounds[3]))
                }
                if (this._font.on)
                    this._font.on("render", this._onFontRender, this);
                this._fontAsset.localizedAsset && this._system.app.assets.get(this._fontAsset.localizedAsset).resource !== this._font && (this._fontAsset.defaultAsset = null);
                a.type !== b && (a = this._element._isScreenSpace(),
                this._updateMaterial(a));
                a = 0;
                for (b = this._font.textures.length; a < b; a++)
                    if (this._meshInfo[a]) {
                        if (c = this._meshInfo[a].meshInstance)
                            c.setParameter("font_sdfIntensity", this._font.intensity),
                            c.setParameter("font_pxrange", this._getPxRange(this._font)),
                            c.setParameter("font_textureWidth", this._font.data.info.maps[a].width),
                            this._setTextureParams(c, this._font.textures[a])
                    } else
                        this._meshInfo[a] = new ko;
                b = !1;
                for (a = this._font.textures.length; a < this._meshInfo.length; a++)
                    this._meshInfo[a].meshInstance && (b || (this._element.removeModelFromLayers(this._model),
                    b = !0),
                    this._removeMeshInstance(this._meshInfo[a].meshInstance));
                this._meshInfo.length > this._font.textures.length && (this._meshInfo.length = this._font.textures.length);
                this._updateText()
            }
        }
    });
    Object.defineProperty(na.prototype, "alignment", {
        get: function() {
            return this._alignment
        },
        set: function(a) {
            a instanceof P ? this._alignment.set(a.x, a.y) : this._alignment.set(a[0], a[1]);
            this._font && this._updateText()
        }
    });
    Object.defineProperty(na.prototype, "autoWidth", {
        get: function() {
            return this._autoWidth
        },
        set: function(a) {
            var b = this._autoWidth;
            (this._autoWidth = a) && 1E-4 > Math.abs(this._element.anchor.x - this._element.anchor.z) && (this._element.width = this.width);
            b !== a && (a = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize,
            a !== this._fontSize && (this._fontSize = a,
            this._font && this._updateText()))
        }
    });
    Object.defineProperty(na.prototype, "autoHeight", {
        get: function() {
            return this._autoHeight
        },
        set: function(a) {
            var b = this._autoHeight;
            (this._autoHeight = a) && 1E-4 > Math.abs(this._element.anchor.y - this._element.anchor.w) && (this._element.height = this.height);
            b !== a && (a = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize,
            a !== this._fontSize && (this._fontSize = a,
            this._font && this._updateText()))
        }
    });
    Object.defineProperty(na.prototype, "rtlReorder", {
        get: function() {
            return this._rtlReorder
        },
        set: function(a) {
            this._rtlReorder !== a && (this._rtlReorder = a,
            this._font && this._updateText())
        }
    });
    Object.defineProperty(na.prototype, "unicodeConverter", {
        get: function() {
            return this._unicodeConverter
        },
        set: function(a) {
            this._unicodeConverter !== a && (this._unicodeConverter = a,
            this._setText(this._text))
        }
    });
    Object.defineProperty(na.prototype, "aabb", {
        get: function() {
            if (this._aabbDirty) {
                for (var a = !1, b = 0; b < this._meshInfo.length; b++)
                    this._meshInfo[b].meshInstance && (a ? this._aabb.add(this._meshInfo[b].meshInstance.aabb) : (this._aabb.copy(this._meshInfo[b].meshInstance.aabb),
                    a = !0));
                this._aabbDirty = !1
            }
            return this._aabb
        }
    });
    Object.defineProperty(na.prototype, "outlineColor", {
        get: function() {
            return this._outlineColor
        },
        set: function(a) {
            var b = a instanceof L ? a.r : a[0]
              , c = a instanceof L ? a.g : a[1]
              , d = a instanceof L ? a.b : a[2];
            a = a instanceof L ? a.a : a[3];
            if (this._outlineColor.r !== b || this._outlineColor.g !== c || this._outlineColor.b !== d || this._outlineColor.a !== a)
                if (this._outlineColor.r = b,
                this._outlineColor.g = c,
                this._outlineColor.b = d,
                this._outlineColor.a = a,
                this._model)
                    for (this._outlineColorUniform[0] = this._outlineColor.r,
                    this._outlineColorUniform[1] = this._outlineColor.g,
                    this._outlineColorUniform[2] = this._outlineColor.b,
                    this._outlineColorUniform[3] = this._outlineColor.a,
                    b = 0,
                    c = this._model.meshInstances.length; b < c; b++)
                        this._model.meshInstances[b].setParameter("outline_color", this._outlineColorUniform)
        }
    });
    Object.defineProperty(na.prototype, "outlineThickness", {
        get: function() {
            return this._outlineThickness
        },
        set: function(a) {
            var b = this._outlineThickness;
            this._outlineThickness = a;
            if (b !== a && this._font && this._model)
                for (a = 0,
                b = this._model.meshInstances.length; a < b; a++)
                    this._model.meshInstances[a].setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness)
        }
    });
    Object.defineProperty(na.prototype, "shadowColor", {
        get: function() {
            return this._shadowColor
        },
        set: function(a) {
            var b = a instanceof L ? a.r : a[0]
              , c = a instanceof L ? a.g : a[1]
              , d = a instanceof L ? a.b : a[2];
            a = a instanceof L ? a.a : a[3];
            if (this._shadowColor.r !== b || this._shadowColor.g !== c || this._shadowColor.b !== d || this._shadowColor.a !== a)
                if (this._shadowColor.r = b,
                this._shadowColor.g = c,
                this._shadowColor.b = d,
                this._shadowColor.a = a,
                this._model)
                    for (this._shadowColorUniform[0] = this._shadowColor.r,
                    this._shadowColorUniform[1] = this._shadowColor.g,
                    this._shadowColorUniform[2] = this._shadowColor.b,
                    this._shadowColorUniform[3] = this._shadowColor.a,
                    b = 0,
                    c = this._model.meshInstances.length; b < c; b++)
                        this._model.meshInstances[b].setParameter("shadow_color", this._shadowColorUniform)
        }
    });
    Object.defineProperty(na.prototype, "shadowOffset", {
        get: function() {
            return this._shadowOffset
        },
        set: function(a) {
            var b = a instanceof P ? a.x : a[0];
            a = a instanceof P ? a.y : a[1];
            if (this._shadowOffset.x !== b || this._shadowOffset.y !== a)
                if (this._shadowOffset.set(b, a),
                this._font && this._model)
                    for (b = 0,
                    a = this._model.meshInstances.length; b < a; b++) {
                        var c = this._font.data.info.maps[b].width / this._font.data.info.maps[b].height;
                        this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
                        this._shadowOffsetUniform[1] = c * this._shadowOffsetScale * this._shadowOffset.y;
                        this._model.meshInstances[b].setParameter("shadow_offset", this._shadowOffsetUniform)
                    }
        }
    });
    Object.defineProperty(na.prototype, "minFontSize", {
        get: function() {
            return this._minFontSize
        },
        set: function(a) {
            this._minFontSize !== a && (this._minFontSize = a,
            this.font && this._shouldAutoFit() && this._updateText())
        }
    });
    Object.defineProperty(na.prototype, "maxFontSize", {
        get: function() {
            return this._maxFontSize
        },
        set: function(a) {
            this._maxFontSize !== a && (this._maxFontSize = a,
            this.font && this._shouldAutoFit() && this._updateText())
        }
    });
    Object.defineProperty(na.prototype, "autoFitWidth", {
        get: function() {
            return this._autoFitWidth
        },
        set: function(a) {
            this._autoFitWidth !== a && (this._autoFitWidth = a,
            this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize,
            this.font && this._updateText())
        }
    });
    Object.defineProperty(na.prototype, "autoFitHeight", {
        get: function() {
            return this._autoFitHeight
        },
        set: function(a) {
            this._autoFitHeight !== a && (this._autoFitHeight = a,
            this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize,
            this.font && this._updateText())
        }
    });
    Object.defineProperty(na.prototype, "maxLines", {
        get: function() {
            return this._maxLines
        },
        set: function(a) {
            this._maxLines === a || null === a && -1 === this._maxLines || (this._maxLines = null === a ? -1 : a,
            this.font && this._wrapLines && this._updateText())
        }
    });
    Object.defineProperty(na.prototype, "enableMarkup", {
        get: function() {
            return this._enableMarkup
        },
        set: function(a) {
            a = !!a;
            this._enableMarkup !== a && (this._enableMarkup = a,
            this.font && this._updateText())
        }
    });
    Object.defineProperty(na.prototype, "symbols", {
        get: function() {
            return this._symbols
        }
    });
    Object.defineProperty(na.prototype, "symbolColors", {
        get: function() {
            return null === this._symbolColors ? null : this._symbolColors.map(function(a) {
                return this._colorPalette.slice(3 * a, 3 * a + 3)
            }, this)
        }
    });
    Object.defineProperty(na.prototype, "rtl", {
        get: function() {
            return this._rtl
        }
    });
    Object.defineProperty(na.prototype, "rangeStart", {
        get: function() {
            return this._rangeStart
        },
        set: function(a) {
            a = Math.max(0, Math.min(a, this._symbols.length));
            a !== this._rangeStart && (this._rangeStart = a,
            this._updateRenderRange())
        }
    });
    Object.defineProperty(na.prototype, "rangeEnd", {
        get: function() {
            return this._rangeEnd
        },
        set: function(a) {
            a = Math.max(this._rangeStart, Math.min(a, this._symbols.length));
            a !== this._rangeEnd && (this._rangeEnd = a,
            this._updateRenderRange())
        }
    });
    var Fc = new z
      , me = new z
      , bc = new K
      , Ih = new K
      , Jh = new K
      , nf = new K;
    ia.prototype = Object.create(O.prototype);
    ia.prototype.constructor = ia;
    Object.assign(ia.prototype, {
        _patch: function() {
            this.entity._sync = this._sync;
            this.entity.setPosition = this._setPosition;
            this.entity.setLocalPosition = this._setLocalPosition
        },
        _unpatch: function() {
            this.entity._sync = fa.prototype._sync;
            this.entity.setPosition = fa.prototype.setPosition;
            this.entity.setLocalPosition = fa.prototype.setLocalPosition
        },
        _setPosition: function() {
            var a = new z
              , b = new K;
            return function(c, d, e) {
                if (!this.element.screen)
                    return fa.prototype.setPosition.call(this, c, d, e);
                c instanceof z ? a.copy(c) : a.set(c, d, e);
                this.getWorldTransform();
                b.copy(this.element._screenToWorld).invert();
                b.transformPoint(a, this.localPosition);
                this._dirtyLocal || this._dirtifyLocal()
            }
        }(),
        _setLocalPosition: function(a, b, c) {
            a instanceof z ? this.localPosition.copy(a) : this.localPosition.set(a, b, c);
            a = this.element;
            b = this.localPosition;
            c = a._pivot;
            a._margin.x = b.x - a._calculatedWidth * c.x;
            a._margin.z = a._localAnchor.z - a._localAnchor.x - a._calculatedWidth - a._margin.x;
            a._margin.y = b.y - a._calculatedHeight * c.y;
            a._margin.w = a._localAnchor.w - a._localAnchor.y - a._calculatedHeight - a._margin.y;
            this._dirtyLocal || this._dirtifyLocal()
        },
        _sync: function() {
            var a = this.element
              , b = a.screen;
            if (b) {
                if (a._anchorDirty) {
                    var c = 0
                      , d = 1;
                    if (this._parent && this._parent.element) {
                        var e = this._parent.element.calculatedWidth;
                        var f = this._parent.element.calculatedHeight;
                        c = this._parent.element.pivot.x;
                        d = this._parent.element.pivot.y
                    } else
                        f = b.screen.resolution,
                        e = f.x / b.screen.scale,
                        f = f.y / b.screen.scale;
                    a._anchorTransform.setTranslate(e * (a.anchor.x - c), -(f * (d - a.anchor.y)), 0);
                    a._anchorDirty = !1;
                    a._calculateLocalAnchors()
                }
                a._sizeDirty && a._calculateSize(!1, !1)
            }
            this._dirtyLocal && (this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale),
            e = this.localPosition,
            c = a._pivot,
            a._margin.x = e.x - a._calculatedWidth * c.x,
            a._margin.z = a._localAnchor.z - a._localAnchor.x - a._calculatedWidth - a._margin.x,
            a._margin.y = e.y - a._calculatedHeight * c.y,
            a._margin.w = a._localAnchor.w - a._localAnchor.y - a._calculatedHeight - a._margin.y,
            this._dirtyLocal = !1);
            if (!b)
                return this._dirtyWorld && (a._cornersDirty = !0,
                a._canvasCornersDirty = !0,
                a._worldCornersDirty = !0),
                fa.prototype._sync.call(this);
            this._dirtyWorld && (null === this._parent ? this.worldTransform.copy(this.localTransform) : (this._parent.element ? a._screenToWorld.mul2(this._parent.element._modelTransform, a._anchorTransform) : a._screenToWorld.copy(a._anchorTransform),
            a._modelTransform.mul2(a._screenToWorld, this.localTransform),
            b ? (a._screenToWorld.mul2(b.screen._screenMatrix, a._screenToWorld),
            b.screen.screenSpace || a._screenToWorld.mul2(b.worldTransform, a._screenToWorld),
            this.worldTransform.mul2(a._screenToWorld, this.localTransform),
            e = a._parentWorldTransform,
            e.setIdentity(),
            (c = this._parent) && c.element && c !== b && (bc.setTRS(z.ZERO, c.getLocalRotation(), c.getLocalScale()),
            e.mul2(c.element._parentWorldTransform, bc)),
            Fc.set(0, 0, this.localPosition.z),
            me.set(a._absLeft + a._pivot.x * a.calculatedWidth, a._absBottom + a._pivot.y * a.calculatedHeight, 0),
            bc.setTranslate(-me.x, -me.y, -me.z),
            Ih.setTRS(Fc, this.getLocalRotation(), this.getLocalScale()),
            Jh.setTranslate(me.x, me.y, me.z),
            a._screenTransform.mul2(a._parentWorldTransform, Jh).mul(Ih).mul(bc),
            a._cornersDirty = !0,
            a._canvasCornersDirty = !0,
            a._worldCornersDirty = !0) : this.worldTransform.copy(a._modelTransform)),
            this._dirtyWorld = !1)
        },
        _onInsert: function(a) {
            a = this._parseUpToScreen();
            this.entity._dirtifyWorld();
            this._updateScreen(a.screen);
            this._dirtifyMask()
        },
        _dirtifyMask: function() {
            for (var a = this.entity; a; ) {
                var b = a.parent;
                if ((null === b || b.screen) && a.element) {
                    this.system._prerender && this.system._prerender.length || (this.system._prerender = [],
                    this.system.app.once("prerender", this._onPrerender, this));
                    var c = this.system._prerender.indexOf(this.entity);
                    0 <= c && this.system._prerender.splice(c, 1);
                    0 > this.system._prerender.indexOf(a) && this.system._prerender.push(a)
                }
                a = b
            }
        },
        _onPrerender: function() {
            for (var a = 0; a < this.system._prerender.length; a++) {
                var b = this.system._prerender[a];
                b.element && b.element.syncMask(1)
            }
            this.system._prerender.length = 0
        },
        _bindScreen: function(a) {
            a.on("set:resolution", this._onScreenResize, this);
            a.on("set:referenceresolution", this._onScreenResize, this);
            a.on("set:scaleblend", this._onScreenResize, this);
            a.on("set:screenspace", this._onScreenSpaceChange, this);
            a.on("remove", this._onScreenRemove, this)
        },
        _unbindScreen: function(a) {
            a.off("set:resolution", this._onScreenResize, this);
            a.off("set:referenceresolution", this._onScreenResize, this);
            a.off("set:scaleblend", this._onScreenResize, this);
            a.off("set:screenspace", this._onScreenSpaceChange, this);
            a.off("remove", this._onScreenRemove, this)
        },
        _updateScreen: function(a) {
            this.screen && this.screen !== a && this._unbindScreen(this.screen.screen);
            var b = this.screen;
            (this.screen = a) && this._bindScreen(this.screen.screen);
            this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
            this.fire("set:screen", this.screen, b);
            this._anchorDirty = !0;
            b = this.entity.children;
            for (var c = 0, d = b.length; c < d; c++)
                b[c].element && b[c].element._updateScreen(a);
            this.screen && this.screen.screen.syncDrawOrder()
        },
        syncMask: function(a) {
            var b = this._parseUpToScreen();
            this._updateMask(b.mask, a)
        },
        _setMaskedBy: function(a) {
            var b = this._image || this._text;
            if (a) {
                var c = new Rd({
                    ref: a.element._image._maskRef,
                    func: 2
                });
                b && b._setStencil && b._setStencil(c);
                this._maskedBy = a
            } else
                b && b._setStencil && b._setStencil(null),
                this._maskedBy = null
        },
        _updateMask: function(a, b) {
            var c;
            a ? (this._setMaskedBy(a),
            this.mask && (a = new Rd({
                ref: a.element._image._maskRef,
                func: 2,
                zpass: 3
            }),
            this._image._setStencil(a),
            this._image._maskRef = b,
            b++,
            a = this.entity)) : (this._setMaskedBy(null),
            this.mask && (a = new Rd({
                ref: b,
                func: 7,
                zpass: 2
            }),
            this._image._setStencil(a),
            this._image._maskRef = b,
            b++,
            a = this.entity));
            var d = this.entity.children;
            var e = 0;
            for (c = d.length; e < c; e++)
                d[e].element && d[e].element._updateMask(a, b)
        },
        _parseUpToScreen: function() {
            for (var a = {
                screen: null,
                mask: null
            }, b = this.entity._parent; b && !b.screen; )
                b.element && b.element.mask && !a.mask && (a.mask = b),
                b = b.parent;
            b && b.screen && (a.screen = b);
            return a
        },
        _onScreenResize: function(a) {
            this._worldCornersDirty = this._cornersDirty = this._anchorDirty = !0;
            this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
            this.fire("screen:set:resolution", a)
        },
        _onScreenSpaceChange: function() {
            this.fire("screen:set:screenspace", this.screen.screen.screenSpace)
        },
        _onScreenRemove: function() {
            this.screen && !this.screen._destroying && this._updateScreen(null)
        },
        _calculateLocalAnchors: function() {
            var a = 1E3
              , b = 1E3
              , c = this.entity._parent;
            c && c.element ? (a = c.element.calculatedWidth,
            b = c.element.calculatedHeight) : this.screen && (b = this.screen.screen.resolution,
            c = this.screen.screen.scale,
            a = b.x / c,
            b = b.y / c);
            this._localAnchor.set(this._anchor.x * a, this._anchor.y * b, this._anchor.z * a, this._anchor.w * b)
        },
        getOffsetPosition: function(a, b) {
            var c = this.entity.getLocalPosition().clone();
            c.x += a;
            c.y += b;
            this._screenToWorld.transformPoint(c, c);
            return c
        },
        onLayersChanged: function(a, b) {
            this.addModelToLayers(this._image ? this._image._model : this._text._model);
            a.off("add", this.onLayerAdded, this);
            a.off("remove", this.onLayerRemoved, this);
            b.on("add", this.onLayerAdded, this);
            b.on("remove", this.onLayerRemoved, this)
        },
        onLayerAdded: function(a) {
            0 > this.layers.indexOf(a.id) || (this._image ? a.addMeshInstances(this._image._model.meshInstances) : this._text && a.addMeshInstances(this._text._model.meshInstances))
        },
        onLayerRemoved: function(a) {
            0 > this.layers.indexOf(a.id) || (this._image ? a.removeMeshInstances(this._image._model.meshInstances) : this._text && a.removeMeshInstances(this._text._model.meshInstances))
        },
        onEnable: function() {
            if (this._image)
                this._image.onEnable();
            if (this._text)
                this._text.onEnable();
            if (this._group)
                this._group.onEnable();
            this.useInput && this.system.app.elementInput && this.system.app.elementInput.addElement(this);
            this.system.app.scene.on("set:layers", this.onLayersChanged, this);
            this.system.app.scene.layers && (this.system.app.scene.layers.on("add", this.onLayerAdded, this),
            this.system.app.scene.layers.on("remove", this.onLayerRemoved, this));
            0 <= this._batchGroupId && this.system.app.batcher.insert(bb.ELEMENT, this.batchGroupId, this.entity);
            this.fire("enableelement")
        },
        onDisable: function() {
            this.system.app.scene.off("set:layers", this.onLayersChanged, this);
            this.system.app.scene.layers && (this.system.app.scene.layers.off("add", this.onLayerAdded, this),
            this.system.app.scene.layers.off("remove", this.onLayerRemoved, this));
            if (this._image)
                this._image.onDisable();
            if (this._text)
                this._text.onDisable();
            if (this._group)
                this._group.onDisable();
            this.system.app.elementInput && this.useInput && this.system.app.elementInput.removeElement(this);
            0 <= this._batchGroupId && this.system.app.batcher.remove(bb.ELEMENT, this.batchGroupId, this.entity);
            this.fire("disableelement")
        },
        onRemove: function() {
            this.entity.off("insert", this._onInsert, this);
            this._unpatch();
            this._image && this._image.destroy();
            this._text && this._text.destroy();
            this.system.app.elementInput && this.useInput && this.system.app.elementInput.removeElement(this);
            this.screen && this.screen.screen && (this._unbindScreen(this.screen.screen),
            this.screen.screen.syncDrawOrder());
            this.off()
        },
        _calculateSize: function(a, b) {
            if (this.entity._parent || this.screen) {
                this._calculateLocalAnchors();
                var c = this._absRight - this._absLeft
                  , d = this._absTop - this._absBottom;
                a ? this._setWidth(c) : this._setCalculatedWidth(c, !1);
                b ? this._setHeight(d) : this._setCalculatedHeight(d, !1);
                a = this.entity.getLocalPosition();
                a.x = this._margin.x + this._calculatedWidth * this._pivot.x;
                a.y = this._margin.y + this._calculatedHeight * this._pivot.y;
                this.entity.setLocalPosition(a);
                this._sizeDirty = !1
            }
        },
        _setWidth: function(a) {
            this._width = a;
            this._setCalculatedWidth(a, !1);
            this.fire("set:width", this._width)
        },
        _setHeight: function(a) {
            this._height = a;
            this._setCalculatedHeight(a, !1);
            this.fire("set:height", this._height)
        },
        _setCalculatedWidth: function(a, b) {
            1E-4 >= Math.abs(a - this._calculatedWidth) || (this._calculatedWidth = a,
            this.entity._dirtifyLocal(),
            b && (a = this.entity.getLocalPosition(),
            this._margin.x = a.x - this._calculatedWidth * this._pivot.x,
            this._margin.z = this._localAnchor.z - this._localAnchor.x - this._calculatedWidth - this._margin.x),
            this._flagChildrenAsDirty(),
            this.fire("set:calculatedWidth", this._calculatedWidth),
            this.fire("resize", this._calculatedWidth, this._calculatedHeight))
        },
        _setCalculatedHeight: function(a, b) {
            1E-4 >= Math.abs(a - this._calculatedHeight) || (this._calculatedHeight = a,
            this.entity._dirtifyLocal(),
            b && (a = this.entity.getLocalPosition(),
            this._margin.y = a.y - this._calculatedHeight * this._pivot.y,
            this._margin.w = this._localAnchor.w - this._localAnchor.y - this._calculatedHeight - this._margin.y),
            this._flagChildrenAsDirty(),
            this.fire("set:calculatedHeight", this._calculatedHeight),
            this.fire("resize", this._calculatedWidth, this._calculatedHeight))
        },
        _flagChildrenAsDirty: function() {
            var a, b = this.entity._children;
            var c = 0;
            for (a = b.length; c < a; c++)
                b[c].element && (b[c].element._anchorDirty = !0,
                b[c].element._sizeDirty = !0)
        },
        addModelToLayers: function(a) {
            var b;
            this._addedModels.push(a);
            for (var c = 0; c < this.layers.length; c++)
                (b = this.system.app.scene.layers.getLayerById(this.layers[c])) && b.addMeshInstances(a.meshInstances)
        },
        removeModelFromLayers: function(a) {
            var b = this._addedModels.indexOf(a);
            0 <= b && this._addedModels.splice(b, 1);
            for (var c = 0; c < this.layers.length; c++)
                (b = this.system.app.scene.layers.getLayerById(this.layers[c])) && b.removeMeshInstances(a.meshInstances)
        },
        getMaskOffset: function() {
            var a = this.system.app.frame;
            this._offsetReadAt !== a && (this._maskOffset = .5,
            this._offsetReadAt = a);
            a = this._maskOffset;
            this._maskOffset -= .001;
            return a
        },
        isVisibleForCamera: function(a) {
            if (this.maskedBy) {
                a = this.maskedBy.element.screenCorners;
                var b = Math.min(Math.min(a[0].x, a[1].x), Math.min(a[2].x, a[3].x));
                var c = Math.max(Math.max(a[0].x, a[1].x), Math.max(a[2].x, a[3].x));
                var d = Math.min(Math.min(a[0].y, a[1].y), Math.min(a[2].y, a[3].y));
                a = Math.max(Math.max(a[0].y, a[1].y), Math.max(a[2].y, a[3].y))
            } else {
                b = this.system.app.graphicsDevice.width;
                var e = this.system.app.graphicsDevice.height;
                c = a._rect.z * b;
                d = a._rect.w * e;
                b *= a._rect.x;
                c = b + c;
                a = (1 - a._rect.y) * e;
                d = a - d
            }
            e = this.screenCorners;
            var f = Math.min(Math.min(e[0].x, e[1].x), Math.min(e[2].x, e[3].x))
              , g = Math.min(Math.min(e[0].y, e[1].y), Math.min(e[2].y, e[3].y))
              , k = Math.max(Math.max(e[0].y, e[1].y), Math.max(e[2].y, e[3].y));
            return Math.max(Math.max(e[0].x, e[1].x), Math.max(e[2].x, e[3].x)) < b || f > c || g > a || k < d ? !1 : !0
        },
        _isScreenSpace: function() {
            return this.screen && this.screen.screen ? this.screen.screen.screenSpace : !1
        },
        _isScreenCulled: function() {
            return this.screen && this.screen.screen ? this.screen.screen.cull : !1
        }
    });
    Object.defineProperty(ia.prototype, "type", {
        get: function() {
            return this._type
        },
        set: function(a) {
            a !== this._type && (this._type = a,
            this._image && (this._image.destroy(),
            this._image = null),
            this._text && (this._text.destroy(),
            this._text = null),
            "image" === a ? this._image = new cb(this) : "text" === a && (this._text = new na(this)))
        }
    });
    Object.defineProperty(ia.prototype, "layers", {
        get: function() {
            return this._layers
        },
        set: function(a) {
            var b, c, d;
            if (this._addedModels.length)
                for (b = 0; b < this._layers.length; b++)
                    if (d = this.system.app.scene.layers.getLayerById(this._layers[b]))
                        for (c = 0; c < this._addedModels.length; c++)
                            d.removeMeshInstances(this._addedModels[c].meshInstances);
            this._layers = a;
            if (this.enabled && this.entity.enabled && this._addedModels.length)
                for (b = 0; b < this._layers.length; b++)
                    if (d = this.system.app.scene.layers.getLayerById(this._layers[b]))
                        for (c = 0; c < this._addedModels.length; c++)
                            d.addMeshInstances(this._addedModels[c].meshInstances)
        }
    });
    Object.defineProperty(ia.prototype, "drawOrder", {
        get: function() {
            return this._drawOrder
        },
        set: function(a) {
            var b = 0;
            this.screen && (b = this.screen.screen.priority);
            16777215 < a && (a = 16777215);
            this._drawOrder = (b << 24) + a;
            this.fire("set:draworder", this._drawOrder)
        }
    });
    Object.defineProperty(ia.prototype, "_absLeft", {
        get: function() {
            return this._localAnchor.x + this._margin.x
        }
    });
    Object.defineProperty(ia.prototype, "_absRight", {
        get: function() {
            return this._localAnchor.z - this._margin.z
        }
    });
    Object.defineProperty(ia.prototype, "_absTop", {
        get: function() {
            return this._localAnchor.w - this._margin.w
        }
    });
    Object.defineProperty(ia.prototype, "_absBottom", {
        get: function() {
            return this._localAnchor.y + this._margin.y
        }
    });
    Object.defineProperty(ia.prototype, "margin", {
        get: function() {
            return this._margin
        },
        set: function(a) {
            this._margin.copy(a);
            this._calculateSize(!0, !0);
            this.fire("set:margin", this._margin)
        }
    });
    Object.defineProperty(ia.prototype, "left", {
        get: function() {
            return this._margin.x
        },
        set: function(a) {
            this._margin.x = a;
            var b = this.entity.getLocalPosition();
            this._setWidth(this._absRight - (this._localAnchor.x + a));
            b.x = a + this._calculatedWidth * this._pivot.x;
            this.entity.setLocalPosition(b)
        }
    });
    Object.defineProperty(ia.prototype, "right", {
        get: function() {
            return this._margin.z
        },
        set: function(a) {
            this._margin.z = a;
            var b = this.entity.getLocalPosition();
            this._setWidth(this._localAnchor.z - a - this._absLeft);
            b.x = this._localAnchor.z - this._localAnchor.x - a - this._calculatedWidth * (1 - this._pivot.x);
            this.entity.setLocalPosition(b)
        }
    });
    Object.defineProperty(ia.prototype, "top", {
        get: function() {
            return this._margin.w
        },
        set: function(a) {
            this._margin.w = a;
            var b = this.entity.getLocalPosition();
            this._setHeight(this._localAnchor.w - a - this._absBottom);
            b.y = this._localAnchor.w - this._localAnchor.y - a - this._calculatedHeight * (1 - this._pivot.y);
            this.entity.setLocalPosition(b)
        }
    });
    Object.defineProperty(ia.prototype, "bottom", {
        get: function() {
            return this._margin.y
        },
        set: function(a) {
            this._margin.y = a;
            var b = this.entity.getLocalPosition();
            this._setHeight(this._absTop - (this._localAnchor.y + a));
            b.y = a + this._calculatedHeight * this._pivot.y;
            this.entity.setLocalPosition(b)
        }
    });
    Object.defineProperty(ia.prototype, "width", {
        get: function() {
            return this._width
        },
        set: function(a) {
            this._width = a;
            this._hasSplitAnchorsX || this._setCalculatedWidth(a, !0);
            this.fire("set:width", this._width)
        }
    });
    Object.defineProperty(ia.prototype, "height", {
        get: function() {
            return this._height
        },
        set: function(a) {
            this._height = a;
            this._hasSplitAnchorsY || this._setCalculatedHeight(a, !0);
            this.fire("set:height", this._height)
        }
    });
    Object.defineProperty(ia.prototype, "calculatedWidth", {
        get: function() {
            return this._calculatedWidth
        },
        set: function(a) {
            this._setCalculatedWidth(a, !0)
        }
    });
    Object.defineProperty(ia.prototype, "calculatedHeight", {
        get: function() {
            return this._calculatedHeight
        },
        set: function(a) {
            this._setCalculatedHeight(a, !0)
        }
    });
    Object.defineProperty(ia.prototype, "pivot", {
        get: function() {
            return this._pivot
        },
        set: function(a) {
            var b = this._pivot.x
              , c = this._pivot.y;
            a instanceof P ? this._pivot.set(a.x, a.y) : this._pivot.set(a[0], a[1]);
            a = this._margin.x + this._margin.z;
            b = this._pivot.x - b;
            this._margin.x += a * b;
            this._margin.z -= a * b;
            b = this._margin.y + this._margin.w;
            c = this._pivot.y - c;
            this._margin.y += b * c;
            this._margin.w -= b * c;
            this._worldCornersDirty = this._cornersDirty = this._anchorDirty = !0;
            this._calculateSize(!1, !1);
            this._flagChildrenAsDirty();
            this.fire("set:pivot", this._pivot)
        }
    });
    Object.defineProperty(ia.prototype, "anchor", {
        get: function() {
            return this._anchor
        },
        set: function(a) {
            a instanceof X ? this._anchor.set(a.x, a.y, a.z, a.w) : this._anchor.set(a[0], a[1], a[2], a[3]);
            this.entity._parent || this.screen ? this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY) : this._calculateLocalAnchors();
            this._anchorDirty = !0;
            this.entity._dirtyLocal || this.entity._dirtifyLocal();
            this.fire("set:anchor", this._anchor)
        }
    });
    Object.defineProperty(ia.prototype, "_hasSplitAnchorsX", {
        get: function() {
            return .001 < Math.abs(this._anchor.x - this._anchor.z)
        }
    });
    Object.defineProperty(ia.prototype, "_hasSplitAnchorsY", {
        get: function() {
            return .001 < Math.abs(this._anchor.y - this._anchor.w)
        }
    });
    Object.defineProperty(ia.prototype, "aabb", {
        get: function() {
            return this._image ? this._image.aabb : this._text ? this._text.aabb : null
        }
    });
    Object.defineProperty(ia.prototype, "screenCorners", {
        get: function() {
            if (!this._cornersDirty || !this.screen)
                return this._screenCorners;
            var a = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];
            this._screenCorners[0].set(this._absLeft, this._absBottom, 0);
            this._screenCorners[1].set(this._absRight, this._absBottom, 0);
            this._screenCorners[2].set(this._absRight, this._absTop, 0);
            this._screenCorners[3].set(this._absLeft, this._absTop, 0);
            for (var b = this.screen.screen.screenSpace, c = 0; 4 > c; c++)
                this._screenTransform.transformPoint(this._screenCorners[c], this._screenCorners[c]),
                b && this._screenCorners[c].scale(this.screen.screen.scale),
                a && this._screenCorners[c].add(a);
            this._cornersDirty = !1;
            this._worldCornersDirty = this._canvasCornersDirty = !0;
            return this._screenCorners
        }
    });
    Object.defineProperty(ia.prototype, "canvasCorners", {
        get: function() {
            if (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace)
                return this._canvasCorners;
            for (var a = this.system.app.graphicsDevice, b = this.screenCorners, c = a.canvas.clientWidth / a.width, d = a.canvas.clientHeight / a.height, e = 0; 4 > e; e++)
                this._canvasCorners[e].set(b[e].x * c, (a.height - b[e].y) * d);
            this._canvasCornersDirty = !1;
            return this._canvasCorners
        }
    });
    Object.defineProperty(ia.prototype, "worldCorners", {
        get: function() {
            if (!this._worldCornersDirty)
                return this._worldCorners;
            if (this.screen) {
                var a = this.screenCorners;
                if (!this.screen.screen.screenSpace) {
                    bc.copy(this.screen.screen._screenMatrix);
                    bc.data[13] = -bc.data[13];
                    bc.mul2(this.screen.getWorldTransform(), bc);
                    for (var b = 0; 4 > b; b++)
                        bc.transformPoint(a[b], this._worldCorners[b])
                }
            } else
                a = this.entity.getLocalPosition(),
                bc.setTranslate(-a.x, -a.y, -a.z),
                Ih.setTRS(z.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale()),
                Jh.setTranslate(a.x, a.y, a.z),
                nf.copy(this.entity.parent.getWorldTransform()),
                nf.mul(Jh).mul(Ih).mul(bc),
                Fc.set(a.x - this.pivot.x * this.calculatedWidth, a.y - this.pivot.y * this.calculatedHeight, a.z),
                nf.transformPoint(Fc, this._worldCorners[0]),
                Fc.set(a.x + (1 - this.pivot.x) * this.calculatedWidth, a.y - this.pivot.y * this.calculatedHeight, a.z),
                nf.transformPoint(Fc, this._worldCorners[1]),
                Fc.set(a.x + (1 - this.pivot.x) * this.calculatedWidth, a.y + (1 - this.pivot.y) * this.calculatedHeight, a.z),
                nf.transformPoint(Fc, this._worldCorners[2]),
                Fc.set(a.x - this.pivot.x * this.calculatedWidth, a.y + (1 - this.pivot.y) * this.calculatedHeight, a.z),
                nf.transformPoint(Fc, this._worldCorners[3]);
            this._worldCornersDirty = !1;
            return this._worldCorners
        }
    });
    Object.defineProperty(ia.prototype, "textWidth", {
        get: function() {
            return this._text ? this._text.width : 0
        }
    });
    Object.defineProperty(ia.prototype, "textHeight", {
        get: function() {
            return this._text ? this._text.height : 0
        }
    });
    Object.defineProperty(ia.prototype, "useInput", {
        get: function() {
            return this._useInput
        },
        set: function(a) {
            this._useInput !== a && (this._useInput = a,
            this.system.app.elementInput ? a ? this.enabled && this.entity.enabled && this.system.app.elementInput.addElement(this) : this.system.app.elementInput.removeElement(this) : !0 === this._useInput && console.warn("Elements will not get any input events because this.system.app.elementInput is not created"),
            this.fire("set:useInput", a))
        }
    });
    Object.defineProperty(ia.prototype, "batchGroupId", {
        get: function() {
            return this._batchGroupId
        },
        set: function(a) {
            this._batchGroupId !== a && (this.entity.enabled && 0 <= this._batchGroupId && this.system.app.batcher.remove(bb.ELEMENT, this.batchGroupId, this.entity),
            this.entity.enabled && 0 <= a && this.system.app.batcher.insert(bb.ELEMENT, a, this.entity),
            0 > a && 0 <= this._batchGroupId && this.enabled && this.entity.enabled && (this._image && this._image._renderable.model ? this.addModelToLayers(this._image._renderable.model) : this._text && this._text._model && this.addModelToLayers(this._text._model)),
            this._batchGroupId = a)
        }
    });
    Object.defineProperty(ia.prototype, "maskedBy", {
        get: function() {
            return this._maskedBy
        }
    });
    var ja = function(a) {
        Object.defineProperty(ia.prototype, a, {
            get: function() {
                return this._text ? this._text[a] : this._image ? this._image[a] : null
            },
            set: function(b) {
                this._text ? this._text[a] = b : this._image && (this._image[a] = b)
            }
        })
    };
    ja("fontSize");
    ja("minFontSize");
    ja("maxFontSize");
    ja("maxLines");
    ja("autoFitWidth");
    ja("autoFitHeight");
    ja("color");
    ja("font");
    ja("fontAsset");
    ja("spacing");
    ja("lineHeight");
    ja("wrapLines");
    ja("lines");
    ja("alignment");
    ja("autoWidth");
    ja("autoHeight");
    ja("rtlReorder");
    ja("unicodeConverter");
    ja("text");
    ja("key");
    ja("texture");
    ja("textureAsset");
    ja("material");
    ja("materialAsset");
    ja("sprite");
    ja("spriteAsset");
    ja("spriteFrame");
    ja("pixelsPerUnit");
    ja("opacity");
    ja("rect");
    ja("mask");
    ja("outlineColor");
    ja("outlineThickness");
    ja("shadowColor");
    ja("shadowOffset");
    ja("enableMarkup");
    ja("rangeStart");
    ja("rangeEnd");
    var ol = ["enabled"];
    Ce.prototype = Object.create(H.prototype);
    Ce.prototype.constructor = Ce;
    O._buildAccessors(ia.prototype, ol);
    Object.assign(Ce.prototype, {
        destroy: function() {
            this._defaultTexture.destroy()
        },
        initializeComponentData: function(a, b, c) {
            a._beingInitialized = !0;
            void 0 !== b.anchor && (b.anchor instanceof X ? a.anchor.copy(b.anchor) : a.anchor.set(b.anchor[0], b.anchor[1], b.anchor[2], b.anchor[3]));
            void 0 !== b.pivot && (b.pivot instanceof P ? a.pivot.copy(b.pivot) : a.pivot.set(b.pivot[0], b.pivot[1]));
            var d = .001 < Math.abs(a.anchor.x - a.anchor.z)
              , e = .001 < Math.abs(a.anchor.y - a.anchor.w)
              , f = !1;
            void 0 !== b.margin && (b.margin instanceof X ? a.margin.copy(b.margin) : a._margin.set(b.margin[0], b.margin[1], b.margin[2], b.margin[3]),
            f = !0);
            void 0 !== b.left && (a._margin.x = b.left,
            f = !0);
            void 0 !== b.bottom && (a._margin.y = b.bottom,
            f = !0);
            void 0 !== b.right && (a._margin.z = b.right,
            f = !0);
            void 0 !== b.top && (a._margin.w = b.top,
            f = !0);
            f && (a.margin = a._margin);
            f = !1;
            void 0 === b.width || d ? d && (f = !0) : a.width = b.width;
            void 0 === b.height || e ? e && (f = !0) : a.height = b.height;
            f && (a.anchor = a.anchor);
            void 0 !== b.enabled && (a.enabled = b.enabled);
            void 0 !== b.useInput && (a.useInput = b.useInput);
            a.batchGroupId = void 0 === b.batchGroupId || null === b.batchGroupId ? -1 : b.batchGroupId;
            b.layers && Array.isArray(b.layers) && (a.layers = b.layers.slice(0));
            a.type = b.type;
            "image" === a.type ? (void 0 !== b.rect && (a.rect = b.rect),
            void 0 !== b.color && (d = b.color,
            d instanceof L || (d = new L(b.color[0],b.color[1],b.color[2])),
            a.color = d),
            void 0 !== b.opacity && (a.opacity = b.opacity),
            void 0 !== b.textureAsset && (a.textureAsset = b.textureAsset),
            b.texture && (a.texture = b.texture),
            void 0 !== b.spriteAsset && (a.spriteAsset = b.spriteAsset),
            b.sprite && (a.sprite = b.sprite),
            void 0 !== b.spriteFrame && (a.spriteFrame = b.spriteFrame),
            void 0 !== b.pixelsPerUnit && null !== b.pixelsPerUnit && (a.pixelsPerUnit = b.pixelsPerUnit),
            void 0 !== b.materialAsset && (a.materialAsset = b.materialAsset),
            b.material && (a.material = b.material),
            void 0 !== b.mask && (a.mask = b.mask)) : "text" === a.type && (void 0 !== b.autoWidth && (a.autoWidth = b.autoWidth),
            void 0 !== b.autoHeight && (a.autoHeight = b.autoHeight),
            void 0 !== b.rtlReorder && (a.rtlReorder = b.rtlReorder),
            void 0 !== b.unicodeConverter && (a.unicodeConverter = b.unicodeConverter),
            null !== b.text && void 0 !== b.text ? a.text = b.text : null !== b.key && void 0 !== b.key && (a.key = b.key),
            void 0 !== b.color && (d = b.color,
            d instanceof L || (d = new L(d[0],d[1],d[2])),
            a.color = d),
            void 0 !== b.opacity && (a.opacity = b.opacity),
            void 0 !== b.spacing && (a.spacing = b.spacing),
            void 0 !== b.fontSize && (a.fontSize = b.fontSize,
            b.lineHeight || (a.lineHeight = b.fontSize)),
            void 0 !== b.lineHeight && (a.lineHeight = b.lineHeight),
            void 0 !== b.maxLines && (a.maxLines = b.maxLines),
            void 0 !== b.wrapLines && (a.wrapLines = b.wrapLines),
            void 0 !== b.minFontSize && (a.minFontSize = b.minFontSize),
            void 0 !== b.maxFontSize && (a.maxFontSize = b.maxFontSize),
            b.autoFitWidth && (a.autoFitWidth = b.autoFitWidth),
            b.autoFitHeight && (a.autoFitHeight = b.autoFitHeight),
            void 0 !== b.fontAsset && (a.fontAsset = b.fontAsset),
            void 0 !== b.font && (a.font = b.font),
            void 0 !== b.alignment && (a.alignment = b.alignment),
            void 0 !== b.outlineColor && (a.outlineColor = b.outlineColor),
            void 0 !== b.outlineThickness && (a.outlineThickness = b.outlineThickness),
            void 0 !== b.shadowColor && (a.shadowColor = b.shadowColor),
            void 0 !== b.shadowOffset && (a.shadowOffset = b.shadowOffset),
            void 0 !== b.enableMarkup && (a.enableMarkup = b.enableMarkup));
            d = a._parseUpToScreen();
            d.screen && a._updateScreen(d.screen);
            H.prototype.initializeComponentData.call(this, a, b, c);
            a._beingInitialized = !1;
            "image" === a.type && a._image._meshDirty && a._image._updateMesh(a._image.mesh)
        },
        onRemoveComponent: function(a, b) {
            b.onRemove()
        },
        cloneComponent: function(a, b) {
            a = a.element;
            var c = {
                enabled: a.enabled,
                width: a.width,
                height: a.height,
                anchor: a.anchor.clone(),
                pivot: a.pivot.clone(),
                margin: a.margin.clone(),
                alignment: a.alignment && a.alignment.clone() || a.alignment,
                autoWidth: a.autoWidth,
                autoHeight: a.autoHeight,
                type: a.type,
                rect: a.rect && a.rect.clone() || a.rect,
                rtlReorder: a.rtlReorder,
                unicodeConverter: a.unicodeConverter,
                materialAsset: a.materialAsset,
                material: a.material,
                color: a.color && a.color.clone() || a.color,
                opacity: a.opacity,
                textureAsset: a.textureAsset,
                texture: a.texture,
                spriteAsset: a.spriteAsset,
                sprite: a.sprite,
                spriteFrame: a.spriteFrame,
                pixelsPerUnit: a.pixelsPerUnit,
                spacing: a.spacing,
                lineHeight: a.lineHeight,
                wrapLines: a.wrapLines,
                layers: a.layers,
                fontSize: a.fontSize,
                minFontSize: a.minFontSize,
                maxFontSize: a.maxFontSize,
                autoFitWidth: a.autoFitWidth,
                autoFitHeight: a.autoFitHeight,
                maxLines: a.maxLines,
                fontAsset: a.fontAsset,
                font: a.font,
                useInput: a.useInput,
                batchGroupId: a.batchGroupId,
                mask: a.mask,
                outlineColor: a.outlineColor && a.outlineColor.clone() || a.outlineColor,
                outlineThickness: a.outlineThickness,
                shadowColor: a.shadowColor && a.shadowColor.clone() || a.shadowColor,
                shadowOffset: a.shadowOffset && a.shadowOffset.clone() || a.shadowOffset,
                enableMarkup: a.enableMarkup
            };
            void 0 !== a.key && null !== a.key ? c.key = a.key : c.text = a.text;
            return this.addComponent(b, c)
        },
        getTextElementMaterial: function(a, b) {
            if (a) {
                if (b)
                    return this.defaultScreenSpaceTextMaterial || (this.defaultScreenSpaceTextMaterial = new la,
                    this.defaultScreenSpaceTextMaterial.name = "defaultScreenSpaceTextMaterial",
                    this.defaultScreenSpaceTextMaterial.msdfMap = this._defaultTexture,
                    this.defaultScreenSpaceTextMaterial.useLighting = !1,
                    this.defaultScreenSpaceTextMaterial.useGammaTonemap = !1,
                    this.defaultScreenSpaceTextMaterial.useFog = !1,
                    this.defaultScreenSpaceTextMaterial.useSkybox = !1,
                    this.defaultScreenSpaceTextMaterial.diffuse.set(0, 0, 0),
                    this.defaultScreenSpaceTextMaterial.emissive.set(1, 1, 1),
                    this.defaultScreenSpaceTextMaterial.opacity = .5,
                    this.defaultScreenSpaceTextMaterial.blendType = 4,
                    this.defaultScreenSpaceTextMaterial.depthWrite = !1,
                    this.defaultScreenSpaceTextMaterial.depthTest = !1,
                    this.defaultScreenSpaceTextMaterial.emissiveVertexColor = !0,
                    this.defaultScreenSpaceTextMaterial.update()),
                    this.defaultScreenSpaceTextMaterial;
                this.defaultScreenSpaceBitmapTextMaterial || (this.defaultScreenSpaceBitmapTextMaterial = new la,
                this.defaultScreenSpaceBitmapTextMaterial.name = "defaultScreenSpaceBitmapTextMaterial",
                this.defaultScreenSpaceBitmapTextMaterial.emissive.set(.5, .5, .5),
                this.defaultScreenSpaceBitmapTextMaterial.emissiveMap = this._defaultTexture,
                this.defaultScreenSpaceBitmapTextMaterial.emissiveTint = !0,
                this.defaultScreenSpaceBitmapTextMaterial.opacity = .5,
                this.defaultScreenSpaceBitmapTextMaterial.opacityMap = this._defaultTexture,
                this.defaultScreenSpaceBitmapTextMaterial.opacityMapChannel = "a",
                this.defaultScreenSpaceBitmapTextMaterial.useLighting = !1,
                this.defaultScreenSpaceBitmapTextMaterial.useGammaTonemap = !1,
                this.defaultScreenSpaceBitmapTextMaterial.useFog = !1,
                this.defaultScreenSpaceBitmapTextMaterial.useSkybox = !1,
                this.defaultScreenSpaceBitmapTextMaterial.diffuse.set(0, 0, 0),
                this.defaultScreenSpaceBitmapTextMaterial.blendType = 4,
                this.defaultScreenSpaceBitmapTextMaterial.depthWrite = !1,
                this.defaultScreenSpaceBitmapTextMaterial.depthTest = !1,
                this.defaultScreenSpaceBitmapTextMaterial.emissiveVertexColor = !0,
                this.defaultScreenSpaceBitmapTextMaterial.update());
                return this.defaultScreenSpaceBitmapTextMaterial
            }
            if (b)
                return this.defaultTextMaterial || (this.defaultTextMaterial = new la,
                this.defaultTextMaterial.name = "defaultTextMaterial",
                this.defaultTextMaterial.msdfMap = this._defaultTexture,
                this.defaultTextMaterial.useLighting = !1,
                this.defaultTextMaterial.useGammaTonemap = !1,
                this.defaultTextMaterial.useFog = !1,
                this.defaultTextMaterial.useSkybox = !1,
                this.defaultTextMaterial.diffuse.set(0, 0, 0),
                this.defaultTextMaterial.emissive.set(1, 1, 1),
                this.defaultTextMaterial.opacity = .5,
                this.defaultTextMaterial.blendType = 4,
                this.defaultTextMaterial.depthWrite = !1,
                this.defaultTextMaterial.emissiveVertexColor = !0,
                this.defaultTextMaterial.update()),
                this.defaultTextMaterial;
            this.defaultBitmapTextMaterial || (this.defaultBitmapTextMaterial = new la,
            this.defaultBitmapTextMaterial.name = "defaultBitmapTextMaterial",
            this.defaultBitmapTextMaterial.emissive.set(.5, .5, .5),
            this.defaultBitmapTextMaterial.emissiveTint = !0,
            this.defaultBitmapTextMaterial.emissiveMap = this._defaultTexture,
            this.defaultBitmapTextMaterial.opacity = .5,
            this.defaultBitmapTextMaterial.opacityMap = this._defaultTexture,
            this.defaultBitmapTextMaterial.opacityMapChannel = "a",
            this.defaultBitmapTextMaterial.useLighting = !1,
            this.defaultBitmapTextMaterial.useGammaTonemap = !1,
            this.defaultBitmapTextMaterial.useFog = !1,
            this.defaultBitmapTextMaterial.useSkybox = !1,
            this.defaultBitmapTextMaterial.diffuse.set(0, 0, 0),
            this.defaultBitmapTextMaterial.blendType = 4,
            this.defaultBitmapTextMaterial.depthWrite = !1,
            this.defaultBitmapTextMaterial.emissiveVertexColor = !0,
            this.defaultBitmapTextMaterial.update());
            return this.defaultBitmapTextMaterial
        },
        _createBaseImageMaterial: function() {
            var a = new la;
            a.diffuse.set(0, 0, 0);
            a.emissive.set(.5, .5, .5);
            a.emissiveMap = this._defaultTexture;
            a.emissiveTint = !0;
            a.opacityMap = this._defaultTexture;
            a.opacityMapChannel = "a";
            a.opacityTint = !0;
            a.opacity = 0;
            a.useLighting = !1;
            a.useGammaTonemap = !1;
            a.useFog = !1;
            a.useSkybox = !1;
            a.blendType = 4;
            a.depthWrite = !1;
            return a
        },
        getImageElementMaterial: function(a, b, c, d) {
            if (a) {
                if (b) {
                    if (c)
                        return this.defaultScreenSpaceImageMask9SlicedMaterial || (this.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial(),
                        this.defaultScreenSpaceImageMask9SlicedMaterial.name = "defaultScreenSpaceImageMask9SlicedMaterial",
                        this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = 1,
                        this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = !1,
                        this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1,
                        this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = !1,
                        this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = !1,
                        this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = !1,
                        this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = !1,
                        this.defaultScreenSpaceImageMask9SlicedMaterial.update(),
                        this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial)),
                        this.defaultScreenSpaceImageMask9SlicedMaterial;
                    if (d)
                        return this.defaultScreenSpaceImageMask9TiledMaterial || (this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone(),
                        this.defaultScreenSpaceImageMask9TiledMaterial.name = "defaultScreenSpaceImageMask9TiledMaterial",
                        this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = 2,
                        this.defaultScreenSpaceImageMask9TiledMaterial.depthTest = !1,
                        this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1,
                        this.defaultScreenSpaceImageMask9TiledMaterial.redWrite = !1,
                        this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = !1,
                        this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = !1,
                        this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = !1,
                        this.defaultScreenSpaceImageMask9TiledMaterial.update(),
                        this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial)),
                        this.defaultScreenSpaceImageMask9TiledMaterial;
                    this.defaultScreenSpaceImageMaskMaterial || (this.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial(),
                    this.defaultScreenSpaceImageMaskMaterial.name = "defaultScreenSpaceImageMaskMaterial",
                    this.defaultScreenSpaceImageMaskMaterial.depthTest = !1,
                    this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1,
                    this.defaultScreenSpaceImageMaskMaterial.redWrite = !1,
                    this.defaultScreenSpaceImageMaskMaterial.greenWrite = !1,
                    this.defaultScreenSpaceImageMaskMaterial.blueWrite = !1,
                    this.defaultScreenSpaceImageMaskMaterial.alphaWrite = !1,
                    this.defaultScreenSpaceImageMaskMaterial.update(),
                    this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial));
                    return this.defaultScreenSpaceImageMaskMaterial
                }
                if (c)
                    return this.defaultScreenSpaceImage9SlicedMaterial || (this.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial(),
                    this.defaultScreenSpaceImage9SlicedMaterial.name = "defaultScreenSpaceImage9SlicedMaterial",
                    this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = 1,
                    this.defaultScreenSpaceImage9SlicedMaterial.depthTest = !1,
                    this.defaultScreenSpaceImage9SlicedMaterial.update(),
                    this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial)),
                    this.defaultScreenSpaceImage9SlicedMaterial;
                if (d)
                    return this.defaultScreenSpaceImage9TiledMaterial || (this.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial(),
                    this.defaultScreenSpaceImage9TiledMaterial.name = "defaultScreenSpaceImage9TiledMaterial",
                    this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = 2,
                    this.defaultScreenSpaceImage9TiledMaterial.depthTest = !1,
                    this.defaultScreenSpaceImage9TiledMaterial.update(),
                    this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial)),
                    this.defaultScreenSpaceImage9TiledMaterial;
                this.defaultScreenSpaceImageMaterial || (this.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial(),
                this.defaultScreenSpaceImageMaterial.name = "defaultScreenSpaceImageMaterial",
                this.defaultScreenSpaceImageMaterial.depthTest = !1,
                this.defaultScreenSpaceImageMaterial.update(),
                this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial));
                return this.defaultScreenSpaceImageMaterial
            }
            if (b) {
                if (c)
                    return this.defaultImage9SlicedMaskMaterial || (this.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial(),
                    this.defaultImage9SlicedMaskMaterial.name = "defaultImage9SlicedMaskMaterial",
                    this.defaultImage9SlicedMaskMaterial.nineSlicedMode = 1,
                    this.defaultImage9SlicedMaskMaterial.alphaTest = 1,
                    this.defaultImage9SlicedMaskMaterial.redWrite = !1,
                    this.defaultImage9SlicedMaskMaterial.greenWrite = !1,
                    this.defaultImage9SlicedMaskMaterial.blueWrite = !1,
                    this.defaultImage9SlicedMaskMaterial.alphaWrite = !1,
                    this.defaultImage9SlicedMaskMaterial.update(),
                    this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial)),
                    this.defaultImage9SlicedMaskMaterial;
                if (d)
                    return this.defaultImage9TiledMaskMaterial || (this.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial(),
                    this.defaultImage9TiledMaskMaterial.name = "defaultImage9TiledMaskMaterial",
                    this.defaultImage9TiledMaskMaterial.nineSlicedMode = 2,
                    this.defaultImage9TiledMaskMaterial.alphaTest = 1,
                    this.defaultImage9TiledMaskMaterial.redWrite = !1,
                    this.defaultImage9TiledMaskMaterial.greenWrite = !1,
                    this.defaultImage9TiledMaskMaterial.blueWrite = !1,
                    this.defaultImage9TiledMaskMaterial.alphaWrite = !1,
                    this.defaultImage9TiledMaskMaterial.update(),
                    this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial)),
                    this.defaultImage9TiledMaskMaterial;
                this.defaultImageMaskMaterial || (this.defaultImageMaskMaterial = this._createBaseImageMaterial(),
                this.defaultImageMaskMaterial.name = "defaultImageMaskMaterial",
                this.defaultImageMaskMaterial.alphaTest = 1,
                this.defaultImageMaskMaterial.redWrite = !1,
                this.defaultImageMaskMaterial.greenWrite = !1,
                this.defaultImageMaskMaterial.blueWrite = !1,
                this.defaultImageMaskMaterial.alphaWrite = !1,
                this.defaultImageMaskMaterial.update(),
                this.defaultImageMaterials.push(this.defaultImageMaskMaterial));
                return this.defaultImageMaskMaterial
            }
            if (c)
                return this.defaultImage9SlicedMaterial || (this.defaultImage9SlicedMaterial = this._createBaseImageMaterial(),
                this.defaultImage9SlicedMaterial.name = "defaultImage9SlicedMaterial",
                this.defaultImage9SlicedMaterial.nineSlicedMode = 1,
                this.defaultImage9SlicedMaterial.update(),
                this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial)),
                this.defaultImage9SlicedMaterial;
            if (d)
                return this.defaultImage9TiledMaterial || (this.defaultImage9TiledMaterial = this._createBaseImageMaterial(),
                this.defaultImage9TiledMaterial.name = "defaultImage9TiledMaterial",
                this.defaultImage9TiledMaterial.nineSlicedMode = 2,
                this.defaultImage9TiledMaterial.update(),
                this.defaultImageMaterials.push(this.defaultImage9TiledMaterial)),
                this.defaultImage9TiledMaterial;
            this.defaultImageMaterial || (this.defaultImageMaterial = this._createBaseImageMaterial(),
            this.defaultImageMaterial.name = "defaultImageMaterial",
            this.defaultImageMaterial.update(),
            this.defaultImageMaterials.push(this.defaultImageMaterial));
            return this.defaultImageMaterial
        },
        registerUnicodeConverter: function(a) {
            this._unicodeConverter = a
        },
        registerRtlReorder: function(a) {
            this._rtlReorder = a
        },
        getUnicodeConverter: function() {
            return this._unicodeConverter
        },
        getRtlReorder: function() {
            return this._rtlReorder
        }
    });
    Sd.prototype = Object.create(O.prototype);
    Sd.prototype.constructor = Sd;
    Td("minWidth");
    Td("minHeight");
    Td("maxWidth");
    Td("maxHeight");
    Td("fitWidthProportion");
    Td("fitHeightProportion");
    Td("excludeFromLayout");
    var Um = ["enabled"]
      , Pe = function(a) {
        H.call(this, a);
        this.id = "layoutchild";
        this.ComponentType = Sd;
        this.DataType = mo;
        this.schema = Um
    };
    Pe.prototype = Object.create(H.prototype);
    Pe.prototype.constructor = Pe;
    O._buildAccessors(Sd.prototype, Um);
    Object.assign(Pe.prototype, {
        initializeComponentData: function(a, b, c) {
            void 0 !== b.enabled && (a.enabled = b.enabled);
            void 0 !== b.minWidth && (a.minWidth = b.minWidth);
            void 0 !== b.minHeight && (a.minHeight = b.minHeight);
            void 0 !== b.maxWidth && (a.maxWidth = b.maxWidth);
            void 0 !== b.maxHeight && (a.maxHeight = b.maxHeight);
            void 0 !== b.fitWidthProportion && (a.fitWidthProportion = b.fitWidthProportion);
            void 0 !== b.fitHeightProportion && (a.fitHeightProportion = b.fitHeightProportion);
            void 0 !== b.excludeFromLayout && (a.excludeFromLayout = b.excludeFromLayout);
            H.prototype.initializeComponentData.call(this, a, b, c)
        },
        cloneComponent: function(a, b) {
            a = a.layoutchild;
            return this.addComponent(b, {
                enabled: a.enabled,
                minWidth: a.minWidth,
                minHeight: a.minHeight,
                maxWidth: a.maxWidth,
                maxHeight: a.maxHeight,
                fitWidthProportion: a.fitWidthProportion,
                fitHeightProportion: a.fitHeightProportion,
                excludeFromLayout: a.excludeFromLayout
            })
        }
    });
    var mj = 0
      , ql = {
        0: {
            axis: "x",
            size: "width",
            calculatedSize: "calculatedWidth",
            minSize: "minWidth",
            maxSize: "maxWidth",
            fitting: "widthFitting",
            fittingProportion: "fitWidthProportion"
        },
        1: {
            axis: "y",
            size: "height",
            calculatedSize: "calculatedHeight",
            minSize: "minHeight",
            maxSize: "maxHeight",
            fitting: "heightFitting",
            fittingProportion: "fitHeightProportion"
        }
    }
      , oo = {
        0: 1,
        1: 0
    }
      , no = {
        minWidth: 0,
        minHeight: 0,
        maxWidth: Number.POSITIVE_INFINITY,
        maxHeight: Number.POSITIVE_INFINITY,
        width: null,
        height: null,
        fitWidthProportion: 0,
        fitHeightProportion: 0
    }
      , zb = {
        NONE: "NONE",
        APPLY_STRETCHING: "APPLY_STRETCHING",
        APPLY_SHRINKING: "APPLY_SHRINKING"
    }
      , Gb = new P
      , jk = {};
    jk[0] = pl(0);
    jk[1] = pl(1);
    Object.assign(lj.prototype, {
        calculateLayout: function(a, b) {
            var c = jk[b.orientation];
            if (c)
                return c(a, b);
            throw Error("Unrecognized orientation value: " + b.orientation);
        }
    });
    jd.prototype = Object.create(O.prototype);
    jd.prototype.constructor = jd;
    Object.assign(jd.prototype, {
        _isSelfOrChild: function(a) {
            return a === this.entity || -1 !== this.entity.children.indexOf(a)
        },
        _listenForReflowEvents: function(a, b) {
            a.element && (a.element[b]("enableelement", this._scheduleReflow, this),
            a.element[b]("disableelement", this._scheduleReflow, this),
            a.element[b]("resize", this._scheduleReflow, this),
            a.element[b]("set:pivot", this._scheduleReflow, this));
            a.layoutchild && (a.layoutchild[b]("set_enabled", this._scheduleReflow, this),
            a.layoutchild[b]("resize", this._scheduleReflow, this))
        },
        _onElementOrLayoutComponentAdd: function(a) {
            this._isSelfOrChild(a) && (this._listenForReflowEvents(a, "on"),
            this._scheduleReflow())
        },
        _onElementOrLayoutComponentRemove: function(a) {
            this._isSelfOrChild(a) && (this._listenForReflowEvents(a, "off"),
            this._scheduleReflow())
        },
        _onChildInsert: function(a) {
            this._listenForReflowEvents(a, "on");
            this._scheduleReflow()
        },
        _onChildRemove: function(a) {
            this._listenForReflowEvents(a, "off");
            this._scheduleReflow()
        },
        _scheduleReflow: function() {
            this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow && this.system.scheduleReflow(this)
        },
        reflow: function() {
            var a = this.entity.element
              , b = this.entity.children.filter(qo).map(po);
            a && 0 !== b.length && (a = {
                orientation: this._orientation,
                reverseX: this._reverseX,
                reverseY: this._reverseY,
                alignment: this._alignment,
                padding: this._padding,
                spacing: this._spacing,
                widthFitting: this._widthFitting,
                heightFitting: this._heightFitting,
                wrap: this._wrap,
                containerSize: new P(Math.max(a.calculatedWidth, 0),Math.max(a.calculatedHeight, 0))
            },
            this._isPerformingReflow = !0,
            b = this._layoutCalculator.calculateLayout(b, a),
            this._isPerformingReflow = !1,
            this.fire("reflow", b))
        },
        onEnable: function() {
            this._scheduleReflow()
        },
        onRemove: function() {
            this.entity.off("childinsert", this._onChildInsert, this);
            this.entity.off("childremove", this._onChildRemove, this);
            this._listenForReflowEvents(this.entity, "off");
            this.entity.children.forEach(function(a) {
                this._listenForReflowEvents(a, "off")
            }
            .bind(this));
            this.system.app.systems.element.off("add", this._onElementOrLayoutComponentAdd, this);
            this.system.app.systems.element.off("beforeremove", this._onElementOrLayoutComponentRemove, this);
            this.system.app.systems.layoutchild.off("add", this._onElementOrLayoutComponentAdd, this);
            this.system.app.systems.layoutchild.off("beforeremove", this._onElementOrLayoutComponentRemove, this)
        }
    });
    Mc("orientation");
    Mc("reverseX");
    Mc("reverseY");
    Mc("alignment");
    Mc("padding");
    Mc("spacing");
    Mc("widthFitting");
    Mc("heightFitting");
    Mc("wrap");
    var rl = ["enabled"];
    De.prototype = Object.create(H.prototype);
    De.prototype.constructor = De;
    O._buildAccessors(jd.prototype, rl);
    Object.assign(De.prototype, {
        initializeComponentData: function(a, b, c) {
            void 0 !== b.enabled && (a.enabled = b.enabled);
            void 0 !== b.orientation && (a.orientation = b.orientation);
            void 0 !== b.reverseX && (a.reverseX = b.reverseX);
            void 0 !== b.reverseY && (a.reverseY = b.reverseY);
            void 0 !== b.alignment && (b.alignment instanceof P ? a.alignment.copy(b.alignment) : a.alignment.set(b.alignment[0], b.alignment[1]),
            a.alignment = a.alignment);
            void 0 !== b.padding && (b.padding instanceof X ? a.padding.copy(b.padding) : a.padding.set(b.padding[0], b.padding[1], b.padding[2], b.padding[3]),
            a.padding = a.padding);
            void 0 !== b.spacing && (b.spacing instanceof P ? a.spacing.copy(b.spacing) : a.spacing.set(b.spacing[0], b.spacing[1]),
            a.spacing = a.spacing);
            void 0 !== b.widthFitting && (a.widthFitting = b.widthFitting);
            void 0 !== b.heightFitting && (a.heightFitting = b.heightFitting);
            void 0 !== b.wrap && (a.wrap = b.wrap);
            H.prototype.initializeComponentData.call(this, a, b, c)
        },
        cloneComponent: function(a, b) {
            a = a.layoutgroup;
            return this.addComponent(b, {
                enabled: a.enabled,
                orientation: a.orientation,
                reverseX: a.reverseX,
                reverseY: a.reverseY,
                alignment: a.alignment,
                padding: a.padding,
                spacing: a.spacing,
                widthFitting: a.widthFitting,
                heightFitting: a.heightFitting,
                wrap: a.wrap
            })
        },
        scheduleReflow: function(a) {
            -1 === this._reflowQueue.indexOf(a) && this._reflowQueue.push(a)
        },
        _onPostUpdate: function() {
            this._processReflowQueue()
        },
        _processReflowQueue: function() {
            if (0 !== this._reflowQueue.length)
                for (var a = 0; 0 < this._reflowQueue.length; ) {
                    var b = this._reflowQueue.slice();
                    this._reflowQueue.length = 0;
                    b.sort(function(d, e) {
                        return d.entity.graphDepth - e.entity.graphDepth
                    });
                    for (var c = 0; c < b.length; ++c)
                        b[c].reflow();
                    if (100 <= ++a) {
                        console.warn("Max reflow iterations limit reached, bailing.");
                        break
                    }
                }
        },
        _onRemoveComponent: function(a, b) {
            b.onRemove()
        }
    });
    var Kh = new z
      , Lh = new z
      , kk = new z
      , lk = {
        r: 0,
        g: 1,
        b: 2,
        a: 3
    }
      , Va = function() {
        this._type = 0;
        this._color = new L(.8,.8,.8);
        this._intensity = 1;
        this.enabled = this._castShadows = !1;
        this.mask = 1;
        this.isStatic = !1;
        this.key = 0;
        this.bakeDir = !0;
        this.attenuationEnd = this.attenuationStart = 10;
        this._shadowType = this._falloffMode = 0;
        this._vsmBlurSize = 11;
        this.vsmBlurMode = 1;
        this.vsmBias = .0025;
        this._cookie = null;
        this.cookieIntensity = 1;
        this._cookieFalloff = !0;
        this._cookieChannel = "rgb";
        this._cookieTransform = null;
        this._cookieTransformUniform = new Float32Array(4);
        this._cookieOffset = null;
        this._cookieOffsetUniform = new Float32Array(2);
        this._cookieOffsetSet = this._cookieTransformSet = !1;
        this._innerConeAngle = 40;
        this._outerConeAngle = 45;
        this._finalColor = new Float32Array([.8, .8, .8]);
        var a = Math.pow(this._finalColor[0], 2.2);
        this._linearFinalColor = new Float32Array([a, a, a]);
        this._position = new z(0,0,0);
        this._direction = new z(0,0,0);
        this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);
        this._outerConeAngleCos = Math.cos(this._outerConeAngle * Math.PI / 180);
        this._shadowCamera = null;
        this._shadowMatrix = new K;
        this.shadowDistance = 40;
        this._shadowResolution = 1024;
        this.shadowBias = -5E-4;
        this._normalOffsetBias = 0;
        this.shadowUpdateMode = 2;
        this._node = this._scene = null;
        this._rendererParams = [];
        this._isVsm = !1;
        this._isPcf = !0;
        this._isCachedShadowMap = this._cacheShadowMap = !1;
        this._visibleLength = [0];
        this._visibleList = [[]];
        this._visibleCameraSettings = []
    };
    Object.assign(Va.prototype, {
        destroy: function() {
            this._destroyShadowMap()
        },
        clone: function() {
            var a = new Va;
            a.type = this._type;
            a.setColor(this._color);
            a.intensity = this._intensity;
            a.castShadows = this.castShadows;
            a.enabled = this.enabled;
            a.attenuationStart = this.attenuationStart;
            a.attenuationEnd = this.attenuationEnd;
            a.falloffMode = this._falloffMode;
            a.shadowType = this._shadowType;
            a.vsmBlurSize = this._vsmBlurSize;
            a.vsmBlurMode = this.vsmBlurMode;
            a.vsmBias = this.vsmBias;
            a.shadowUpdateMode = this.shadowUpdateMode;
            a.mask = this.mask;
            a.innerConeAngle = this._innerConeAngle;
            a.outerConeAngle = this._outerConeAngle;
            a.shadowBias = this.shadowBias;
            a.normalOffsetBias = this._normalOffsetBias;
            a.shadowResolution = this._shadowResolution;
            a.shadowDistance = this.shadowDistance;
            return a
        },
        getColor: function() {
            return this._color
        },
        getBoundingSphere: function(a) {
            if (2 === this._type) {
                var b = this.attenuationEnd
                  , c = this._outerConeAngle
                  , d = Math.cos(c * N.DEG_TO_RAD)
                  , e = this._node;
                Kh.copy(e.up);
                Kh.scale(.5 * -b * d);
                Kh.add(e.getPosition());
                a.center = Kh;
                Lh.copy(e.up);
                Lh.scale(-b);
                kk.copy(e.right);
                kk.scale(Math.sin(c * N.DEG_TO_RAD) * b);
                Lh.add(kk);
                a.radius = .5 * Lh.length()
            } else
                1 === this._type && (a.center = this._node.getPosition(),
                a.radius = this.attenuationEnd)
        },
        getBoundingBox: function(a) {
            if (2 === this._type) {
                var b = this.attenuationEnd
                  , c = this._node
                  , d = Math.abs(Math.sin(this._outerConeAngle * N.DEG_TO_RAD) * b);
                a.center.set(0, .5 * -b, 0);
                a.halfExtents.set(d, .5 * b, d);
                a.setFromTransformedAabb(a, c.getWorldTransform())
            } else
                1 === this._type && (a.center.copy(this._node.getPosition()),
                a.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd))
        },
        _updateFinalColor: function() {
            var a = this._color
              , b = a.r
              , c = a.g;
            a = a.b;
            var d = this._intensity
              , e = this._finalColor
              , f = this._linearFinalColor;
            e[0] = b * d;
            e[1] = c * d;
            e[2] = a * d;
            1 <= d ? (f[0] = Math.pow(b, 2.2) * d,
            f[1] = Math.pow(c, 2.2) * d,
            f[2] = Math.pow(a, 2.2) * d) : (f[0] = Math.pow(e[0], 2.2),
            f[1] = Math.pow(e[1], 2.2),
            f[2] = Math.pow(e[2], 2.2))
        },
        setColor: function() {
            if (1 === arguments.length) {
                var a = arguments[0].r;
                var b = arguments[0].g;
                var c = arguments[0].b
            } else
                3 === arguments.length && (a = arguments[0],
                b = arguments[1],
                c = arguments[2]);
            this._color.set(a, b, c);
            this._updateFinalColor()
        },
        _destroyShadowMap: function() {
            if (this._shadowCamera) {
                if (!this._isCachedShadowMap) {
                    var a = this._shadowCamera.renderTarget, b;
                    if (a)
                        if (a.length)
                            for (b = 0; b < a.length; b++)
                                a[b].colorBuffer && a[b].colorBuffer.destroy(),
                                a[b].destroy();
                        else
                            a.colorBuffer && a.colorBuffer.destroy(),
                            a.depthBuffer && a.depthBuffer.destroy(),
                            a.destroy()
                }
                this._shadowCubeMap = this._shadowCamera = this._shadowCamera.renderTarget = null;
                0 === this.shadowUpdateMode && (this.shadowUpdateMode = 1)
            }
        },
        updateShadow: function() {
            2 !== this.shadowUpdateMode && (this.shadowUpdateMode = 1)
        },
        updateKey: function() {
            var a = this._type << 29 | (this._castShadows ? 1 : 0) << 28 | this._shadowType << 25 | this._falloffMode << 23 | (0 !== this._normalOffsetBias ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | lk[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12;
            3 === this._cookieChannel.length && (a |= lk[this._cookieChannel.charAt(1)] << 16,
            a |= lk[this._cookieChannel.charAt(2)] << 14);
            a !== this.key && null !== this._scene && (this._scene.layers._dirtyLights = !0);
            this.key = a
        }
    });
    Object.defineProperty(Va.prototype, "type", {
        get: function() {
            return this._type
        },
        set: function(a) {
            this._type !== a && (this._type = a,
            this._destroyShadowMap(),
            this.updateKey(),
            a = this._shadowType,
            this._shadowType = null,
            this.shadowType = a)
        }
    });
    Object.defineProperty(Va.prototype, "shadowType", {
        get: function() {
            return this._shadowType
        },
        set: function(a) {
            if (this._shadowType !== a) {
                var b = ea.getApplication().graphicsDevice;
                1 === this._type && (a = 0);
                4 !== a || b.webgl2 || (a = 0);
                3 !== a || b.textureFloatRenderable || (a = 2);
                2 !== a || b.textureHalfFloatRenderable || (a = 1);
                this._isVsm = 1 <= a && 3 >= a;
                this._isPcf = 4 === a || 0 === a;
                this._shadowType = a;
                this._destroyShadowMap();
                this.updateKey()
            }
        }
    });
    Object.defineProperty(Va.prototype, "castShadows", {
        get: function() {
            return this._castShadows && 4 !== this.mask && 0 !== this.mask
        },
        set: function(a) {
            this._castShadows !== a && (this._castShadows = a,
            this.updateKey())
        }
    });
    Object.defineProperty(Va.prototype, "shadowResolution", {
        get: function() {
            return this._shadowResolution
        },
        set: function(a) {
            if (this._shadowResolution !== a) {
                var b = ea.getApplication().graphicsDevice;
                this._shadowResolution = a = 1 === this._type ? Math.min(a, b.maxCubeMapSize) : Math.min(a, b.maxTextureSize)
            }
        }
    });
    Object.defineProperty(Va.prototype, "vsmBlurSize", {
        get: function() {
            return this._vsmBlurSize
        },
        set: function(a) {
            this._vsmBlurSize !== a && (0 === a % 2 && a++,
            this._vsmBlurSize = a)
        }
    });
    Object.defineProperty(Va.prototype, "normalOffsetBias", {
        get: function() {
            return this._normalOffsetBias
        },
        set: function(a) {
            this._normalOffsetBias !== a && ((!this._normalOffsetBias && a || this._normalOffsetBias && !a) && this.updateKey(),
            this._normalOffsetBias = a)
        }
    });
    Object.defineProperty(Va.prototype, "falloffMode", {
        get: function() {
            return this._falloffMode
        },
        set: function(a) {
            this._falloffMode !== a && (this._falloffMode = a,
            this.updateKey())
        }
    });
    Object.defineProperty(Va.prototype, "innerConeAngle", {
        get: function() {
            return this._innerConeAngle
        },
        set: function(a) {
            this._innerConeAngle !== a && (this._innerConeAngle = a,
            this._innerConeAngleCos = Math.cos(a * Math.PI / 180))
        }
    });
    Object.defineProperty(Va.prototype, "outerConeAngle", {
        get: function() {
            return this._outerConeAngle
        },
        set: function(a) {
            this._outerConeAngle !== a && (this._outerConeAngle = a,
            this._outerConeAngleCos = Math.cos(a * Math.PI / 180))
        }
    });
    Object.defineProperty(Va.prototype, "intensity", {
        get: function() {
            return this._intensity
        },
        set: function(a) {
            this._intensity !== a && (this._intensity = a,
            this._updateFinalColor())
        }
    });
    Object.defineProperty(Va.prototype, "cookie", {
        get: function() {
            return this._cookie
        },
        set: function(a) {
            this._cookie !== a && (this._cookie = a,
            this.updateKey())
        }
    });
    Object.defineProperty(Va.prototype, "cookieFalloff", {
        get: function() {
            return this._cookieFalloff
        },
        set: function(a) {
            this._cookieFalloff !== a && (this._cookieFalloff = a,
            this.updateKey())
        }
    });
    Object.defineProperty(Va.prototype, "cookieChannel", {
        get: function() {
            return this._cookieChannel
        },
        set: function(a) {
            if (this._cookieChannel !== a) {
                if (3 > a.length)
                    for (var b = a.charAt(a.length - 1), c = 3 - a.length, d = 0; d < c; d++)
                        a += b;
                this._cookieChannel = a;
                this.updateKey()
            }
        }
    });
    Object.defineProperty(Va.prototype, "cookieTransform", {
        get: function() {
            return this._cookieTransform
        },
        set: function(a) {
            this._cookieTransform !== a && (this._cookieTransform = a,
            this._cookieTransformSet = !!a,
            a && !this._cookieOffset && (this.cookieOffset = new P,
            this._cookieOffsetSet = !1),
            this.updateKey())
        }
    });
    Object.defineProperty(Va.prototype, "cookieOffset", {
        get: function() {
            return this._cookieOffset
        },
        set: function(a) {
            this._cookieOffset !== a && ((this._cookieTransformSet || a) && !a && this._cookieOffset ? this._cookieOffset.set(0, 0) : this._cookieOffset = a,
            this._cookieOffsetSet = !!a,
            a && !this._cookieTransform && (this.cookieTransform = new X(1,1,0,0),
            this._cookieTransformSet = !1),
            this.updateKey())
        }
    });
    kd.prototype = Object.create(O.prototype);
    kd.prototype.constructor = kd;
    var Mh = []
      , Vm = []
      , qa = function(a, b, c, d) {
        var e = kd.prototype;
        Mh.push(a);
        Vm.push(b);
        Object.defineProperty(e, a, {
            get: function() {
                return this.data[a]
            },
            set: function(f) {
                var g = this.data
                  , k = g[a];
                if (d || k !== f)
                    g[a] = f,
                    c && c.call(this, f, k)
            },
            configurable: !0
        })
    };
    (function() {
        qa("enabled", !0, function(a, b) {
            this.onSetEnabled(null, b, a)
        });
        qa("light", null);
        qa("type", "directional", function(a, b) {
            this.system.changeType(this, b, a);
            this.refreshProperties()
        });
        qa("color", new L(1,1,1), function(a, b) {
            this.light.setColor(a)
        }, !0);
        qa("intensity", 1, function(a, b) {
            this.light.intensity = a
        });
        qa("castShadows", !1, function(a, b) {
            this.light.castShadows = a
        });
        qa("shadowDistance", 40, function(a, b) {
            this.light.shadowDistance = a
        });
        qa("shadowResolution", 1024, function(a, b) {
            this.light.shadowResolution = a
        });
        qa("shadowBias", .05, function(a, b) {
            this.light.shadowBias = -.01 * a
        });
        qa("normalOffsetBias", 0, function(a, b) {
            this.light.normalOffsetBias = a
        });
        qa("range", 10, function(a, b) {
            this.light.attenuationEnd = a
        });
        qa("innerConeAngle", 40, function(a, b) {
            this.light.innerConeAngle = a
        });
        qa("outerConeAngle", 45, function(a, b) {
            this.light.outerConeAngle = a
        });
        qa("falloffMode", 0, function(a, b) {
            this.light.falloffMode = a
        });
        qa("shadowType", 0, function(a, b) {
            this.light.shadowType = a
        });
        qa("vsmBlurSize", 11, function(a, b) {
            this.light.vsmBlurSize = a
        });
        qa("vsmBlurMode", 1, function(a, b) {
            this.light.vsmBlurMode = a
        });
        qa("vsmBias", .0025, function(a, b) {
            this.light.vsmBias = a
        });
        qa("cookieAsset", null, function(a, b) {
            if (!this._cookieAssetId || !(a instanceof aa && a.id === this._cookieAssetId || a === this._cookieAssetId))
                if (this.onCookieAssetRemove(),
                this._cookieAssetId = null,
                a instanceof aa)
                    this._cookieAssetId = this.data.cookieAsset = a.id,
                    this.onCookieAssetAdd(a);
                else if ("number" === typeof a)
                    if (this._cookieAssetId = a,
                    a = this.system.app.assets.get(a))
                        this.onCookieAssetAdd(a);
                    else
                        this._cookieAssetAdd = !0,
                        this.system.app.assets.on("add:" + this._cookieAssetId, this.onCookieAssetAdd, this)
        });
        qa("cookie", null, function(a, b) {
            this.light.cookie = a
        });
        qa("cookieIntensity", 1, function(a, b) {
            this.light.cookieIntensity = a
        });
        qa("cookieFalloff", !0, function(a, b) {
            this.light.cookieFalloff = a
        });
        qa("cookieChannel", "rgb", function(a, b) {
            this.light.cookieChannel = a
        });
        qa("cookieAngle", 0, function(a, b) {
            if (0 !== a || null !== this.cookieScale) {
                this._cookieMatrix || (this._cookieMatrix = new X);
                var c = b = 1;
                this.cookieScale && (b = this.cookieScale.x,
                c = this.cookieScale.y);
                var d = Math.cos(a * N.DEG_TO_RAD);
                a = Math.sin(a * N.DEG_TO_RAD);
                this._cookieMatrix.set(d / b, -a / b, a / c, d / c);
                this.light.cookieTransform = this._cookieMatrix
            } else
                this.light.cookieTransform = null
        });
        qa("cookieScale", null, function(a, b) {
            if (null !== a || 0 !== this.cookieAngle) {
                this._cookieMatrix || (this._cookieMatrix = new X);
                b = a.x;
                a = a.y;
                var c = Math.cos(this.cookieAngle * N.DEG_TO_RAD)
                  , d = Math.sin(this.cookieAngle * N.DEG_TO_RAD);
                this._cookieMatrix.set(c / b, -d / b, d / a, c / a);
                this.light.cookieTransform = this._cookieMatrix
            } else
                this.light.cookieTransform = null
        }, !0);
        qa("cookieOffset", null, function(a, b) {
            this.light.cookieOffset = a
        }, !0);
        qa("shadowUpdateMode", 2, function(a, b) {
            this.light.shadowUpdateMode = a
        });
        qa("mask", 1, function(a, b) {
            this.light.mask = a
        });
        qa("affectDynamic", !0, function(a, b) {
            this.light.mask = a ? this.light.mask | 1 : this.light.mask & -2
        });
        qa("affectLightmapped", !1, function(a, b) {
            a ? (this.light.mask |= 2,
            this.bake && (this.light.mask &= -5)) : (this.light.mask &= -3,
            this.bake && (this.light.mask |= 4))
        });
        qa("bake", !1, function(a, b) {
            a ? (this.light.mask |= 4,
            this.affectLightmapped && (this.light.mask &= -3)) : (this.light.mask &= -5,
            this.affectLightmapped && (this.light.mask |= 2))
        });
        qa("bakeDir", !0, function(a, b) {
            this.light.bakeDir = a
        });
        qa("isStatic", !1, function(a, b) {
            this.light.isStatic = a
        });
        qa("layers", [0], function(a, b) {
            var c, d;
            for (c = 0; c < b.length; c++)
                (d = this.system.app.scene.layers.getLayerById(b[c])) && d.removeLight(this);
            for (c = 0; c < a.length; c++)
                (d = this.system.app.scene.layers.getLayerById(a[c])) && this.enabled && this.entity.enabled && d.addLight(this)
        })
    }
    )();
    Object.assign(kd.prototype, {
        addLightToLayers: function() {
            for (var a, b = 0; b < this.layers.length; b++)
                (a = this.system.app.scene.layers.getLayerById(this.layers[b])) && a.addLight(this)
        },
        removeLightFromLayers: function() {
            for (var a, b = 0; b < this.layers.length; b++)
                (a = this.system.app.scene.layers.getLayerById(this.layers[b])) && a.removeLight(this)
        },
        onLayersChanged: function(a, b) {
            this.enabled && this.entity.enabled && this.addLightToLayers();
            a.off("add", this.onLayerAdded, this);
            a.off("remove", this.onLayerRemoved, this);
            b.on("add", this.onLayerAdded, this);
            b.on("remove", this.onLayerRemoved, this)
        },
        onLayerAdded: function(a) {
            0 > this.layers.indexOf(a.id) || this.enabled && this.entity.enabled && a.addLight(this)
        },
        onLayerRemoved: function(a) {
            0 > this.layers.indexOf(a.id) || a.removeLight(this)
        },
        refreshProperties: function() {
            for (var a, b = 0; b < Mh.length; b++)
                a = Mh[b],
                this[a] = this[a];
            if (this.enabled && this.entity.enabled)
                this.onEnable()
        },
        updateShadow: function() {
            this.light.updateShadow()
        },
        onCookieAssetSet: function() {
            var a = !1;
            "cubemap" !== this._cookieAsset.type || this._cookieAsset.loadFaces || (a = this._cookieAsset.loadFaces = !0);
            this._cookieAsset.resource && !a || this.system.app.assets.load(this._cookieAsset);
            if (this._cookieAsset.resource)
                this.onCookieAssetLoad()
        },
        onCookieAssetAdd: function(a) {
            if (this._cookieAssetId === a.id) {
                this._cookieAsset = a;
                if (this.light.enabled)
                    this.onCookieAssetSet();
                this._cookieAsset.on("load", this.onCookieAssetLoad, this);
                this._cookieAsset.on("remove", this.onCookieAssetRemove, this)
            }
        },
        onCookieAssetLoad: function() {
            this._cookieAsset && this._cookieAsset.resource && (this.cookie = this._cookieAsset.resource)
        },
        onCookieAssetRemove: function() {
            this._cookieAssetId && (this._cookieAssetAdd && (this.system.app.assets.off("add:" + this._cookieAssetId, this.onCookieAssetAdd, this),
            this._cookieAssetAdd = !1),
            this._cookieAsset && (this._cookieAsset.off("load", this.onCookieAssetLoad, this),
            this._cookieAsset.off("remove", this.onCookieAssetRemove, this),
            this._cookieAsset = null),
            this.cookie = null)
        },
        onEnable: function() {
            this.light.enabled = !0;
            this.system.app.scene.on("set:layers", this.onLayersChanged, this);
            this.system.app.scene.layers && (this.system.app.scene.layers.on("add", this.onLayerAdded, this),
            this.system.app.scene.layers.on("remove", this.onLayerRemoved, this));
            this.enabled && this.entity.enabled && this.addLightToLayers();
            if (this._cookieAsset && !this.cookie)
                this.onCookieAssetSet()
        },
        onDisable: function() {
            this.light.enabled = !1;
            this.system.app.scene.off("set:layers", this.onLayersChanged, this);
            this.system.app.scene.layers && (this.system.app.scene.layers.off("add", this.onLayerAdded, this),
            this.system.app.scene.layers.off("remove", this.onLayerRemoved, this));
            this.removeLightFromLayers()
        },
        onRemove: function() {
            this.light.destroy();
            this.cookieAsset = null
        }
    });
    var nj = Mh
      , to = Vm
      , Wm = {
        directional: 0,
        point: 1,
        spot: 2
    };
    Ee.prototype = Object.create(H.prototype);
    Ee.prototype.constructor = Ee;
    Object.assign(Ee.prototype, {
        initializeComponentData: function(a, b) {
            for (var c = nj, d = {}, e = 0, f = c.length; e < f; e++) {
                var g = c[e];
                d[g] = b[g]
            }
            d.type || (d.type = a.data.type);
            a.data.type = d.type;
            d.layers && Array.isArray(d.layers) && (d.layers = d.layers.slice(0));
            d.color && Array.isArray(d.color) && (d.color = new L(d.color[0],d.color[1],d.color[2]));
            d.cookieOffset && d.cookieOffset instanceof Array && (d.cookieOffset = new P(d.cookieOffset[0],d.cookieOffset[1]));
            d.cookieScale && d.cookieScale instanceof Array && (d.cookieScale = new P(d.cookieScale[0],d.cookieScale[1]));
            d.enable && (console.warn("WARNING: enable: Property is deprecated. Set enabled property instead."),
            d.enabled = d.enable);
            b = new Va;
            b.type = Wm[d.type];
            b._node = a.entity;
            b._scene = this.app.scene;
            a.data.light = b;
            H.prototype.initializeComponentData.call(this, a, d, c)
        },
        _onRemoveComponent: function(a, b) {
            b.onRemove()
        },
        cloneComponent: function(a, b) {
            a = a.light;
            for (var c = [], d, e = nj, f = 0; f < e.length; f++)
                d = e[f],
                "light" !== d && (c[d] = a[d] && a[d].clone ? a[d].clone() : a[d]);
            this.addComponent(b, c)
        },
        changeType: function(a, b, c) {
            b !== c && (a.light.type = Wm[c])
        }
    });
    Ha.prototype = Object.create(O.prototype);
    Ha.prototype.constructor = Ha;
    Object.assign(Ha.prototype, {
        addModelToLayers: function() {
            for (var a, b = this.system.app.scene.layers, c = 0; c < this._layers.length; c++)
                (a = b.getLayerById(this._layers[c])) && a.addMeshInstances(this.meshInstances)
        },
        removeModelFromLayers: function() {
            for (var a, b = this.system.app.scene.layers, c = 0; c < this._layers.length; c++)
                (a = b.getLayerById(this._layers[c])) && a.removeMeshInstances(this.meshInstances)
        },
        onRemoveChild: function() {
            this._model && this.removeModelFromLayers()
        },
        onInsertChild: function() {
            this._model && this.enabled && this.entity.enabled && this.addModelToLayers()
        },
        onRemove: function() {
            "asset" === this.type ? this.asset = null : this.model = null;
            this.materialAsset = null;
            this._unsetMaterialEvents();
            this.entity.off("remove", this.onRemoveChild, this);
            this.entity.off("insert", this.onInsertChild, this)
        },
        onLayersChanged: function(a, b) {
            this.addModelToLayers();
            a.off("add", this.onLayerAdded, this);
            a.off("remove", this.onLayerRemoved, this);
            b.on("add", this.onLayerAdded, this);
            b.on("remove", this.onLayerRemoved, this)
        },
        onLayerAdded: function(a) {
            0 > this.layers.indexOf(a.id) || a.addMeshInstances(this.meshInstances)
        },
        onLayerRemoved: function(a) {
            0 > this.layers.indexOf(a.id) || a.removeMeshInstances(this.meshInstances)
        },
        _setMaterialEvent: function(a, b, c, d) {
            b = b + ":" + c;
            this.system.app.assets.on(b, d, this);
            this._materialEvents || (this._materialEvents = []);
            this._materialEvents[a] || (this._materialEvents[a] = {});
            this._materialEvents[a][b] = {
                id: c,
                handler: d
            }
        },
        _unsetMaterialEvents: function() {
            var a = this.system.app.assets
              , b = this._materialEvents;
            if (b) {
                for (var c = 0, d = b.length; c < d; c++)
                    if (b[c]) {
                        var e = b[c], f;
                        for (f in e)
                            a.off(f, e[f].handler, this)
                    }
                this._materialEvents = null
            }
        },
        _getAssetByIdOrPath: function(a) {
            var b = null;
            isNaN(parseInt(a, 10)) ? this.asset && (a = this._getMaterialAssetUrl(a)) && (b = this.system.app.assets.getByUrl(a)) : b = this.system.app.assets.get(a);
            return b
        },
        _getMaterialAssetUrl: function(a) {
            if (!this.asset)
                return null;
            var b = this.system.app.assets.get(this.asset);
            return b ? b.getAbsoluteUrl(a) : null
        },
        _loadAndSetMeshInstanceMaterial: function(a, b, c) {
            var d = this.system.app.assets;
            a && (a.resource ? (b.material = a.resource,
            this._setMaterialEvent(c, "remove", a.id, function() {
                b.material = this.system.defaultMaterial
            })) : (this._setMaterialEvent(c, "load", a.id, function(e) {
                b.material = e.resource;
                this._setMaterialEvent(c, "remove", a.id, function() {
                    b.material = this.system.defaultMaterial
                })
            }),
            this.enabled && this.entity.enabled && d.load(a)))
        },
        onEnable: function() {
            var a = this.system.app
              , b = a.scene;
            b.on("set:layers", this.onLayersChanged, this);
            b.layers && (b.layers.on("add", this.onLayerAdded, this),
            b.layers.on("remove", this.onLayerRemoved, this));
            b = "asset" === this._type;
            var c;
            this._model ? this.addModelToLayers() : b && this._asset && (c = a.assets.get(this._asset)) && c.resource !== this._model && this._bindModelAsset(c);
            this._materialAsset && (c = a.assets.get(this._materialAsset)) && c.resource !== this._material && this._bindMaterialAsset(c);
            if (b && this._mapping)
                for (var d in this._mapping)
                    this._mapping[d] && (c = this._getAssetByIdOrPath(this._mapping[d])) && !c.resource && a.assets.load(c);
            0 <= this._batchGroupId && a.batcher.insert(bb.MODEL, this.batchGroupId, this.entity)
        },
        onDisable: function() {
            var a = this.system.app
              , b = a.scene;
            b.off("set:layers", this.onLayersChanged, this);
            b.layers && (b.layers.off("add", this.onLayerAdded, this),
            b.layers.off("remove", this.onLayerRemoved, this));
            0 <= this._batchGroupId && a.batcher.remove(bb.MODEL, this.batchGroupId, this.entity);
            this._model && this.removeModelFromLayers()
        },
        hide: function() {
            if (this._model) {
                var a, b = this._model.meshInstances;
                var c = 0;
                for (a = b.length; c < a; c++)
                    b[c].visible = !1
            }
        },
        show: function() {
            if (this._model) {
                var a, b = this._model.meshInstances;
                var c = 0;
                for (a = b.length; c < a; c++)
                    b[c].visible = !0
            }
        },
        _bindMaterialAsset: function(a) {
            a.on("load", this._onMaterialAssetLoad, this);
            a.on("unload", this._onMaterialAssetUnload, this);
            a.on("remove", this._onMaterialAssetRemove, this);
            a.on("change", this._onMaterialAssetChange, this);
            a.resource ? this._onMaterialAssetLoad(a) : this.enabled && this.entity.enabled && this.system.app.assets.load(a)
        },
        _unbindMaterialAsset: function(a) {
            a.off("load", this._onMaterialAssetLoad, this);
            a.off("unload", this._onMaterialAssetUnload, this);
            a.off("remove", this._onMaterialAssetRemove, this);
            a.off("change", this._onMaterialAssetChange, this)
        },
        _onMaterialAssetAdd: function(a) {
            this.system.app.assets.off("add:" + a.id, this._onMaterialAssetAdd, this);
            this._materialAsset === a.id && this._bindMaterialAsset(a)
        },
        _onMaterialAssetLoad: function(a) {
            this._setMaterial(a.resource)
        },
        _onMaterialAssetUnload: function(a) {
            this._setMaterial(this.system.defaultMaterial)
        },
        _onMaterialAssetRemove: function(a) {
            this._onMaterialAssetUnload(a)
        },
        _onMaterialAssetChange: function(a) {},
        _bindModelAsset: function(a) {
            this._unbindModelAsset(a);
            a.on("load", this._onModelAssetLoad, this);
            a.on("unload", this._onModelAssetUnload, this);
            a.on("change", this._onModelAssetChange, this);
            a.on("remove", this._onModelAssetRemove, this);
            a.resource ? this._onModelAssetLoad(a) : this.enabled && this.entity.enabled && this.system.app.assets.load(a)
        },
        _unbindModelAsset: function(a) {
            a.off("load", this._onModelAssetLoad, this);
            a.off("unload", this._onModelAssetUnload, this);
            a.off("change", this._onModelAssetChange, this);
            a.off("remove", this._onModelAssetRemove, this)
        },
        _onModelAssetAdded: function(a) {
            this.system.app.assets.off("add:" + a.id, this._onModelAssetAdd, this);
            a.id === this._asset && this._bindModelAsset(a)
        },
        _onModelAssetLoad: function(a) {
            this.model = a.resource.clone();
            this._clonedModel = !0
        },
        _onModelAssetUnload: function(a) {
            this.model = null
        },
        _onModelAssetChange: function(a, b, c, d) {
            "data" === b && (this.mapping = this._mapping)
        },
        _onModelAssetRemove: function(a) {
            this.model = null
        },
        _setMaterial: function(a) {
            if (this._material !== a) {
                this._material = a;
                var b = this._model;
                if (b && "asset" !== this._type) {
                    b = b.meshInstances;
                    for (var c = 0, d = b.length; c < d; c++)
                        b[c].material = a
                }
            }
        }
    });
    Object.defineProperty(Ha.prototype, "meshInstances", {
        get: function() {
            return this._model ? this._model.meshInstances : null
        },
        set: function(a) {
            this._model && (this._model.meshInstances = a)
        }
    });
    Object.defineProperty(Ha.prototype, "type", {
        get: function() {
            return this._type
        },
        set: function(a) {
            if (this._type !== a)
                if (this._area = null,
                this._type = a,
                "asset" === a)
                    null !== this._asset ? this._bindModelAsset(this._asset) : this.model = null;
                else {
                    var b = this.system
                      , c = b.app.graphicsDevice;
                    switch (a) {
                    case "box":
                        b.box || (b.box = Eg(c, {
                            halfExtents: new z(.5,.5,.5)
                        }));
                        a = b.box;
                        this._area = {
                            x: 2,
                            y: 2,
                            z: 2,
                            uv: 2 / 3
                        };
                        break;
                    case "capsule":
                        b.capsule || (b.capsule = ni(c, {
                            radius: .5,
                            height: 2
                        }));
                        a = b.capsule;
                        this._area = {
                            x: 2 * Math.PI,
                            y: Math.PI,
                            z: 2 * Math.PI,
                            uv: 1 / 3 + 1 / 3 / 3 * 2
                        };
                        break;
                    case "cone":
                        b.cone || (b.cone = oi(c, {
                            baseRadius: .5,
                            peakRadius: 0,
                            height: 1
                        }));
                        a = b.cone;
                        this._area = {
                            x: 2.54,
                            y: 2.54,
                            z: 2.54,
                            uv: 1 / 3 + 1 / 3 / 3
                        };
                        break;
                    case "cylinder":
                        b.cylinder || (b.cylinder = mi(c, {
                            radius: .5,
                            height: 1
                        }));
                        a = b.cylinder;
                        this._area = {
                            x: Math.PI,
                            y: 1.58,
                            z: Math.PI,
                            uv: 1 / 3 + 1 / 3 / 3 * 2
                        };
                        break;
                    case "plane":
                        b.plane || (b.plane = qi(c, {
                            halfExtents: new P(.5,.5),
                            widthSegments: 1,
                            lengthSegments: 1
                        }));
                        a = b.plane;
                        this._area = {
                            x: 0,
                            y: 1,
                            z: 0,
                            uv: 1
                        };
                        break;
                    case "sphere":
                        b.sphere || (b.sphere = pi(c, {
                            radius: .5
                        }));
                        a = b.sphere;
                        this._area = {
                            x: Math.PI,
                            y: Math.PI,
                            z: Math.PI,
                            uv: 1
                        };
                        break;
                    default:
                        throw Error("Invalid model type: " + a);
                    }
                    c = new Z;
                    var d = new sb;
                    d.graph = c;
                    d.meshInstances = [new va(c,a,this._material)];
                    b._inTools && d.generateWireframe();
                    this.model = d;
                    this._asset = null
                }
        }
    });
    Object.defineProperty(Ha.prototype, "asset", {
        get: function() {
            return this._asset
        },
        set: function(a) {
            var b = this.system.app.assets
              , c = a;
            a instanceof aa && (c = a.id);
            this._asset !== c && (this._asset && (b.off("add:" + this._asset, this._onModelAssetAdded, this),
            (a = b.get(this._asset)) && this._unbindModelAsset(a)),
            (this._asset = c) ? (c = b.get(this._asset)) ? this._bindModelAsset(c) : (this.model = null,
            b.on("add:" + this._asset, this._onModelAssetAdded, this)) : this.model = null)
        }
    });
    Object.defineProperty(Ha.prototype, "model", {
        get: function() {
            return this._model
        },
        set: function(a) {
            if (!(this._model === a || a && a._immutable) && (this._model && (this._model._immutable = !1,
            this.removeModelFromLayers(),
            this.entity.removeChild(this._model.getGraph()),
            delete this._model._entity,
            this._clonedModel && (this._model.destroy(),
            this._clonedModel = !1)),
            this._model = a)) {
                this._model._immutable = !0;
                var b = this._model.meshInstances;
                for (a = 0; a < b.length; a++)
                    b[a].castShadow = this._castShadows,
                    b[a].receiveShadow = this._receiveShadows,
                    b[a].isStatic = this._isStatic;
                this.lightmapped = this._lightmapped;
                this.entity.addChild(this._model.graph);
                this.enabled && this.entity.enabled && this.addModelToLayers();
                this._model._entity = this.entity;
                this.entity.animation && this.entity.animation.setModel(this._model);
                this.entity.anim && this.entity.anim.resetStateGraph();
                "asset" === this.type ? this.mapping = this._mapping : this._unsetMaterialEvents()
            }
        }
    });
    Object.defineProperty(Ha.prototype, "lightmapped", {
        get: function() {
            return this._lightmapped
        },
        set: function(a) {
            if (a !== this._lightmapped && (this._lightmapped = a,
            this._model)) {
                var b = this._model.meshInstances;
                if (a)
                    for (a = 0; a < b.length; a++) {
                        var c = b[a];
                        var d = c.mask;
                        c.mask = (d | 2) & -6
                    }
                else
                    for (a = 0; a < b.length; a++)
                        c = b[a],
                        c.deleteParameter("texture_lightMap"),
                        c.deleteParameter("texture_dirLightMap"),
                        c._shaderDefs &= -65,
                        d = c.mask,
                        c.mask = (d | 1) & -7
            }
        }
    });
    Object.defineProperty(Ha.prototype, "castShadows", {
        get: function() {
            return this._castShadows
        },
        set: function(a) {
            if (this._castShadows !== a) {
                var b, c, d = this._model;
                if (d) {
                    var e = this.layers
                      , f = this.system.app.scene;
                    if (this._castShadows && !a)
                        for (c = 0; c < e.length; c++)
                            (b = this.system.app.scene.layers.getLayerById(this.layers[c])) && b.removeShadowCasters(d.meshInstances);
                    b = d.meshInstances;
                    for (c = 0; c < b.length; c++)
                        b[c].castShadow = a;
                    if (!this._castShadows && a)
                        for (c = 0; c < e.length; c++)
                            (b = f.layers.getLayerById(e[c])) && b.addShadowCasters(d.meshInstances)
                }
                this._castShadows = a
            }
        }
    });
    Object.defineProperty(Ha.prototype, "receiveShadows", {
        get: function() {
            return this._receiveShadows
        },
        set: function(a) {
            if (this._receiveShadows !== a && (this._receiveShadows = a,
            this._model))
                for (var b = this._model.meshInstances, c = 0, d = b.length; c < d; c++)
                    b[c].receiveShadow = a
        }
    });
    Object.defineProperty(Ha.prototype, "castShadowsLightmap", {
        get: function() {
            return this._castShadowsLightmap
        },
        set: function(a) {
            this._castShadowsLightmap = a
        }
    });
    Object.defineProperty(Ha.prototype, "lightmapSizeMultiplier", {
        get: function() {
            return this._lightmapSizeMultiplier
        },
        set: function(a) {
            this._lightmapSizeMultiplier = a
        }
    });
    Object.defineProperty(Ha.prototype, "isStatic", {
        get: function() {
            return this._isStatic
        },
        set: function(a) {
            if (this._isStatic !== a) {
                this._isStatic = a;
                var b;
                if (this._model) {
                    var c = this._model.meshInstances;
                    for (b = 0; b < c.length; b++) {
                        var d = c[b];
                        d.isStatic = a
                    }
                }
            }
        }
    });
    Object.defineProperty(Ha.prototype, "layers", {
        get: function() {
            return this._layers
        },
        set: function(a) {
            var b, c, d = this.system.app.scene.layers;
            if (this.meshInstances)
                for (b = 0; b < this._layers.length; b++)
                    (c = d.getLayerById(this._layers[b])) && c.removeMeshInstances(this.meshInstances);
            for (b = this._layers.length = 0; b < a.length; b++)
                this._layers[b] = a[b];
            if (this.enabled && this.entity.enabled && this.meshInstances)
                for (b = 0; b < this._layers.length; b++)
                    (c = d.getLayerById(this._layers[b])) && c.addMeshInstances(this.meshInstances)
        }
    });
    Object.defineProperty(Ha.prototype, "batchGroupId", {
        get: function() {
            return this._batchGroupId
        },
        set: function(a) {
            if (this._batchGroupId !== a) {
                var b = this.system.app.batcher;
                this.entity.enabled && 0 <= this._batchGroupId && b.remove(bb.MODEL, this.batchGroupId, this.entity);
                this.entity.enabled && 0 <= a && b.insert(bb.MODEL, a, this.entity);
                0 > a && 0 <= this._batchGroupId && this.enabled && this.entity.enabled && this.addModelToLayers();
                this._batchGroupId = a
            }
        }
    });
    Object.defineProperty(Ha.prototype, "materialAsset", {
        get: function() {
            return this._materialAsset
        },
        set: function(a) {
            var b = a;
            a instanceof aa && (b = a.id);
            a = this.system.app.assets;
            if (b !== this._materialAsset) {
                if (this._materialAsset) {
                    a.off("add:" + this._materialAsset, this._onMaterialAssetAdd, this);
                    var c = a.get(this._materialAsset);
                    c && this._unbindMaterialAsset(c)
                }
                (this._materialAsset = b) ? (b = a.get(this._materialAsset)) ? this._bindMaterialAsset(b) : (this._setMaterial(this.system.defaultMaterial),
                a.on("add:" + this._materialAsset, this._onMaterialAssetAdd, this)) : this._setMaterial(this.system.defaultMaterial)
            }
        }
    });
    Object.defineProperty(Ha.prototype, "material", {
        get: function() {
            return this._material
        },
        set: function(a) {
            this._material !== a && (this.materialAsset = null,
            this._setMaterial(a))
        }
    });
    Object.defineProperty(Ha.prototype, "mapping", {
        get: function() {
            return this._mapping
        },
        set: function(a) {
            if ("asset" === this._type && (this._unsetMaterialEvents(),
            a || (a = {}),
            this._mapping = a,
            this._model)) {
                var b = this._model.meshInstances
                  , c = this.asset ? this.system.app.assets.get(this.asset) : null;
                c = c ? c.data.mapping : null;
                for (var d = null, e = 0, f = b.length; e < f; e++)
                    if (void 0 !== a[e])
                        a[e] ? (d = this.system.app.assets.get(a[e]),
                        this._loadAndSetMeshInstanceMaterial(d, b[e], e)) : b[e].material = this.system.defaultMaterial;
                    else if (c)
                        if (c[e] && (c[e].material || c[e].path)) {
                            if (void 0 !== c[e].material)
                                d = this.system.app.assets.get(c[e].material);
                            else if (void 0 !== c[e].path) {
                                var g = this._getMaterialAssetUrl(c[e].path);
                                g && (d = this.system.app.assets.getByUrl(g))
                            }
                            this._loadAndSetMeshInstanceMaterial(d, b[e], e)
                        } else
                            b[e].material = this.system.defaultMaterial
            }
        }
    });
    var sl = ["enabled"];
    Fe.prototype = Object.create(H.prototype);
    Fe.prototype.constructor = Fe;
    O._buildAccessors(Ha.prototype, sl);
    Object.assign(Fe.prototype, {
        initializeComponentData: function(a, b, c) {
            c = "material materialAsset asset castShadows receiveShadows castShadowsLightmap lightmapped lightmapSizeMultiplier type mapping layers isStatic batchGroupId".split(" ");
            if (null === b.batchGroupId || void 0 === b.batchGroupId)
                b.batchGroupId = -1;
            b.layers && b.layers.length && (b.layers = b.layers.slice(0));
            for (var d = 0; d < c.length; d++)
                b.hasOwnProperty(c[d]) && (a[c[d]] = b[c[d]]);
            H.prototype.initializeComponentData.call(this, a, b, ["enabled"])
        },
        cloneComponent: function(a, b) {
            var c = {
                type: a.model.type,
                asset: a.model.asset,
                castShadows: a.model.castShadows,
                receiveShadows: a.model.receiveShadows,
                castShadowsLightmap: a.model.castShadowsLightmap,
                lightmapped: a.model.lightmapped,
                lightmapSizeMultiplier: a.model.lightmapSizeMultiplier,
                isStatic: a.model.isStatic,
                enabled: a.model.enabled,
                layers: a.model.layers,
                batchGroupId: a.model.batchGroupId,
                mapping: Gc({}, a.model.mapping)
            }
              , d = a.model.materialAsset;
            d instanceof aa || null == d || (d = this.app.assets.get(d));
            var e = a.model.material;
            e && e !== this.defaultMaterial && d && e !== d.resource || (c.materialAsset = d);
            b = this.addComponent(b, c);
            a.model.model && "asset" === a.model.type && !a.model.asset && (b.model = a.model.model.clone(),
            b._clonedModel = !0);
            c.materialAsset || (b.material = e);
            if (a.model.model)
                for (a = a.model.model.meshInstances,
                c = b.model.meshInstances,
                e = 0; e < a.length; e++)
                    c[e].mask = a[e].mask,
                    c[e].material = a[e].material,
                    c[e].layer = a[e].layer,
                    c[e].receiveShadow = a[e].receiveShadow
        },
        onRemove: function(a, b) {
            b.onRemove()
        }
    });
    var Mp = "emitterExtents emitterRadius emitterExtentsInner emitterRadiusInner loop initialVelocity animSpeed normalMap particleNormal".split(" "), Np = "numParticles lifetime rate rate2 startAngle startAngle2 lighting halfLambert intensity wrap wrapBounds depthWrite noFog sort stretch alignToMotion preWarm emitterShape animTilesX animTilesY animStartFrame animNumFrames animNumAnimations animIndex randomizeAnimIndex animLoop colorMap localSpace screenSpace orientation".split(" "), Op = "scaleGraph scaleGraph2 colorGraph colorGraph2 alphaGraph alphaGraph2 velocityGraph velocityGraph2 localVelocityGraph localVelocityGraph2 rotationSpeedGraph rotationSpeedGraph2 radialSpeedGraph radialSpeedGraph2".split(" "), Nh = ["colorMapAsset", "normalMapAsset", "meshAsset"], of, ld = function(a, b) {
        O.call(this, a, b);
        this.on("set_colorMapAsset", this.onSetColorMapAsset, this);
        this.on("set_normalMapAsset", this.onSetNormalMapAsset, this);
        this.on("set_meshAsset", this.onSetMeshAsset, this);
        this.on("set_mesh", this.onSetMesh, this);
        this.on("set_loop", this.onSetLoop, this);
        this.on("set_blendType", this.onSetBlendType, this);
        this.on("set_depthSoftening", this.onSetDepthSoftening, this);
        this.on("set_layers", this.onSetLayers, this);
        Mp.forEach(function(c) {
            this.on("set_" + c, this.onSetSimpleProperty, this)
        }
        .bind(this));
        Np.forEach(function(c) {
            this.on("set_" + c, this.onSetComplexProperty, this)
        }
        .bind(this));
        Op.forEach(function(c) {
            this.on("set_" + c, this.onSetGraphProperty, this)
        }
        .bind(this));
        this._requestedDepth = !1;
        this._drawOrder = 0
    };
    ld.prototype = Object.create(O.prototype);
    ld.prototype.constructor = ld;
    Object.defineProperties(ld.prototype, {
        drawOrder: {
            get: function() {
                return this._drawOrder
            },
            set: function(a) {
                this._drawOrder = a;
                this.emitter && (this.emitter.drawOrder = a)
            }
        }
    });
    Object.assign(ld.prototype, {
        addModelToLayers: function() {
            if (this.data.model)
                for (var a, b = 0; b < this.layers.length; b++)
                    if (a = this.system.app.scene.layers.getLayerById(this.layers[b]))
                        a.addMeshInstances(this.data.model.meshInstances),
                        this.emitter._layer = a
        },
        removeModelFromLayers: function(a) {
            if (this.data.model)
                for (var b = 0; b < this.layers.length; b++)
                    (a = this.system.app.scene.layers.getLayerById(this.layers[b])) && a.removeMeshInstances(this.data.model.meshInstances)
        },
        onSetLayers: function(a, b, c) {
            if (this.data.model) {
                var d;
                for (a = 0; a < b.length; a++)
                    (d = this.system.app.scene.layers.getLayerById(b[a])) && d.removeMeshInstances(this.data.model.meshInstances);
                if (this.enabled && this.entity.enabled)
                    for (a = 0; a < c.length; a++)
                        (d = this.system.app.scene.layers.getLayerById(c[a])) && d.addMeshInstances(this.data.model.meshInstances)
            }
        },
        onLayersChanged: function(a, b) {
            this.addModelToLayers();
            a.off("add", this.onLayerAdded, this);
            a.off("remove", this.onLayerRemoved, this);
            b.on("add", this.onLayerAdded, this);
            b.on("remove", this.onLayerRemoved, this)
        },
        onLayerAdded: function(a) {
            this.data.model && (0 > this.layers.indexOf(a.id) || a.addMeshInstances(this.data.model.meshInstances))
        },
        onLayerRemoved: function(a) {
            this.data.model && (0 > this.layers.indexOf(a.id) || a.removeMeshInstances(this.data.model.meshInstances))
        },
        _bindColorMapAsset: function(a) {
            a.on("load", this._onColorMapAssetLoad, this);
            a.on("unload", this._onColorMapAssetUnload, this);
            a.on("remove", this._onColorMapAssetRemove, this);
            a.on("change", this._onColorMapAssetChange, this);
            a.resource ? this._onColorMapAssetLoad(a) : this.enabled && this.entity.enabled && this.system.app.assets.load(a)
        },
        _unbindColorMapAsset: function(a) {
            a.off("load", this._onColorMapAssetLoad, this);
            a.off("unload", this._onColorMapAssetUnload, this);
            a.off("remove", this._onColorMapAssetRemove, this);
            a.off("change", this._onColorMapAssetChange, this)
        },
        _onColorMapAssetLoad: function(a) {
            this.colorMap = a.resource
        },
        _onColorMapAssetUnload: function(a) {
            this.colorMap = null
        },
        _onColorMapAssetRemove: function(a) {
            this._onColorMapAssetUnload(a)
        },
        _onColorMapAssetChange: function(a) {},
        onSetColorMapAsset: function(a, b, c) {
            var d = this;
            a = this.system.app.assets;
            b && (b = a.get(b)) && this._unbindColorMapAsset(b);
            if (c)
                if (c instanceof aa && (c = this.data.colorMapAsset = c.id),
                b = a.get(c))
                    d._bindColorMapAsset(b);
                else
                    a.once("add:" + c, function(e) {
                        d._bindColorMapAsset(e)
                    });
            else
                this.colorMap = null
        },
        _bindNormalMapAsset: function(a) {
            a.on("load", this._onNormalMapAssetLoad, this);
            a.on("unload", this._onNormalMapAssetUnload, this);
            a.on("remove", this._onNormalMapAssetRemove, this);
            a.on("change", this._onNormalMapAssetChange, this);
            a.resource ? this._onNormalMapAssetLoad(a) : this.enabled && this.entity.enabled && this.system.app.assets.load(a)
        },
        _unbindNormalMapAsset: function(a) {
            a.off("load", this._onNormalMapAssetLoad, this);
            a.off("unload", this._onNormalMapAssetUnload, this);
            a.off("remove", this._onNormalMapAssetRemove, this);
            a.off("change", this._onNormalMapAssetChange, this)
        },
        _onNormalMapAssetLoad: function(a) {
            this.normalMap = a.resource
        },
        _onNormalMapAssetUnload: function(a) {
            this.normalMap = null
        },
        _onNormalMapAssetRemove: function(a) {
            this._onNormalMapAssetUnload(a)
        },
        _onNormalMapAssetChange: function(a) {},
        onSetNormalMapAsset: function(a, b, c) {
            var d = this;
            a = this.system.app.assets;
            b && (b = a.get(b)) && this._unbindNormalMapAsset(b);
            if (c)
                if (c instanceof aa && (c = this.data.normalMapAsset = c.id),
                b = a.get(c))
                    d._bindNormalMapAsset(b);
                else
                    a.once("add:" + c, function(e) {
                        d._bindNormalMapAsset(e)
                    });
            else
                this.normalMap = null
        },
        _bindMeshAsset: function(a) {
            a.on("load", this._onMeshAssetLoad, this);
            a.on("unload", this._onMeshAssetUnload, this);
            a.on("remove", this._onMeshAssetRemove, this);
            a.on("change", this._onMeshAssetChange, this);
            a.resource ? this._onMeshAssetLoad(a) : this.enabled && this.entity.enabled && this.system.app.assets.load(a)
        },
        _unbindMeshAsset: function(a) {
            a.off("load", this._onMeshAssetLoad, this);
            a.off("unload", this._onMeshAssetUnload, this);
            a.off("remove", this._onMeshAssetRemove, this);
            a.off("change", this._onMeshAssetChange, this)
        },
        _onMeshAssetLoad: function(a) {
            this._onMeshChanged(a.resource)
        },
        _onMeshAssetUnload: function(a) {
            this.mesh = null
        },
        _onMeshAssetRemove: function(a) {
            this._onMeshAssetUnload(a)
        },
        _onMeshAssetChange: function(a) {},
        onSetMeshAsset: function(a, b, c) {
            a = this.system.app.assets;
            b && (b = a.get(b)) && this._unbindMeshAsset(b);
            if (c) {
                if (c instanceof aa && (c = this.data.meshAsset = c.id),
                b = a.get(c))
                    this._bindMeshAsset(b),
                    b.resource ? this._onMeshChanged(b.resource) : a.load(b)
            } else
                this._onMeshChanged(null)
        },
        onSetMesh: function(a, b, c) {
            !c || c instanceof aa || "number" === typeof c ? this.meshAsset = c : this._onMeshChanged(c)
        },
        _onMeshChanged: function(a) {
            !a || a instanceof rb || (a = a.meshInstances[0] ? a.meshInstances[0].mesh : null);
            this.data.mesh = a;
            this.emitter && (this.emitter.mesh = a,
            this.emitter.resetMaterial(),
            this.rebuild())
        },
        onSetLoop: function(a, b, c) {
            this.emitter && (this.emitter[a] = c,
            this.emitter.resetTime())
        },
        onSetBlendType: function(a, b, c) {
            this.emitter && (this.emitter[a] = c,
            this.emitter.material.blendType = c,
            this.emitter.resetMaterial(),
            this.rebuild())
        },
        _requestDepth: function() {
            this._requestedDepth || (of || (of = this.system.app.scene.layers.getLayerById(1)),
            of && (of.incrementCounter(),
            this._requestedDepth = !0))
        },
        _releaseDepth: function() {
            this._requestedDepth && of && (of.decrementCounter(),
            this._requestedDepth = !1)
        },
        onSetDepthSoftening: function(a, b, c) {
            b !== c && (c ? this.enabled && this.entity.enabled && this._requestDepth() : this.enabled && this.entity.enabled && this._releaseDepth(),
            this.emitter && (this.emitter[a] = c),
            this.emitter && (this.reset(),
            this.emitter.resetMaterial(),
            this.rebuild()))
        },
        onSetSimpleProperty: function(a, b, c) {
            this.emitter && (this.emitter[a] = c,
            this.emitter.resetMaterial())
        },
        onSetComplexProperty: function(a, b, c) {
            this.emitter && (this.emitter[a] = c,
            this.emitter.resetMaterial(),
            this.rebuild(),
            this.reset())
        },
        onSetGraphProperty: function(a, b, c) {
            this.emitter && (this.emitter[a] = c,
            this.emitter.rebuildGraphs(),
            this.emitter.resetMaterial())
        },
        onEnable: function() {
            for (var a = this.data, b = 0, c = Nh.length; b < c; b++) {
                var d = a[Nh[b]];
                if (d) {
                    if (!(d instanceof aa))
                        if (0 <= parseInt(d, 10))
                            d = this.system.app.assets.get(d);
                        else
                            continue;
                    d && !d.resource && this.system.app.assets.load(d)
                }
            }
            this.emitter || (b = a.mesh,
            b instanceof rb || (b = null),
            this.emitter = new $b(this.system.app.graphicsDevice,{
                numParticles: a.numParticles,
                emitterExtents: a.emitterExtents,
                emitterExtentsInner: a.emitterExtentsInner,
                emitterRadius: a.emitterRadius,
                emitterRadiusInner: a.emitterRadiusInner,
                emitterShape: a.emitterShape,
                initialVelocity: a.initialVelocity,
                wrap: a.wrap,
                localSpace: a.localSpace,
                screenSpace: a.screenSpace,
                wrapBounds: a.wrapBounds,
                lifetime: a.lifetime,
                rate: a.rate,
                rate2: a.rate2,
                orientation: a.orientation,
                particleNormal: a.particleNormal,
                animTilesX: a.animTilesX,
                animTilesY: a.animTilesY,
                animStartFrame: a.animStartFrame,
                animNumFrames: a.animNumFrames,
                animNumAnimations: a.animNumAnimations,
                animIndex: a.animIndex,
                randomizeAnimIndex: a.randomizeAnimIndex,
                animSpeed: a.animSpeed,
                animLoop: a.animLoop,
                startAngle: a.startAngle,
                startAngle2: a.startAngle2,
                scaleGraph: a.scaleGraph,
                scaleGraph2: a.scaleGraph2,
                colorGraph: a.colorGraph,
                colorGraph2: a.colorGraph2,
                alphaGraph: a.alphaGraph,
                alphaGraph2: a.alphaGraph2,
                localVelocityGraph: a.localVelocityGraph,
                localVelocityGraph2: a.localVelocityGraph2,
                velocityGraph: a.velocityGraph,
                velocityGraph2: a.velocityGraph2,
                rotationSpeedGraph: a.rotationSpeedGraph,
                rotationSpeedGraph2: a.rotationSpeedGraph2,
                radialSpeedGraph: a.radialSpeedGraph,
                radialSpeedGraph2: a.radialSpeedGraph2,
                colorMap: a.colorMap,
                normalMap: a.normalMap,
                loop: a.loop,
                preWarm: a.preWarm,
                sort: a.sort,
                stretch: a.stretch,
                alignToMotion: a.alignToMotion,
                lighting: a.lighting,
                halfLambert: a.halfLambert,
                intensity: a.intensity,
                depthSoftening: a.depthSoftening,
                scene: this.system.app.scene,
                mesh: b,
                depthWrite: a.depthWrite,
                noFog: a.noFog,
                node: this.entity,
                blendType: a.blendType
            }),
            this.emitter.meshInstance.node = this.entity,
            this.emitter.drawOrder = this.drawOrder,
            this.psys = new sb,
            this.psys.graph = this.entity,
            this.psys.emitter = this.emitter,
            this.psys.meshInstances = [this.emitter.meshInstance],
            a.model = this.psys,
            this.emitter.psys = this.psys,
            a.autoPlay || (this.pause(),
            this.emitter.meshInstance.visible = !1));
            a.model && this.emitter.colorMap && this.addModelToLayers();
            this.system.app.scene.on("set:layers", this.onLayersChanged, this);
            this.system.app.scene.layers && (this.system.app.scene.layers.on("add", this.onLayerAdded, this),
            this.system.app.scene.layers.on("remove", this.onLayerRemoved, this));
            this.enabled && this.entity.enabled && a.depthSoftening && this._requestDepth()
        },
        onDisable: function() {
            this.system.app.scene.off("set:layers", this.onLayersChanged, this);
            this.system.app.scene.layers && (this.system.app.scene.layers.off("add", this.onLayerAdded, this),
            this.system.app.scene.layers.off("remove", this.onLayerRemoved, this));
            this.data.model && (this.removeModelFromLayers(),
            this.data.depthSoftening && this._releaseDepth());
            this.emitter && (this.emitter.camera = null)
        },
        onBeforeRemove: function() {
            this.enabled && (this.enabled = !1);
            var a = this.data;
            a.model && (this.entity.removeChild(a.model.getGraph()),
            a.model.destroy(),
            a.model = null);
            this.emitter && (this.emitter.destroy(),
            this.emitter = null);
            for (var b = 0; b < Nh.length; b++) {
                var c = Nh[b];
                a[c] && (this[c] = null)
            }
            this.off()
        },
        reset: function() {
            this.emitter && this.emitter.reset()
        },
        stop: function() {
            this.emitter && (this.emitter.loop = !1,
            this.emitter.resetTime(),
            this.emitter.addTime(0, !0))
        },
        pause: function() {
            this.data.paused = !0
        },
        unpause: function() {
            this.data.paused = !1
        },
        play: function() {
            this.data.paused = !1;
            this.emitter && (this.emitter.meshInstance.visible = !0,
            this.emitter.loop = this.data.loop,
            this.emitter.resetTime())
        },
        isPlaying: function() {
            return this.data.paused ? !1 : this.emitter && this.emitter.loop ? !0 : Date.now() <= this.emitter.endTime
        },
        rebuild: function() {
            var a = this.enabled;
            this.enabled = !1;
            this.emitter && (this.emitter.rebuild(),
            this.emitter.meshInstance.node = this.entity,
            this.data.model.meshInstances = [this.emitter.meshInstance]);
            this.enabled = a
        }
    });
    var tl = "enabled autoPlay numParticles lifetime rate rate2 startAngle startAngle2 loop preWarm lighting halfLambert intensity depthWrite noFog depthSoftening sort blendType stretch alignToMotion emitterShape emitterExtents emitterExtentsInner emitterRadius emitterRadiusInner initialVelocity wrap wrapBounds localSpace screenSpace colorMapAsset normalMapAsset mesh meshAsset orientation particleNormal localVelocityGraph localVelocityGraph2 velocityGraph velocityGraph2 rotationSpeedGraph rotationSpeedGraph2 radialSpeedGraph radialSpeedGraph2 scaleGraph scaleGraph2 colorGraph colorGraph2 alphaGraph alphaGraph2 colorMap normalMap animTilesX animTilesY animStartFrame animNumFrames animNumAnimations animIndex randomizeAnimIndex animSpeed animLoop layers".split(" ");
    Ge.prototype = Object.create(H.prototype);
    Ge.prototype.constructor = Ge;
    O._buildAccessors(ld.prototype, tl);
    Object.assign(Ge.prototype, {
        initializeComponentData: function(a, b, c) {
            var d = {};
            c = [];
            var e = this.propertyTypes;
            if (b.mesh instanceof aa || "number" === typeof b.mesh)
                b.meshAsset = b.mesh,
                delete b.mesh;
            for (var f in b) {
                b.hasOwnProperty(f) && (c.push(f),
                d[f] = b[f]);
                if ("vec3" === e[f])
                    Array.isArray(d[f]) && (d[f] = new z(d[f][0],d[f][1],d[f][2]));
                else if ("curve" === e[f]) {
                    if (!(d[f]instanceof gb)) {
                        var g = d[f].type;
                        d[f] = new gb(d[f].keys);
                        d[f].type = g
                    }
                } else
                    "curveset" !== e[f] || d[f]instanceof Cb || (g = d[f].type,
                    d[f] = new Cb(d[f].keys),
                    d[f].type = g);
                d.layers && Array.isArray(d.layers) && (d.layers = d.layers.slice(0))
            }
            H.prototype.initializeComponentData.call(this, a, d, c)
        },
        cloneComponent: function(a, b) {
            a = a.particlesystem.data;
            for (var c = this.schema, d = {}, e = 0, f = c.length; e < f; e++) {
                var g = c[e]
                  , k = a[g];
                k instanceof z || k instanceof gb || k instanceof Cb ? (k = k.clone(),
                d[g] = k) : "layers" === g ? d.layers = a.layers.slice(0) : null !== k && void 0 !== k && (d[g] = k)
            }
            return this.addComponent(b, d)
        },
        onUpdate: function(a) {
            var b = this.store, c, d = this.app.stats.particles, e;
            for (e in b)
                if (b.hasOwnProperty(e)) {
                    var f = b[e];
                    var g = f.entity;
                    var k = f.data;
                    if (k.enabled && g.enabled) {
                        var h = k.model.emitter;
                        if (h.meshInstance.visible) {
                            if (h.lighting) {
                                var l = k.layers;
                                for (g = 0; g < l.length; g++)
                                    if (f = this.app.scene.layers.getLayerById(l[g])) {
                                        f._lightCube || (f._lightCube = new Float32Array(18));
                                        var n = f._lightCube;
                                        for (g = 0; 6 > g; g++)
                                            n[3 * g] = this.app.scene.ambientLight.r,
                                            n[3 * g + 1] = this.app.scene.ambientLight.g,
                                            n[3 * g + 2] = this.app.scene.ambientLight.b;
                                        var p = f._sortedLights[0];
                                        for (c = 0; c < p.length; c++)
                                            for (f = 0; 6 > f; f++) {
                                                var q = Math.max(h.lightCubeDir[f].dot(p[c]._direction), 0) * p[c]._intensity;
                                                n[3 * f] += p[c]._color.r * q;
                                                n[3 * f + 1] += p[c]._color.g * q;
                                                n[3 * f + 2] += p[c]._color.b * q
                                            }
                                    }
                                h.constantLightCube.setValue(n)
                            }
                            if (!k.paused) {
                                h.simTime += a;
                                if (h.simTime > h.fixedTimeStep) {
                                    var r = Math.floor(h.simTime / h.fixedTimeStep);
                                    h.simTime -= r * h.fixedTimeStep
                                }
                                if (r) {
                                    r = Math.min(r, h.maxSubSteps);
                                    for (g = 0; g < r; g++)
                                        h.addTime(h.fixedTimeStep, !1);
                                    d._updatesPerFrame += r;
                                    d._frameTime += h._addTimeTime;
                                    h._addTimeTime = 0
                                }
                                h.finishFrame()
                            }
                        }
                    }
                }
        },
        onBeforeRemove: function(a, b) {
            b.onBeforeRemove()
        }
    });
    Object.assign(Vg.prototype, {
        _resize: function(a) {
            if (a > this._pool.length)
                for (var b = this._pool.length; b < a; b++)
                    this._pool[b] = new this._constructor
        },
        allocate: function() {
            this._count >= this._pool.length && this._resize(2 * this._pool.length);
            return this._pool[this._count++]
        },
        freeAll: function() {
            this._count = 0
        }
    });
    var Ub, ya, Jf, oj, pj;
    hc.prototype = Object.create(O.prototype);
    hc.prototype.constructor = hc;
    Object.defineProperty(hc.prototype, "linearVelocity", {
        get: function() {
            var a = this.body;
            a && "dynamic" === this.type && (a = a.getLinearVelocity(),
            this._linearVelocity.set(a.x(), a.y(), a.z()));
            return this._linearVelocity
        },
        set: function(a) {
            var b = this.body;
            b && "dynamic" === this.type && (b.activate(),
            ya.setValue(a.x, a.y, a.z),
            b.setLinearVelocity(ya),
            this._linearVelocity.copy(a))
        }
    });
    Object.defineProperty(hc.prototype, "angularVelocity", {
        get: function() {
            var a = this.body;
            a && "dynamic" === this.type && (a = a.getAngularVelocity(),
            this._angularVelocity.set(a.x(), a.y(), a.z()));
            return this._angularVelocity
        },
        set: function(a) {
            var b = this.body;
            b && "dynamic" === this.type && (b.activate(),
            ya.setValue(a.x, a.y, a.z),
            b.setAngularVelocity(ya),
            this._angularVelocity.copy(a))
        }
    });
    Object.assign(hc.prototype, {
        createBody: function() {
            var a = this.entity;
            if (a.collision) {
                var b = a.collision.shape;
                a.trigger && (a.trigger.destroy(),
                delete a.trigger)
            }
            if (b) {
                if (this.body)
                    this.system.onRemove(this.entity, this);
                var c = "dynamic" === this.type ? this.mass : 0;
                this._getEntityTransform(Ub);
                b = this.system.createBody(c, b, Ub);
                b.setRestitution(this.restitution);
                b.setFriction(this.friction);
                b.setDamping(this.linearDamping, this.angularDamping);
                "dynamic" === this.type ? (c = this.linearFactor,
                ya.setValue(c.x, c.y, c.z),
                b.setLinearFactor(ya),
                c = this.angularFactor,
                ya.setValue(c.x, c.y, c.z),
                b.setAngularFactor(ya)) : "kinematic" === this.type && (b.setCollisionFlags(b.getCollisionFlags() | 2),
                b.setActivationState(4));
                b.entity = a;
                a.rigidbody.body = b;
                this.enabled && this.entity.enabled && this.enableSimulation()
            }
        },
        isActive: function() {
            var a = this.body;
            return a ? a.isActive() : !1
        },
        activate: function() {
            var a = this.body;
            a && a.activate()
        },
        enableSimulation: function() {
            if (this.entity.collision && this.entity.collision.enabled && !this.data.simulationEnabled) {
                var a = this.body;
                if (a) {
                    this.system.addBody(a, this.group, this.mask);
                    switch (this.type) {
                    case "dynamic":
                        this.system._dynamic.push(this);
                        a.forceActivationState(1);
                        this.syncEntityToBody();
                        break;
                    case "kinematic":
                        this.system._kinematic.push(this);
                        a.forceActivationState(4);
                        break;
                    case He:
                        a.forceActivationState(1),
                        this.syncEntityToBody()
                    }
                    "compound" === this.entity.collision.type && this.system._compounds.push(this.entity.collision);
                    a.activate();
                    this.data.simulationEnabled = !0
                }
            }
        },
        disableSimulation: function() {
            var a = this.body;
            if (a && this.data.simulationEnabled) {
                var b = this.system._compounds.indexOf(this.entity.collision);
                -1 < b && this.system._compounds.splice(b, 1);
                b = this.system._dynamic.indexOf(this);
                -1 < b && this.system._dynamic.splice(b, 1);
                b = this.system._kinematic.indexOf(this);
                -1 < b && this.system._kinematic.splice(b, 1);
                this.system.removeBody(a);
                a.forceActivationState(5);
                this.data.simulationEnabled = !1
            }
        },
        applyForce: function() {
            switch (arguments.length) {
            case 1:
                var a = arguments[0].x;
                var b = arguments[0].y;
                var c = arguments[0].z;
                break;
            case 2:
                a = arguments[0].x;
                b = arguments[0].y;
                c = arguments[0].z;
                var d = arguments[1].x;
                var e = arguments[1].y;
                var f = arguments[1].z;
                break;
            case 3:
                a = arguments[0];
                b = arguments[1];
                c = arguments[2];
                break;
            case 6:
                a = arguments[0],
                b = arguments[1],
                c = arguments[2],
                d = arguments[3],
                e = arguments[4],
                f = arguments[5]
            }
            var g = this.body;
            g && (g.activate(),
            ya.setValue(a, b, c),
            void 0 !== d ? (Jf.setValue(d, e, f),
            g.applyForce(ya, Jf)) : g.applyForce(ya, pj))
        },
        applyTorque: function() {
            switch (arguments.length) {
            case 1:
                var a = arguments[0].x;
                var b = arguments[0].y;
                var c = arguments[0].z;
                break;
            case 3:
                a = arguments[0];
                b = arguments[1];
                c = arguments[2];
                break;
            default:
                return
            }
            var d = this.body;
            d && (d.activate(),
            ya.setValue(a, b, c),
            d.applyTorque(ya))
        },
        applyImpulse: function() {
            switch (arguments.length) {
            case 1:
                var a = arguments[0].x;
                var b = arguments[0].y;
                var c = arguments[0].z;
                break;
            case 2:
                a = arguments[0].x;
                b = arguments[0].y;
                c = arguments[0].z;
                var d = arguments[1].x;
                var e = arguments[1].y;
                var f = arguments[1].z;
                break;
            case 3:
                a = arguments[0];
                b = arguments[1];
                c = arguments[2];
                break;
            case 6:
                a = arguments[0];
                b = arguments[1];
                c = arguments[2];
                d = arguments[3];
                e = arguments[4];
                f = arguments[5];
                break;
            default:
                return
            }
            var g = this.body;
            g && (g.activate(),
            ya.setValue(a, b, c),
            void 0 !== d ? (Jf.setValue(d, e, f),
            g.applyImpulse(ya, Jf)) : g.applyImpulse(ya, pj))
        },
        applyTorqueImpulse: function() {
            switch (arguments.length) {
            case 1:
                var a = arguments[0].x;
                var b = arguments[0].y;
                var c = arguments[0].z;
                break;
            case 3:
                a = arguments[0];
                b = arguments[1];
                c = arguments[2];
                break;
            default:
                return
            }
            var d = this.body;
            d && (d.activate(),
            ya.setValue(a, b, c),
            d.applyTorqueImpulse(ya))
        },
        isStatic: function() {
            return this.type === He
        },
        isStaticOrKinematic: function() {
            return this.type === He || "kinematic" === this.type
        },
        isKinematic: function() {
            return "kinematic" === this.type
        },
        _getEntityTransform: function(a) {
            var b = this.entity.getPosition()
              , c = this.entity.getRotation();
            ya.setValue(b.x, b.y, b.z);
            oj.setValue(c.x, c.y, c.z, c.w);
            a.setOrigin(ya);
            a.setRotation(oj)
        },
        syncEntityToBody: function() {
            var a = this.data.body;
            if (a) {
                this._getEntityTransform(Ub);
                a.setWorldTransform(Ub);
                if ("kinematic" === this.type) {
                    var b = a.getMotionState();
                    b && b.setWorldTransform(Ub)
                }
                a.activate()
            }
        },
        _updateDynamic: function() {
            var a = this.data.body;
            if (a.isActive() && (a = a.getMotionState())) {
                a.getWorldTransform(Ub);
                a = Ub.getOrigin();
                var b = Ub.getRotation();
                this.entity.setPosition(a.x(), a.y(), a.z());
                this.entity.setRotation(b.x(), b.y(), b.z(), b.w())
            }
        },
        _updateKinematic: function() {
            var a = this.data.body.getMotionState();
            a && (this._getEntityTransform(Ub),
            a.setWorldTransform(Ub))
        },
        teleport: function() {
            3 > arguments.length ? (arguments[0] && this.entity.setPosition(arguments[0]),
            arguments[1] && (arguments[1]instanceof Y ? this.entity.setRotation(arguments[1]) : this.entity.setEulerAngles(arguments[1]))) : (6 === arguments.length && this.entity.setEulerAngles(arguments[3], arguments[4], arguments[5]),
            this.entity.setPosition(arguments[0], arguments[1], arguments[2]));
            this.syncEntityToBody()
        },
        onEnable: function() {
            this.body || this.createBody();
            this.enableSimulation()
        },
        onDisable: function() {
            this.disableSimulation()
        },
        onSetMass: function(a, b, c) {
            (a = this.data.body) && "dynamic" === this.type && ((b = this.enabled && this.entity.enabled) && this.disableSimulation(),
            a.getCollisionShape().calculateLocalInertia(c, ya),
            a.setMassProps(c, ya),
            a.updateInertiaTensor(),
            b && this.enableSimulation())
        },
        onSetLinearDamping: function(a, b, c) {
            (a = this.data.body) && a.setDamping(c, this.data.angularDamping)
        },
        onSetAngularDamping: function(a, b, c) {
            (a = this.data.body) && a.setDamping(this.data.linearDamping, c)
        },
        onSetLinearFactor: function(a, b, c) {
            (a = this.data.body) && "dynamic" === this.type && (ya.setValue(c.x, c.y, c.z),
            a.setLinearFactor(ya))
        },
        onSetAngularFactor: function(a, b, c) {
            (a = this.data.body) && "dynamic" === this.type && (ya.setValue(c.x, c.y, c.z),
            a.setAngularFactor(ya))
        },
        onSetFriction: function(a, b, c) {
            (a = this.data.body) && a.setFriction(c)
        },
        onSetRestitution: function(a, b, c) {
            (a = this.data.body) && a.setRestitution(c)
        },
        onSetType: function(a, b, c) {
            c !== b && (this.disableSimulation(),
            "dynamic" === c ? (this.data.group = 1,
            this.data.mask = 65535) : "kinematic" === c ? (this.data.group = 4,
            this.data.mask = 65535) : (this.data.group = qj,
            this.data.mask = Wg),
            this.createBody())
        },
        onSetGroupOrMask: function(a, b, c) {
            c !== b && this.enabled && this.entity.enabled && (this.disableSimulation(),
            this.enableSimulation())
        },
        onSetBody: function(a, b, c) {
            this.body && this.data.simulationEnabled && this.body.activate()
        }
    });
    var ne, oe, wd = {}, mg = {}, xl = "enabled type mass linearDamping angularDamping linearFactor angularFactor friction restitution group mask body".split(" ");
    Ud.prototype = Object.create(H.prototype);
    Ud.prototype.constructor = Ud;
    O._buildAccessors(hc.prototype, xl);
    Object.assign(Ud.prototype, {
        onLibraryLoaded: function() {
            if ("undefined" !== typeof Ammo) {
                this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration;
                this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);
                this.overlappingPairCache = new Ammo.btDbvtBroadphase;
                this.solver = new Ammo.btSequentialImpulseConstraintSolver;
                this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher,this.overlappingPairCache,this.solver,this.collisionConfiguration);
                if (this.dynamicsWorld.setInternalTickCallback) {
                    var a = Ammo.addFunction(this._checkForCollisions.bind(this), "vif");
                    this.dynamicsWorld.setInternalTickCallback(a)
                }
                ne = new Ammo.btVector3;
                oe = new Ammo.btVector3;
                this.contactPointPool = new Vg(vl,1);
                this.contactResultPool = new Vg(wl,1);
                this.singleContactResultPool = new Vg(ul,1);
                H.bind("update", this.onUpdate, this)
            } else
                H.unbind("update", this.onUpdate, this)
        },
        initializeComponentData: function(a, b, c) {
            c = "enabled mass linearDamping angularDamping linearFactor angularFactor friction restitution type group mask".split(" ");
            for (var d = {}, e = 0, f = c.length; e < f; e++) {
                var g = c[e];
                d[g] = b[g]
            }
            b.bodyType && (d.type = b.bodyType);
            d.linearFactor && Array.isArray(d.linearFactor) && (d.linearFactor = new z(d.linearFactor[0],d.linearFactor[1],d.linearFactor[2]));
            d.angularFactor && Array.isArray(d.angularFactor) && (d.angularFactor = new z(d.angularFactor[0],d.angularFactor[1],d.angularFactor[2]));
            H.prototype.initializeComponentData.call(this, a, d, c)
        },
        cloneComponent: function(a, b) {
            this.addComponent(b, {
                enabled: a.rigidbody.enabled,
                mass: a.rigidbody.mass,
                linearDamping: a.rigidbody.linearDamping,
                angularDamping: a.rigidbody.angularDamping,
                linearFactor: [a.rigidbody.linearFactor.x, a.rigidbody.linearFactor.y, a.rigidbody.linearFactor.z],
                angularFactor: [a.rigidbody.angularFactor.x, a.rigidbody.angularFactor.y, a.rigidbody.angularFactor.z],
                friction: a.rigidbody.friction,
                restitution: a.rigidbody.restitution,
                type: a.rigidbody.type,
                group: a.rigidbody.group,
                mask: a.rigidbody.mask
            })
        },
        onBeforeRemove: function(a, b) {
            b.enabled && (b.enabled = !1)
        },
        onRemove: function(a, b) {
            if (a = b.body)
                this.removeBody(a),
                this.destroyBody(a),
                b.body = null
        },
        addBody: function(a, b, c) {
            void 0 !== b && void 0 !== c ? this.dynamicsWorld.addRigidBody(a, b, c) : this.dynamicsWorld.addRigidBody(a)
        },
        removeBody: function(a) {
            this.dynamicsWorld.removeRigidBody(a)
        },
        createBody: function(a, b, c) {
            var d = new Ammo.btVector3(0,0,0);
            0 !== a && b.calculateLocalInertia(a, d);
            c = new Ammo.btDefaultMotionState(c);
            a = new Ammo.btRigidBodyConstructionInfo(a,c,b,d);
            b = new Ammo.btRigidBody(a);
            Ammo.destroy(a);
            Ammo.destroy(d);
            return b
        },
        destroyBody: function(a) {
            var b = a.getMotionState();
            b && Ammo.destroy(b);
            Ammo.destroy(a)
        },
        raycastFirst: function(a, b) {
            var c = null;
            ne.setValue(a.x, a.y, a.z);
            oe.setValue(b.x, b.y, b.z);
            var d = new Ammo.ClosestRayResultCallback(ne,oe);
            this.dynamicsWorld.rayTest(ne, oe, d);
            if (d.hasHit()) {
                var e = d.get_m_collisionObject();
                if (e = Ammo.castObject(e, Ammo.btRigidBody)) {
                    c = d.get_m_hitPointWorld();
                    var f = d.get_m_hitNormalWorld();
                    c = new rj(e.entity,new z(c.x(),c.y(),c.z()),new z(f.x(),f.y(),f.z()));
                    if (2 < arguments.length)
                        (0,
                        arguments[2])(c)
                }
            }
            Ammo.destroy(d);
            return c
        },
        raycastAll: function(a, b) {
            var c = [];
            ne.setValue(a.x, a.y, a.z);
            oe.setValue(b.x, b.y, b.z);
            a = new Ammo.AllHitsRayResultCallback(ne,oe);
            this.dynamicsWorld.rayTest(ne, oe, a);
            if (a.hasHit()) {
                b = a.get_m_collisionObjects();
                for (var d = a.get_m_hitPointWorld(), e = a.get_m_hitNormalWorld(), f = b.size(), g = 0; g < f; g++) {
                    var k = Ammo.castObject(b.at(g), Ammo.btRigidBody);
                    if (k) {
                        var h = d.at(g)
                          , l = e.at(g);
                        k = new rj(k.entity,new z(h.x(),h.y(),h.z()),new z(l.x(),l.y(),l.z()));
                        c.push(k)
                    }
                }
            }
            Ammo.destroy(a);
            return c
        },
        _storeCollision: function(a, b) {
            var c = !1
              , d = a.getGuid();
            wd[d] = wd[d] || {
                others: [],
                entity: a
            };
            0 > wd[d].others.indexOf(b) && (wd[d].others.push(b),
            c = !0);
            mg[d] = mg[d] || {
                others: [],
                entity: a
            };
            mg[d].others.push(b);
            return c
        },
        _createContactPointFromAmmo: function(a) {
            var b = a.get_m_localPointA()
              , c = a.get_m_localPointB()
              , d = a.getPositionWorldOnA()
              , e = a.getPositionWorldOnB();
            a = a.get_m_normalWorldOnB();
            var f = this.contactPointPool.allocate();
            f.localPoint.set(b.x(), b.y(), b.z());
            f.localPointOther.set(c.x(), c.y(), c.z());
            f.point.set(d.x(), d.y(), d.z());
            f.pointOther.set(e.x(), e.y(), e.z());
            f.normal.set(a.x(), a.y(), a.z());
            return f
        },
        _createReverseContactPointFromAmmo: function(a) {
            var b = a.get_m_localPointA()
              , c = a.get_m_localPointB()
              , d = a.getPositionWorldOnA()
              , e = a.getPositionWorldOnB();
            a = a.get_m_normalWorldOnB();
            var f = this.contactPointPool.allocate();
            f.localPointOther.set(b.x(), b.y(), b.z());
            f.localPoint.set(c.x(), c.y(), c.z());
            f.pointOther.set(d.x(), d.y(), d.z());
            f.point.set(e.x(), e.y(), e.z());
            f.normal.set(a.x(), a.y(), a.z());
            return f
        },
        _createSingleContactResult: function(a, b, c) {
            var d = this.singleContactResultPool.allocate();
            d.a = a;
            d.b = b;
            d.localPointA = c.localPoint;
            d.localPointB = c.localPointOther;
            d.pointA = c.point;
            d.pointB = c.pointOther;
            d.normal = c.normal;
            return d
        },
        _createContactResult: function(a, b) {
            var c = this.contactResultPool.allocate();
            c.other = a;
            c.contacts = b;
            return c
        },
        _cleanOldCollisions: function() {
            for (var a in wd)
                if (wd.hasOwnProperty(a)) {
                    var b = mg[a]
                      , c = wd[a]
                      , d = c.entity
                      , e = d.collision
                      , f = d.rigidbody;
                    c = c.others;
                    for (var g = c.length; g--; ) {
                        var k = c[g];
                        if (!b || 0 > b.others.indexOf(k))
                            c.splice(g, 1),
                            d.trigger ? (e && e.fire("triggerleave", k),
                            k.rigidbody && k.rigidbody.fire("triggerleave", d)) : k.trigger || (f && f.fire("collisionend", k),
                            e && e.fire("collisionend", k))
                    }
                    0 === c.length && delete wd[a]
                }
        },
        _hasContactEvent: function(a) {
            var b = a.collision;
            return b && (b.hasEvent("collisionstart") || b.hasEvent("collisionend") || b.hasEvent("contact")) ? !0 : (a = a.rigidbody) && (a.hasEvent("collisionstart") || a.hasEvent("collisionend") || a.hasEvent("contact"))
        },
        _checkForCollisions: function(a, b) {
            a = Ammo.wrapPointer(a, Ammo.btDynamicsWorld).getDispatcher();
            b = a.getNumManifolds();
            mg = {};
            for (var c = 0; c < b; c++) {
                var d = a.getManifoldByIndexInternal(c)
                  , e = d.getBody0()
                  , f = d.getBody1()
                  , g = Ammo.castObject(e, Ammo.btRigidBody)
                  , k = Ammo.castObject(f, Ammo.btRigidBody);
                f = g.entity;
                e = k.entity;
                if (f && e) {
                    var h = g.getCollisionFlags()
                      , l = k.getCollisionFlags()
                      , n = d.getNumContacts()
                      , p = []
                      , q = [];
                    if (0 < n)
                        if (h & 4 || l & 4) {
                            k = f.collision && (f.collision.hasEvent("triggerenter") || f.collision.hasEvent("triggerleave"));
                            g = e.collision && (e.collision.hasEvent("triggerenter") || e.collision.hasEvent("triggerleave"));
                            d = f.rigidbody && (f.rigidbody.hasEvent("triggerenter") || f.rigidbody.hasEvent("triggerleave"));
                            q = e.rigidbody && (e.rigidbody.hasEvent("triggerenter") || e.rigidbody.hasEvent("triggerleave"));
                            if (k) {
                                var r = this._storeCollision(f, e);
                                !r || l & 4 || f.collision.fire("triggerenter", e)
                            }
                            g && (r = this._storeCollision(e, f),
                            !r || h & 4 || e.collision.fire("triggerenter", f));
                            d && (r || (r = this._storeCollision(e, f)),
                            r && f.rigidbody.fire("triggerenter", e));
                            q && (r || (r = this._storeCollision(f, e)),
                            r && e.rigidbody.fire("triggerenter", f))
                        } else if (k = this._hasContactEvent(f),
                        g = this._hasContactEvent(e),
                        (h = this.hasEvent("contact")) || k || g) {
                            for (l = 0; l < n; l++) {
                                var t = d.getContactPoint(l)
                                  , u = this._createContactPointFromAmmo(t);
                                if (k || g)
                                    t = this._createReverseContactPointFromAmmo(t),
                                    p.push(u),
                                    q.push(t);
                                h && (u = this._createSingleContactResult(f, e, u),
                                this.fire("contact", u))
                            }
                            k && (d = this._createContactResult(e, p),
                            r = this._storeCollision(f, e),
                            f.collision && (f.collision.fire("contact", d),
                            r && f.collision.fire("collisionstart", d)),
                            f.rigidbody && (f.rigidbody.fire("contact", d),
                            r && f.rigidbody.fire("collisionstart", d)));
                            g && (d = this._createContactResult(f, q),
                            r = this._storeCollision(e, f),
                            e.collision && (e.collision.fire("contact", d),
                            r && e.collision.fire("collisionstart", d)),
                            e.rigidbody && (e.rigidbody.fire("contact", d),
                            r && e.rigidbody.fire("collisionstart", d)))
                        }
                }
            }
            this._cleanOldCollisions();
            this.contactPointPool.freeAll();
            this.contactResultPool.freeAll();
            this.singleContactResultPool.freeAll()
        },
        onUpdate: function(a) {
            var b;
            var c = this.dynamicsWorld.getGravity();
            if (c.x() !== this.gravity.x || c.y() !== this.gravity.y || c.z() !== this.gravity.z)
                c.setValue(this.gravity.x, this.gravity.y, this.gravity.z),
                this.dynamicsWorld.setGravity(c);
            var d = this._triggers;
            c = 0;
            for (b = d.length; c < b; c++)
                d[c].updateTransform();
            d = this._compounds;
            c = 0;
            for (b = d.length; c < b; c++)
                d[c]._updateCompound();
            d = this._kinematic;
            c = 0;
            for (b = d.length; c < b; c++)
                d[c]._updateKinematic();
            this.dynamicsWorld.stepSimulation(a, this.maxSubSteps, this.fixedTimeStep);
            d = this._dynamic;
            c = 0;
            for (b = d.length; c < b; c++)
                d[c]._updateDynamic();
            this.dynamicsWorld.setInternalTickCallback || this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), a)
        },
        destroy: function() {
            "undefined" !== typeof Ammo && (Ammo.destroy(this.dynamicsWorld),
            Ammo.destroy(this.solver),
            Ammo.destroy(this.overlappingPairCache),
            Ammo.destroy(this.dispatcher),
            Ammo.destroy(this.collisionConfiguration),
            this.collisionConfiguration = this.dispatcher = this.overlappingPairCache = this.solver = this.dynamicsWorld = null)
        }
    });
    var Vd = "none";
    Hb.prototype = Object.create(O.prototype);
    Hb.prototype.constructor = Hb;
    var Xm = new K;
    Object.assign(Hb.prototype, {
        syncDrawOrder: function() {
            this.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this)
        },
        _recurseDrawOrderSync: function(a, b) {
            if (!(a instanceof fa))
                return b;
            if (a.element) {
                var c = a.element.drawOrder;
                a.element.drawOrder = b++;
                0 <= a.element._batchGroupId && c != a.element.drawOrder && this.system.app.batcher.markGroupDirty(a.element._batchGroupId)
            }
            a.particlesystem && (a.particlesystem.drawOrder = b++);
            a = a.children;
            for (c = 0; c < a.length; c++)
                b = this._recurseDrawOrderSync(a[c], b);
            return b
        },
        _processDrawOrderSync: function() {
            this._recurseDrawOrderSync(this.entity, 1);
            this.fire("syncdraworder")
        },
        _calcProjectionMatrix: function() {
            var a = this._resolution.x / this.scale
              , b = this._resolution.y / this.scale;
            this._screenMatrix.setOrtho(0, a, -b, 0, 1, -1);
            this._screenSpace || (Xm.setScale(.5 * a, .5 * b, 1),
            this._screenMatrix.mul2(Xm, this._screenMatrix))
        },
        _updateScale: function() {
            this.scale = this._calcScale(this._resolution, this.referenceResolution)
        },
        _calcScale: function(a, b) {
            return Math.pow(2, Math.log2(a.x / b.x) * (1 - this._scaleBlend) + Math.log2(a.y / b.y) * this._scaleBlend)
        },
        _onResize: function(a, b) {
            this._screenSpace && (this._resolution.set(a, b),
            this.resolution = this._resolution)
        },
        onRemove: function() {
            this.system.app.graphicsDevice.off("resizecanvas", this._onResize, this);
            this.fire("remove");
            this.off()
        }
    });
    Object.defineProperty(Hb.prototype, "resolution", {
        set: function(a) {
            this._screenSpace ? this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height) : this._resolution.set(a.x, a.y);
            this._updateScale();
            this._calcProjectionMatrix();
            this.entity._dirtyLocal || this.entity._dirtifyLocal();
            this.fire("set:resolution", this._resolution)
        },
        get: function() {
            return this._resolution
        }
    });
    Object.defineProperty(Hb.prototype, "referenceResolution", {
        set: function(a) {
            this._referenceResolution.set(a.x, a.y);
            this._updateScale();
            this._calcProjectionMatrix();
            this.entity._dirtyLocal || this.entity._dirtifyLocal();
            this.fire("set:referenceresolution", this._resolution)
        },
        get: function() {
            return this._scaleMode === Vd ? this._resolution : this._referenceResolution
        }
    });
    Object.defineProperty(Hb.prototype, "screenSpace", {
        set: function(a) {
            (this._screenSpace = a) && this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
            this.resolution = this._resolution;
            this.entity._dirtyLocal || this.entity._dirtifyLocal();
            this.fire("set:screenspace", this._screenSpace)
        },
        get: function() {
            return this._screenSpace
        }
    });
    Object.defineProperty(Hb.prototype, "scaleMode", {
        set: function(a) {
            a !== Vd && "blend" !== a && (a = Vd);
            this._screenSpace || a === Vd || (a = Vd);
            this._scaleMode = a;
            this.resolution = this._resolution;
            this.fire("set:scalemode", this._scaleMode)
        },
        get: function() {
            return this._scaleMode
        }
    });
    Object.defineProperty(Hb.prototype, "scaleBlend", {
        set: function(a) {
            this._scaleBlend = a;
            this._updateScale();
            this._calcProjectionMatrix();
            this.entity._dirtyLocal || this.entity._dirtifyLocal();
            this.fire("set:scaleblend", this._scaleBlend)
        },
        get: function() {
            return this._scaleBlend
        }
    });
    Object.defineProperty(Hb.prototype, "priority", {
        get: function() {
            return this._priority
        },
        set: function(a) {
            255 < a && (a = 255);
            this._priority = a
        }
    });
    var yl = ["enabled"];
    Ie.prototype = Object.create(H.prototype);
    Ie.prototype.constructor = Ie;
    O._buildAccessors(Hb.prototype, yl);
    Object.assign(Ie.prototype, {
        initializeComponentData: function(a, b, c) {
            void 0 !== b.priority && (a.priority = b.priority);
            void 0 !== b.screenSpace && (a.screenSpace = b.screenSpace);
            a.cull = a.screenSpace;
            void 0 !== b.scaleMode && (a.scaleMode = b.scaleMode);
            void 0 !== b.scaleBlend && (a.scaleBlend = b.scaleBlend);
            void 0 !== b.resolution && (b.resolution instanceof P ? a._resolution.copy(b.resolution) : a._resolution.set(b.resolution[0], b.resolution[1]),
            a.resolution = a._resolution);
            void 0 !== b.referenceResolution && (b.referenceResolution instanceof P ? a._referenceResolution.copy(b.referenceResolution) : a._referenceResolution.set(b.referenceResolution[0], b.referenceResolution[1]),
            a.referenceResolution = a._referenceResolution);
            a.syncDrawOrder();
            H.prototype.initializeComponentData.call(this, a, b, c)
        },
        destroy: function() {
            this.off();
            this.app.graphicsDevice.off("resizecanvas", this._onResize, this)
        },
        _onUpdate: function(a) {
            var b = this.store, c;
            for (c in b)
                b[c].entity.screen.update && b[c].entity.screen.update(a)
        },
        _onResize: function(a, b) {
            this.windowResolution.x = a;
            this.windowResolution.y = b
        },
        cloneComponent: function(a, b) {
            a = a.screen;
            return this.addComponent(b, {
                enabled: a.enabled,
                screenSpace: a.screenSpace,
                scaleMode: a.scaleMode,
                resolution: a.resolution.clone(),
                referenceResolution: a.referenceResolution.clone()
            })
        },
        onRemoveComponent: function(a, b) {
            b.onRemove()
        },
        processDrawOrderSyncQueue: function() {
            for (var a = this._drawOrderSyncQueue.list(), b = 0; b < a.length; b++) {
                var c = a[b];
                c.callback.call(c.scope)
            }
            this._drawOrderSyncQueue.clear()
        },
        queueDrawOrderSync: function(a, b, c) {
            if (!this._drawOrderSyncQueue.list().length)
                this.app.once("prerender", this.processDrawOrderSyncQueue, this);
            this._drawOrderSyncQueue.has(a) || this._drawOrderSyncQueue.push(a, {
                callback: b,
                scope: c
            })
        }
    });
    var Pp = ["x", "y", "z", "w"]
      , Qp = [void 0, void 0, P, z, X]
      , Oh = function(a, b, c, d) {
        var e;
        switch (b.type) {
        case "boolean":
            return !!c;
        case "number":
            if ("number" === typeof c)
                break;
            else {
                if ("string" === typeof c)
                    return c = parseInt(c, 10),
                    isNaN(c) ? null : c;
                if ("boolean" === typeof c)
                    return 0 + c
            }
            return null;
        case "json":
            var f = {};
            if (Array.isArray(b.schema))
                for (c && "object" === typeof c || (c = {}),
                e = 0; e < b.schema.length; e++) {
                    var g = b.schema[e];
                    if (g.name)
                        if (g.array) {
                            if (f[g.name] = [],
                            Array.isArray(c[g.name]))
                                for (d = 0; d < c[g.name].length; d++)
                                    f[g.name].push(Oh(a, g, c[g.name][d]))
                        } else
                            f[g.name] = Oh(a, g, c[g.name])
                }
            return f;
        case "asset":
            if (c instanceof aa)
                break;
            else {
                if ("number" === typeof c)
                    return a.assets.get(c) || null;
                if ("string" === typeof c)
                    return a.assets.get(parseInt(c, 10)) || null
            }
            return null;
        case "entity":
            if (c instanceof Z)
                break;
            else if ("string" === typeof c)
                return a.getEntityFromIndex(c);
            return null;
        case "rgb":
        case "rgba":
            if (c instanceof L)
                return d instanceof L ? (d.copy(c),
                d) : c.clone();
            if (c instanceof Array && 3 <= c.length && 4 >= c.length) {
                for (e = 0; e < c.length; e++)
                    if ("number" !== typeof c[e])
                        return null;
                d || (d = new L);
                d.r = c[0];
                d.g = c[1];
                d.b = c[2];
                d.a = 3 === c.length ? 1 : c[3];
                return d
            }
            return "string" === typeof c && /#([0-9abcdef]{2}){3,4}/i.test(c) ? (d || (d = new L),
            d.fromString(c),
            d) : null;
        case "vec2":
        case "vec3":
        case "vec4":
            a = parseInt(b.type.slice(3), 10);
            b = Qp[a];
            if (c instanceof b)
                return d instanceof b ? (d.copy(c),
                d) : c.clone();
            if (c instanceof Array && c.length === a) {
                for (e = 0; e < c.length; e++)
                    if ("number" !== typeof c[e])
                        return null;
                d || (d = new b);
                for (e = 0; e < a; e++)
                    d[Pp[e]] = c[e];
                return d
            }
            return null;
        case "curve":
            if (c)
                return c instanceof gb || c instanceof Cb ? e = c.clone() : (e = new (c.keys[0]instanceof Array ? Cb : gb)(c.keys),
                e.type = c.type),
                e
        }
        return c
    };
    Wd.prototype.add = function(a, b) {
        this.index[a] || Ib.reservedAttributes[a] || (this.index[a] = b,
        Object.defineProperty(this.scriptType.prototype, a, {
            get: function() {
                return this.__attributes[a]
            },
            set: function(c) {
                var d = this.__attributes[a];
                if (b.array) {
                    if (this.__attributes[a] = [],
                    c) {
                        var e;
                        var f = 0;
                        for (e = c.length; f < e; f++)
                            this.__attributes[a].push(Oh(this.app, b, c[f], d ? d[f] : null))
                    }
                } else
                    this.__attributes[a] = Oh(this.app, b, c, d);
                this.fire("attr", a, this.__attributes[a], d);
                this.fire("attr:" + a, this.__attributes[a], d)
            }
        }))
    }
    ;
    Wd.prototype.remove = function(a) {
        if (!this.index[a])
            return !1;
        delete this.index[a];
        delete this.scriptType.prototype[a];
        return !0
    }
    ;
    Wd.prototype.has = function(a) {
        return !!this.index[a]
    }
    ;
    Wd.prototype.get = function(a) {
        return this.index[a] || null
    }
    ;
    var Rp = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^\(\s\/]*)\s*/;
    db.prototype = Object.create(M.prototype);
    db.prototype.constructor = db;
    db.__name = null;
    db.__getScriptName = function(a) {
        if ("function" === typeof a)
            return "name"in Function.prototype ? a.name : a === Function || a === Function.prototype.constructor ? "Function" : (a = ("" + a).match(Rp)) ? a[1] : void 0
    }
    ;
    Object.defineProperty(db, "scriptName", {
        get: function() {
            return this.__name
        }
    });
    Object.defineProperty(db, "attributes", {
        get: function() {
            this.hasOwnProperty("__attributes") || (this.__attributes = new Wd(this));
            return this.__attributes
        }
    });
    db.prototype.__initializeAttributes = function(a) {
        if (a || this.__attributesRaw) {
            for (var b in this.__scriptType.attributes.index)
                this.__attributesRaw && this.__attributesRaw.hasOwnProperty(b) ? this[b] = this.__attributesRaw[b] : this.__attributes.hasOwnProperty(b) || (this.__scriptType.attributes.index[b].hasOwnProperty("default") ? this[b] = this.__scriptType.attributes.index[b].default : this[b] = null);
            this.__attributesRaw = null
        }
    }
    ;
    db.extend = function(a) {
        for (var b in a)
            a.hasOwnProperty(b) && (this.prototype[b] = a[b])
    }
    ;
    Object.defineProperty(db.prototype, "enabled", {
        get: function() {
            return this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled
        },
        set: function(a) {
            this._enabled = !!a;
            this.enabled !== this._enabledOld && (this._enabledOld = this.enabled,
            this.fire(this.enabled ? "enable" : "disable"),
            this.fire("state", this.enabled),
            !this._initialized && this.enabled && (this._initialized = !0,
            this.__initializeAttributes(!0),
            this.initialize && this.entity.script._scriptMethod(this, Xa.scriptMethods.initialize)),
            this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled && (this._postInitialized = !0,
            this.postInitialize && this.entity.script._scriptMethod(this, Xa.scriptMethods.postInitialize)))
        }
    });
    Ib.reservedScripts = "system entity create destroy swap move scripts _scripts _scriptsIndex _scriptsData enabled _oldState onEnable onDisable onPostStateChange _onSetEnabled _checkState _onBeforeRemove _onInitializeAttributes _onInitialize _onPostInitialize _onUpdate _onPostUpdate _callbacks has get on off fire once hasEvent".split(" ");
    var Ym = {}, xd;
    for (xd = 0; xd < Ib.reservedScripts.length; xd++)
        Ym[Ib.reservedScripts[xd]] = 1;
    Ib.reservedScripts = Ym;
    Ib.reservedAttributes = "app entity enabled _enabled _enabledOld _destroyed __attributes __attributesRaw __scriptType __executionOrder _callbacks has get on off fire once hasEvent".split(" ");
    var Zm = {};
    for (xd = 0; xd < Ib.reservedAttributes.length; xd++)
        Zm[Ib.reservedAttributes[xd]] = 1;
    Ib.reservedAttributes = Zm;
    ic.prototype._binarySearch = function(a) {
        var b = 0
          , c = this.items.length - 1;
        a = a[this._sortBy];
        for (var d, e; b <= c; )
            d = Math.floor((b + c) / 2),
            e = this.items[d][this._sortBy],
            e <= a ? b = d + 1 : e > a && (c = d - 1);
        return b
    }
    ;
    ic.prototype._doSort = function(a, b) {
        var c = this._sortBy;
        return a[c] - b[c]
    }
    ;
    ic.prototype.insert = function(a) {
        var b = this._binarySearch(a);
        this.items.splice(b, 0, a);
        this.length++;
        this.loopIndex >= b && this.loopIndex++
    }
    ;
    ic.prototype.append = function(a) {
        this.items.push(a);
        this.length++
    }
    ;
    ic.prototype.remove = function(a) {
        a = this.items.indexOf(a);
        0 > a || (this.items.splice(a, 1),
        this.length--,
        this.loopIndex >= a && this.loopIndex--)
    }
    ;
    ic.prototype.sort = function() {
        var a = 0 <= this.loopIndex ? this.items[this.loopIndex] : null;
        this.items.sort(this._sortHandler);
        null !== a && (this.loopIndex = this.items.indexOf(a))
    }
    ;
    Xa.prototype = Object.create(O.prototype);
    Xa.prototype.constructor = Xa;
    Xa.scriptMethods = {
        initialize: "initialize",
        postInitialize: "postInitialize",
        update: "update",
        postUpdate: "postUpdate",
        swap: "swap"
    };
    Object.assign(Xa.prototype, {
        onEnable: function() {
            this._beingEnabled = !0;
            this._checkState();
            if (!this.entity._beingEnabled)
                this.onPostStateChange();
            this._beingEnabled = !1
        },
        onDisable: function() {
            this._checkState()
        },
        onPostStateChange: function() {
            for (var a, b = this._beginLooping(), c = 0, d = this.scripts.length; c < d; c++)
                a = this.scripts[c],
                a._initialized && !a._postInitialized && a.enabled && (a._postInitialized = !0,
                a.postInitialize && this._scriptMethod(a, Xa.scriptMethods.postInitialize));
            this._endLooping(b)
        },
        _beginLooping: function() {
            var a = this._isLoopingThroughScripts;
            this._isLoopingThroughScripts = !0;
            return a
        },
        _endLooping: function(a) {
            (this._isLoopingThroughScripts = a) || this._removeDestroyedScripts()
        },
        _onSetEnabled: function(a, b, c) {
            this._beingEnabled = !0;
            this._checkState();
            this._beingEnabled = !1
        },
        _checkState: function() {
            var a = this.enabled && this.entity.enabled;
            if (a !== this._oldState) {
                this._oldState = a;
                this.fire(a ? "enable" : "disable");
                this.fire("state", a);
                a ? this.system._addComponentToEnabled(this) : this.system._removeComponentFromEnabled(this);
                a = this._beginLooping();
                for (var b, c = 0, d = this.scripts.length; c < d; c++)
                    b = this.scripts[c],
                    b.enabled = b._enabled;
                this._endLooping(a)
            }
        },
        _onBeforeRemove: function() {
            this.fire("remove");
            for (var a = this._beginLooping(), b = 0; b < this.scripts.length; b++) {
                var c = this.scripts[b];
                c && this.destroy(c.__scriptType.__name)
            }
            this._endLooping(a)
        },
        _removeDestroyedScripts: function() {
            var a = this._destroyedScripts.length;
            if (a) {
                var b;
                for (b = 0; b < a; b++)
                    this._removeScriptInstance(this._destroyedScripts[b]);
                this._destroyedScripts.length = 0;
                this._resetExecutionOrder(0, this._scripts.length)
            }
        },
        _onInitializeAttributes: function() {
            for (var a = 0, b = this.scripts.length; a < b; a++)
                this.scripts[a].__initializeAttributes()
        },
        _scriptMethod: function(a, b, c) {
            a[b](c)
        },
        _onInitialize: function() {
            for (var a, b = this._scripts, c = this._beginLooping(), d = 0, e = b.length; d < e; d++)
                a = b[d],
                !a._initialized && a.enabled && (a._initialized = !0,
                a.initialize && this._scriptMethod(a, Xa.scriptMethods.initialize));
            this._endLooping(c)
        },
        _onPostInitialize: function() {
            this.onPostStateChange()
        },
        _onUpdate: function(a) {
            var b = this._updateList;
            if (b.length) {
                var c = this._beginLooping();
                for (b.loopIndex = 0; b.loopIndex < b.length; b.loopIndex++) {
                    var d = b.items[b.loopIndex];
                    d.enabled && this._scriptMethod(d, Xa.scriptMethods.update, a)
                }
                this._endLooping(c)
            }
        },
        _onPostUpdate: function(a) {
            var b = this._postUpdateList;
            if (b.length) {
                var c = this._beginLooping();
                for (b.loopIndex = 0; b.loopIndex < b.length; b.loopIndex++) {
                    var d = b.items[b.loopIndex];
                    d.enabled && this._scriptMethod(d, Xa.scriptMethods.postUpdate, a)
                }
                this._endLooping(c)
            }
        },
        _insertScriptInstance: function(a, b, c) {
            -1 === b ? (this._scripts.push(a),
            a.__executionOrder = c,
            a.update && this._updateList.append(a),
            a.postUpdate && this._postUpdateList.append(a)) : (this._scripts.splice(b, 0, a),
            a.__executionOrder = b,
            this._resetExecutionOrder(b + 1, c + 1),
            a.update && this._updateList.insert(a),
            a.postUpdate && this._postUpdateList.insert(a))
        },
        _removeScriptInstance: function(a) {
            var b = this._scripts.indexOf(a);
            if (-1 === b)
                return b;
            this._scripts.splice(b, 1);
            a.update && this._updateList.remove(a);
            a.postUpdate && this._postUpdateList.remove(a);
            return b
        },
        _resetExecutionOrder: function(a, b) {
            for (; a < b; a++)
                this._scripts[a].__executionOrder = a
        },
        _resolveEntityScriptAttribute: function(a, b, c, d, e, f) {
            if (a.array) {
                if (a = c.length) {
                    c = c.slice();
                    for (var g = 0; g < a; g++) {
                        var k = c[g]instanceof fa ? c[g].getGuid() : c[g];
                        f[k] && (c[g] = d ? f[k].getGuid() : f[k])
                    }
                    e[b] = c
                }
            } else {
                if (c instanceof fa)
                    c = c.getGuid();
                else if ("string" !== typeof c)
                    return;
                f[c] && (e[b] = f[c])
            }
        },
        has: function(a) {
            if ("string" === typeof a)
                return !!this._scriptsIndex[a];
            if (!a)
                return !1;
            var b = this._scriptsIndex[a.__name];
            return (b && b.instance)instanceof a
        },
        get: function(a) {
            if ("string" === typeof a)
                return (a = this._scriptsIndex[a]) ? a.instance : null;
            if (!a)
                return null;
            var b = this._scriptsIndex[a.__name];
            b = b && b.instance;
            return b instanceof a ? b : null
        },
        create: function(a, b) {
            var c = this;
            b = b || {};
            var d = a
              , e = a;
            "string" === typeof d ? d = this.system.app.scripts.get(d) : d && (e = d.__name);
            if (d) {
                if (!this._scriptsIndex[e] || !this._scriptsIndex[e].instance) {
                    a = new d({
                        app: this.system.app,
                        entity: this.entity,
                        enabled: b.hasOwnProperty("enabled") ? b.enabled : !0,
                        attributes: b.attributes
                    });
                    d = this._scripts.length;
                    var f = -1;
                    "number" === typeof b.ind && -1 !== b.ind && d > b.ind && (f = b.ind);
                    this._insertScriptInstance(a, f, d);
                    this._scriptsIndex[e] = {
                        instance: a,
                        onSwap: function() {
                            c.swap(e)
                        }
                    };
                    this[e] = a;
                    b.preloading || a.__initializeAttributes();
                    this.fire("create", e, a);
                    this.fire("create:" + e, a);
                    this.system.app.scripts.on("swap:" + e, this._scriptsIndex[e].onSwap);
                    b.preloading || (a.enabled && !a._initialized && (a._initialized = !0,
                    a.initialize && this._scriptMethod(a, Xa.scriptMethods.initialize)),
                    a.enabled && !a._postInitialized && (a._postInitialized = !0,
                    a.postInitialize && this._scriptMethod(a, Xa.scriptMethods.postInitialize)));
                    return a
                }
                console.warn("script '" + e + "' is already added to entity '" + this.entity.name + "'")
            } else
                this._scriptsIndex[e] = {
                    awaiting: !0,
                    ind: this._scripts.length
                },
                console.warn("script '" + e + "' is not found, awaiting it to be added to registry");
            return null
        },
        destroy: function(a) {
            var b = a;
            "string" === typeof a ? this.system.app.scripts.get(a) : a && (b = a.__name);
            a = this._scriptsIndex[b];
            delete this._scriptsIndex[b];
            if (!a)
                return !1;
            var c = a.instance;
            if (c && !c._destroyed)
                if (c.enabled = !1,
                c._destroyed = !0,
                this._isLoopingThroughScripts)
                    this._destroyedScripts.push(c);
                else {
                    var d = this._removeScriptInstance(c);
                    0 <= d && this._resetExecutionOrder(d, this._scripts.length)
                }
            this.system.app.scripts.off("swap:" + b, a.onSwap);
            delete this[b];
            this.fire("destroy", b, c || null);
            this.fire("destroy:" + b, c || null);
            c && c.fire("destroy");
            return !0
        },
        swap: function(a) {
            var b = a;
            "string" === typeof a ? a = this.system.app.scripts.get(a) : a && (b = a.__name);
            var c = this._scriptsIndex[b];
            if (!c || !c.instance)
                return !1;
            c = c.instance;
            var d = this._scripts.indexOf(c);
            a = new a({
                app: this.system.app,
                entity: this.entity,
                enabled: c.enabled,
                attributes: c.__attributes
            });
            if (!a.swap)
                return !1;
            a.__initializeAttributes();
            this._scripts[d] = a;
            this._scriptsIndex[b].instance = a;
            this[b] = a;
            a.__executionOrder = d;
            c.update && this._updateList.remove(c);
            c.postUpdate && this._postUpdateList.remove(c);
            a.update && this._updateList.insert(a);
            a.postUpdate && this._postUpdateList.insert(a);
            this._scriptMethod(a, Xa.scriptMethods.swap, c);
            this.fire("swap", b, a);
            this.fire("swap:" + b, a);
            return !0
        },
        resolveDuplicatedEntityReferenceProperties: function(a, b) {
            var c = this.entity.script, d, e, f;
            for (f in a._scriptsIndex) {
                var g = this.system.app.scripts.get(f);
                if (g && (d = a._scriptsIndex[f]) && d.instance) {
                    var k = c[f].__attributesRaw
                      , h = c[f].__attributes;
                    if (k || h) {
                        var l = !!k, n = d.instance.__attributes, p;
                        for (p in n)
                            if (n[p]) {
                                var q = g.attributes.get(p);
                                if (q)
                                    if ("entity" === q.type)
                                        this._resolveEntityScriptAttribute(q, p, n[p], l, k || h, b);
                                    else if ("json" === q.type && Array.isArray(q.schema)) {
                                        var r = n[p]
                                          , t = k ? k[p] : h[p];
                                        for (d = 0; d < q.schema.length; d++) {
                                            var u = q.schema[d];
                                            if ("entity" === u.type)
                                                if (q.array)
                                                    for (e = 0; e < r.length; e++)
                                                        this._resolveEntityScriptAttribute(u, u.name, r[e][u.name], l, t[e], b);
                                                else
                                                    this._resolveEntityScriptAttribute(u, u.name, r[u.name], l, t, b)
                                        }
                                    }
                            }
                    }
                }
            }
        },
        move: function(a, b) {
            var c = this._scripts.length;
            if (b >= c || 0 > b)
                return !1;
            var d = a
              , e = a;
            "string" !== typeof e ? e = a.__name : d = null;
            a = this._scriptsIndex[e];
            if (!a || !a.instance)
                return !1;
            a = a.instance;
            if (d && !(a instanceof d))
                return !1;
            d = this._scripts.indexOf(a);
            if (-1 === d || d === b)
                return !1;
            this._scripts.splice(b, 0, this._scripts.splice(d, 1)[0]);
            this._resetExecutionOrder(0, c);
            this._updateList.sort();
            this._postUpdateList.sort();
            this.fire("move", e, a, b, d);
            this.fire("move:" + e, a, b, d);
            return !0
        }
    });
    Object.defineProperty(Xa.prototype, "enabled", {
        get: function() {
            return this._enabled
        },
        set: function(a) {
            var b = this._enabled;
            this._enabled = a;
            this.fire("set", "enabled", b, a)
        }
    });
    Object.defineProperty(Xa.prototype, "scripts", {
        get: function() {
            return this._scripts
        },
        set: function(a) {
            this._scriptsData = a;
            for (var b in a)
                if (a.hasOwnProperty(b)) {
                    var c = this._scriptsIndex[b];
                    if (c) {
                        if ("boolean" === typeof a[b].enabled && (c.enabled = !!a[b].enabled),
                        "object" === typeof a[b].attributes)
                            for (var d in a[b].attributes)
                                if (!Ib.reservedAttributes[d]) {
                                    if (!c.__attributes.hasOwnProperty(d)) {
                                        var e = this.system.app.scripts.get(b);
                                        e && e.attributes.add(d, {})
                                    }
                                    c[d] = a[b].attributes[d]
                                }
                    } else
                        console.log(this.order)
                }
        }
    });
    var Ph = 0;
    Je.prototype = Object.create(H.prototype);
    Je.prototype.constructor = Je;
    Object.assign(Je.prototype, {
        initializeComponentData: function(a, b) {
            a._executionOrder = Ph++;
            this._components.append(a);
            Ph > Number.MAX_SAFE_INTEGER && this._resetExecutionOrder();
            a.enabled = b.hasOwnProperty("enabled") ? !!b.enabled : !0;
            a.enabled && a.entity.enabled && this._enabledComponents.append(a);
            if (b.hasOwnProperty("order") && b.hasOwnProperty("scripts")) {
                a._scriptsData = b.scripts;
                for (var c = 0; c < b.order.length; c++)
                    a.create(b.order[c], {
                        enabled: b.scripts[b.order[c]].enabled,
                        attributes: b.scripts[b.order[c]].attributes,
                        preloading: this.preloading
                    })
            }
        },
        cloneComponent: function(a, b) {
            var c, d, e = [], f = {};
            for (c = 0; c < a.script._scripts.length; c++) {
                var g = a.script._scripts[c]
                  , k = g.__scriptType.__name;
                e.push(k);
                var h = {};
                for (d in g.__attributes)
                    h[d] = g.__attributes[d];
                f[k] = {
                    enabled: g._enabled,
                    attributes: h
                }
            }
            for (d in a.script._scriptsIndex)
                d.awaiting && e.splice(d.ind, 0, d);
            return this.addComponent(b, {
                enabled: a.script.enabled,
                order: e,
                scripts: f
            })
        },
        _resetExecutionOrder: function() {
            for (var a = Ph = 0, b = this._components.length; a < b; a++)
                this._components.items[a]._executionOrder = Ph++
        },
        _callComponentMethod: function(a, b, c) {
            for (a.loopIndex = 0; a.loopIndex < a.length; a.loopIndex++)
                a.items[a.loopIndex][b](c)
        },
        _onInitialize: function() {
            this.preloading = !1;
            this._callComponentMethod(this._components, "_onInitializeAttributes");
            this._callComponentMethod(this._enabledComponents, "_onInitialize")
        },
        _onPostInitialize: function() {
            this._callComponentMethod(this._enabledComponents, "_onPostInitialize")
        },
        _onUpdate: function(a) {
            this._callComponentMethod(this._enabledComponents, "_onUpdate", a)
        },
        _onPostUpdate: function(a) {
            this._callComponentMethod(this._enabledComponents, "_onPostUpdate", a)
        },
        _addComponentToEnabled: function(a) {
            this._enabledComponents.insert(a)
        },
        _removeComponentFromEnabled: function(a) {
            this._enabledComponents.remove(a)
        },
        _onBeforeRemove: function(a, b) {
            0 <= this._components.items.indexOf(b) && b._onBeforeRemove();
            this._removeComponentFromEnabled(b);
            this._components.remove(b)
        }
    });
    Xd.prototype = Object.create(O.prototype);
    Xd.prototype.constructor = Xd;
    Object.assign(Xd.prototype, {
        send: function(a, b) {
            var c = Array.prototype.slice.call(arguments, 2), d = this.entity.script.instances, e;
            if (d && d[a] && (e = d[a].instance[b]))
                return e.apply(d[a].instance, c)
        },
        onEnable: function() {
            this.data.areScriptsLoaded && !this.system.preloading && (this.data.initialized ? this.system._enableScriptComponent(this) : this.system._initializeScriptComponent(this),
            this.data.postInitialized || this.system._postInitializeScriptComponent(this))
        },
        onDisable: function() {
            this.system._disableScriptComponent(this)
        },
        onSetScripts: function(a, b, c) {
            this.system._inTools && !this.runInTools || this._updateScriptAttributes(b, c) || (this.enabled && this.system._disableScriptComponent(this),
            this.system._destroyScriptComponent(this),
            this.data.areScriptsLoaded = !1,
            a = c.map(function(d) {
                return d.url
            }),
            this._loadFromCache(a) || this._loadScripts(a))
        },
        _updateScriptAttributes: function(a, b) {
            var c = !0;
            if (a.length !== b.length)
                c = !1;
            else {
                var d, e = b.length;
                for (d = 0; d < e; d++)
                    if (a[d].url !== b[d].url) {
                        c = !1;
                        break
                    }
            }
            if (c)
                for (var f in this.instances)
                    this.instances.hasOwnProperty(f) && this.system._updateAccessors(this.entity, this.instances[f]);
            return c
        },
        _loadFromCache: function(a) {
            var b, c = [], d = this.system.app._scriptPrefix || "", e = /^http(s)?:\/\//i;
            var f = 0;
            for (b = a.length; f < b; f++) {
                var g = a[f];
                e.test(g) || (g = ca.join(d, g));
                g = this.system.app.loader.getFromCache(g, "script");
                if (!g)
                    return !1;
                c.push(g)
            }
            f = 0;
            for (b = c.length; f < b; f++)
                d = c[f],
                !0 !== d && d && this.entity.script && !this.entity.script.instances[d._pcScriptName] && (e = new d(this.entity),
                this.system._preRegisterInstance(this.entity, a[f], d._pcScriptName, e));
            this.data && (this.data.areScriptsLoaded = !0);
            this.system.preloading || (this.system.onInitialize(this.entity),
            this.system.onPostInitialize(this.entity));
            return !0
        },
        _loadScripts: function(a) {
            var b = a.length
              , c = this.system.app._scriptPrefix || "";
            a.forEach(function(d) {
                var e = null
                  , f = null;
                d.toLowerCase().startsWith("http://") || d.toLowerCase().startsWith("https://") ? e = f = d : (f = d,
                e = ca.join(c, d));
                this.system.app.loader.load(e, "script", function(g, k) {
                    b--;
                    g ? console.error(g) : k && this.entity.script && !this.entity.script.instances[k._pcScriptName] && (g = new k(this.entity),
                    this.system._preRegisterInstance(this.entity, f, k._pcScriptName, g));
                    0 === b && (this.data.areScriptsLoaded = !0,
                    this.system.preloading || (this.system.onInitialize(this.entity),
                    this.system.onPostInitialize(this.entity)))
                }
                .bind(this))
            }
            .bind(this))
        }
    });
    var $m = ["enabled", "scripts", "instances", "runInTools"]
      , Ne = function(a) {
        H.call(this, a);
        this.id = "script";
        this.ComponentType = Xd;
        this.DataType = zo;
        this.schema = $m;
        this.preloading = !1;
        this.instancesWithUpdate = [];
        this.instancesWithFixedUpdate = [];
        this.instancesWithPostUpdate = [];
        this.instancesWithToolsUpdate = [];
        this.on("beforeremove", this.onBeforeRemove, this);
        H.bind("initialize", this.onInitialize, this);
        H.bind("postInitialize", this.onPostInitialize, this);
        H.bind("update", this.onUpdate, this);
        H.bind("fixedUpdate", this.onFixedUpdate, this);
        H.bind("postUpdate", this.onPostUpdate, this);
        H.bind("toolsUpdate", this.onToolsUpdate, this)
    };
    Ne.prototype = Object.create(H.prototype);
    Ne.prototype.constructor = Ne;
    O._buildAccessors(Xd.prototype, $m);
    Object.assign(Ne.prototype, {
        initializeComponentData: function(a, b, c) {
            c = ["runInTools", "enabled", "scripts"];
            b.scripts && b.scripts.length && b.scripts.forEach(function(d) {
                if (d.attributes && Array.isArray(d.attributes)) {
                    for (var e = {}, f = 0; f < d.attributes.length; f++)
                        e[d.attributes[f].name] = d.attributes[f];
                    d.attributes = e
                }
            });
            H.prototype.initializeComponentData.call(this, a, b, c)
        },
        cloneComponent: function(a, b) {
            var c = this.store[a.getGuid()];
            a = {
                runInTools: c.data.runInTools,
                scripts: [],
                enabled: c.data.enabled
            };
            c = c.data.scripts;
            for (var d = 0, e = c.length; d < e; d++) {
                var f = c[d].attributes;
                f && delete c[d].attributes;
                a.scripts.push(Gc({}, c[d]));
                f && (a.scripts[d].attributes = this._cloneAttributes(f),
                c[d].attributes = f)
            }
            return this.addComponent(b, a)
        },
        onBeforeRemove: function(a, b) {
            b.enabled && this._disableScriptComponent(b);
            this._destroyScriptComponent(b)
        },
        onInitialize: function(a) {
            this._registerInstances(a);
            if (a.enabled) {
                a.script && a.script.enabled && this._initializeScriptComponent(a.script);
                a = a._children;
                var b, c = a.length;
                for (b = 0; b < c; b++)
                    if (a[b]instanceof fa)
                        this.onInitialize(a[b])
            }
        },
        onPostInitialize: function(a) {
            if (a.enabled) {
                a.script && a.script.enabled && this._postInitializeScriptComponent(a.script);
                a = a._children;
                var b, c = a.length;
                for (b = 0; b < c; b++)
                    if (a[b]instanceof fa)
                        this.onPostInitialize(a[b])
            }
        },
        _callInstancesMethod: function(a, b) {
            a = a.data.instances;
            for (var c in a)
                if (a.hasOwnProperty(c)) {
                    var d = a[c].instance;
                    if (d[b])
                        d[b]()
                }
        },
        _initializeScriptComponent: function(a) {
            this._callInstancesMethod(a, "initialize");
            a.data.initialized = !0;
            a.enabled && a.entity.enabled && this._enableScriptComponent(a)
        },
        _enableScriptComponent: function(a) {
            this._callInstancesMethod(a, "onEnable")
        },
        _disableScriptComponent: function(a) {
            this._callInstancesMethod(a, "onDisable")
        },
        _destroyScriptComponent: function(a) {
            var b = a.data.instances, c;
            for (c in b)
                if (b.hasOwnProperty(c)) {
                    var d = b[c].instance;
                    d.destroy && d.destroy();
                    if (d.update) {
                        var e = this.instancesWithUpdate.indexOf(d);
                        0 <= e && this.instancesWithUpdate.splice(e, 1)
                    }
                    d.fixedUpdate && (e = this.instancesWithFixedUpdate.indexOf(d),
                    0 <= e && this.instancesWithFixedUpdate.splice(e, 1));
                    d.postUpdate && (e = this.instancesWithPostUpdate.indexOf(d),
                    0 <= e && this.instancesWithPostUpdate.splice(e, 1));
                    d.toolsUpdate && (e = this.instancesWithToolsUpdate.indexOf(d),
                    0 <= e && this.instancesWithToolsUpdate.splice(e, 1));
                    a.instances[c].instance === a[c] && delete a[c];
                    delete a.instances[c]
                }
        },
        _postInitializeScriptComponent: function(a) {
            this._callInstancesMethod(a, "postInitialize");
            a.data.postInitialized = !0
        },
        _updateInstances: function(a, b, c) {
            for (var d, e = 0, f = b.length; e < f; e++)
                if ((d = b[e]) && d.entity && d.entity.enabled && d.entity.script.enabled)
                    d[a](c)
        },
        onUpdate: function(a) {
            this._updateInstances("update", this.instancesWithUpdate, a)
        },
        onFixedUpdate: function(a) {
            this._updateInstances("fixedUpdate", this.instancesWithFixedUpdate, a)
        },
        onPostUpdate: function(a) {
            this._updateInstances("postUpdate", this.instancesWithPostUpdate, a)
        },
        onToolsUpdate: function(a) {
            this._updateInstances("toolsUpdate", this.instancesWithToolsUpdate, a)
        },
        broadcast: function(a, b) {
            var c = Array.prototype.slice.call(arguments, 2), d, e, f = this.store;
            for (d in f)
                if (f.hasOwnProperty(d)) {
                    var g = f[d].data;
                    g.instances[a] && (e = g.instances[a].instance[b]) && e.apply(g.instances[a].instance, c)
                }
        },
        _preRegisterInstance: function(a, b, c, d) {
            if (a.script) {
                a.script.data._instances = a.script.data._instances || {};
                if (a.script.data._instances[c])
                    throw Error("Script name collision '" + c + "'. Scripts from '" + b + "' and '" + a.script.data._instances[c].url + "' {" + a.getGuid() + "}");
                a.script.data._instances[c] = {
                    url: b,
                    name: c,
                    instance: d
                }
            }
        },
        _registerInstances: function(a) {
            var b;
            if (a.script && a.script.data._instances) {
                a.script.instances = a.script.data._instances;
                for (b in a.script.instances) {
                    var c = a.script.instances[b];
                    var d = c.instance;
                    Of.attach(d);
                    d.update && this.instancesWithUpdate.push(d);
                    d.fixedUpdate && this.instancesWithFixedUpdate.push(d);
                    d.postUpdate && this.instancesWithPostUpdate.push(d);
                    d.toolsUpdate && this.instancesWithToolsUpdate.push(d);
                    a.script.scripts && this._createAccessors(a, c);
                    if (a.script[b])
                        throw Error("Script with name '" + b + "' is already attached to Script Component");
                    a.script[b] = d
                }
                delete a.script.data._instances
            }
            a = a._children;
            d = a.length;
            for (c = 0; c < d; c++)
                a[c]instanceof fa && this._registerInstances(a[c])
        },
        _cloneAttributes: function(a) {
            var b = {}, c;
            for (c in a)
                if (a.hasOwnProperty(c))
                    if ("entity" !== a[c].type)
                        b[c] = Gc({}, a[c]);
                    else {
                        var d = a[c].value;
                        delete a[c].value;
                        b[c] = Gc({}, a[c]);
                        b[c].value = d;
                        a[c].value = d
                    }
            return b
        },
        _createAccessors: function(a, b) {
            var c, d = a.script.scripts.length, e = b.url;
            for (c = 0; c < d; c++) {
                var f = a.script.scripts[c];
                if (f.url === e) {
                    c = f.attributes;
                    if (f.name && c) {
                        for (var g in c)
                            c.hasOwnProperty(g) && this._createAccessor(c[g], b);
                        a.script.data.attributes[f.name] = this._cloneAttributes(c)
                    }
                    break
                }
            }
        },
        _createAccessor: function(a, b) {
            var c = this;
            a = {
                name: a.name,
                value: a.value,
                type: a.type
            };
            c._convertAttributeValue(a);
            Object.defineProperty(b.instance, a.name, {
                get: function() {
                    return a.value
                },
                set: function(d) {
                    var e = a.value;
                    a.value = d;
                    c._convertAttributeValue(a);
                    b.instance.fire("set", a.name, e, a.value)
                },
                configurable: !0
            })
        },
        _updateAccessors: function(a, b) {
            var c, d = a.script.scripts.length, e, f = b.url;
            for (c = 0; c < d; c++) {
                var g = a.script;
                var k = g.scripts[c];
                if (k.url === f) {
                    a = k.name;
                    k = k.attributes;
                    if (a) {
                        if (k)
                            for (e in k)
                                k.hasOwnProperty(e) && this._createAccessor(k[e], b);
                        if (c = g.data.attributes[a])
                            for (e in c)
                                if (d = c[e],
                                !(e in k))
                                    delete b.instance[d.name];
                                else if (k[e].value !== d.value && b.instance.onAttributeChanged)
                                    b.instance.onAttributeChanged(d.name, d.value, k[e].value);
                        k ? g.data.attributes[a] = this._cloneAttributes(k) : delete g.data.attributes[a]
                    }
                    break
                }
            }
        },
        _convertAttributeValue: function(a) {
            if ("rgb" === a.type || "rgba" === a.type)
                Array.isArray(a.value) && (a.value = 3 === a.value.length ? new L(a.value[0],a.value[1],a.value[2]) : new L(a.value[0],a.value[1],a.value[2],a.value[3]));
            else if ("vec2" === a.type)
                Array.isArray(a.value) && (a.value = new P(a.value[0],a.value[1]));
            else if ("vec3" === a.type || "vector" === a.type)
                Array.isArray(a.value) && (a.value = new z(a.value[0],a.value[1],a.value[2]));
            else if ("vec4" === a.type)
                Array.isArray(a.value) && (a.value = new X(a.value[0],a.value[1],a.value[2],a.value[3]));
            else if ("entity" === a.type)
                null !== a.value && "string" === typeof a.value && (a.value = this.app.root.findByGuid(a.value));
            else if ("curve" === a.type || "colorcurve" === a.type)
                a.value = new (a.value.keys[0]instanceof Array ? Cb : gb)(a.value.keys),
                a.value.type = a.value.type
        }
    });
    var yd = new P
      , an = new z
      , ng = new z
      , Qh = new z
      , bn = new z
      , mk = new z
      , Sp = new Y
      , Tp = {
        x: "y",
        y: "x"
    };
    Nc.prototype = Object.create(M.prototype);
    Nc.prototype.constructor = Nc;
    Object.assign(Nc.prototype, {
        _toggleLifecycleListeners: function(a) {
            this._element[a]("mousedown", this._onMouseDownOrTouchStart, this);
            this._element[a]("touchstart", this._onMouseDownOrTouchStart, this)
        },
        _toggleDragListeners: function(a) {
            var b = "on" === a
              , c = b ? "addEventListener" : "removeEventListener";
            this._hasDragListeners && b || (this._handleMouseUpOrTouchEnd || (this._handleMouseUpOrTouchEnd = this._onMouseUpOrTouchEnd.bind(this)),
            this._app.mouse && (this._app.mouse[a]("mousemove", this._onMove, this),
            window[c]("mouseup", this._handleMouseUpOrTouchEnd, !1)),
            Ca.touch && (this._app.touch[a]("touchmove", this._onMove, this),
            window[c]("touchend", this._handleMouseUpOrTouchEnd, !1),
            window[c]("touchcancel", this._handleMouseUpOrTouchEnd, !1)),
            this._hasDragListeners = b)
        },
        _onMouseDownOrTouchStart: function(a) {
            this._element && !this._isDragging && this.enabled && (this._dragCamera = a.camera,
            this._calculateDragScale(),
            a = this._screenToLocal(a)) && (this._toggleDragListeners("on"),
            this._isDragging = !0,
            this._dragStartMousePosition.copy(a),
            this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition()),
            this.fire("drag:start"))
        },
        _onMouseUpOrTouchEnd: function() {
            this._isDragging && (this._isDragging = !1,
            this._toggleDragListeners("off"),
            this.fire("drag:end"))
        },
        _screenToLocal: function(a) {
            this._determineInputPosition(a);
            this._chooseRayOriginAndDirection();
            bn.copy(this._element.entity.getPosition());
            mk.copy(this._element.entity.forward).scale(-1);
            a = mk.dot(Qh);
            return 0 < Math.abs(a) ? (a = bn.sub(ng).dot(mk) / a,
            a = ng.add(Qh.scale(a)),
            Sp.copy(this._element.entity.getRotation()).invert().transformVector(a, a),
            a.mul(this._dragScale),
            a) : null
        },
        _determineInputPosition: function(a) {
            var b = this._app.graphicsDevice.maxPixelRatio;
            "undefined" !== typeof a.x && "undefined" !== typeof a.y ? (yd.x = a.x * b,
            yd.y = a.y * b) : a.changedTouches ? (yd.x = a.changedTouches[0].x * b,
            yd.y = a.changedTouches[0].y * b) : console.warn("Could not determine position from input event")
        },
        _chooseRayOriginAndDirection: function() {
            this._element.screen && this._element.screen.screen.screenSpace ? (ng.set(yd.x, -yd.y, 0),
            Qh.set(0, 0, -1)) : (an.copy(this._dragCamera.screenToWorld(yd.x, yd.y, 1)),
            ng.copy(this._dragCamera.entity.getPosition()),
            Qh.copy(an).sub(ng).normalize())
        },
        _calculateDragScale: function() {
            var a = this._element.entity.parent
              , b = this._element.screen && this._element.screen.screen
              , c = b && b.screenSpace;
            b = c ? b.scale : 1;
            var d = this._dragScale;
            for (d.set(b, b, b); a && (d.mul(a.getLocalScale()),
            a = a.parent,
            !c || !a.screen); )
                ;
            d.x = 1 / d.x;
            d.y = 1 / d.y;
            d.z = 1 / d.z
        },
        _onMove: function(a) {
            if (this._element && this._isDragging && this.enabled && this._element.enabled && this._element.entity.enabled && (a = this._screenToLocal(a),
            this._dragStartMousePosition && a)) {
                this._deltaMousePosition.copy(a).sub(this._dragStartMousePosition);
                this._deltaHandlePosition.copy(this._dragStartHandlePosition).add(this._deltaMousePosition);
                if (this._axis) {
                    a = this._element.entity.getLocalPosition();
                    var b = Tp[this._axis];
                    this._deltaHandlePosition[b] = a[b]
                }
                this._element.entity.setLocalPosition(this._deltaHandlePosition);
                this.fire("drag:move", this._deltaHandlePosition)
            }
        },
        destroy: function() {
            this._toggleLifecycleListeners("off");
            this._toggleDragListeners("off")
        }
    });
    Object.defineProperty(Nc.prototype, "enabled", {
        get: function() {
            return this._enabled
        },
        set: function(a) {
            this._enabled = a
        }
    });
    Object.defineProperty(Nc.prototype, "isDragging", {
        get: function() {
            return this._isDragging
        }
    });
    var nk = new P;
    md.prototype = Object.create(O.prototype);
    md.prototype.constructor = md;
    Object.assign(md.prototype, {
        _toggleLifecycleListeners: function(a, b) {
            this[a]("set_horizontal", this._onSetHorizontalScrollingEnabled, this);
            this[a]("set_vertical", this._onSetVerticalScrollingEnabled, this);
            b.app.systems.element[a]("add", this._onElementComponentAdd, this);
            b.app.systems.element[a]("beforeremove", this._onElementComponentRemove, this)
        },
        _toggleElementListeners: function(a) {
            !this.entity.element || "on" === a && this._hasElementListeners || (this.entity.element[a]("resize", this._onSetContentOrViewportSize, this),
            this._hasElementListeners = "on" === a)
        },
        _onElementComponentAdd: function(a) {
            this.entity === a && this._toggleElementListeners("on")
        },
        _onElementComponentRemove: function(a) {
            this.entity === a && this._toggleElementListeners("off")
        },
        _onViewportElementGain: function() {
            this._syncAll()
        },
        _onContentElementGain: function() {
            this._destroyDragHelper();
            this._contentDragHelper = new Nc(this._contentReference.entity.element);
            this._contentDragHelper.on("drag:start", this._onContentDragStart, this);
            this._contentDragHelper.on("drag:end", this._onContentDragEnd, this);
            this._contentDragHelper.on("drag:move", this._onContentDragMove, this);
            this._prevContentSizes[0] = null;
            this._prevContentSizes[1] = null;
            this._syncAll()
        },
        _onContentElementLose: function() {
            this._destroyDragHelper()
        },
        _onContentDragStart: function() {
            this._contentReference.entity && this.enabled && this.entity.enabled && this._dragStartPosition.copy(this._contentReference.entity.getLocalPosition())
        },
        _onContentDragEnd: function() {
            this._prevContentDragPosition = null;
            this._enableContentInput()
        },
        _onContentDragMove: function(a) {
            if (this._contentReference.entity && this.enabled && this.entity.enabled && (this._wasDragged = !0,
            this._setScrollFromContentPosition(a),
            this._setVelocityFromContentPositionDelta(a),
            !this._disabledContentInput)) {
                var b = a.y - this._dragStartPosition.y;
                (Math.abs(a.x - this._dragStartPosition.x) > this.dragThreshold || Math.abs(b) > this.dragThreshold) && this._disableContentInput()
            }
        },
        _onSetContentOrViewportSize: function() {
            this._syncAll()
        },
        _onSetHorizontalScrollbarValue: function(a) {
            !this._scrollbarUpdateFlags[0] && this.enabled && this.entity.enabled && this._onSetScroll(a, null)
        },
        _onSetVerticalScrollbarValue: function(a) {
            !this._scrollbarUpdateFlags[1] && this.enabled && this.entity.enabled && this._onSetScroll(null, a)
        },
        _onSetHorizontalScrollingEnabled: function() {
            this._syncScrollbarEnabledState(0)
        },
        _onSetVerticalScrollingEnabled: function() {
            this._syncScrollbarEnabledState(1)
        },
        _onHorizontalScrollbarGain: function() {
            this._syncScrollbarEnabledState(0);
            this._syncScrollbarPosition(0)
        },
        _onVerticalScrollbarGain: function() {
            this._syncScrollbarEnabledState(1);
            this._syncScrollbarPosition(1)
        },
        _onSetScroll: function(a, b, c) {
            !1 !== c && this._velocity.set(0, 0, 0);
            a = 0 | this._updateAxis(a, "x", 0);
            (a |= this._updateAxis(b, "y", 1)) && this.fire("set:scroll", this._scroll)
        },
        _updateAxis: function(a, b, c) {
            var d = null !== a && 1E-5 < Math.abs(a - this._scroll[b]);
            if (d || this._isDragging() || 0 === a)
                this._scroll[b] = this._determineNewScrollValue(a, b, c),
                this._syncContentPosition(c),
                this._syncScrollbarPosition(c);
            return d
        },
        _determineNewScrollValue: function(a, b, c) {
            if (!this._getScrollingEnabled(c))
                return this._scroll[b];
            switch (this.scrollMode) {
            case 0:
                return N.clamp(a, 0, this._getMaxScrollValue(c));
            case 1:
                return this._setVelocityFromOvershoot(a, b, c),
                a;
            case 2:
                return a;
            default:
                return console.warn("Unhandled scroll mode:" + this.scrollMode),
                a
            }
        },
        _syncAll: function() {
            this._syncContentPosition(0);
            this._syncContentPosition(1);
            this._syncScrollbarPosition(0);
            this._syncScrollbarPosition(1);
            this._syncScrollbarEnabledState(0);
            this._syncScrollbarEnabledState(1)
        },
        _syncContentPosition: function(a) {
            var b = this._getAxis(a)
              , c = this._getSign(a)
              , d = this._contentReference.entity;
            if (d) {
                var e = this._prevContentSizes[a]
                  , f = this._getContentSize(a);
                if (null !== e && 1E-4 < Math.abs(e - f)) {
                    e = this._getMaxOffset(a, e);
                    var g = this._getMaxOffset(a, f);
                    this._scroll[b] = 0 === g ? 1 : N.clamp(this._scroll[b] * e / g, 0, 1)
                }
                e = this._scroll[b] * this._getMaxOffset(a);
                g = d.getLocalPosition();
                g[b] = e * c;
                d.setLocalPosition(g);
                this._prevContentSizes[a] = f
            }
        },
        _syncScrollbarPosition: function(a) {
            var b = this._getAxis(a)
              , c = this._scrollbarReferences[a].entity;
            c && c.scrollbar && (this._scrollbarUpdateFlags[a] = !0,
            c.scrollbar.value = this._scroll[b],
            c.scrollbar.handleSize = this._getScrollbarHandleSize(b, a),
            this._scrollbarUpdateFlags[a] = !1)
        },
        _syncScrollbarEnabledState: function(a) {
            var b = this._scrollbarReferences[a].entity;
            if (b) {
                var c = this._getScrollingEnabled(a)
                  , d = this._getScrollbarVisibility(a);
                switch (d) {
                case 0:
                    b.enabled = c;
                    break;
                case 1:
                    b.enabled = c && this._contentIsLargerThanViewport(a);
                    break;
                default:
                    console.warn("Unhandled scrollbar visibility:" + d),
                    b.enabled = c
                }
            }
        },
        _contentIsLargerThanViewport: function(a) {
            return this._getContentSize(a) > this._getViewportSize(a)
        },
        _contentPositionToScrollValue: function(a) {
            var b = this._getMaxOffset(0)
              , c = this._getMaxOffset(1);
            nk.x = 0 === b ? 0 : a.x / b;
            nk.y = 0 === c ? 0 : a.y / -c;
            return nk
        },
        _getMaxOffset: function(a, b) {
            b = void 0 === b ? this._getContentSize(a) : b;
            var c = this._getViewportSize(a);
            return b < c ? -this._getViewportSize(a) : c - b
        },
        _getMaxScrollValue: function(a) {
            return this._contentIsLargerThanViewport(a) ? 1 : 0
        },
        _getScrollbarHandleSize: function(a, b) {
            var c = this._getViewportSize(b)
              , d = this._getContentSize(b);
            if (.001 > Math.abs(d))
                return 1;
            c = Math.min(c / d, 1);
            a = this._toOvershoot(this._scroll[a], b);
            return 0 === a ? c : c / (1 + Math.abs(a))
        },
        _getViewportSize: function(a) {
            return this._getSize(a, this._viewportReference)
        },
        _getContentSize: function(a) {
            return this._getSize(a, this._contentReference)
        },
        _getSize: function(a, b) {
            return b.entity && b.entity.element ? b.entity.element[this._getCalculatedDimension(a)] : 0
        },
        _getScrollingEnabled: function(a) {
            if (0 === a)
                return this.horizontal;
            if (1 === a)
                return this.vertical;
            console.warn("Unrecognized orientation: " + a)
        },
        _getScrollbarVisibility: function(a) {
            if (0 === a)
                return this.horizontalScrollbarVisibility;
            if (1 === a)
                return this.verticalScrollbarVisibility;
            console.warn("Unrecognized orientation: " + a)
        },
        _getSign: function(a) {
            return 0 === a ? 1 : -1
        },
        _getAxis: function(a) {
            return 0 === a ? "x" : "y"
        },
        _getCalculatedDimension: function(a) {
            return 0 === a ? "calculatedWidth" : "calculatedHeight"
        },
        _destroyDragHelper: function() {
            this._contentDragHelper && this._contentDragHelper.destroy()
        },
        onUpdate: function() {
            this._contentReference.entity && (this._updateVelocity(),
            this._syncScrollbarEnabledState(0),
            this._syncScrollbarEnabledState(1))
        },
        _updateVelocity: function() {
            if (!this._isDragging() && (1 === this.scrollMode && (this._hasOvershoot("x", 0) && this._setVelocityFromOvershoot(this.scroll.x, "x", 0),
            this._hasOvershoot("y", 1) && this._setVelocityFromOvershoot(this.scroll.y, "y", 1)),
            this._velocity.x *= 1 - this.friction,
            this._velocity.y *= 1 - this.friction,
            1E-4 < Math.abs(this._velocity.x) || 1E-4 < Math.abs(this._velocity.y))) {
                var a = this._contentReference.entity.getLocalPosition();
                a.x += this._velocity.x;
                a.y += this._velocity.y;
                this._contentReference.entity.setLocalPosition(a);
                this._setScrollFromContentPosition(a)
            }
        },
        _hasOvershoot: function(a, b) {
            return .001 < Math.abs(this._toOvershoot(this.scroll[a], b))
        },
        _toOvershoot: function(a, b) {
            b = this._getMaxScrollValue(b);
            return 0 > a ? a : a > b ? a - b : 0
        },
        _setVelocityFromOvershoot: function(a, b, c) {
            a = this._toOvershoot(a, c) * this._getMaxOffset(c) * this._getSign(c);
            0 < Math.abs(a) && (this._velocity[b] = -a / (50 * this.bounceAmount + 1))
        },
        _setVelocityFromContentPositionDelta: function(a) {
            this._prevContentDragPosition ? (this._velocity.sub2(a, this._prevContentDragPosition),
            this._prevContentDragPosition.copy(a)) : (this._velocity.set(0, 0, 0),
            this._prevContentDragPosition = a.clone())
        },
        _setScrollFromContentPosition: function(a) {
            a = this._contentPositionToScrollValue(a);
            this._isDragging() && (a = this._applyScrollValueTension(a));
            this._onSetScroll(a.x, a.y, !1)
        },
        _applyScrollValueTension: function(a) {
            var b = this._getMaxScrollValue(0);
            var c = this._toOvershoot(a.x, 0);
            0 < c ? a.x = b + 1 * Math.log10(1 + c) : 0 > c && (a.x = -1 * Math.log10(1 - c));
            b = this._getMaxScrollValue(1);
            c = this._toOvershoot(a.y, 1);
            0 < c ? a.y = b + 1 * Math.log10(1 + c) : 0 > c && (a.y = -1 * Math.log10(1 - c));
            return a
        },
        _isDragging: function() {
            return this._contentDragHelper && this._contentDragHelper.isDragging
        },
        _setScrollbarComponentsEnabled: function(a) {
            this._scrollbarReferences[0].hasComponent("scrollbar") && (this._scrollbarReferences[0].entity.scrollbar.enabled = a);
            this._scrollbarReferences[1].hasComponent("scrollbar") && (this._scrollbarReferences[1].entity.scrollbar.enabled = a)
        },
        _setContentDraggingEnabled: function(a) {
            this._contentDragHelper && (this._contentDragHelper.enabled = a)
        },
        _enableContentInput: function() {
            for (; this._disabledContentInputEntities.length; ) {
                var a = this._disabledContentInputEntities.pop();
                a.element && (a.element.useInput = !0)
            }
            this._disabledContentInput = !1
        },
        _disableContentInput: function() {
            var a = this
              , b = function(f) {
                f.element && f.element.useInput && (a._disabledContentInputEntities.push(f),
                f.element.useInput = !1);
                f = f.children;
                var g;
                var k = 0;
                for (g = f.length; k < g; k++)
                    b(f[k])
            }
              , c = this._contentReference.entity;
            if (c) {
                c = c.children;
                var d, e = c.length;
                for (d = 0; d < e; d++)
                    b(c[d])
            }
            this._disabledContentInput = !0
        },
        onEnable: function() {
            this._viewportReference.onParentComponentEnable();
            this._contentReference.onParentComponentEnable();
            this._scrollbarReferences[0].onParentComponentEnable();
            this._scrollbarReferences[1].onParentComponentEnable();
            this._setScrollbarComponentsEnabled(!0);
            this._setContentDraggingEnabled(!0);
            this._syncAll()
        },
        onDisable: function() {
            this._setScrollbarComponentsEnabled(!1);
            this._setContentDraggingEnabled(!1)
        },
        onRemove: function() {
            this._toggleLifecycleListeners("off", this.system);
            this._toggleElementListeners("off");
            this._destroyDragHelper()
        }
    });
    Object.defineProperty(md.prototype, "scroll", {
        get: function() {
            return this._scroll
        },
        set: function(a) {
            this._onSetScroll(a.x, a.y)
        }
    });
    var ok = [{
        name: "enabled",
        type: "boolean"
    }, {
        name: "horizontal",
        type: "boolean"
    }, {
        name: "vertical",
        type: "boolean"
    }, {
        name: "scrollMode",
        type: "number"
    }, {
        name: "bounceAmount",
        type: "number"
    }, {
        name: "friction",
        type: "number"
    }, {
        name: "dragThreshold",
        type: "number"
    }, {
        name: "horizontalScrollbarVisibility",
        type: "number"
    }, {
        name: "verticalScrollbarVisibility",
        type: "number"
    }, {
        name: "viewportEntity",
        type: "entity"
    }, {
        name: "contentEntity",
        type: "entity"
    }, {
        name: "horizontalScrollbarEntity",
        type: "entity"
    }, {
        name: "verticalScrollbarEntity",
        type: "entity"
    }]
      , Oe = function(a) {
        H.call(this, a);
        this.id = "scrollview";
        this.ComponentType = md;
        this.DataType = Ao;
        this.schema = ok;
        this.on("beforeremove", this._onRemoveComponent, this);
        H.bind("update", this.onUpdate, this)
    };
    Oe.prototype = Object.create(H.prototype);
    Oe.prototype.constructor = Oe;
    O._buildAccessors(md.prototype, ok);
    Object.assign(Oe.prototype, {
        initializeComponentData: function(a, b, c) {
            void 0 === b.dragThreshold && (b.dragThreshold = 10);
            H.prototype.initializeComponentData.call(this, a, b, ok)
        },
        onUpdate: function(a) {
            a = this.store;
            for (var b in a) {
                var c = a[b].entity
                  , d = c.scrollview;
                if (d.enabled && c.enabled)
                    d.onUpdate()
            }
        },
        _onRemoveComponent: function(a, b) {
            b.onRemove()
        }
    });
    Yd.prototype = Object.create(O.prototype);
    Yd.prototype.constructor = Yd;
    Object.assign(Yd.prototype, {
        _toggleLifecycleListeners: function(a) {
            this[a]("set_value", this._onSetValue, this);
            this[a]("set_handleSize", this._onSetHandleSize, this);
            this[a]("set_orientation", this._onSetOrientation, this)
        },
        _onHandleElementGain: function() {
            this._destroyDragHelper();
            this._handleDragHelper = new Nc(this._handleReference.entity.element,this._getAxis());
            this._handleDragHelper.on("drag:move", this._onHandleDrag, this);
            this._updateHandlePositionAndSize()
        },
        _onHandleElementLose: function() {
            this._destroyDragHelper()
        },
        _onHandleDrag: function(a) {
            this._handleReference.entity && this.enabled && this.entity.enabled && (this.value = this._handlePositionToScrollValue(a[this._getAxis()]))
        },
        _onSetValue: function(a, b, c) {
            1E-5 < Math.abs(c - b) && (this.data.value = N.clamp(c, 0, 1),
            this._updateHandlePositionAndSize(),
            this.fire("set:value", this.data.value))
        },
        _onSetHandleSize: function(a, b, c) {
            1E-5 < Math.abs(c - b) && (this.data.handleSize = N.clamp(c, 0, 1),
            this._updateHandlePositionAndSize())
        },
        _onSetHandleAlignment: function() {
            this._updateHandlePositionAndSize()
        },
        _onSetOrientation: function(a, b, c) {
            c !== b && this._handleReference.hasComponent("element") && (this._handleReference.entity.element[this._getOppositeDimension()] = 0)
        },
        _updateHandlePositionAndSize: function() {
            var a = this._handleReference.entity
              , b = a && a.element;
            a && (a = a.getLocalPosition(),
            a[this._getAxis()] = this._getHandlePosition(),
            this._handleReference.entity.setLocalPosition(a));
            b && (b[this._getDimension()] = this._getHandleLength())
        },
        _handlePositionToScrollValue: function(a) {
            return a * this._getSign() / this._getUsableTrackLength()
        },
        _scrollValueToHandlePosition: function(a) {
            return a * this._getSign() * this._getUsableTrackLength()
        },
        _getUsableTrackLength: function() {
            return Math.max(this._getTrackLength() - this._getHandleLength(), .001)
        },
        _getTrackLength: function() {
            return this.entity.element ? 0 === this.orientation ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight : 0
        },
        _getHandleLength: function() {
            return this._getTrackLength() * this.handleSize
        },
        _getHandlePosition: function() {
            return this._scrollValueToHandlePosition(this.value)
        },
        _getSign: function() {
            return 0 === this.orientation ? 1 : -1
        },
        _getAxis: function() {
            return 0 === this.orientation ? "x" : "y"
        },
        _getDimension: function() {
            return 0 === this.orientation ? "width" : "height"
        },
        _getOppositeDimension: function() {
            return 0 === this.orientation ? "height" : "width"
        },
        _destroyDragHelper: function() {
            this._handleDragHelper && this._handleDragHelper.destroy()
        },
        _setHandleDraggingEnabled: function(a) {
            this._handleDragHelper && (this._handleDragHelper.enabled = a)
        },
        onEnable: function() {
            this._handleReference.onParentComponentEnable();
            this._setHandleDraggingEnabled(!0)
        },
        onDisable: function() {
            this._setHandleDraggingEnabled(!1)
        },
        onRemove: function() {
            this._destroyDragHelper();
            this._toggleLifecycleListeners("off")
        }
    });
    var sj = [{
        name: "enabled",
        type: "boolean"
    }, {
        name: "orientation",
        type: "number"
    }, {
        name: "value",
        type: "number"
    }, {
        name: "handleSize",
        type: "number"
    }, {
        name: "handleEntity",
        type: "entity"
    }];
    Ke.prototype = Object.create(H.prototype);
    Ke.prototype.constructor = Ke;
    O._buildAccessors(Yd.prototype, sj);
    Object.assign(Ke.prototype, {
        initializeComponentData: function(a, b, c) {
            H.prototype.initializeComponentData.call(this, a, b, sj)
        },
        _onRemoveComponent: function(a, b) {
            b.onRemove()
        }
    });
    ed() ? (m.SoundInstance = function(a, b, c) {
        M.call(this);
        c = c || {};
        this._volume = void 0 !== c.volume ? N.clamp(Number(c.volume) || 0, 0, 1) : 1;
        this._pitch = void 0 !== c.pitch ? Math.max(.01, Number(c.pitch) || 0) : 1;
        this._loop = !(void 0 === c.loop || !c.loop);
        this._sound = b;
        this._state = 2;
        this._suspendInstanceEvents = this._suspendEndEvent = this._suspended = !1;
        this._startTime = Math.max(0, Number(c.startTime) || 0);
        this._duration = Math.max(0, Number(c.duration) || 0);
        this._startedAt = 0;
        this._startOffset = null;
        this._currentOffset = this._currentTime = 0;
        this._playWhenLoaded = !0;
        this._manager = a;
        this._lastNode = this._firstNode = this._connectorNode = this._inputNode = null;
        this._initializeNodes();
        this._onPlayCallback = c.onPlay;
        this._onPauseCallback = c.onPause;
        this._onResumeCallback = c.onResume;
        this._onStopCallback = c.onStop;
        this._onEndCallback = c.onEnd;
        this._endedHandler = this._onEnded.bind(this);
        this.source = null
    }
    ,
    m.SoundInstance.prototype = Object.create(M.prototype),
    m.SoundInstance.prototype.constructor = m.SoundInstance,
    Object.assign(m.SoundInstance.prototype, {
        _initializeNodes: function() {
            this._connectorNode = this._inputNode = this.gain = this._manager.context.createGain();
            this._connectorNode.connect(this._manager.context.destination)
        },
        play: function() {
            2 !== this._state && this.stop();
            this.source || this._createSource();
            var a = this._startOffset % this.duration || 0;
            a = (this._startTime + a) % this._sound.duration || 0;
            this._startOffset = null;
            this._duration ? this.source.start(0, a, this._duration) : this.source.start(0, a);
            this._startedAt = this._manager.context.currentTime;
            this._currentTime = 0;
            this._currentOffset = a;
            this._state = 0;
            this._playWhenLoaded = !1;
            this.volume = this._volume;
            this.loop = this._loop;
            this.pitch = this._pitch;
            this._manager.on("volumechange", this._onManagerVolumeChange, this);
            this._manager.on("suspend", this._onManagerSuspend, this);
            this._manager.on("resume", this._onManagerResume, this);
            this._manager.on("destroy", this._onManagerDestroy, this);
            this._manager.suspended && this._onManagerSuspend();
            this._suspendInstanceEvents || this._onPlay();
            return !0
        },
        pause: function() {
            if (0 !== this._state || !this.source)
                return !1;
            this._updateCurrentTime();
            this._state = 1;
            this._suspendEndEvent = !0;
            this.source.stop(0);
            this.source = null;
            this._playWhenLoaded = !1;
            this._startOffset = null;
            this._suspendInstanceEvents || this._onPause();
            return !0
        },
        resume: function() {
            if (1 !== this._state)
                return !1;
            this.source || this._createSource();
            var a = this.currentTime;
            null !== this._startOffset && (a = this._startOffset % this.duration || 0,
            a = (this._startTime + a) % this._sound.duration || 0,
            this._startOffset = null);
            this._duration ? this.source.start(0, a, this._duration) : this.source.start(0, a);
            this._state = 0;
            this._startedAt = this._manager.context.currentTime;
            this._currentOffset = a;
            this.volume = this._volume;
            this.loop = this._loop;
            this.pitch = this._pitch;
            this._playWhenLoaded = !1;
            this._suspendInstanceEvents || this._onResume();
            return !0
        },
        stop: function() {
            if (2 === this._state || !this.source)
                return !1;
            this._manager.off("volumechange", this._onManagerVolumeChange, this);
            this._manager.off("suspend", this._onManagerSuspend, this);
            this._manager.off("resume", this._onManagerResume, this);
            this._manager.off("destroy", this._onManagerDestroy, this);
            this._currentOffset = this._currentTime = this._startedAt = 0;
            this._startOffset = null;
            this._playWhenLoaded = !1;
            this._suspendEndEvent = !0;
            0 === this._state && this.source.stop(0);
            this.source = null;
            this._state = 2;
            this._suspendInstanceEvents || this._onStop();
            return !0
        },
        setExternalNodes: function(a, b) {
            if (a) {
                b || (b = a);
                var c = this._manager.context.destination;
                this._firstNode !== a && (this._firstNode ? this._connectorNode.disconnect(this._firstNode) : this._connectorNode.disconnect(c),
                this._firstNode = a,
                this._connectorNode.connect(a));
                this._lastNode !== b && (this._lastNode && this._lastNode.disconnect(c),
                this._lastNode = b,
                this._lastNode.connect(c))
            } else
                console.error("The firstNode must be a valid Audio Node")
        },
        clearExternalNodes: function() {
            var a = this._manager.context.destination;
            this._firstNode && (this._connectorNode.disconnect(this._firstNode),
            this._firstNode = null);
            this._lastNode && (this._lastNode.disconnect(a),
            this._lastNode = null);
            this._connectorNode.connect(a)
        },
        getExternalNodes: function() {
            return [this._firstNode, this._lastNode]
        },
        _createSource: function() {
            if (!this._sound)
                return null;
            var a = this._manager.context;
            this._sound.buffer && (this.source = a.createBufferSource(),
            this.source.buffer = this._sound.buffer,
            this.source.connect(this._inputNode),
            this.source.onended = this._endedHandler,
            this.source.loopStart = this._startTime % this.source.buffer.duration || 0,
            this._duration && (this.source.loopEnd = Math.max(this.source.loopStart, (this._startTime + this._duration) % this.source.buffer.duration || 0)));
            return this.source
        },
        _updateCurrentTime: function() {
            this._currentTime = ((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset) % this.duration || 0
        },
        _onManagerDestroy: function() {
            this.source && 0 === this._state && (this.source.stop(0),
            this.source = null)
        }
    }),
    Object.defineProperty(m.SoundInstance.prototype, "volume", {
        get: function() {
            return this._volume
        },
        set: function(a) {
            this._volume = a = N.clamp(a, 0, 1);
            this.gain && (this.gain.gain.value = a * this._manager.volume)
        }
    }),
    Object.defineProperty(m.SoundInstance.prototype, "pitch", {
        get: function() {
            return this._pitch
        },
        set: function(a) {
            this._currentOffset = this.currentTime;
            this._startedAt = this._manager.context.currentTime;
            this._pitch = Math.max(Number(a) || 0, .01);
            this.source && (this.source.playbackRate.value = this._pitch)
        }
    }),
    Object.defineProperty(m.SoundInstance.prototype, "loop", {
        get: function() {
            return this._loop
        },
        set: function(a) {
            this._loop = !!a;
            this.source && (this.source.loop = this._loop)
        }
    }),
    Object.defineProperty(m.SoundInstance.prototype, "sound", {
        get: function() {
            return this._sound
        },
        set: function(a) {
            this._sound = a;
            2 !== this._state ? this.stop() : this._createSource()
        }
    }),
    Object.defineProperty(m.SoundInstance.prototype, "currentTime", {
        get: function() {
            if (null !== this._startOffset)
                return this._startOffset;
            if (1 === this._state)
                return this._currentTime;
            if (2 === this._state || !this.source)
                return 0;
            this._updateCurrentTime();
            return this._currentTime
        },
        set: function(a) {
            if (!(0 > a))
                if (0 === this._state) {
                    this.stop();
                    var b = this._suspendInstanceEvents;
                    this._suspendInstanceEvents = !0;
                    this._startOffset = a;
                    this.play();
                    this._suspendInstanceEvents = b
                } else
                    this._currentTime = this._startOffset = a
        }
    })) : ue() ? (m.SoundInstance = function(a, b, c) {
        M.call(this);
        c = c || {};
        this._volume = void 0 !== c.volume ? N.clamp(Number(c.volume) || 0, 0, 1) : 1;
        this._pitch = void 0 !== c.pitch ? Math.max(.01, Number(c.pitch) || 0) : 1;
        this._loop = !(void 0 === c.loop || !c.loop);
        this._sound = b;
        this._state = 2;
        this._suspendInstanceEvents = this._suspendEndEvent = this._suspended = !1;
        this._playWhenLoaded = !0;
        this._startTime = Math.max(0, Number(c.startTime) || 0);
        this._duration = Math.max(0, Number(c.duration) || 0);
        this._startOffset = null;
        this._isReady = !1;
        this._manager = a;
        this._loadedMetadataHandler = this._onLoadedMetadata.bind(this);
        this._timeUpdateHandler = this._onTimeUpdate.bind(this);
        this._endedHandler = this._onEnded.bind(this);
        this._onPlayCallback = c.onPlay;
        this._onPauseCallback = c.onPause;
        this._onResumeCallback = c.onResume;
        this._onStopCallback = c.onStop;
        this._onEndCallback = c.onEnd;
        this.source = null;
        this._createSource()
    }
    ,
    m.SoundInstance.prototype = Object.create(M.prototype),
    m.SoundInstance.prototype.constructor = m.SoundInstance,
    Object.assign(m.SoundInstance.prototype, {
        play: function() {
            2 !== this._state && this.stop();
            if (!this.source && !this._createSource())
                return !1;
            this.volume = this._volume;
            this.pitch = this._pitch;
            this.loop = this._loop;
            this.source.play();
            this._state = 0;
            this._playWhenLoaded = !1;
            this._manager.on("volumechange", this._onManagerVolumeChange, this);
            this._manager.on("suspend", this._onManagerSuspend, this);
            this._manager.on("resume", this._onManagerResume, this);
            this._manager.on("destroy", this._onManagerDestroy, this);
            this._manager.suspended && this._onManagerSuspend();
            this._suspendInstanceEvents || this._onPlay();
            return !0
        },
        pause: function() {
            if (!this.source || 0 !== this._state)
                return !1;
            this._suspendEndEvent = !0;
            this.source.pause();
            this._playWhenLoaded = !1;
            this._state = 1;
            this._startOffset = null;
            this._suspendInstanceEvents || this._onPause();
            return !0
        },
        resume: function() {
            if (!this.source || 1 !== this._state)
                return !1;
            this._state = 0;
            this._playWhenLoaded = !1;
            this.source.paused && (this.source.play(),
            this._suspendInstanceEvents || this._onResume());
            return !0
        },
        stop: function() {
            if (!this.source || 2 === this._state)
                return !1;
            this._manager.off("volumechange", this._onManagerVolumeChange, this);
            this._manager.off("suspend", this._onManagerSuspend, this);
            this._manager.off("resume", this._onManagerResume, this);
            this._manager.off("destroy", this._onManagerDestroy, this);
            this._suspendEndEvent = !0;
            this.source.pause();
            this._playWhenLoaded = !1;
            this._state = 2;
            this._startOffset = null;
            this._suspendInstanceEvents || this._onStop();
            return !0
        },
        setExternalNodes: function() {},
        clearExternalNodes: function() {},
        getExternalNodes: function() {
            return [null, null]
        },
        _onLoadedMetadata: function() {
            this.source.removeEventListener("loadedmetadata", this._loadedMetadataHandler);
            this._isReady = !0;
            var a = this._startOffset % this.duration || 0;
            a = (this._startTime + a) % this._sound.duration || 0;
            this._startOffset = null;
            this.source.currentTime = a
        },
        _createSource: function() {
            this._sound && this._sound.audio && (this._isReady = !1,
            this.source = this._sound.audio.cloneNode(!0),
            this.source.addEventListener("loadedmetadata", this._loadedMetadataHandler),
            this.source.addEventListener("timeupdate", this._timeUpdateHandler),
            this.source.onended = this._endedHandler);
            return this.source
        },
        _onTimeUpdate: function() {
            this._duration && this.source.currentTime > ((this._startTime + this._duration) % this.source.duration || 0) && (this.loop ? this.source.currentTime = this._startTime % this.source.duration || 0 : (this.source.removeEventListener("timeupdate", this._timeUpdateHandler),
            this.source.pause(),
            this._onEnded()))
        },
        _onManagerDestroy: function() {
            this.source && this.source.pause()
        }
    }),
    Object.defineProperty(m.SoundInstance.prototype, "volume", {
        get: function() {
            return this._volume
        },
        set: function(a) {
            this._volume = a = N.clamp(a, 0, 1);
            this.source && (this.source.volume = a * this._manager.volume)
        }
    }),
    Object.defineProperty(m.SoundInstance.prototype, "pitch", {
        get: function() {
            return this._pitch
        },
        set: function(a) {
            this._pitch = Math.max(Number(a) || 0, .01);
            this.source && (this.source.playbackRate = this._pitch)
        }
    }),
    Object.defineProperty(m.SoundInstance.prototype, "loop", {
        get: function() {
            return this._loop
        },
        set: function(a) {
            this._loop = !!a;
            this.source && (this.source.loop = this._loop)
        }
    }),
    Object.defineProperty(m.SoundInstance.prototype, "sound", {
        get: function() {
            return this._sound
        },
        set: function(a) {
            this.stop();
            this._sound = a
        }
    }),
    Object.defineProperty(m.SoundInstance.prototype, "currentTime", {
        get: function() {
            return null !== this._startOffset ? this._startOffset : 2 !== this._state && this.source ? this.source.currentTime - this._startTime : 0
        },
        set: function(a) {
            0 > a || (this._startOffset = a,
            this.source && this._isReady && (this.source.currentTime = (this._startTime + (a % this.duration || 0)) % this._sound.duration || 0,
            this._startOffset = null))
        }
    })) : m.SoundInstance = function() {}
    ;
    Object.assign(m.SoundInstance.prototype, {
        _onPlay: function() {
            this.fire("play");
            this._onPlayCallback && this._onPlayCallback(this)
        },
        _onPause: function() {
            this.fire("pause");
            this._onPauseCallback && this._onPauseCallback(this)
        },
        _onResume: function() {
            this.fire("resume");
            this._onResumeCallback && this._onResumeCallback(this)
        },
        _onStop: function() {
            this.fire("stop");
            this._onStopCallback && this._onStopCallback(this)
        },
        _onEnded: function() {
            this._suspendEndEvent ? this._suspendEndEvent = !1 : (this.fire("end"),
            this._onEndCallback && this._onEndCallback(this),
            this.stop())
        },
        _onManagerVolumeChange: function() {
            this.volume = this._volume
        },
        _onManagerSuspend: function() {
            0 !== this._state || this._suspended || (this._suspended = !0,
            this.pause())
        },
        _onManagerResume: function() {
            this._suspended && (this._suspended = !1,
            this.resume())
        }
    });
    Object.defineProperty(m.SoundInstance.prototype, "startTime", {
        get: function() {
            return this._startTime
        },
        set: function(a) {
            this._startTime = Math.max(0, Number(a) || 0);
            a = 0 === this._state;
            this.stop();
            a && this.play()
        }
    });
    Object.defineProperty(m.SoundInstance.prototype, "duration", {
        get: function() {
            return this._sound ? this._duration ? this._duration % this._sound.duration || 0 : this._sound.duration : 0
        },
        set: function(a) {
            this._duration = Math.max(0, Number(a) || 0);
            a = 0 === this._state;
            this.stop();
            a && this.play()
        }
    });
    Object.defineProperty(m.SoundInstance.prototype, "isPlaying", {
        get: function() {
            return 0 === this._state
        }
    });
    Object.defineProperty(m.SoundInstance.prototype, "isPaused", {
        get: function() {
            return 1 === this._state
        }
    });
    Object.defineProperty(m.SoundInstance.prototype, "isStopped", {
        get: function() {
            return 2 === this._state
        }
    });
    Object.defineProperty(m.SoundInstance.prototype, "isSuspended", {
        get: function() {
            return this._suspended
        }
    });
    if (ed())
        m.SoundInstance3d = function(a, b, c) {
            m.SoundInstance.call(this, a, b, c);
            c = c || {};
            this._position = new z;
            c.position && (this.position = c.position);
            this._velocity = new z;
            c.velocity && (this.velocity = c.velocity);
            this.maxDistance = void 0 !== c.maxDistance ? Number(c.maxDistance) : 1E4;
            this.refDistance = void 0 !== c.refDistance ? Number(c.refDistance) : 1;
            this.rollOffFactor = void 0 !== c.rollOffFactor ? Number(c.rollOffFactor) : 1;
            this.distanceModel = void 0 !== c.distanceModel ? c.distanceModel : "linear"
        }
        ,
        m.SoundInstance3d.prototype = Object.create(m.SoundInstance.prototype),
        m.SoundInstance3d.prototype.constructor = m.SoundInstance3d,
        Object.assign(m.SoundInstance3d.prototype, {
            _initializeNodes: function() {
                this.gain = this._manager.context.createGain();
                this.panner = this._manager.context.createPanner();
                this.panner.connect(this.gain);
                this._inputNode = this.panner;
                this._connectorNode = this.gain;
                this._connectorNode.connect(this._manager.context.destination)
            }
        }),
        Object.defineProperty(m.SoundInstance3d.prototype, "position", {
            get: function() {
                return this._position
            },
            set: function(a) {
                this._position.copy(a);
                this.panner.setPosition(a.x, a.y, a.z)
            }
        }),
        Object.defineProperty(m.SoundInstance3d.prototype, "velocity", {
            get: function() {
                return this._velocity
            },
            set: function(a) {
                this._velocity.copy(a);
                this.panner.setVelocity(a.x, a.y, a.z)
            }
        }),
        Object.defineProperty(m.SoundInstance3d.prototype, "maxDistance", {
            get: function() {
                return this.panner.maxDistance
            },
            set: function(a) {
                this.panner.maxDistance = a
            }
        }),
        Object.defineProperty(m.SoundInstance3d.prototype, "refDistance", {
            get: function() {
                return this.panner.refDistance
            },
            set: function(a) {
                this.panner.refDistance = a
            }
        }),
        Object.defineProperty(m.SoundInstance3d.prototype, "rollOffFactor", {
            get: function() {
                return this.panner.rolloffFactor
            },
            set: function(a) {
                this.panner.rolloffFactor = a
            }
        }),
        Object.defineProperty(m.SoundInstance3d.prototype, "distanceModel", {
            get: function() {
                return this.panner.distanceModel
            },
            set: function(a) {
                this.panner.distanceModel = a
            }
        });
    else if (ue()) {
        var pk = new z;
        m.SoundInstance3d = function(a, b, c) {
            m.SoundInstance.call(this, a, b, c);
            c = c || {};
            this._position = new z;
            c.position && (this.position = c.position);
            this._velocity = new z;
            c.velocity && (this.velocity = c.velocity);
            this._maxDistance = void 0 !== c.maxDistance ? Number(c.maxDistance) : 1E4;
            this._refDistance = void 0 !== c.refDistance ? Number(c.refDistance) : 1;
            this._rollOffFactor = void 0 !== c.rollOffFactor ? Number(c.rollOffFactor) : 1;
            this._distanceModel = void 0 !== c.distanceModel ? c.distanceModel : "linear"
        }
        ;
        m.SoundInstance3d.prototype = Object.create(m.SoundInstance.prototype);
        m.SoundInstance3d.prototype.constructor = m.SoundInstance3d;
        Object.defineProperty(m.SoundInstance3d.prototype, "position", {
            get: function() {
                return this._position
            },
            set: function(a) {
                this._position.copy(a);
                if (this.source) {
                    var b = this._manager.listener.getPosition();
                    a = this.refDistance;
                    var c = this.maxDistance
                      , d = this.rollOffFactor
                      , e = this.distanceModel;
                    pk = pk.sub2(b, this._position);
                    b = pk.length();
                    if (b < a)
                        a = 1;
                    else if (b > c)
                        a = 0;
                    else {
                        var f = 0;
                        "linear" === e ? f = 1 - d * (b - a) / (c - a) : e === Hf ? f = a / (a + d * (b - a)) : "exponential" === e && (f = Math.pow(b / a, -d));
                        a = N.clamp(f, 0, 1)
                    }
                    this.source.volume = this.volume * a * this._manager.volume
                }
            }
        });
        Object.defineProperty(m.SoundInstance3d.prototype, "velocity", {
            get: function() {
                return this._velocity
            },
            set: function(a) {
                this._velocity.copy(a)
            }
        });
        Object.defineProperty(m.SoundInstance3d.prototype, "maxDistance", {
            get: function() {
                return this._maxDistance
            },
            set: function(a) {
                this._maxDistance = a
            }
        });
        Object.defineProperty(m.SoundInstance3d.prototype, "refDistance", {
            get: function() {
                return this._refDistance
            },
            set: function(a) {
                this._refDistance = a
            }
        });
        Object.defineProperty(m.SoundInstance3d.prototype, "rollOffFactor", {
            get: function() {
                return this._rollOffFactor
            },
            set: function(a) {
                this._rollOffFactor = a
            }
        });
        Object.defineProperty(m.SoundInstance3d.prototype, "distanceModel", {
            get: function() {
                return this._distanceModel
            },
            set: function(a) {
                this._distanceModel = a
            }
        })
    } else
        m.SoundInstance3d = function() {}
        ;
    var fb = {
        volume: 0,
        pitch: 0,
        loop: !1,
        startTime: 0,
        duration: 0,
        position: new z,
        maxDistance: 0,
        refDistance: 0,
        rollOffFactor: 0,
        distanceModel: 0,
        onPlay: null,
        onPause: null,
        onResume: null,
        onStop: null,
        onEnd: null
    };
    Qa.prototype = Object.create(M.prototype);
    Qa.prototype.constructor = Qa;
    Object.assign(Qa.prototype, {
        play: function() {
            this.overlap || this.stop();
            if (this.isLoaded || this._hasAsset()) {
                var a = this._createInstance();
                this.instances.push(a);
                if (this.isLoaded)
                    a.play();
                else {
                    var b = function(c) {
                        var d = a._playWhenLoaded;
                        a.sound = c;
                        d && a.play()
                    };
                    this.off("load", b);
                    this.once("load", b);
                    this.load()
                }
                return a
            }
        },
        pause: function() {
            for (var a = !1, b = this.instances, c = 0, d = b.length; c < d; c++)
                b[c].pause() && (a = !0);
            return a
        },
        resume: function() {
            for (var a = !1, b = this.instances, c = 0, d = b.length; c < d; c++)
                b[c].resume() && (a = !0);
            return a
        },
        stop: function() {
            for (var a = !1, b = this.instances, c = b.length; c--; )
                b[c].stop(),
                a = !0;
            b.length = 0;
            return a
        },
        load: function() {
            if (this._hasAsset()) {
                var a = this._assets.get(this._asset);
                a ? (a.off("remove", this._onAssetRemoved, this),
                a.on("remove", this._onAssetRemoved, this),
                a.resource ? this.fire("load", a.resource) : (a.off("load", this._onAssetLoad, this),
                a.once("load", this._onAssetLoad, this),
                this._assets.load(a))) : (this._assets.off("add:" + this._asset, this._onAssetAdd, this),
                this._assets.once("add:" + this._asset, this._onAssetAdd, this))
            }
        },
        setExternalNodes: function(a, b) {
            if (a) {
                if (b || (b = a),
                this._firstNode = a,
                this._lastNode = b,
                !this._overlap)
                    for (var c = this.instances, d = 0, e = c.length; d < e; d++)
                        c[d].setExternalNodes(a, b)
            } else
                console.error("The firstNode must have a valid AudioNode")
        },
        clearExternalNodes: function() {
            this._lastNode = this._firstNode = null;
            if (!this._overlap)
                for (var a = this.instances, b = 0, c = a.length; b < c; b++)
                    a[b].clearExternalNodes()
        },
        getExternalNodes: function() {
            return [this._firstNode, this._lastNode]
        },
        _hasAsset: function() {
            return null != this._asset
        },
        _createInstance: function() {
            var a = this._component;
            var b = null;
            if (this._hasAsset()) {
                var c = this._assets.get(this._asset);
                c && (b = c.resource)
            }
            fb.volume = this._volume * a.volume;
            fb.pitch = this._pitch * a.pitch;
            fb.loop = this._loop;
            fb.startTime = this._startTime;
            fb.duration = this._duration;
            fb.onPlay = this._onInstancePlayHandler;
            fb.onPause = this._onInstancePauseHandler;
            fb.onResume = this._onInstanceResumeHandler;
            fb.onStop = this._onInstanceStopHandler;
            fb.onEnd = this._onInstanceEndHandler;
            a.positional ? (fb.position.copy(a.entity.getPosition()),
            fb.maxDistance = a.maxDistance,
            fb.refDistance = a.refDistance,
            fb.rollOffFactor = a.rollOffFactor,
            fb.distanceModel = a.distanceModel,
            a = new m.SoundInstance3d(this._manager,b,fb)) : a = new m.SoundInstance(this._manager,b,fb);
            this._firstNode && a.setExternalNodes(this._firstNode, this._lastNode);
            return a
        },
        _onInstancePlay: function(a) {
            this.fire("play", a);
            this._component.fire("play", this, a)
        },
        _onInstancePause: function(a) {
            this.fire("pause", a);
            this._component.fire("pause", this, a)
        },
        _onInstanceResume: function(a) {
            this.fire("resume", a);
            this._component.fire("resume", this, a)
        },
        _onInstanceStop: function(a) {
            var b = this.instances.indexOf(a);
            -1 !== b && this.instances.splice(b, 1);
            this.fire("stop", a);
            this._component.fire("stop", this, a)
        },
        _onInstanceEnd: function(a) {
            var b = this.instances.indexOf(a);
            -1 !== b && this.instances.splice(b, 1);
            this.fire("end", a);
            this._component.fire("end", this, a)
        },
        _onAssetAdd: function(a) {
            this.load()
        },
        _onAssetLoad: function(a) {
            this.load()
        },
        _onAssetRemoved: function(a) {
            a.off("remove", this._onAssetRemoved, this);
            this._assets.off("add:" + a.id, this._onAssetAdd, this);
            this.stop()
        },
        updatePosition: function(a) {
            for (var b = this.instances, c = 0, d = b.length; c < d; c++)
                b[c].position = a
        }
    });
    Object.defineProperty(Qa.prototype, "volume", {
        get: function() {
            return this._volume
        },
        set: function(a) {
            this._volume = N.clamp(Number(a) || 0, 0, 1);
            if (!this._overlap) {
                a = this.instances;
                for (var b = 0, c = a.length; b < c; b++)
                    a[b].volume = this._volume * this._component.volume
            }
        }
    });
    Object.defineProperty(Qa.prototype, "pitch", {
        get: function() {
            return this._pitch
        },
        set: function(a) {
            this._pitch = Math.max(Number(a) || 0, .01);
            if (!this._overlap) {
                a = this.instances;
                for (var b = 0, c = a.length; b < c; b++)
                    a[b].pitch = this.pitch * this._component.pitch
            }
        }
    });
    Object.defineProperty(Qa.prototype, "loop", {
        get: function() {
            return this._loop
        },
        set: function(a) {
            this._loop = !!a;
            a = this.instances;
            for (var b = 0, c = a.length; b < c; b++)
                a[b].loop = this._loop
        }
    });
    Object.defineProperty(Qa.prototype, "autoPlay", {
        get: function() {
            return this._autoPlay
        },
        set: function(a) {
            this._autoPlay = !!a
        }
    });
    Object.defineProperty(Qa.prototype, "overlap", {
        get: function() {
            return this._overlap
        },
        set: function(a) {
            this._overlap = !!a
        }
    });
    Object.defineProperty(Qa.prototype, "startTime", {
        get: function() {
            return this._startTime
        },
        set: function(a) {
            this._startTime = Math.max(0, Number(a) || 0);
            if (!this._overlap) {
                a = this.instances;
                for (var b = 0, c = a.length; b < c; b++)
                    a[b].startTime = this._startTime
            }
        }
    });
    Object.defineProperty(Qa.prototype, "duration", {
        get: function() {
            var a = 0;
            this._hasAsset() && (a = this._assets.get(this._asset),
            a = a.resource ? a.resource.duration : 0);
            return null != this._duration ? this._duration % (a || 1) : a
        },
        set: function(a) {
            this._duration = Math.max(0, Number(a) || 0) || null;
            if (!this._overlap) {
                a = this.instances;
                for (var b = 0, c = a.length; b < c; b++)
                    a[b].duration = this._duration
            }
        }
    });
    Object.defineProperty(Qa.prototype, "asset", {
        get: function() {
            return this._asset
        },
        set: function(a) {
            var b = this._asset;
            b && (this._assets.off("add:" + b, this._onAssetAdd, this),
            (b = this._assets.get(b)) && b.off("remove", this._onAssetRemoved, this));
            this._asset = a;
            this._asset instanceof aa && (this._asset = this._asset.id);
            this._hasAsset() && this._component.enabled && this._component.entity.enabled && this.load()
        }
    });
    Object.defineProperty(Qa.prototype, "isLoaded", {
        get: function() {
            if (this._hasAsset()) {
                var a = this._assets.get(this._asset);
                if (a)
                    return !!a.resource
            }
            return !1
        }
    });
    Object.defineProperty(Qa.prototype, "isPlaying", {
        get: function() {
            for (var a = this.instances, b = 0, c = a.length; b < c; b++)
                if (a[b].isPlaying)
                    return !0;
            return !1
        }
    });
    Object.defineProperty(Qa.prototype, "isPaused", {
        get: function() {
            var a = this.instances
              , b = a.length;
            if (0 === b)
                return !1;
            for (var c = 0; c < b; c++)
                if (!a[c].isPaused)
                    return !1;
            return !0
        }
    });
    Object.defineProperty(Qa.prototype, "isStopped", {
        get: function() {
            for (var a = this.instances, b = 0, c = a.length; b < c; b++)
                if (!a[b].isStopped)
                    return !1;
            return !0
        }
    });
    jc.prototype = Object.create(O.prototype);
    jc.prototype.constructor = jc;
    Al("pitch", "_pitch");
    Al("volume", "_volume");
    Xg("refDistance", "_refDistance");
    Xg("maxDistance", "_maxDistance");
    Xg("rollOffFactor", "_rollOffFactor");
    Xg("distanceModel", "_distanceModel");
    Object.defineProperty(jc.prototype, "positional", {
        get: function() {
            return this._positional
        },
        set: function(a) {
            this._positional = a;
            a = this._slots;
            for (var b in a) {
                var c = a[b];
                if (!c.overlap)
                    for (var d = c.instances, e = 0, f = d.length; e < f; e++) {
                        var g = d[e].isPlaying || d[e].isSuspended
                          , k = d[e].currentTime;
                        g && d[e].stop();
                        d[e] = c._createInstance();
                        g && (d[e].play(),
                        d[e].currentTime = k)
                    }
            }
        }
    });
    Object.defineProperty(jc.prototype, "slots", {
        get: function() {
            return this._slots
        },
        set: function(a) {
            var b, c = this._slots;
            if (c)
                for (b in c)
                    c[b].stop();
            c = {};
            for (b in a)
                a[b]instanceof Qa ? c[a[b].name] = a[b] : a[b].name && (c[a[b].name] = new Qa(this,a[b].name,a[b]));
            this._slots = c;
            if (this.enabled && this.entity.enabled)
                this.onEnable()
        }
    });
    Object.assign(jc.prototype, {
        onEnable: function() {
            if (!this.system._inTools) {
                var a = this._slots, b = this._playingBeforeDisable, c;
                for (c in a) {
                    var d = a[c];
                    d.autoPlay && d.isStopped ? d.play() : b[c] ? d.resume() : d.isLoaded || d.load()
                }
            }
        },
        onDisable: function() {
            var a = this._slots, b = {}, c;
            for (c in a)
                !a[c].overlap && a[c].isPlaying && (a[c].pause(),
                b[c] = !0);
            this._playingBeforeDisable = b
        },
        onRemove: function() {
            this.off()
        },
        addSlot: function(a, b) {
            var c = this._slots;
            if (c[a])
                return null;
            b = new Qa(this,a,b);
            c[a] = b;
            b.autoPlay && this.enabled && this.entity.enabled && b.play();
            return b
        },
        removeSlot: function(a) {
            var b = this._slots;
            b[a] && (b[a].stop(),
            delete b[a])
        },
        slot: function(a) {
            return this._slots[a]
        },
        play: function(a) {
            return this.enabled && this.entity.enabled ? (a = this._slots[a]) ? a.play() : null : null
        },
        pause: function(a) {
            var b = this._slots;
            if (a)
                (a = b[a]) && a.pause();
            else
                for (var c in b)
                    b[c].pause()
        },
        resume: function(a) {
            var b = this._slots;
            if (a)
                (a = b[a]) && a.isPaused && a.resume();
            else
                for (var c in b)
                    b[c].resume()
        },
        stop: function(a) {
            var b = this._slots;
            if (a)
                (a = b[a]) && a.stop();
            else
                for (var c in b)
                    b[c].stop()
        }
    });
    var cn = ["enabled"]
      , od = function(a, b) {
        H.call(this, a);
        this.id = "sound";
        this.ComponentType = jc;
        this.DataType = Co;
        this.schema = cn;
        this.manager = b;
        H.bind("update", this.onUpdate, this);
        this.on("beforeremove", this.onBeforeRemove, this)
    };
    od.prototype = Object.create(H.prototype);
    od.prototype.constructor = od;
    O._buildAccessors(jc.prototype, cn);
    Object.assign(od.prototype, {
        initializeComponentData: function(a, b, c) {
            c = "volume pitch positional refDistance maxDistance rollOffFactor distanceModel slots".split(" ");
            for (var d = 0; d < c.length; d++)
                b.hasOwnProperty(c[d]) && (a[c[d]] = b[c[d]]);
            H.prototype.initializeComponentData.call(this, a, b, ["enabled"])
        },
        cloneComponent: function(a, b) {
            a = a.sound;
            var c = a.slots, d = {}, e;
            for (e in c) {
                var f = c[e];
                d[e] = {
                    name: f.name,
                    volume: f.volume,
                    pitch: f.pitch,
                    loop: f.loop,
                    duration: f.duration,
                    startTime: f.startTime,
                    overlap: f.overlap,
                    autoPlay: f.autoPlay,
                    asset: f.asset
                }
            }
            return this.addComponent(b, {
                distanceModel: a.distanceModel,
                enabled: a.enabled,
                maxDistance: a.maxDistance,
                pitch: a.pitch,
                positional: a.positional,
                refDistance: a.refDistance,
                rollOffFactor: a.rollOffFactor,
                slots: d,
                volume: a.volume
            })
        },
        onUpdate: function(a) {
            a = this.store;
            for (var b in a)
                if (a.hasOwnProperty(b)) {
                    var c = a[b].entity;
                    if (c.enabled) {
                        var d = c.sound;
                        if (d.enabled && d.positional) {
                            c = c.getPosition();
                            d = d.slots;
                            for (var e in d)
                                d[e].updatePosition(c)
                        }
                    }
                }
        },
        onBeforeRemove: function(a, b) {
            a = b.slots;
            for (var c in a)
                a[c].overlap || a[c].stop();
            b.onRemove()
        }
    });
    Object.defineProperty(od.prototype, "volume", {
        get: function() {
            return this.manager.volume
        },
        set: function(a) {
            this.manager.volume = a
        }
    });
    Object.defineProperty(od.prototype, "context", {
        get: function() {
            return ed() ? this.manager.context : null
        }
    });
    vb.prototype = Object.create(M.prototype);
    vb.prototype.constructor = vb;
    Object.assign(vb.prototype, {
        _onSpriteAssetAdded: function(a) {
            this._component.system.app.assets.off("add:" + a.id, this._onSpriteAssetAdded, this);
            this._spriteAsset === a.id && this._bindSpriteAsset(a)
        },
        _bindSpriteAsset: function(a) {
            a.on("load", this._onSpriteAssetLoad, this);
            a.on("remove", this._onSpriteAssetRemove, this);
            a.resource ? this._onSpriteAssetLoad(a) : this._component.system.app.assets.load(a)
        },
        _unbindSpriteAsset: function(a) {
            a.off("load", this._onSpriteAssetLoad, this);
            a.off("remove", this._onSpriteAssetRemove, this);
            a.resource && a.resource.atlas && this._component.system.app.assets.off("load:" + a.data.textureAtlasAsset, this._onTextureAtlasLoad, this)
        },
        _onSpriteAssetLoad: function(a) {
            if (a.resource)
                if (a.resource.atlas)
                    this.sprite = a.resource;
                else {
                    a = a.data.textureAtlasAsset;
                    var b = this._component.system.app.assets;
                    b.off("load:" + a, this._onTextureAtlasLoad, this);
                    b.once("load:" + a, this._onTextureAtlasLoad, this)
                }
            else
                this.sprite = null
        },
        _onTextureAtlasLoad: function(a) {
            a = this._spriteAsset;
            a instanceof aa ? this._onSpriteAssetLoad(a) : this._onSpriteAssetLoad(this._component.system.app.assets.get(a))
        },
        _onSpriteAssetRemove: function(a) {
            this.sprite = null
        },
        _onSpriteMeshesChange: function() {
            this._component.currentClip === this && this._component._showFrame(this.frame)
        },
        _onSpritePpuChanged: function() {
            this._component.currentClip === this && 0 !== this.sprite.renderMode && this._component._showFrame(this.frame)
        },
        _update: function(a) {
            if (0 !== this.fps && this._playing && !this._paused && this._sprite) {
                var b = this._time + a * this._component.speed * (0 > this.fps ? -1 : 1)
                  , c = this.duration;
                a = b > c || 0 > b;
                this._setTime(b);
                b = this._sprite ? Math.floor(this._sprite.frameKeys.length * this._time / c) : 0;
                b !== this._frame && this._setFrame(b);
                a && (this.loop ? (this.fire("loop"),
                this._component.fire("loop", this)) : (this._paused = this._playing = !1,
                this.fire("end"),
                this._component.fire("end", this)))
            }
        },
        _setTime: function(a) {
            this._time = a;
            a = this.duration;
            0 > this._time ? this._time = this.loop ? this._time % a + a : 0 : this._time > a && (this._time = this.loop ? this._time % a : a)
        },
        _setFrame: function(a) {
            this._frame = this._sprite ? N.clamp(a, 0, this._sprite.frameKeys.length - 1) : a;
            this._component.currentClip === this && this._component._showFrame(this._frame)
        },
        _destroy: function() {
            this._sprite && (this.sprite = null);
            this._spriteAsset && (this.spriteAsset = null)
        },
        play: function() {
            this._playing || (this._playing = !0,
            this._paused = !1,
            this.frame = 0,
            this.fire("play"),
            this._component.fire("play", this))
        },
        pause: function() {
            this._playing && !this._paused && (this._paused = !0,
            this.fire("pause"),
            this._component.fire("pause", this))
        },
        resume: function() {
            this._paused && (this._paused = !1,
            this.fire("resume"),
            this._component.fire("resume", this))
        },
        stop: function() {
            this._playing && (this._paused = this._playing = !1,
            this.frame = this._time = 0,
            this.fire("stop"),
            this._component.fire("stop", this))
        }
    });
    Object.defineProperty(vb.prototype, "spriteAsset", {
        get: function() {
            return this._spriteAsset
        },
        set: function(a) {
            var b = this._component.system.app.assets
              , c = a;
            a instanceof aa && (c = a.id);
            this._spriteAsset !== c && (this._spriteAsset && (a = b.get(this._spriteAsset)) && this._unbindSpriteAsset(a),
            (this._spriteAsset = c) ? (c = b.get(this._spriteAsset)) ? this._bindSpriteAsset(c) : (this.sprite = null,
            b.on("add:" + this._spriteAsset, this._onSpriteAssetAdded, this)) : this.sprite = null)
        }
    });
    Object.defineProperty(vb.prototype, "sprite", {
        get: function() {
            return this._sprite
        },
        set: function(a) {
            this._sprite && (this._sprite.off("set:meshes", this._onSpriteMeshesChange, this),
            this._sprite.off("set:pixelsPerUnit", this._onSpritePpuChanged, this),
            this._sprite.off("set:atlas", this._onSpriteMeshesChange, this),
            this._sprite.atlas && this._sprite.atlas.off("set:texture", this._onSpriteMeshesChange, this));
            if (this._sprite = a)
                if (this._sprite.on("set:meshes", this._onSpriteMeshesChange, this),
                this._sprite.on("set:pixelsPerUnit", this._onSpritePpuChanged, this),
                this._sprite.on("set:atlas", this._onSpriteMeshesChange, this),
                this._sprite.atlas)
                    this._sprite.atlas.on("set:texture", this._onSpriteMeshesChange, this);
            if (this._component.currentClip === this) {
                var b;
                if (a && a.atlas) {
                    if (a.atlas.texture) {
                        if (b = this._component._meshInstance)
                            b.setParameter("texture_emissiveMap", a.atlas.texture),
                            b.setParameter("texture_opacityMap", a.atlas.texture);
                        this._component.enabled && this._component.entity.enabled && this._component._showModel()
                    }
                    this.time && this.fps ? this.time = this.time : this.frame = this.frame
                } else {
                    if (b = this._component._meshInstance)
                        b.deleteParameter("texture_emissiveMap"),
                        b.deleteParameter("texture_opacityMap");
                    this._component._hideModel()
                }
            }
        }
    });
    Object.defineProperty(vb.prototype, "frame", {
        get: function() {
            return this._frame
        },
        set: function(a) {
            this._setFrame(a);
            this._setTime(this._frame / (this.fps || Number.MIN_VALUE))
        }
    });
    Object.defineProperty(vb.prototype, "isPlaying", {
        get: function() {
            return this._playing
        }
    });
    Object.defineProperty(vb.prototype, "isPaused", {
        get: function() {
            return this._paused
        }
    });
    Object.defineProperty(vb.prototype, "duration", {
        get: function() {
            return this._sprite ? this._sprite.frameKeys.length / Math.abs(this.fps || Number.MIN_VALUE) : 0
        }
    });
    Object.defineProperty(vb.prototype, "time", {
        get: function() {
            return this._time
        },
        set: function(a) {
            this._setTime(a);
            this.frame = this._sprite ? Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps))) : 0
        }
    });
    var Ba = function(a, b) {
        O.call(this, a, b);
        this._type = "simple";
        this._material = a.defaultMaterial;
        this._color = new L(1,1,1,1);
        this._colorUniform = new Float32Array(3);
        this._speed = 1;
        this._flipY = this._flipX = !1;
        this._height = this._width = 1;
        this._drawOrder = 0;
        this._layers = [0];
        this._outerScale = new P(1,1);
        this._outerScaleUniform = new Float32Array(2);
        this._innerOffset = new X;
        this._innerOffsetUniform = new Float32Array(4);
        this._atlasRect = new X;
        this._atlasRectUniform = new Float32Array(4);
        this._batchGroupId = -1;
        this._batchGroup = null;
        this._node = new Z;
        this._model = new sb;
        this._model.graph = this._node;
        this._meshInstance = null;
        b.addChild(this._model.graph);
        this._model._entity = b;
        this._updateAabbFunc = this._updateAabb.bind(this);
        this._addedModel = !1;
        this._autoPlayClip = null;
        this._clips = {};
        this._currentClip = this._defaultClip = new vb(this,{
            name: this.entity.name,
            fps: 0,
            loop: !1,
            spriteAsset: null
        })
    };
    Ba.prototype = Object.create(O.prototype);
    Ba.prototype.constructor = Ba;
    Object.assign(Ba.prototype, {
        onEnable: function() {
            var a = this.system.app
              , b = a.scene;
            b.on("set:layers", this._onLayersChanged, this);
            b.layers && (b.layers.on("add", this._onLayerAdded, this),
            b.layers.on("remove", this._onLayerRemoved, this));
            this._showModel();
            this._autoPlayClip && this._tryAutoPlay();
            0 <= this._batchGroupId && a.batcher.insert(bb.SPRITE, this._batchGroupId, this.entity)
        },
        onDisable: function() {
            var a = this.system.app
              , b = a.scene;
            b.off("set:layers", this._onLayersChanged, this);
            b.layers && (b.layers.off("add", this._onLayerAdded, this),
            b.layers.off("remove", this._onLayerRemoved, this));
            this.stop();
            this._hideModel();
            0 <= this._batchGroupId && a.batcher.remove(bb.SPRITE, this._batchGroupId, this.entity)
        },
        onDestroy: function() {
            this._currentClip = null;
            this._defaultClip && (this._defaultClip._destroy(),
            this._defaultClip = null);
            for (var a in this._clips)
                this._clips[a]._destroy();
            this._clips = null;
            this._hideModel();
            this._model = null;
            this._node && (this._node.parent && this._node.parent.removeChild(this._node),
            this._node = null);
            this._meshInstance && (this._meshInstance.material = null,
            this._meshInstance = this._meshInstance.mesh = null)
        },
        _showModel: function() {
            if (!this._addedModel && this._meshInstance) {
                var a, b = [this._meshInstance];
                var c = 0;
                for (a = this._layers.length; c < a; c++) {
                    var d = this.system.app.scene.layers.getLayerById(this._layers[c]);
                    d && d.addMeshInstances(b)
                }
                this._addedModel = !0
            }
        },
        _hideModel: function() {
            if (this._addedModel && this._meshInstance) {
                var a, b = [this._meshInstance];
                var c = 0;
                for (a = this._layers.length; c < a; c++) {
                    var d = this.system.app.scene.layers.getLayerById(this._layers[c]);
                    d && d.removeMeshInstances(b)
                }
                this._addedModel = !1
            }
        },
        _showFrame: function(a) {
            if (this.sprite) {
                var b = this.sprite.meshes[a];
                if (b) {
                    var c = 1 === this.sprite.renderMode ? this.system.default9SlicedMaterialSlicedMode : 2 === this.sprite.renderMode ? this.system.default9SlicedMaterialTiledMode : this.system.defaultMaterial;
                    this._meshInstance || (this._meshInstance = new va(this._node,b,this._material),
                    this._meshInstance.castShadow = !1,
                    this._meshInstance.receiveShadow = !1,
                    this._meshInstance.drawOrder = this._drawOrder,
                    this._model.meshInstances.push(this._meshInstance),
                    this._colorUniform[0] = this._color.r,
                    this._colorUniform[1] = this._color.g,
                    this._colorUniform[2] = this._color.b,
                    this._meshInstance.setParameter("material_emissive", this._colorUniform),
                    this._meshInstance.setParameter("material_opacity", this._color.a),
                    this.enabled && this.entity.enabled && this._showModel());
                    this._meshInstance.material !== c && (this._meshInstance.material = c);
                    this._meshInstance.mesh !== b && (this._meshInstance.mesh = b,
                    this._meshInstance.visible = !0,
                    this._meshInstance._aabbVer = -1);
                    this.sprite.atlas && this.sprite.atlas.texture ? (this._meshInstance.setParameter("texture_emissiveMap", this.sprite.atlas.texture),
                    this._meshInstance.setParameter("texture_opacityMap", this.sprite.atlas.texture)) : (this._meshInstance.deleteParameter("texture_emissiveMap"),
                    this._meshInstance.deleteParameter("texture_opacityMap"));
                    !this.sprite.atlas || 1 !== this.sprite.renderMode && 2 !== this.sprite.renderMode ? this._meshInstance._updateAabbFunc = null : (this._meshInstance._updateAabbFunc = this._updateAabbFunc,
                    (a = this.sprite.atlas.frames[this.sprite.frameKeys[a]]) ? (b = 2 / a.rect.z,
                    c = 2 / a.rect.w,
                    this._innerOffset.set(a.border.x * b, a.border.y * c, a.border.z * b, a.border.w * c),
                    b = this.sprite.atlas.texture,
                    this._atlasRect.set(a.rect.x / b.width, a.rect.y / b.height, a.rect.z / b.width, a.rect.w / b.height)) : this._innerOffset.set(0, 0, 0, 0),
                    this._innerOffsetUniform[0] = this._innerOffset.x,
                    this._innerOffsetUniform[1] = this._innerOffset.y,
                    this._innerOffsetUniform[2] = this._innerOffset.z,
                    this._innerOffsetUniform[3] = this._innerOffset.w,
                    this._meshInstance.setParameter("innerOffset", this._innerOffsetUniform),
                    this._atlasRectUniform[0] = this._atlasRect.x,
                    this._atlasRectUniform[1] = this._atlasRect.y,
                    this._atlasRectUniform[2] = this._atlasRect.z,
                    this._atlasRectUniform[3] = this._atlasRect.w,
                    this._meshInstance.setParameter("atlasRect", this._atlasRectUniform));
                    this._updateTransform()
                } else
                    this._meshInstance && (this._meshInstance.mesh = null,
                    this._meshInstance.visible = !1)
            }
        },
        _updateTransform: function() {
            var a = this.flipX ? -1 : 1
              , b = this.flipY ? -1 : 1
              , c = 0
              , d = 0;
            if (this.sprite && (1 === this.sprite.renderMode || 2 === this.sprite.renderMode)) {
                var e = 1
                  , f = 1;
                if (this.sprite.atlas) {
                    var g = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];
                    g && (e = g.rect.z,
                    f = g.rect.w,
                    c = (.5 - g.pivot.x) * this._width,
                    d = (.5 - g.pivot.y) * this._height)
                }
                e /= this.sprite.pixelsPerUnit;
                f /= this.sprite.pixelsPerUnit;
                this._outerScale.set(Math.max(this._width, this._innerOffset.x * e), Math.max(this._height, this._innerOffset.y * f));
                b *= f;
                this._outerScale.x /= e;
                this._outerScale.y /= f;
                a = a * e * N.clamp(this._width / (this._innerOffset.x * e), 1E-4, 1);
                b *= N.clamp(this._height / (this._innerOffset.y * f), 1E-4, 1);
                this._meshInstance && (this._outerScaleUniform[0] = this._outerScale.x,
                this._outerScaleUniform[1] = this._outerScale.y,
                this._meshInstance.setParameter("outerScale", this._outerScaleUniform))
            }
            this._node.setLocalScale(a, b, 1);
            this._node.setLocalPosition(c, d, 0)
        },
        _updateAabb: function(a) {
            a.center.set(0, 0, 0);
            a.halfExtents.set(.5 * this._outerScale.x, .5 * this._outerScale.y, .001);
            a.setFromTransformedAabb(a, this._node.getWorldTransform());
            return a
        },
        _tryAutoPlay: function() {
            if (this._autoPlayClip && "animated" === this.type) {
                var a = this._clips[this._autoPlayClip];
                !a || a.isPlaying || this._currentClip && this._currentClip.isPlaying || this.enabled && this.entity.enabled && this.play(a.name)
            }
        },
        _onLayersChanged: function(a, b) {
            a.off("add", this.onLayerAdded, this);
            a.off("remove", this.onLayerRemoved, this);
            b.on("add", this.onLayerAdded, this);
            b.on("remove", this.onLayerRemoved, this);
            this.enabled && this.entity.enabled && this._showModel()
        },
        _onLayerAdded: function(a) {
            0 > this.layers.indexOf(a.id) || this._addedModel && this.enabled && this.entity.enabled && this._meshInstance && a.addMeshInstances([this._meshInstance])
        },
        _onLayerRemoved: function(a) {
            this._meshInstance && (0 > this.layers.indexOf(a.id) || a.removeMeshInstances([this._meshInstance]))
        },
        removeModelFromLayers: function() {
            for (var a, b = 0; b < this.layers.length; b++)
                (a = this.system.app.scene.layers.getLayerById(this.layers[b])) && a.removeMeshInstances([this._meshInstance])
        },
        addClip: function(a) {
            var b = new vb(this,{
                name: a.name,
                fps: a.fps,
                loop: a.loop,
                spriteAsset: a.spriteAsset
            });
            this._clips[a.name] = b;
            b.name && b.name === this._autoPlayClip && this._tryAutoPlay();
            return b
        },
        removeClip: function(a) {
            delete this._clips[a]
        },
        clip: function(a) {
            return this._clips[a]
        },
        play: function(a) {
            a = this._clips[a];
            var b = this._currentClip;
            b && b !== a && (b._playing = !1);
            if (this._currentClip = a)
                this._currentClip = a,
                this._currentClip.play();
            return a
        },
        pause: function() {
            this._currentClip !== this._defaultClip && this._currentClip.isPlaying && this._currentClip.pause()
        },
        resume: function() {
            this._currentClip !== this._defaultClip && this._currentClip.isPaused && this._currentClip.resume()
        },
        stop: function() {
            this._currentClip !== this._defaultClip && this._currentClip.stop()
        }
    });
    Object.defineProperty(Ba.prototype, "type", {
        get: function() {
            return this._type
        },
        set: function(a) {
            this._type !== a && (this._type = a,
            "simple" === this._type ? (this.stop(),
            this._currentClip = this._defaultClip,
            this.enabled && this.entity.enabled && (this._currentClip.frame = this.frame,
            this._currentClip.sprite ? this._showModel() : this._hideModel())) : "animated" === this._type && (this.stop(),
            this._autoPlayClip && this._tryAutoPlay(),
            this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled ? this._showModel() : this._hideModel()))
        }
    });
    Object.defineProperty(Ba.prototype, "frame", {
        get: function() {
            return this._currentClip.frame
        },
        set: function(a) {
            this._currentClip.frame = a
        }
    });
    Object.defineProperty(Ba.prototype, "spriteAsset", {
        get: function() {
            return this._defaultClip._spriteAsset
        },
        set: function(a) {
            this._defaultClip.spriteAsset = a
        }
    });
    Object.defineProperty(Ba.prototype, "sprite", {
        get: function() {
            return this._currentClip.sprite
        },
        set: function(a) {
            this._currentClip.sprite = a
        }
    });
    Object.defineProperty(Ba.prototype, "material", {
        get: function() {
            return this._material
        },
        set: function(a) {
            this._material = a;
            this._meshInstance && (this._meshInstance.material = a)
        }
    });
    Object.defineProperty(Ba.prototype, "color", {
        get: function() {
            return this._color
        },
        set: function(a) {
            this._color.r = a.r;
            this._color.g = a.g;
            this._color.b = a.b;
            this._meshInstance && (this._colorUniform[0] = this._color.r,
            this._colorUniform[1] = this._color.g,
            this._colorUniform[2] = this._color.b,
            this._meshInstance.setParameter("material_emissive", this._colorUniform))
        }
    });
    Object.defineProperty(Ba.prototype, "opacity", {
        get: function() {
            return this._color.a
        },
        set: function(a) {
            this._color.a = a;
            this._meshInstance && this._meshInstance.setParameter("material_opacity", a)
        }
    });
    Object.defineProperty(Ba.prototype, "clips", {
        get: function() {
            return this._clips
        },
        set: function(a) {
            var b, c;
            if (a) {
                for (b in this._clips) {
                    var d = !1;
                    for (c in a)
                        if (a[c].name === b) {
                            d = !0;
                            this._clips[b].fps = a[c].fps;
                            this._clips[b].loop = a[c].loop;
                            a[c].hasOwnProperty("sprite") ? this._clips[b].sprite = a[c].sprite : a[c].hasOwnProperty("spriteAsset") && (this._clips[b].spriteAsset = a[c].spriteAsset);
                            break
                        }
                    d || this.removeClip(b)
                }
                for (c in a)
                    this._clips[a[c].name] || this.addClip(a[c]);
                this._autoPlayClip && this._tryAutoPlay();
                this._currentClip && this._currentClip.sprite || this._hideModel()
            } else
                for (b in this._clips)
                    this.removeClip(b)
        }
    });
    Object.defineProperty(Ba.prototype, "currentClip", {
        get: function() {
            return this._currentClip
        }
    });
    Object.defineProperty(Ba.prototype, "speed", {
        get: function() {
            return this._speed
        },
        set: function(a) {
            this._speed = a
        }
    });
    Object.defineProperty(Ba.prototype, "flipX", {
        get: function() {
            return this._flipX
        },
        set: function(a) {
            this._flipX !== a && (this._flipX = a,
            this._updateTransform())
        }
    });
    Object.defineProperty(Ba.prototype, "flipY", {
        get: function() {
            return this._flipY
        },
        set: function(a) {
            this._flipY !== a && (this._flipY = a,
            this._updateTransform())
        }
    });
    Object.defineProperty(Ba.prototype, "width", {
        get: function() {
            return this._width
        },
        set: function(a) {
            a !== this._width && (this._width = a,
            this._outerScale.x = this._width,
            !this.sprite || 2 !== this.sprite.renderMode && 1 !== this.sprite.renderMode || this._updateTransform())
        }
    });
    Object.defineProperty(Ba.prototype, "height", {
        get: function() {
            return this._height
        },
        set: function(a) {
            a !== this._height && (this._height = a,
            this._outerScale.y = this.height,
            !this.sprite || 2 !== this.sprite.renderMode && 1 !== this.sprite.renderMode || this._updateTransform())
        }
    });
    Object.defineProperty(Ba.prototype, "batchGroupId", {
        get: function() {
            return this._batchGroupId
        },
        set: function(a) {
            if (this._batchGroupId !== a) {
                var b = this._batchGroupId;
                this._batchGroupId = a;
                this.entity.enabled && 0 <= b && this.system.app.batcher.remove(bb.SPRITE, b, this.entity);
                this.entity.enabled && 0 <= a ? this.system.app.batcher.insert(bb.SPRITE, a, this.entity) : 0 <= b && this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled && this._showModel()
            }
        }
    });
    Object.defineProperty(Ba.prototype, "autoPlayClip", {
        get: function() {
            return this._autoPlayClip
        },
        set: function(a) {
            this._autoPlayClip = a instanceof vb ? a.name : a;
            this._tryAutoPlay()
        }
    });
    Object.defineProperty(Ba.prototype, "drawOrder", {
        get: function() {
            return this._drawOrder
        },
        set: function(a) {
            this._drawOrder = a;
            this._meshInstance && (this._meshInstance.drawOrder = a)
        }
    });
    Object.defineProperty(Ba.prototype, "layers", {
        get: function() {
            return this._layers
        },
        set: function(a) {
            this._addedModel && this._hideModel();
            this._layers = a;
            this._meshInstance && this.enabled && this.entity.enabled && this._showModel()
        }
    });
    Object.defineProperty(Ba.prototype, "aabb", {
        get: function() {
            return this._meshInstance ? this._meshInstance.aabb : null
        }
    });
    var Bl = ["enabled"];
    Zd.prototype = Object.create(H.prototype);
    Zd.prototype.constructor = Zd;
    O._buildAccessors(Ba.prototype, Bl);
    Object.defineProperties(Zd.prototype, {
        defaultMaterial: {
            get: function() {
                if (!this._defaultMaterial) {
                    var a = new V(this.app.graphicsDevice,{
                        width: 1,
                        height: 1,
                        format: 7
                    })
                      , b = new Uint8Array(a.lock());
                    b[0] = b[1] = b[2] = b[3] = 255;
                    a.name = "sprite";
                    a.unlock();
                    b = new la;
                    b.diffuse.set(0, 0, 0);
                    b.emissive.set(.5, .5, .5);
                    b.emissiveMap = a;
                    b.emissiveMapTint = !0;
                    b.opacityMap = a;
                    b.opacityMapChannel = "a";
                    b.opacityTint = !0;
                    b.opacity = 0;
                    b.useLighting = !1;
                    b.useGammaTonemap = !1;
                    b.useFog = !1;
                    b.useSkybox = !1;
                    b.blendType = 4;
                    b.depthWrite = !1;
                    b.pixelSnap = !1;
                    b.cull = 0;
                    b.update();
                    this._defaultTexture = a;
                    this._defaultMaterial = b
                }
                return this._defaultMaterial
            },
            set: function(a) {
                this._defaultMaterial = a
            }
        },
        default9SlicedMaterialSlicedMode: {
            get: function() {
                if (!this._default9SlicedMaterialSlicedMode) {
                    var a = this.defaultMaterial.clone();
                    a.nineSlicedMode = 1;
                    a.update();
                    this._default9SlicedMaterialSlicedMode = a
                }
                return this._default9SlicedMaterialSlicedMode
            },
            set: function(a) {
                this._default9SlicedMaterialSlicedMode = a
            }
        },
        default9SlicedMaterialTiledMode: {
            get: function() {
                if (!this._default9SlicedMaterialTiledMode) {
                    var a = this.defaultMaterial.clone();
                    a.nineSlicedMode = 2;
                    a.update();
                    this._default9SlicedMaterialTiledMode = a
                }
                return this._default9SlicedMaterialTiledMode
            },
            set: function(a) {
                this._default9SlicedMaterialTiledMode = a
            }
        }
    });
    Object.assign(Zd.prototype, {
        destroy: function() {
            this._defaultTexture && (this._defaultTexture.destroy(),
            this._defaultTexture = null)
        },
        initializeComponentData: function(a, b, c) {
            void 0 !== b.enabled && (a.enabled = b.enabled);
            a.type = b.type;
            b.layers && Array.isArray(b.layers) && (a.layers = b.layers.slice(0));
            void 0 !== b.drawOrder && (a.drawOrder = b.drawOrder);
            void 0 !== b.color && (b.color instanceof L ? a.color.set(b.color.r, b.color.g, b.color.b, void 0 !== b.opacity ? b.opacity : 1) : a.color.set(b.color[0], b.color[1], b.color[2], void 0 !== b.opacity ? b.opacity : 1),
            a.color = a.color);
            void 0 !== b.opacity && (a.opacity = b.opacity);
            void 0 !== b.flipX && (a.flipX = b.flipX);
            void 0 !== b.flipY && (a.flipY = b.flipY);
            void 0 !== b.width && (a.width = b.width);
            void 0 !== b.height && (a.height = b.height);
            void 0 !== b.spriteAsset && (a.spriteAsset = b.spriteAsset);
            b.sprite && (a.sprite = b.sprite);
            void 0 !== b.frame && (a.frame = b.frame);
            if (b.clips)
                for (var d in b.clips)
                    a.addClip(b.clips[d]);
            void 0 !== b.speed && (a.speed = b.speed);
            b.autoPlayClip && (a.autoPlayClip = b.autoPlayClip);
            a.batchGroupId = void 0 === b.batchGroupId || null === b.batchGroupId ? -1 : b.batchGroupId;
            H.prototype.initializeComponentData.call(this, a, b, c)
        },
        cloneComponent: function(a, b) {
            a = a.sprite;
            return this.addComponent(b, {
                enabled: a.enabled,
                type: a.type,
                spriteAsset: a.spriteAsset,
                sprite: a.sprite,
                frame: a.frame,
                color: a.color.clone(),
                opacity: a.opacity,
                flipX: a.flipX,
                flipY: a.flipY,
                speed: a.speed,
                clips: a.clips,
                autoPlayClip: a.autoPlayClip,
                batchGroupId: a.batchGroupId,
                drawOrder: a.drawOrder,
                layers: a.layers.slice(0)
            })
        },
        onUpdate: function(a) {
            var b = this.store, c;
            for (c in b)
                if (b.hasOwnProperty(c)) {
                    var d = b[c];
                    d.data.enabled && d.entity.enabled && (d = d.entity.sprite,
                    d._currentClip && d._currentClip._update(a))
                }
        },
        onBeforeRemove: function(a, b) {
            b.onDestroy()
        }
    });
    nd.prototype = Object.create(O.prototype);
    nd.prototype.constructor = nd;
    Object.assign(nd.prototype, {
        onEnable: function() {
            this._checkState()
        },
        onDisable: function() {
            this._checkState()
        },
        _onSetEnabled: function(a, b, c) {
            this._checkState()
        },
        _checkState: function() {
            var a = this.enabled && this.entity.enabled;
            a !== this._oldState && (this._oldState = a,
            this.fire("enable"),
            this.fire("state", this.enabled))
        },
        _onBeforeRemove: function() {
            this.fire("remove")
        }
    });
    Object.defineProperty(nd.prototype, "size", {
        set: function(a) {
            a instanceof z ? this._size.copy(a) : a instanceof Array && 3 <= a.length && this.size.set(a[0], a[1], a[2])
        },
        get: function() {
            return this._size
        }
    });
    var dn = ["enabled"]
      , Qe = function(a) {
        H.call(this, a);
        this.id = "zone";
        this.ComponentType = nd;
        this.DataType = Eo;
        this.schema = dn;
        this.on("beforeremove", this._onBeforeRemove, this)
    };
    Qe.prototype = Object.create(H.prototype);
    Qe.prototype.constructor = Qe;
    O._buildAccessors(nd.prototype, dn);
    Object.assign(Qe.prototype, {
        initializeComponentData: function(a, b, c) {
            a.enabled = b.hasOwnProperty("enabled") ? !!b.enabled : !0;
            b.size && (b.size instanceof z ? a.size.copy(b.size) : b.size instanceof Array && 3 <= b.size.length && a.size.set(b.size[0], b.size[1], b.size[2]))
        },
        cloneComponent: function(a, b) {
            return this.addComponent(b, {
                size: a.zone.size
            })
        },
        _onBeforeRemove: function(a, b) {
            b._onBeforeRemove()
        }
    });
    kc.prototype.destroy = function() {
        this._app = null
    }
    ;
    kc.prototype.list = function() {
        return this._list
    }
    ;
    kc.prototype.add = function(a, b) {
        if (this._index.hasOwnProperty(a))
            return !1;
        a = new Cl(a,b);
        b = this._list.push(a);
        this._index[a.name] = b - 1;
        this._urlIndex[a.url] = b - 1;
        return !0
    }
    ;
    kc.prototype.find = function(a) {
        return this._index.hasOwnProperty(a) ? this._list[this._index[a]] : null
    }
    ;
    kc.prototype.findByUrl = function(a) {
        return this._urlIndex.hasOwnProperty(a) ? this._list[this._urlIndex[a]] : null
    }
    ;
    kc.prototype.remove = function(a) {
        if (this._index.hasOwnProperty(a)) {
            var b = this._index[a]
              , c = this._list[b];
            delete this._urlIndex[c.url];
            delete this._index[a];
            this._list.splice(b, 1);
            for (b = 0; b < this._list.length; b++)
                c = this._list[b],
                this._index[c.name] = b,
                this._urlIndex[c.url] = b
        }
    }
    ;
    kc.prototype.loadSceneHierarchy = function(a, b) {
        var c = this
          , d = this._app.loader.getHandler("hierarchy");
        this._app.assets && this._app.assets.prefix && !ff.test(a) && (a = ca.join(this._app.assets.prefix, a));
        d.load(a, function(e, f) {
            e ? b && b(e) : c._app._preloadScripts(f, function() {
                c._app.systems.script.preloading = !0;
                var g = d.open(a, f);
                c._app.systems.script.preloading = !1;
                c._app.loader.clearCache(a, "hierarchy");
                c._app.root.addChild(g);
                H.initialize(g);
                H.postInitialize(g);
                b && b(e, g)
            })
        })
    }
    ;
    kc.prototype.loadSceneSettings = function(a, b) {
        var c = this;
        this._app.assets && this._app.assets.prefix && !ff.test(a) && (a = ca.join(this._app.assets.prefix, a));
        this._app.loader.load(a, "scenesettings", function(d, e) {
            d ? b && b(d) : (c._app.applySceneSettings(e),
            b && b(null))
        })
    }
    ;
    kc.prototype.loadScene = function(a, b) {
        var c = this
          , d = this._app.loader.getHandler("scene");
        this._app.assets && this._app.assets.prefix && !ff.test(a) && (a = ca.join(this._app.assets.prefix, a));
        d.load(a, function(e, f) {
            e ? b && b(e) : c._app._preloadScripts(f, function() {
                c._app.systems.script.preloading = !0;
                var g = d.open(a, f);
                c._app.systems.script.preloading = !1;
                c._app.loader.clearCache(a, "scene");
                c._app.loader.patch({
                    resource: g,
                    type: "scene"
                }, c._app.assets);
                c._app.root.addChild(g.root);
                c._app.systems.rigidbody && "undefined" !== typeof Ammo && c._app.systems.rigidbody.gravity.set(g._gravity.x, g._gravity.y, g._gravity.z);
                b && b(null, g)
            })
        })
    }
    ;
    var pf = !1
      , zd = new Z;
    m.app = null;
    ea.prototype = Object.create(M.prototype);
    ea.prototype.constructor = ea;
    ea._currentApplication = null;
    ea._applications = {};
    ea.getApplication = function(a) {
        return a ? ea._applications[a] : ea._currentApplication
    }
    ;
    var en = function(a) {
        this.length = a;
        this.count = 0;
        this.inc = function() {
            this.count++
        }
        ;
        this.done = function() {
            return this.count === this.length
        }
    };
    Object.defineProperty(ea.prototype, "fillMode", {
        get: function() {
            return this._fillMode
        }
    });
    Object.defineProperty(ea.prototype, "resolutionMode", {
        get: function() {
            return this._resolutionMode
        }
    });
    Object.assign(ea.prototype, {
        configure: function(a, b) {
            var c = this;
            wa.get(a, function(d, e) {
                if (d)
                    b(d);
                else {
                    var f = e.scenes
                      , g = e.assets;
                    c._parseApplicationProperties(e.application_properties, function(k) {
                        c._parseScenes(f);
                        c._parseAssets(g);
                        k ? b(k) : b(null)
                    })
                }
            })
        },
        preload: function(a) {
            var b = this, c;
            b.fire("preload:start");
            var d = this.assets.list({
                preload: !0
            })
              , e = new en(d.length)
              , f = !1
              , g = function() {
                b.graphicsDevice && !f && e.done() && (f = !0,
                b.fire("preload:end"),
                a())
            };
            var k = d.length;
            if (e.length) {
                var h = function(n) {
                    e.inc();
                    b.fire("preload:progress", e.count / k);
                    e.done() && g()
                }
                  , l = function(n, p) {
                    e.inc();
                    b.fire("preload:progress", e.count / k);
                    e.done() && g()
                };
                for (c = 0; c < d.length; c++)
                    d[c].loaded ? (e.inc(),
                    b.fire("preload:progress", e.count / k),
                    e.done() && g()) : (d[c].once("load", h),
                    d[c].once("error", l),
                    this.assets.load(d[c]))
            } else
                g()
        },
        getSceneUrl: function(a) {
            return (a = this.scenes.find(a)) ? a.url : null
        },
        loadSceneHierarchy: function(a, b) {
            this.scenes.loadSceneHierarchy(a, b)
        },
        loadSceneSettings: function(a, b) {
            this.scenes.loadSceneSettings(a, b)
        },
        loadScene: function(a, b) {
            this.scenes.loadScene(a, b)
        },
        _preloadScripts: function(a, b) {
            if (ub.legacy) {
                var c = this;
                c.systems.script.preloading = !0;
                a = this._getScriptReferences(a);
                var d = 0
                  , e = a.length
                  , f = new en(e)
                  , g = /^http(s)?:\/\//;
                if (e) {
                    var k = function(l, n) {
                        l && console.error(l);
                        f.inc();
                        f.done() && (c.systems.script.preloading = !1,
                        b())
                    };
                    for (d = 0; d < e; d++) {
                        var h = a[d];
                        !g.test(h.toLowerCase()) && c._scriptPrefix && (h = ca.join(c._scriptPrefix, a[d]));
                        this.loader.load(h, "script", k)
                    }
                } else
                    c.systems.script.preloading = !1,
                    b()
            } else
                b()
        },
        _parseApplicationProperties: function(a, b) {
            a.useDevicePixelRatio || (a.useDevicePixelRatio = a.use_device_pixel_ratio);
            a.resolutionMode || (a.resolutionMode = a.resolution_mode);
            a.fillMode || (a.fillMode = a.fill_mode);
            this._width = a.width;
            this._height = a.height;
            a.useDevicePixelRatio && (this.graphicsDevice.maxPixelRatio = window.devicePixelRatio);
            this.setCanvasResolution(a.resolutionMode, this._width, this._height);
            this.setCanvasFillMode(a.fillMode, this._width, this._height);
            if (a.layers && a.layerOrder) {
                var c = new xa
                  , d = {};
                for (f in a.layers) {
                    var e = a.layers[f];
                    e.id = parseInt(f, 10);
                    e.enabled = 1 !== e.id;
                    d[f] = new ma(e)
                }
                var f = 0;
                for (e = a.layerOrder.length; f < e; f++) {
                    var g = a.layerOrder[f]
                      , k = d[g.layer];
                    k && (g.transparent ? c.pushTransparent(k) : c.pushOpaque(k),
                    c.subLayerEnabled[f] = g.enabled)
                }
                this.scene.layers = c
            }
            if (a.batchGroups)
                for (f = 0,
                e = a.batchGroups.length; f < e; f++)
                    c = a.batchGroups[f],
                    this.batcher.addGroup(c.name, c.dynamic, c.maxAabbSize, c.id, c.layers);
            a.i18nAssets && (this.i18n.assets = a.i18nAssets);
            this._loadLibraries(a.libraries, b)
        },
        _loadLibraries: function(a, b) {
            var c = a.length
              , d = c
              , e = this
              , f = /^http(s)?:\/\//;
            if (c)
                for (var g = function(l, n) {
                    d--;
                    l ? b(l) : 0 === d && (e.onLibrariesLoaded(),
                    b(null))
                }, k = 0; k < c; ++k) {
                    var h = a[k];
                    !f.test(h.toLowerCase()) && e._scriptPrefix && (h = ca.join(e._scriptPrefix, h));
                    this.loader.load(h, "script", g)
                }
            else
                e.onLibrariesLoaded(),
                b(null)
        },
        _parseScenes: function(a) {
            if (a)
                for (var b = 0; b < a.length; b++)
                    this.scenes.add(a[b].name, a[b].url)
        },
        _parseAssets: function(a) {
            var b, c = [], d = {}, e = {};
            if (ub.legacy) {
                if (this.enableBundles)
                    for (f in a)
                        "bundle" === a[f].type && (e[f] = !0,
                        c.push(a[f]));
                for (f in a)
                    e[f] || c.push(a[f])
            } else {
                for (b = 0; b < this.scriptsOrder.length; b++) {
                    var f = this.scriptsOrder[b];
                    a[f] && (d[f] = !0,
                    c.push(a[f]))
                }
                if (this.enableBundles)
                    for (f in a)
                        "bundle" === a[f].type && (e[f] = !0,
                        c.push(a[f]));
                for (f in a)
                    d[f] || e[f] || c.push(a[f])
            }
            for (b = 0; b < c.length; b++) {
                a = c[b];
                f = new aa(a.name,a.type,a.file,a.data);
                f.id = parseInt(a.id, 10);
                f.preload = a.preload ? a.preload : !1;
                f.loaded = "script" === a.type && a.data && 0 < a.data.loadingType;
                f.tags.add(a.tags);
                if (a.i18n)
                    for (var g in a.i18n)
                        f.addLocalizedAssetId(g, a.i18n[g]);
                this.assets.add(f)
            }
        },
        _getScriptReferences: function(a) {
            var b, c, d = [];
            a.settings.priority_scripts && (d = a.settings.priority_scripts);
            var e = []
              , f = {};
            for (b = 0; b < d.length; b++)
                e.push(d[b]),
                f[d[b]] = !0;
            a = a.entities;
            for (c in a)
                if (a[c].components.script)
                    for (d = a[c].components.script.scripts,
                    b = 0; b < d.length; b++)
                        f[d[b].url] || (e.push(d[b].url),
                        f[d[b].url] = !0);
            return e
        },
        start: function() {
            this.frame = 0;
            this.fire("start", {
                timestamp: Lb(),
                target: this
            });
            if (!this._librariesLoaded)
                this.onLibrariesLoaded();
            H.initialize(this.root);
            this.fire("initialize");
            H.postInitialize(this.root);
            this.fire("postinitialize");
            this.tick()
        },
        update: function(a) {
            this.frame++;
            this.graphicsDevice.updateClientRect();
            this.vr && this.vr.poll();
            ub.legacy && H.fixedUpdate(1 / 60, this._inTools);
            H.update(a, this._inTools);
            H.animationUpdate(a, this._inTools);
            H.postUpdate(a, this._inTools);
            this.fire("update", a);
            this.controller && this.controller.update(a);
            this.mouse && this.mouse.update(a);
            this.keyboard && this.keyboard.update(a);
            this.gamepads && this.gamepads.update(a)
        },
        render: function() {
            this.fire("prerender");
            this.root.syncHierarchy();
            this.batcher.updateAll();
            this.renderer.renderComposition(this.scene.layers);
            this.fire("postrender")
        },
        _fillFrameStatsBasic: function(a, b, c) {
            var d = this.stats.frame;
            d.dt = b;
            d.ms = c;
            a > d._timeToCountFrames ? (d.fps = d._fpsAccum,
            d._fpsAccum = 0,
            d._timeToCountFrames = a + 1E3) : d._fpsAccum++;
            this.stats.drawCalls.total = this.graphicsDevice._drawCallsPerFrame;
            this.graphicsDevice._drawCallsPerFrame = 0
        },
        _fillFrameStats: function() {
            var a = this.stats.frame;
            a.cameras = this.renderer._camerasRendered;
            a.materials = this.renderer._materialSwitches;
            a.shaders = this.graphicsDevice._shaderSwitchesPerFrame;
            a.shadowMapUpdates = this.renderer._shadowMapUpdates;
            a.shadowMapTime = this.renderer._shadowMapTime;
            a.depthMapTime = this.renderer._depthMapTime;
            a.forwardTime = this.renderer._forwardTime;
            var b = this.graphicsDevice._primsPerFrame;
            a.triangles = b[4] / 3 + Math.max(b[5] - 2, 0) + Math.max(b[6] - 2, 0);
            a.cullTime = this.renderer._cullTime;
            a.sortTime = this.renderer._sortTime;
            a.skinTime = this.renderer._skinTime;
            a.morphTime = this.renderer._morphTime;
            a.instancingTime = this.renderer._instancingTime;
            for (var c = a.otherPrimitives = 0; c < b.length; c++)
                4 > c && (a.otherPrimitives += b[c]),
                b[c] = 0;
            this.renderer._camerasRendered = 0;
            this.renderer._materialSwitches = 0;
            this.renderer._shadowMapUpdates = 0;
            this.graphicsDevice._shaderSwitchesPerFrame = 0;
            this.renderer._cullTime = 0;
            this.renderer._sortTime = 0;
            this.renderer._skinTime = 0;
            this.renderer._morphTime = 0;
            this.renderer._instancingTime = 0;
            this.renderer._shadowMapTime = 0;
            this.renderer._depthMapTime = 0;
            this.renderer._forwardTime = 0;
            a = this.stats.drawCalls;
            a.forward = this.renderer._forwardDrawCalls;
            a.culled = this.renderer._numDrawCallsCulled;
            a.depth = 0;
            a.shadow = this.renderer._shadowDrawCalls;
            a.skinned = this.renderer._skinDrawCalls;
            a.immediate = 0;
            a.instanced = 0;
            a.removedByInstancing = 0;
            a.misc = a.total - (a.forward + a.shadow);
            this.renderer._depthDrawCalls = 0;
            this.renderer._shadowDrawCalls = 0;
            this.renderer._forwardDrawCalls = 0;
            this.renderer._numDrawCallsCulled = 0;
            this.renderer._skinDrawCalls = 0;
            this.renderer._immediateRendered = 0;
            this.renderer._instancedDrawCalls = 0;
            this.renderer._removedByInstancing = 0;
            this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;
            a = this.stats.particles;
            a.updatesPerFrame = a._updatesPerFrame;
            a.frameTime = a._frameTime;
            a._updatesPerFrame = 0;
            a._frameTime = 0
        },
        setCanvasFillMode: function(a, b, c) {
            this._fillMode = a;
            this.resizeCanvas(b, c)
        },
        setCanvasResolution: function(a, b, c) {
            this._resolutionMode = a;
            "AUTO" === a && void 0 === b && (b = this.graphicsDevice.canvas.clientWidth,
            c = this.graphicsDevice.canvas.clientHeight);
            this.graphicsDevice.resizeCanvas(b, c)
        },
        isHidden: function() {
            return document[this._hiddenAttr]
        },
        onVisibilityChange: function() {
            this.isHidden() ? this._soundManager.suspend() : this._soundManager.resume()
        },
        resizeCanvas: function(a, b) {
            if (this._allowResize && (!this.xr || !this.xr.session)) {
                var c = window.innerWidth
                  , d = window.innerHeight;
                if (this._fillMode === Yg) {
                    var e = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;
                    e > c / d ? (a = c,
                    b = a / e) : (b = d,
                    a = b * e)
                } else
                    "FILL_WINDOW" === this._fillMode && (a = c,
                    b = d);
                this.graphicsDevice.canvas.style.width = a + "px";
                this.graphicsDevice.canvas.style.height = b + "px";
                "AUTO" === this._resolutionMode && this.setCanvasResolution("AUTO");
                return {
                    width: a,
                    height: b
                }
            }
        },
        onLibrariesLoaded: function() {
            this._librariesLoaded = !0;
            this.systems.rigidbody.onLibraryLoaded()
        },
        applySceneSettings: function(a) {
            if (this.systems.rigidbody && "undefined" !== typeof Ammo) {
                var b = a.physics.gravity;
                this.systems.rigidbody.gravity.set(b[0], b[1], b[2])
            }
            this.scene.applySettings(a);
            if (a.render.hasOwnProperty("skybox"))
                if (a.render.skybox)
                    if (b = this.assets.get(a.render.skybox))
                        this.setSkybox(b);
                    else
                        this.assets.once("add:" + a.render.skybox, this.setSkybox, this);
                else
                    this.setSkybox(null)
        },
        setSkybox: function(a) {
            a ? this._skyboxLast === a.id ? 0 !== this.scene.skyboxMip || a.loadFaces ? this._onSkyboxChange(a) : this._skyboxLoad(a) : (this._skyboxLast && (this.assets.off("add:" + this._skyboxLast, this.setSkybox, this),
            this.assets.off("load:" + this._skyboxLast, this._onSkyboxChange, this),
            this.assets.off("remove:" + this._skyboxLast, this._skyboxRemove, this)),
            this._skyboxLast = a.id,
            this.assets.on("load:" + a.id, this._onSkyboxChange, this),
            this.assets.once("remove:" + a.id, this._skyboxRemove, this),
            a.resource && this.scene.setSkybox(a.resources),
            this._skyboxLoad(a)) : this._skyboxLast && this._skyboxRemove({
                id: this._skyboxLast
            })
        },
        enableVr: function() {
            this.vr || (this.vr = new gd(this))
        },
        disableVr: function() {
            this.vr && (this.vr.destroy(),
            this.vr = null)
        },
        _onSkyboxChange: function(a) {
            this.scene.setSkybox(a.resources)
        },
        _skyboxLoad: function(a) {
            0 === this.scene.skyboxMip && (a.loadFaces = !0);
            this.assets.load(a);
            this._onSkyboxChange(a)
        },
        _skyboxRemove: function(a) {
            this._skyboxLast && (this.assets.off("add:" + a.id, this.setSkybox, this),
            this.assets.off("load:" + a.id, this._onSkyboxChange, this),
            this.assets.off("remove:" + a.id, this._skyboxRemove, this),
            this.scene.setSkybox(null),
            this._skyboxLast = null)
        },
        _firstBake: function() {
            this.lightmapper.bake(null, this.scene.lightmapMode)
        },
        _firstBatch: function() {
            this.scene._needsStaticPrepare && (this.renderer.prepareStaticMeshes(this.graphicsDevice, this.scene),
            this.scene._needsStaticPrepare = !1);
            this.batcher.generate()
        },
        _processTimestamp: function(a) {
            return a
        },
        _preRenderImmediate: function() {
            for (var a = 0; a < this._immediateData.lineBatches.length; a++)
                this._immediateData.lineBatches[a] && this._immediateData.lineBatches[a].finalize(this.meshInstanceArray)
        },
        _postRenderImmediate: function() {
            for (var a = 0; a < this._immediateData.layers.length; a++)
                this._immediateData.layers[a].clearMeshInstances(!0);
            this._immediateData.layers.length = 0
        },
        _initImmediate: function() {
            this._immediateData || (this._immediateData = new zg(this.graphicsDevice),
            this.on("prerender", this._preRenderImmediate, this),
            this.on("postrender", this._postRenderImmediate, this))
        },
        _addLines: function(a, b, c) {
            var d = c && c.layer ? c.layer : this.scene.layers.getLayerById(3)
              , e = c && void 0 !== c.depthTest ? c.depthTest : !0;
            c = c && c.mask ? c.mask : void 0;
            this._initImmediate();
            this._immediateData.addLayer(d);
            var f = this._immediateData.getLayerIdx(d);
            void 0 === f ? (f = new Ik,
            f.init(this.graphicsDevice, this._immediateData.lineVertexFormat, d, a.length / 2),
            f.material.depthTest = e,
            c && (f.meshInstance.mask = c),
            f = this._immediateData.lineBatches.push(f) - 1,
            this._immediateData.addLayerIdx(f, d)) : (this._immediateData.lineBatches[f].init(this.graphicsDevice, this._immediateData.lineVertexFormat, d, a.length / 2),
            this._immediateData.lineBatches[f].material.depthTest = e,
            c && (this._immediateData.lineBatches[f].meshInstance.mask = c));
            this._immediateData.lineBatches[f].addLines(a, b)
        },
        renderLine: function(a, b, c, d, e) {
            var f = c;
            if (d instanceof L)
                if (f = d,
                "number" === typeof e) {
                    pf || (console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead"),
                    pf = !0);
                    var g = 1 === e ? {
                        layer: this.scene.layers.getLayerById(3),
                        depthTest: !1
                    } : {
                        layer: this.scene.layers.getLayerById(3),
                        depthTest: !0
                    }
                } else
                    g = e;
            else
                "number" === typeof d ? (pf || (console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead"),
                pf = !0),
                f = c,
                g = 1 === d ? {
                    layer: this.scene.layers.getLayerById(3),
                    depthTest: !1
                } : {
                    layer: this.scene.layers.getLayerById(3),
                    depthTest: !0
                }) : d && (g = d);
            this._addLines([a, b], [c, f], g)
        },
        renderLines: function(a, b, c) {
            c ? "number" === typeof c && (pf || (console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead"),
            pf = !0),
            c = 1 === c ? {
                layer: this.scene.layers.getLayerById(3),
                depthTest: !1
            } : {
                layer: this.scene.layers.getLayerById(3),
                depthTest: !0
            }) : c = {
                layer: this.scene.layers.getLayerById(3),
                depthTest: !0
            };
            b.length && a.length !== b.length ? console.error("renderLines: position/color arrays have different lengths") : 0 !== a.length % 2 ? console.error("renderLines: array length is not divisible by 2") : this._addLines(a, b, c)
        },
        renderWireCube: function(a, b, c) {
            var d;
            this._initImmediate();
            this._immediateData.cubeLocalPos || (this._immediateData.cubeLocalPos = [new z(-.5,-.5,-.5), new z(-.5,.5,-.5), new z(.5,.5,-.5), new z(.5,-.5,-.5), new z(-.5,-.5,.5), new z(-.5,.5,.5), new z(.5,.5,.5), new z(.5,-.5,.5)],
            this._immediateData.cubeWorldPos = [new z, new z, new z, new z, new z, new z, new z, new z]);
            var e = this._immediateData.cubeLocalPos
              , f = this._immediateData.cubeWorldPos;
            for (d = 0; 8 > d; d++)
                a.transformPoint(e[d], f[d]);
            this.renderLines([f[0], f[1], f[1], f[2], f[2], f[3], f[3], f[0], f[4], f[5], f[5], f[6], f[6], f[7], f[7], f[4], f[0], f[4], f[1], f[5], f[2], f[6], f[3], f[7]], b, c)
        },
        renderMeshInstance: function(a, b) {
            b || (b = {
                layer: this.scene.layers.getLayerById(3)
            });
            this._initImmediate();
            this._immediateData.addLayer(b.layer);
            this.meshInstanceArray[0] = a;
            b.layer.addMeshInstances(this.meshInstanceArray, !0)
        },
        renderMesh: function(a, b, c, d) {
            d || (d = {
                layer: this.scene.layers.getLayerById(3)
            });
            this._initImmediate();
            zd.worldTransform = c;
            zd._dirtyWorld = zd._dirtyNormal = !1;
            a = new va(zd,a,b);
            a.cull = !1;
            d.mask && (a.mask = d.mask);
            this._immediateData.addLayer(d.layer);
            this.meshInstanceArray[0] = a;
            d.layer.addMeshInstances(this.meshInstanceArray, !0)
        },
        renderQuad: function(a, b, c) {
            c || (c = {
                layer: this.scene.layers.getLayerById(3)
            });
            this._initImmediate();
            if (!this._immediateData.quadMesh) {
                var d = new Na(this.graphicsDevice,[{
                    semantic: "POSITION",
                    components: 3,
                    type: 6
                }]);
                d = new ab(this.graphicsDevice,d,4);
                var e = new Pb(d);
                e.element.POSITION.set(-.5, -.5, 0);
                e.next();
                e.element.POSITION.set(.5, -.5, 0);
                e.next();
                e.element.POSITION.set(-.5, .5, 0);
                e.next();
                e.element.POSITION.set(.5, .5, 0);
                e.end();
                this._immediateData.quadMesh = new rb(this.graphicsDevice);
                this._immediateData.quadMesh.vertexBuffer = d;
                this._immediateData.quadMesh.primitive[0].type = 5;
                this._immediateData.quadMesh.primitive[0].base = 0;
                this._immediateData.quadMesh.primitive[0].count = 4;
                this._immediateData.quadMesh.primitive[0].indexed = !1
            }
            zd.worldTransform = a;
            zd._dirtyWorld = zd._dirtyNormal = !1;
            a = new va(zd,this._immediateData.quadMesh,b);
            a.cull = !1;
            this.meshInstanceArray[0] = a;
            this._immediateData.addLayer(c.layer);
            c.layer.addMeshInstances(this.meshInstanceArray, !0)
        },
        destroy: function() {
            var a, b = this.graphicsDevice.canvas.id;
            this.off("librariesloaded");
            document.removeEventListener("visibilitychange", this._visibilityChangeHandler, !1);
            document.removeEventListener("mozvisibilitychange", this._visibilityChangeHandler, !1);
            document.removeEventListener("msvisibilitychange", this._visibilityChangeHandler, !1);
            document.removeEventListener("webkitvisibilitychange", this._visibilityChangeHandler, !1);
            this.onVisibilityChange = this._visibilityChangeHandler = null;
            this.root.destroy();
            this.root = null;
            this.mouse && (this.mouse.off(),
            this.mouse.detach(),
            this.mouse = null);
            this.keyboard && (this.keyboard.off(),
            this.keyboard.detach(),
            this.keyboard = null);
            this.touch && (this.touch.off(),
            this.touch.detach(),
            this.touch = null);
            this.elementInput && (this.elementInput.detach(),
            this.elementInput = null);
            this.controller && (this.controller = null);
            var c = this.systems.list;
            var d = 0;
            for (a = c.length; d < a; d++)
                c[d].destroy();
            H.destroy();
            a = this.assets.list();
            for (d = 0; d < a.length; d++)
                a[d].unload(),
                a[d].off();
            this.assets.off();
            this.bundles.destroy();
            this.bundles = null;
            this.i18n.destroy();
            this.i18n = null;
            for (var e in this.loader.getHandler("script")._cache)
                d = this.loader.getHandler("script")._cache[e],
                (a = d.parentNode) && a.removeChild(d);
            this.loader.getHandler("script")._cache = {};
            this.loader.destroy();
            this.loader = null;
            this.scene.destroy();
            this.scene = null;
            this.systems = [];
            this.context = null;
            this.scripts.destroy();
            this.scripts = null;
            this.scenes.destroy();
            this.scenes = null;
            this.lightmapper.destroy();
            this.lightmapper = null;
            this.batcher.destroyManager();
            this.batcher = null;
            this._entityIndex = {};
            this.defaultLayerDepth.onPreRenderOpaque = null;
            this.defaultLayerDepth.onPostRenderOpaque = null;
            this.defaultLayerDepth.onDisable = null;
            this.defaultLayerWorld = this.defaultLayerDepth = this.defaultLayerDepth.onEnable = null;
            Ed && (Ed.destroy(),
            Ed = null);
            this.vr && (this.vr.destroy(),
            this.vr = null);
            this.xr.end();
            this.graphicsDevice.destroy();
            this.tick = this.renderer = this.graphicsDevice = null;
            this.off();
            this._soundManager && (this._soundManager.destroy(),
            this._soundManager = null);
            ub.app = null;
            $b.DEFAULT_PARAM_TEXTURE = null;
            ea._applications[b] = null;
            ea._currentApplication === this && (ea._currentApplication = null)
        },
        getEntityFromIndex: function(a) {
            return this._entityIndex[a]
        }
    });
    var Rh = {}
      , Go = function(a) {
        var b;
        return function(c, d) {
            if (a.graphicsDevice) {
                ea._currentApplication = a;
                b && (window.cancelAnimationFrame(b),
                b = null);
                m.app = a;
                c = a._processTimestamp(c) || Lb();
                var e = c - (a._time || c);
                var f = N.clamp(e / 1E3, 0, a.maxDeltaTime);
                f *= a.timeScale;
                a._time = c;
                b = a.vr && a.vr.display ? a.vr.display.requestAnimationFrame(a.tick) : a.xr.session ? a.xr.session.requestAnimationFrame(a.tick) : window.requestAnimationFrame(a.tick);
                if (!a.graphicsDevice.contextLost) {
                    a._fillFrameStatsBasic(c, f, e);
                    a.fire("frameupdate", e);
                    d ? (a.xr.update(d),
                    a.graphicsDevice.defaultFramebuffer = d.session.renderState.baseLayer.framebuffer) : a.graphicsDevice.defaultFramebuffer = null;
                    a.update(f);
                    a.fire("framerender");
                    if (a.autoRender || a.renderNextFrame)
                        a.render(),
                        a.renderNextFrame = !1;
                    Rh.timestamp = Lb();
                    Rh.target = a;
                    a.fire("frameend", Rh);
                    a.fire("frameEnd", Rh);
                    a.vr && a.vr.display && a.vr.display.presenting && a.vr.display.submitFrame()
                }
            }
        }
    }
      , Ho = 0;
    Object.defineProperty(ka.prototype, "shader", {
        get: function() {
            return this._shader
        },
        set: function(a) {
            this._shader = a
        }
    });
    Object.defineProperty(ka.prototype, "blendType", {
        get: function() {
            if (!this.blend && 1 === this.blendSrc && 0 === this.blendDst && 0 === this.blendEquation)
                return 3;
            if (!this.blend || 6 !== this.blendSrc || 8 !== this.blendDst || 0 !== this.blendEquation) {
                if (this.blend && 1 === this.blendSrc && 1 === this.blendDst && 0 === this.blendEquation)
                    return 1;
                if (this.blend && 6 === this.blendSrc && 1 === this.blendDst && 0 === this.blendEquation)
                    return 6;
                if (this.blend && 4 === this.blendSrc && 2 === this.blendDst && 0 === this.blendEquation)
                    return 7;
                if (this.blend && 5 === this.blendSrc && 1 === this.blendDst && 0 === this.blendEquation)
                    return 8;
                if (this.blend && 1 === this.blendSrc && 1 === this.blendDst && 3 === this.blendEquation)
                    return 9;
                if (this.blend && 1 === this.blendSrc && 1 === this.blendDst && 4 === this.blendEquation)
                    return 10;
                if (this.blend && 4 === this.blendSrc && 0 === this.blendDst && 0 === this.blendEquation)
                    return 5;
                if (this.blend && 1 === this.blendSrc && 8 === this.blendDst && 0 === this.blendEquation)
                    return 4
            }
            return 2
        },
        set: function(a) {
            var b = this.blend;
            switch (a) {
            case 3:
                this.blend = !1;
                this.blendSrc = 1;
                this.blendEquation = this.blendDst = 0;
                break;
            case 2:
                this.blend = !0;
                this.blendSrc = 6;
                this.blendDst = 8;
                this.blendEquation = 0;
                break;
            case 4:
                this.blend = !0;
                this.blendSrc = 1;
                this.blendDst = 8;
                this.blendEquation = 0;
                break;
            case 1:
                this.blend = !0;
                this.blendDst = this.blendSrc = 1;
                this.blendEquation = 0;
                break;
            case 6:
                this.blend = !0;
                this.blendSrc = 6;
                this.blendDst = 1;
                this.blendEquation = 0;
                break;
            case 7:
                this.blend = !0;
                this.blendSrc = 4;
                this.blendDst = 2;
                this.blendEquation = 0;
                break;
            case 8:
                this.blend = !0;
                this.blendSrc = 5;
                this.blendDst = 1;
                this.blendEquation = 0;
                break;
            case 5:
                this.blend = !0;
                this.blendSrc = 4;
                this.blendEquation = this.blendDst = 0;
                break;
            case 9:
                this.blend = !0;
                this.blendDst = this.blendSrc = 1;
                this.blendEquation = 3;
                break;
            case 10:
                this.blend = !0,
                this.blendDst = this.blendSrc = 1,
                this.blendEquation = 4
            }
            b !== this.blend && (this._scene ? this._scene.layers._dirtyBlend = !0 : this._dirtyBlend = !0);
            this._updateMeshInstanceKeys()
        }
    });
    ka.prototype._cloneInternal = function(a) {
        a.name = this.name;
        a.shader = this.shader;
        a.alphaTest = this.alphaTest;
        a.alphaToCoverage = this.alphaToCoverage;
        a.blend = this.blend;
        a.blendSrc = this.blendSrc;
        a.blendDst = this.blendDst;
        a.blendEquation = this.blendEquation;
        a.separateAlphaBlend = this.separateAlphaBlend;
        a.blendSrcAlpha = this.blendSrcAlpha;
        a.blendDstAlpha = this.blendDstAlpha;
        a.blendAlphaEquation = this.blendAlphaEquation;
        a.cull = this.cull;
        a.depthTest = this.depthTest;
        a.depthWrite = this.depthWrite;
        a.depthBias = this.depthBias;
        a.slopeDepthBias = this.slopeDepthBias;
        this.stencilFront && (a.stencilFront = this.stencilFront.clone());
        this.stencilBack && (a.stencilBack = this.stencilFront === this.stencilBack ? a.stencilFront : this.stencilBack.clone());
        a.redWrite = this.redWrite;
        a.greenWrite = this.greenWrite;
        a.blueWrite = this.blueWrite;
        a.alphaWrite = this.alphaWrite
    }
    ;
    ka.prototype.clone = function() {
        var a = new ka;
        this._cloneInternal(a);
        return a
    }
    ;
    ka.prototype._updateMeshInstanceKeys = function() {
        var a, b = this.meshInstances;
        for (a = 0; a < b.length; a++)
            b[a].updateKey()
    }
    ;
    ka.prototype.updateUniforms = function() {}
    ;
    ka.prototype.updateShader = function(a, b, c) {}
    ;
    ka.prototype.update = function() {
        this.dirty = !0;
        this._shader && (this._shader.failed = !1)
    }
    ;
    ka.prototype.clearParameters = function() {
        this.parameters = {}
    }
    ;
    ka.prototype.getParameters = function() {
        return this.parameters
    }
    ;
    ka.prototype.clearVariants = function() {
        this.variants = {};
        for (var a, b = 0; b < this.meshInstances.length; b++) {
            var c = this.meshInstances[b];
            for (a = 0; a < c._shader.length; a++)
                c._shader[a] = null
        }
    }
    ;
    ka.prototype.getParameter = function(a) {
        return this.parameters[a]
    }
    ;
    ka.prototype.setParameter = function(a, b) {
        if (void 0 === b && "object" === typeof a) {
            b = a;
            if (b.length) {
                for (a = 0; a < b.length; a++)
                    this.setParameter(b[a]);
                return
            }
            a = b.name;
            b = b.value
        }
        var c = this.parameters[a];
        c ? c.data = b : this.parameters[a] = {
            scopeId: null,
            data: b
        }
    }
    ;
    ka.prototype.deleteParameter = function(a) {
        this.parameters[a] && delete this.parameters[a]
    }
    ;
    ka.prototype.setParameters = function(a, b) {
        var c = this.parameters;
        void 0 === b && (b = c);
        for (var d in b)
            if (b = c[d])
                b.scopeId || (b.scopeId = a.scope.resolve(d)),
                b.scopeId.setValue(b.data)
    }
    ;
    ka.prototype.destroy = function() {
        this.variants = {};
        this.shader = null;
        for (var a, b, c = 0; c < this.meshInstances.length; c++) {
            a = this.meshInstances[c];
            for (b = 0; b < a._shader.length; b++)
                a._shader[b] = null;
            a._material = null;
            b = ea.getApplication().scene.defaultMaterial;
            this !== b && (a.material = b)
        }
    }
    ;
    Vb.prototype.updateMinRef = function(a, b, c, d, e, f, g, k, h) {
        this._updateSharedOptions(a, d, e, g);
        this._updateMinOptions(a, d);
        this._updateUVOptions(a, d, e, !0)
    }
    ;
    Vb.prototype.updateRef = function(a, b, c, d, e, f, g, k, h) {
        this._updateSharedOptions(a, d, e, g);
        a.useTexCubeLod = b.useTexCubeLod;
        this._updateEnvOptions(a, d, c, h);
        this._updateMaterialOptions(a, d);
        1 === g && (a.gamma && (a.gamma = 3),
        a.toneMap = 0);
        a.hasTangents = e && d.normalMap && 0 !== (e & 512);
        this._updateLightOptions(a, d, e, k, f);
        this._updateUVOptions(a, d, e, !1);
        a.clearCoat = d.clearCoat;
        a.clearCoatGlossiness = d.clearCoatGlossiness
    }
    ;
    Vb.prototype._updateSharedOptions = function(a, b, c, d) {
        a.pass = d;
        a.alphaTest = 0 < b.alphaTest;
        a.forceFragmentPrecision = b.forceFragmentPrecision || "";
        a.chunks = b.chunks || "";
        a.blendType = b.blendType;
        a.forceUv1 = b.forceUv1;
        a.screenSpace = c && 0 !== (c & 256);
        a.skin = c && 0 !== (c & 2);
        a.useInstancing = c && 0 !== (c & 32);
        a.useMorphPosition = c && 0 !== (c & 1024);
        a.useMorphNormal = c && 0 !== (c & 2048);
        a.useMorphTextureBased = c && 0 !== (c & 4096);
        a.nineSlicedMode = b.nineSlicedMode || 0
    }
    ;
    Vb.prototype._updateUVOptions = function(a, b, c, d) {
        var e = !1
          , f = !1
          , g = !1;
        c && (e = 0 !== (c & 4),
        f = 0 !== (c & 8),
        g = 0 !== (c & 16));
        a.vertexColors = !1;
        this._mapXForms = [];
        for (var k in zc)
            this._updateTexOptions(a, b, k, e, f, g, d);
        this._mapXForms = null
    }
    ;
    Vb.prototype._updateMinOptions = function(a, b) {
        a.opacityTint = 1 !== b.opacity && 3 !== b.blendType;
        a.lights = []
    }
    ;
    Vb.prototype._updateMaterialOptions = function(a, b) {
        var c = 1 === b.diffuse.r && 1 === b.diffuse.g && 1 === b.diffuse.b || !b.diffuseTint && (b.diffuseMap || b.diffuseVertexColor) ? 0 : 3
          , d = !1
          , e = (b.useMetalness ? !0 : !!b.specularMap) || !!b.sphereMap || !!b.cubeMap || !!b.dpAtlas;
        (e = (e = (e = e || (b.useMetalness ? !0 : !(0 === b.specular.r && 0 === b.specular.g && 0 === b.specular.b))) || b.enableGGXSpecular) || 0 < b.clearCoat) && (!b.specularTint && (b.specularMap || b.specularVertexColor) || b.useMetalness || (d = 1 !== b.specular.r || 1 !== b.specular.g || 1 !== b.specular.b));
        var f = b.emissiveMap ? 0 : 3;
        f || (f = (f = (1 !== b.emissive.r || 1 !== b.emissive.g || 1 !== b.emissive.b || 1 !== b.emissiveIntensity) && b.emissiveTint) ? 3 : 1 !== b.emissiveIntensity ? 1 : 0);
        var g = b.normalMap ? 10 === b.normalMap.format || "swizzleGGGR" === b.normalMap.type : !1;
        a.opacityTint = 1 !== b.opacity && 3 !== b.blendType ? 1 : 0;
        a.blendMapsWithColors = !0;
        a.ambientTint = b.ambientTint;
        a.diffuseTint = c;
        a.specularTint = d ? 3 : 0;
        a.metalnessTint = b.useMetalness && 1 > b.metalness ? 1 : 0;
        a.glossTint = 1;
        a.emissiveTint = f;
        a.alphaToCoverage = b.alphaToCoverage;
        a.normalizeNormalMap = b.normalizeNormalMap;
        a.sphereMap = !!b.sphereMap;
        a.cubeMap = !!b.cubeMap;
        a.dpAtlas = !!b.dpAtlas;
        a.ambientSH = !!b.ambientSH;
        a.useSpecular = e;
        a.emissiveFormat = b.emissiveMap ? "rgbm" === b.emissiveMap.type ? 1 : 14 === b.emissiveMap.format ? 2 : 0 : null;
        a.lightMapFormat = b.lightMap ? "rgbm" === b.lightMap.type ? 1 : 14 === b.lightMap.format ? 2 : 0 : null;
        a.specularAntialias = b.specularAntialias && !!b.normalMap && !!b.normalMap.mipmaps && !g;
        a.conserveEnergy = b.conserveEnergy;
        a.occludeSpecular = b.occludeSpecular;
        a.occludeSpecularFloat = 1 !== b.occludeSpecularIntensity;
        a.occludeDirect = b.occludeDirect;
        a.shadingModel = b.shadingModel;
        a.fresnelModel = b.fresnelModel;
        a.packedNormal = g;
        a.fastTbn = b.fastTbn;
        a.cubeMapProjection = b.cubeMapProjection;
        a.customFragmentShader = b.customFragmentShader;
        a.refraction = !!b.refraction;
        a.useMetalness = b.useMetalness;
        a.enableGGXSpecular = b.enableGGXSpecular;
        a.msdf = !!b.msdfMap;
        a.twoSidedLighting = b.twoSidedLighting;
        a.pixelSnap = b.pixelSnap;
        a.aoMapUv = b.aoUvSet;
        a.diffuseDetail = !!b.diffuseMap;
        a.normalDetail = !!b.normalMap;
        a.diffuseDetailMode = b.diffuseDetailMode;
        a.detailModes = !!a.diffuseDetail;
        a.clearCoatTint = 1 !== b.clearCoat ? 1 : 0;
        a.clearCoatGlossTint = 1 !== b.clearCoatGlossiness ? 1 : 0
    }
    ;
    Vb.prototype._updateEnvOptions = function(a, b, c, d) {
        var e = d && "rgbm" === d.type || b.cubeMap && "rgbm" === b.cubeMap.type || b.dpAtlas && "rgbm" === b.dpAtlas.type, f = d && ("rgbm" === d.type || 14 === d.format) || b.cubeMap && ("rgbm" === b.cubeMap.type || 14 === b.cubeMap.format) || b.dpAtlas && ("rgbm" === b.dpAtlas.type || 14 === b.dpAtlas.format), g = d && !b.cubeMap && !b.sphereMap && !b.dpAtlas && "rgbm" === d.type || b.cubeMap && "rgbm" === b.cubeMap.type || b.sphereMap && "rgbm" === b.sphereMap.type || b.dpAtlas && "rgbm" === b.dpAtlas.type, k = (!d || b.cubeMap || b.sphereMap || b.dpAtlas ? !1 : "rgbm" === d.type || 14 === d.format) || b.cubeMap && ("rgbm" === b.cubeMap.type || 14 === b.cubeMap.format) || b.sphereMap && ("rgbm" === b.sphereMap.type || 14 === b.sphereMap.format) || b.dpAtlas && ("rgbm" === b.dpAtlas.type || 14 === b.dpAtlas.format), h;
        b.useSkybox && c._skyboxPrefiltered && (h = c._skyboxPrefiltered[0]);
        a.fog = b.useFog ? c.fog : "none";
        a.gamma = b.useGammaTonemap ? c.gammaCorrection : 0;
        a.toneMap = b.useGammaTonemap ? c.toneMapping : -1;
        a.rgbmAmbient = e;
        a.hdrAmbient = f;
        a.rgbmReflection = g;
        a.hdrReflection = k;
        a.useRgbm = g || e || b.emissiveMap && "rgbm" === b.emissiveMap.type || b.lightMap && "rgbm" === b.lightMap.type;
        a.fixSeams = d ? d.fixCubemapSeams : b.cubeMap ? b.cubeMap.fixCubemapSeams : !1;
        a.prefilteredCubemap = !!d;
        a.skyboxIntensity = d && h && d === h && 1 !== c.skyboxIntensity
    }
    ;
    Vb.prototype._updateLightOptions = function(a, b, c, d, e) {
        a.lightMap = !1;
        a.lightMapChannel = "";
        a.lightMapUv = 0;
        a.lightMapTransform = 0;
        a.lightMapWithoutAmbient = !1;
        a.dirLightMap = !1;
        c && (a.noShadow = 0 !== (c & 1),
        0 !== (c & 64) && (a.lightMapFormat = 1,
        a.lightMap = !0,
        a.lightMapChannel = "rgb",
        a.lightMapUv = 1,
        a.lightMapTransform = 0,
        a.lightMapWithoutAmbient = !b.lightMap,
        a.useRgbm = !0,
        0 !== (c & 128) && (a.dirLightMap = !0)));
        b.useLighting ? (b = [],
        c = c ? c >> 16 : 1,
        d && (this._collectLights(0, d[0], b, c),
        this._collectLights(1, d[1], b, c, e),
        this._collectLights(2, d[2], b, c, e)),
        a.lights = b) : a.lights = [];
        0 === a.lights.length && (a.noShadow = !0)
    }
    ;
    Vb.prototype._updateTexOptions = function(a, b, c, d, e, f, g) {
        var k = c + "Map"
          , h = c + "VertexColor"
          , l = c + "VertexColorChannel"
          , n = k + "Channel"
          , p = k + "Transform"
          , q = k + "Uv";
        "light" !== c && (a[k] = !1,
        a[n] = "",
        a[p] = 0,
        a[q] = 0);
        a[h] = !1;
        a[l] = "";
        var r = "opacity" === c;
        if (r && 3 === b.blendType && 0 === b.alphaTest && !b.alphaToCoverage)
            return a;
        if (!g || r)
            "height" !== c && b[h] && f && (a[h] = b[h],
            a[l] = b[l],
            a.vertexColors = !0),
            b[k] && (c = !0,
            0 !== b[q] || d || (c = !1),
            1 !== b[q] || e || (c = !1),
            c && (a[k] = !!b[k],
            a[p] = this._getMapTransformID(b[p], b[q]),
            a[n] = b[n],
            a[q] = b[q]))
    }
    ;
    Vb.prototype._collectLights = function(a, b, c, d, e) {
        var f;
        for (f = 0; f < b.length; f++) {
            var g = b[f];
            g.enabled && g.mask & d && (0 === a || !g.isStatic) && c.push(g)
        }
        if (e)
            for (f = 0; f < e.length; f++)
                g = e[f],
                g._type === a && c.push(g)
    }
    ;
    Vb.prototype._getMapTransformID = function(a, b) {
        if (!a)
            return 0;
        this._mapXForms[b] || (this._mapXForms[b] = []);
        var c;
        for (c = 0; c < this._mapXForms[b].length && this._mapXForms[b][c][0] == a.x && this._mapXForms[b][c][1] == a.y && this._mapXForms[b][c][2] == a.z && this._mapXForms[b][c][3] == a.w; )
            return c + 1;
        c = this._mapXForms[b].length;
        this._mapXForms[b][c] = [];
        this._mapXForms[b][c][0] = a.x;
        this._mapXForms[b][c][1] = a.y;
        this._mapXForms[b][c][2] = a.z;
        this._mapXForms[b][c][3] = a.w;
        return c + 1
    }
    ;
    la.prototype = Object.create(ka.prototype);
    la.prototype.constructor = la;
    la.TEXTURE_PARAMETERS = kf;
    la.CUBEMAP_PARAMETERS = Eh;
    var Ra = []
      , fn = []
      , qk = []
      , rk = []
      , pe = {}
      , pb = function(a, b, c, d, e, f, g) {
        var k = "_" + b + "Map"
          , h = k + "Tiling"
          , l = k + "Offset"
          , n = k.substring(1) + "Transform"
          , p = n + "Uniform"
          , q = k + "Uv"
          , r = k + "Channel"
          , t = "_" + b + "VertexColor"
          , u = "_" + b + "VertexColorChannel"
          , x = "_" + b + "Mode";
        a[k] = null;
        a[h] = new P(1,1);
        a[l] = new P(0,0);
        a[n] = null;
        a[p] = null;
        a[q] = c;
        0 < d && (c = e ? e : 1 < d ? "rgb" : "g",
        a[r] = c,
        f && (a[u] = c));
        f && (a[t] = !1);
        g && (a[x] = "mul");
        zc[b] = d;
        Object.defineProperty(la.prototype, k.substring(1), {
            get: function() {
                return this[k]
            },
            set: function(v) {
                var w = this[k];
                !!w ^ !!v && (this.dirtyShader = !0);
                w && v && (w.type !== v.type || w.fixCubemapSeams !== v.fixCubemapSeams || w.format !== v.format) && (this.dirtyShader = !0);
                this[k] = v
            }
        });
        a = h.substring(1);
        b = l.substring(1);
        Object.defineProperty(la.prototype, a, {
            get: function() {
                return this[h]
            },
            set: function(v) {
                this.dirtyShader = !0;
                this[h] = v
            }
        });
        pe[a] = function(v, w, y) {
            v = v._updateMapTransform(y ? v[n] : null, w, v[l]);
            return {
                name: "texture_" + n,
                value: v.data
            }
        }
        ;
        Object.defineProperty(la.prototype, b, {
            get: function() {
                return this[l]
            },
            set: function(v) {
                this.dirtyShader = !0;
                this[l] = v
            }
        });
        pe[b] = function(v, w, y) {
            v = v._updateMapTransform(y ? v[n] : null, v[h], w);
            return {
                name: "texture_" + n,
                value: v.data
            }
        }
        ;
        Object.defineProperty(la.prototype, q.substring(1), {
            get: function() {
                return this[q]
            },
            set: function(v) {
                this[q] !== v && (this.dirtyShader = !0);
                this[q] = v
            }
        });
        Object.defineProperty(la.prototype, r.substring(1), {
            get: function() {
                return this[r]
            },
            set: function(v) {
                this[r] !== v && (this.dirtyShader = !0);
                this[r] = v
            }
        });
        f && (Object.defineProperty(la.prototype, t.substring(1), {
            get: function() {
                return this[t]
            },
            set: function(v) {
                this.dirtyShader = !0;
                this[t] = v
            }
        }),
        Object.defineProperty(la.prototype, u.substring(1), {
            get: function() {
                return this[u]
            },
            set: function(v) {
                this[u] !== v && (this.dirtyShader = !0);
                this[u] = v
            }
        }));
        g && Object.defineProperty(la.prototype, x.substring(1), {
            get: function() {
                return this[x]
            },
            set: function(v) {
                this.dirtyShader = !0;
                this[x] = v
            }
        });
        Ra.push(k.substring(1));
        Ra.push(h.substring(1));
        Ra.push(l.substring(1));
        Ra.push(q.substring(1));
        Ra.push(r.substring(1));
        f && (Ra.push(t.substring(1)),
        Ra.push(u.substring(1)));
        g && Ra.push(x.substring(1));
        qk.push(n)
    }
      , Sh = []
      , Th = function(a, b, c, d) {
        var e = "_" + b
          , f = b + "Uniform"
          , g = b + "Intensity"
          , k = "_" + g;
        a[e] = c;
        a[f] = new Float32Array(3);
        Object.defineProperty(la.prototype, b, {
            get: function() {
                this.dirtyShader = this.dirtyColor = !0;
                return this[e]
            },
            set: function(h) {
                var l = this[e];
                (0 === l.r && 0 === l.g && 0 === l.b || 1 === l.r && 1 === l.g && 1 === l.b) ^ (0 === h.r && 0 === h.g && 0 === h.b || 1 === h.r && 1 === h.g && 1 === h.b) && (this.dirtyShader = !0);
                this.dirtyColor = !0;
                this[e] = h
            }
        });
        Ra.push(b);
        rk.push(f);
        Sh.push(b);
        pe[b] = function(h, l, n) {
            n = n ? h[f] : new Float32Array(3);
            var p = !1;
            h.useGammaTonemap && (p = (h._scene || ea.getApplication().scene).gammaCorrection);
            for (var q = 0; 3 > q; q++)
                n[q] = p ? Math.pow(l.data[q], 2.2) : l.data[q],
                d && (n[q] *= h[k]);
            return {
                name: "material_" + b,
                value: n
            }
        }
        ;
        d && (a[k] = 1,
        Object.defineProperty(la.prototype, g, {
            get: function() {
                return this[k]
            },
            set: function(h) {
                var l = this[k];
                (0 === l || 1 === l) ^ (0 === h || 1 === h) && (this.dirtyShader = !0);
                this.dirtyColor = !0;
                this[k] = h
            }
        }),
        Ra.push(g),
        pe[g] = function(h, l, n) {
            l = n ? h[f] : new Float32Array(3);
            n = !1;
            h.useGammaTonemap && (n = (h._scene || ea.getApplication().scene).gammaCorrection);
            for (var p = 0; 3 > p; p++)
                l[p] = n ? Math.pow(h[e].data[p], 2.2) : h[e].data[p],
                l[p] *= h[k];
            return {
                name: "material_" + b,
                value: l
            }
        }
        )
    }
      , qb = function(a, b, c, d) {
        var e = "_" + b;
        a[e] = c;
        Object.defineProperty(la.prototype, b, {
            get: function() {
                return this[e]
            },
            set: function(f) {
                var g = this[e];
                g !== f && (this[e] = f,
                0 === g || 1 === g || 0 === f || 1 === f) && (this.dirtyShader = !0)
            }
        });
        Ra.push(b);
        pe[b] = void 0 !== d ? d : function(f, g, k) {
            return {
                name: "material_" + b,
                value: g
            }
        }
    }
      , sc = function(a, b, c) {
        var d = "_" + b;
        a[d] = null;
        Object.defineProperty(la.prototype, b, {
            get: function() {
                return this[d]
            },
            set: function(e) {
                !!this[d] ^ !!e && (this.dirtyShader = !0);
                this[d] = e
            }
        });
        Ra.push(b);
        pe[b] = c
    }
      , tc = function(a, b, c) {
        Object.defineProperty(la.prototype, c, {
            get: function() {
                return this[b]
            },
            set: function(d) {
                this[b] = d
            }
        })
    }
      , Up = function(a) {
        Object.defineProperty(la.prototype, "chunks", {
            get: function() {
                this.dirtyShader = !0;
                return this._chunks
            },
            set: function(b) {
                this.dirtyShader = !0;
                this._chunks = b
            }
        });
        Ra.push("chunks")
    }
      , Fa = function(a, b, c) {
        var d = "_" + b;
        a[d] = c;
        Object.defineProperty(la.prototype, b, {
            get: function() {
                return this[d]
            },
            set: function(e) {
                this[d] !== e && (this.dirtyShader = !0);
                this[d] = e
            }
        });
        Ra.push(b)
    }
      , gn = function() {};
    gn.prototype.copy = function(a) {
        for (var b in a)
            a.hasOwnProperty(b) && "copy" !== b && (this[b] = a[b])
    }
    ;
    Object.assign(la.prototype, {
        reset: function() {
            var a;
            for (a = 0; a < Ra.length; a++) {
                var b = fn[a];
                this[Ra[a]] = b ? b.clone ? b.clone() : b : b
            }
            for (a = 0; a < qk.length; a++)
                this[qk[a]] = null;
            for (a = 0; a < rk.length; a++)
                this[rk[a]] = new Float32Array(3);
            this._chunks = new gn;
            this.cubeMapMinUniform = new Float32Array(3);
            this.cubeMapMaxUniform = new Float32Array(3)
        },
        clone: function() {
            var a = new la;
            ka.prototype._cloneInternal.call(this, a);
            for (var b, c = 0; c < Ra.length; c++)
                b = Ra[c],
                void 0 !== this[b] && (this[b] && this[b].copy ? a[b] ? a[b].copy(this[b]) : a[b] = this[b].clone() : a[b] = this[b]);
            return a
        },
        _updateMapTransform: function(a, b, c) {
            if (1 === b.x && 1 === b.y && 0 === c.x && 0 === c.y)
                return null;
            a = a || new X;
            a.set(b.x, b.y, c.x, c.y);
            return a
        },
        _setParameter: function(a, b) {
            this.parameters[a] || this._propsSet.push(a);
            this.setParameter(a, b)
        },
        _clearParameters: function() {
            for (var a = this._propsSet, b = 0; b < a.length; b++)
                delete this.parameters[a[b]];
            this._propsSet = []
        },
        _updateMap: function(a) {
            var b = a + "Map";
            if (a = this[b]) {
                this._setParameter("texture_" + b, a);
                a = b + "Transform";
                this[a] = this._updateMapTransform(this[a], this[b + "Tiling"], this[b + "Offset"]);
                var c = this[a];
                if (c) {
                    b += "TransformUniform";
                    var d = this[b];
                    d || (d = new Float32Array(4),
                    this[b] = d);
                    d[0] = c.x;
                    d[1] = c.y;
                    d[2] = c.z;
                    d[3] = c.w;
                    this._setParameter("texture_" + a, d)
                }
            }
        },
        getUniform: function(a, b, c) {
            return (a = pe[a]) ? a(this, b, c) : null
        },
        updateUniforms: function() {
            this._clearParameters();
            this._setParameter("material_ambient", this.ambientUniform);
            this.diffuseMap && !this.diffuseTint || this._setParameter("material_diffuse", this.diffuseUniform);
            this.useMetalness ? ((!this.metalnessMap || 1 > this.metalness) && this._setParameter("material_metalness", this.metalness),
            this.enableGGXSpecular && this._setParameter("material_anisotropy", this.anisotropy)) : this.specularMap && !this.specularTint || this._setParameter("material_specular", this.specularUniform);
            0 < this.clearCoat && (this._setParameter("material_clearCoat", this.clearCoat),
            this._setParameter("material_clearCoatGlossiness", this.clearCoatGlossiness),
            this._setParameter("material_clearCoatReflectivity", this.clearCoat),
            this._setParameter("material_clearCoatBumpiness", this.clearCoatBumpiness));
            var a = this.getUniform("shininess", this.shininess, !0);
            this._setParameter(a.name, a.value);
            this.emissiveMap && !this.emissiveTint || this._setParameter("material_emissive", this.emissiveUniform);
            this.emissiveMap && this._setParameter("material_emissiveIntensity", this.emissiveIntensity);
            0 < this.refraction && (this._setParameter("material_refraction", this.refraction),
            this._setParameter("material_refractionIndex", this.refractionIndex));
            this._setParameter("material_opacity", this.opacity);
            this.occludeSpecular && this._setParameter("material_occludeSpecularIntensity", this.occludeSpecularIntensity);
            1 === this.cubeMapProjection && this._setParameter(this.getUniform("cubeMapProjectionBox", this.cubeMapProjectionBox, !0));
            for (var b in zc)
                this._updateMap(b);
            this.ambientSH && this._setParameter("ambientSH[0]", this.ambientSH);
            this.normalMap && this._setParameter("material_bumpiness", this.bumpiness);
            this.normalMap && this.normalDetailMap && this._setParameter("material_normalDetailMapBumpiness", this.normalDetailMapBumpiness);
            this.heightMap && (a = this.getUniform("heightMapFactor", this.heightMapFactor, !0),
            this._setParameter(a.name, a.value));
            this.cubeMap && this._setParameter("texture_cubeMap", this.cubeMap);
            this.prefilteredCubeMap128 ? this._setParameter("texture_prefilteredCubeMap128", this.prefilteredCubeMap128) : this._scene && this._scene._skyboxPrefiltered[0] && this._setParameter("texture_prefilteredCubeMap128", this._scene._skyboxPrefiltered[0]);
            this.prefilteredCubeMap64 ? this._setParameter("texture_prefilteredCubeMap64", this.prefilteredCubeMap64) : this._scene && this._scene._skyboxPrefiltered[1] && this._setParameter("texture_prefilteredCubeMap64", this._scene._skyboxPrefiltered[1]);
            this.prefilteredCubeMap32 ? this._setParameter("texture_prefilteredCubeMap32", this.prefilteredCubeMap32) : this._scene && this._scene._skyboxPrefiltered[2] && this._setParameter("texture_prefilteredCubeMap32", this._scene._skyboxPrefiltered[2]);
            this.prefilteredCubeMap16 ? this._setParameter("texture_prefilteredCubeMap16", this.prefilteredCubeMap16) : this._scene && this._scene._skyboxPrefiltered[3] && this._setParameter("texture_prefilteredCubeMap16", this._scene._skyboxPrefiltered[3]);
            this.prefilteredCubeMap8 ? this._setParameter("texture_prefilteredCubeMap8", this.prefilteredCubeMap8) : this._scene && this._scene._skyboxPrefiltered[4] && this._setParameter("texture_prefilteredCubeMap8", this._scene._skyboxPrefiltered[4]);
            this.prefilteredCubeMap4 ? this._setParameter("texture_prefilteredCubeMap4", this.prefilteredCubeMap4) : this._scene && this._scene._skyboxPrefiltered[5] && this._setParameter("texture_prefilteredCubeMap4", this._scene._skyboxPrefiltered[5]);
            this.sphereMap && this._setParameter("texture_sphereMap", this.sphereMap);
            this.dpAtlas && this._setParameter("texture_sphereMap", this.dpAtlas);
            this._setParameter("material_reflectivity", this.reflectivity);
            if (this.dirtyShader || !this._scene)
                this.shader = null,
                this.clearVariants();
            this._processColor()
        },
        _processColor: function() {
            var a;
            if (this.dirtyColor && (this._scene || !this.useGammaTonemap)) {
                var b = !1;
                this.useGammaTonemap && (b = this._scene.gammaCorrection);
                for (a = 0; a < Sh.length; a++) {
                    var c = this["_" + Sh[a]]
                      , d = this[Sh[a] + "Uniform"];
                    b ? (d[0] = Math.pow(c.r, 2.2),
                    d[1] = Math.pow(c.g, 2.2),
                    d[2] = Math.pow(c.b, 2.2)) : (d[0] = c.r,
                    d[1] = c.g,
                    d[2] = c.b)
                }
                for (a = 0; 3 > a; a++)
                    this.emissiveUniform[a] *= this.emissiveIntensity;
                this.dirtyColor = !1
            }
        },
        updateShader: function(a, b, c, d, e, f) {
            !this._colorProcessed && this._scene && (this._colorProcessed = !0,
            this._processColor());
            var g = a.useTexCubeLod
              , k = !a.extTextureLod;
            if (this.useSkybox) {
                var h = b._skyboxPrefiltered[0];
                var l = b._skyboxPrefiltered[1];
                var n = b._skyboxPrefiltered[2];
                var p = b._skyboxPrefiltered[3];
                var q = b._skyboxPrefiltered[4];
                var r = b._skyboxPrefiltered[5]
            }
            h = this.prefilteredCubeMap128 || h;
            l = this.prefilteredCubeMap64 || l;
            n = this.prefilteredCubeMap32 || n;
            p = this.prefilteredCubeMap16 || p;
            q = this.prefilteredCubeMap8 || q;
            r = this.prefilteredCubeMap4 || r;
            if (h) {
                var t = h && l && n && p && q && r;
                if (k && t) {
                    if (!h.dpAtlas) {
                        g = [h, l, n, p, q, r];
                        k = new X;
                        r = new X;
                        l = 4 * g[0].width;
                        q = Wa(a, F.fullscreenQuadVS, F.dpAtlasQuadPS, "dpAtlasQuad");
                        n = a.scope.resolve("source");
                        t = a.scope.resolve("params");
                        var u = new V(a,{
                            type: g[0].type,
                            format: g[0].format,
                            width: l,
                            height: l,
                            mipmaps: !1
                        });
                        u.name = "paraboloid";
                        for (var x = new ra(a,u,{
                            depth: !1
                        }), v = (l + 2) / l - 1, w = 0; 6 > w; w++) {
                            var y = a;
                            var A = g[w]
                              , B = w
                              , E = Wa(y, F.fullscreenQuadVS, (A.fixCubemapSeams ? F.fixCubemapSeamsStretchPS : F.fixCubemapSeamsNonePS) + F.genParaboloidPS, "genParaboloid")
                              , C = y.scope.resolve("source")
                              , D = y.scope.resolve("params")
                              , G = new X
                              , J = A.width
                              , R = A.format;
                            J = 2 * Math.max(J, 8);
                            J = new V(y,{
                                type: A.type,
                                format: R,
                                width: 2 * J,
                                height: J,
                                mipmaps: !1
                            });
                            J.name = "paraboloid";
                            R = new ra(y,J,{
                                depth: !1
                            });
                            G.x = B;
                            G.y = 1;
                            C.setValue(A);
                            D.setValue(G.data);
                            La(y, R, E);
                            y = J;
                            n.setValue(y);
                            y = k;
                            A = w;
                            y.x = .5 * N.clamp(A - 2, 0, 1);
                            A -= 6 * y.x;
                            B = 1 - y.x;
                            y.y = Math.min(.5 * A, .75) * B + y.x;
                            y.z = (1 - .5 * N.clamp(A, 0, 1)) * B;
                            y.w = .5 * y.z;
                            y = 1 / y.z;
                            r.x = y * v;
                            r.y = 2 * r.x;
                            r.x += 1;
                            r.y += 1;
                            t.setValue(r.data);
                            k.x *= l;
                            k.y *= l;
                            k.z *= l;
                            k.w *= l;
                            La(a, x, q, k)
                        }
                        h.dpAtlas = u;
                        h.sh = Gl(p)
                    }
                    this.dpAtlas = h.dpAtlas;
                    this.ambientSH = h.sh;
                    this._setParameter("ambientSH[0]", this.ambientSH);
                    this._setParameter("texture_sphereMap", this.dpAtlas)
                } else
                    g ? 6 > h._levels.length ? t ? this._setParameter("texture_prefilteredCubeMap128", h) : console.log("Can't use prefiltered cubemap: " + t + ", " + g + ", " + h._levels) : this._setParameter("texture_prefilteredCubeMap128", h) : t ? (this._setParameter("texture_prefilteredCubeMap128", h),
                    this._setParameter("texture_prefilteredCubeMap64", l),
                    this._setParameter("texture_prefilteredCubeMap32", n),
                    this._setParameter("texture_prefilteredCubeMap16", p),
                    this._setParameter("texture_prefilteredCubeMap8", q),
                    this._setParameter("texture_prefilteredCubeMap4", r)) : console.log("Can't use prefiltered cubemap: " + t + ", " + g + ", " + h._levels)
            }
            g = (p = 1 < e && 18 >= e) ? Oj.optionsContextMin : Oj.optionsContext;
            p ? this.shaderOptBuilder.updateMinRef(g, a, b, this, c, d, e, f, h) : this.shaderOptBuilder.updateRef(g, a, b, this, c, d, e, f, h);
            this.onUpdateShader && (g = this.onUpdateShader(g));
            this.shader = a.getProgramLibrary().getProgram("standard", g);
            c || (this.clearVariants(),
            this.variants[0] = this.shader);
            this.dirtyShader = !1
        }
    });
    (function(a) {
        a.dirtyShader = !0;
        a.dirtyColor = !0;
        a._scene = null;
        a._colorProcessed = !1;
        Th(a, "ambient", new L(.7,.7,.7));
        Th(a, "diffuse", new L(1,1,1));
        Th(a, "specular", new L(0,0,0));
        Th(a, "emissive", new L(0,0,0), !0);
        qb(a, "shininess", 25, function(c, d) {
            return {
                name: "material_shininess",
                value: 0 === c.shadingModel ? Math.pow(2, .11 * d) : .01 * d
            }
        });
        qb(a, "heightMapFactor", 1, function(c, d) {
            return {
                name: "material_heightMapFactor",
                value: .025 * d
            }
        });
        qb(a, "opacity", 1);
        qb(a, "alphaTest", 0);
        qb(a, "bumpiness", 1);
        qb(a, "normalDetailMapBumpiness", 1);
        qb(a, "reflectivity", 1);
        qb(a, "occludeSpecularIntensity", 1);
        qb(a, "refraction", 0);
        qb(a, "refractionIndex", 1 / 1.5);
        qb(a, "metalness", 1);
        qb(a, "anisotropy", 0);
        qb(a, "clearCoat", 0);
        qb(a, "clearCoatGlossiness", 1);
        qb(a, "clearCoatBumpiness", 1);
        qb(a, "aoUvSet", 0, null);
        sc(a, "ambientSH", function(c, d, e) {
            return {
                name: "ambientSH[0]",
                value: d
            }
        });
        sc(a, "cubeMapProjectionBox", function(c, d, e) {
            var f = e ? c.cubeMapMinUniform : new Float32Array(3);
            c = e ? c.cubeMapMaxUniform : new Float32Array(3);
            f[0] = d.center.x - d.halfExtents.x;
            f[1] = d.center.y - d.halfExtents.y;
            f[2] = d.center.z - d.halfExtents.z;
            c[0] = d.center.x + d.halfExtents.x;
            c[1] = d.center.y + d.halfExtents.y;
            c[2] = d.center.z + d.halfExtents.z;
            return [{
                name: "envBoxMin",
                value: f
            }, {
                name: "envBoxMax",
                value: c
            }]
        });
        Up();
        Fa(a, "ambientTint", !1);
        Fa(a, "diffuseTint", !1);
        Fa(a, "specularTint", !1);
        Fa(a, "emissiveTint", !1);
        Fa(a, "fastTbn", !1);
        Fa(a, "specularAntialias", !1);
        Fa(a, "useMetalness", !1);
        Fa(a, "enableGGXSpecular", !1);
        Fa(a, "occludeDirect", !1);
        Fa(a, "normalizeNormalMap", !0);
        Fa(a, "conserveEnergy", !0);
        Fa(a, "occludeSpecular", 1);
        Fa(a, "shadingModel", 1);
        Fa(a, "fresnelModel", 0);
        Fa(a, "cubeMapProjection", 0);
        Fa(a, "customFragmentShader", null);
        Fa(a, "forceFragmentPrecision", null);
        Fa(a, "useFog", !0);
        Fa(a, "useLighting", !0);
        Fa(a, "useGammaTonemap", !0);
        Fa(a, "useSkybox", !0);
        Fa(a, "forceUv1", !1);
        Fa(a, "pixelSnap", !1);
        Fa(a, "twoSidedLighting", !1);
        Fa(a, "nineSlicedMode", void 0);
        pb(a, "diffuse", 0, 3, "", !0);
        pb(a, "specular", 0, 3, "", !0);
        pb(a, "emissive", 0, 3, "", !0);
        pb(a, "normal", 0, -1, "", !1);
        pb(a, "metalness", 0, 1, "", !0);
        pb(a, "gloss", 0, 1, "", !0);
        pb(a, "opacity", 0, 1, "a", !0);
        pb(a, "height", 0, 1, "", !1);
        pb(a, "ao", 0, 1, "", !0);
        pb(a, "light", 1, 3, "", !0);
        pb(a, "msdf", 0, 3, "", !1);
        pb(a, "diffuseDetail", 0, 3, "", !1, !0);
        pb(a, "normalDetail", 0, -1, "", !1);
        pb(a, "clearCoat", 0, 1, "", !0);
        pb(a, "clearCoatGloss", 0, 1, "", !0);
        pb(a, "clearCoatNormal", 0, -1, "", !1);
        sc(a, "cubeMap");
        sc(a, "sphereMap");
        sc(a, "dpAtlas");
        sc(a, "prefilteredCubeMap128");
        sc(a, "prefilteredCubeMap64");
        sc(a, "prefilteredCubeMap32");
        sc(a, "prefilteredCubeMap16");
        sc(a, "prefilteredCubeMap8");
        sc(a, "prefilteredCubeMap4");
        tc(a, "diffuseTint", "diffuseMapTint");
        tc(a, "specularTint", "specularMapTint");
        tc(a, "emissiveTint", "emissiveMapTint");
        tc(a, "aoVertexColor", "aoMapVertexColor");
        tc(a, "diffuseVertexColor", "diffuseMapVertexColor");
        tc(a, "specularVertexColor", "specularMapVertexColor");
        tc(a, "emissiveVertexColor", "emissiveMapVertexColor");
        tc(a, "metalnessVertexColor", "metalnessMapVertexColor");
        tc(a, "glossVertexColor", "glossMapVertexColor");
        tc(a, "opacityVertexColor", "opacityMapVertexColor");
        tc(a, "lightVertexColor", "lightMapVertexColor");
        for (var b = 0; b < Ra.length; b++)
            fn[b] = a[Ra[b]];
        a._propsSet = []
    }
    )(la.prototype);
    Jb.prototype.register = function(a, b) {
        this.isRegistered(a) || (this._generators[a] = b)
    }
    ;
    Jb.prototype.unregister = function(a) {
        this.isRegistered(a) && delete this._generators[a]
    }
    ;
    Jb.prototype.isRegistered = function(a) {
        return void 0 !== this._generators[a]
    }
    ;
    Jb.prototype.getProgram = function(a, b) {
        var c = this._generators[a];
        if (void 0 === c)
            return null;
        var d = this._device
          , e = c.generateKey(b)
          , f = this._cache[e];
        if (!f) {
            if (b.lights) {
                var g = b.lights;
                b.lights = g.map(function(k) {
                    var h = k.clone ? k.clone() : k;
                    h.key = k.key;
                    return h
                })
            }
            this.storeNewProgram(a, b);
            b.lights && (b.lights = g);
            this._precached && console.warn("ProgramLibrary#getProgram: Cache miss for shader", a, "key", e, "after shaders precaching");
            a = c.createShaderDefinition(d, b);
            f = this._cache[e] = new re(d,a)
        }
        return f
    }
    ;
    Jb.prototype.storeNewProgram = function(a, b) {
        var c = {};
        if ("standard" === a) {
            var d = this._getDefaultStdMatOptions(b.pass), e;
            for (e in b)
                if (b.hasOwnProperty(e) && d[e] !== b[e] || "pass" === e)
                    c[e] = b[e]
        } else
            c = b;
        this._programsCollection.push(JSON.stringify({
            name: a,
            options: c
        }))
    }
    ;
    Jb.prototype.dumpPrograms = function() {
        var a = "var device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\nvar shaders = [";
        this._programsCollection[0] && (a += "\n\t" + this._programsCollection[0]);
        for (var b = 1; b < this._programsCollection.length; ++b)
            a += ",\n\t" + this._programsCollection[b];
        a += '\n];\ndevice.programLib.precompile(shaders);\nif (pc.version != "1.35.1" || pc.revision != "3317bcf")\n\tconsole.warn("precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine");';
        b = document.createElement("a");
        b.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(a));
        b.setAttribute("download", "precompile-shaders.js");
        b.style.display = "none";
        document.body.appendChild(b);
        b.click();
        document.body.removeChild(b)
    }
    ;
    Jb.prototype.clearCache = function() {
        var a = this._cache;
        this._isClearingCache = !0;
        for (var b in a)
            a.hasOwnProperty(b) && a[b].destroy();
        this._cache = {};
        this._isClearingCache = !1
    }
    ;
    Jb.prototype.removeFromCache = function(a) {
        if (!this._isClearingCache) {
            var b = this._cache, c;
            for (c in b)
                if (b.hasOwnProperty(c) && b[c] === a) {
                    delete b[c];
                    break
                }
        }
    }
    ;
    Jb.prototype._getDefaultStdMatOptions = function(a) {
        return 1 < a && 18 >= a ? this._defaultStdMatOptionMin : this._defaultStdMatOption
    }
    ;
    Jb.prototype.precompile = function(a) {
        if (a)
            for (var b = Array(a.length), c = 0; c < a.length; c++) {
                if ("standard" === a[c].name) {
                    var d = a[c].options, e = this._getDefaultStdMatOptions(d.pass), f;
                    for (f in e)
                        e.hasOwnProperty(f) && void 0 === d[f] && (d[f] = e[f]);
                    d.useTexCubeLod = this._device.useTexCubeLod
                }
                b[c] = this.getProgram(a[c].name, a[c].options)
            }
        this._precached = !0
    }
    ;
    Object.assign(uj.prototype, {
        equals: function(a) {
            return this.globalId === a.globalId && this.revision === a.revision
        },
        notequals: function(a) {
            return this.globalId !== a.globalId || this.revision !== a.revision
        },
        copy: function(a) {
            this.globalId = a.globalId;
            this.revision = a.revision
        },
        reset: function() {
            this.revision = this.globalId = 0
        }
    });
    var El = 0;
    Object.assign(Dl.prototype, {
        increment: function() {
            this.version.revision++
        }
    });
    Object.assign(Zg.prototype, {
        setValue: function(a) {
            this.value = a;
            this.versionObject.increment()
        },
        getValue: function() {
            return this.value
        }
    });
    Object.assign($g.prototype, {
        resolve: function(a) {
            this.variables.hasOwnProperty(a) || (this.variables[a] = new Zg(a));
            return this.variables[a]
        },
        getSubSpace: function(a) {
            this.namespaces.hasOwnProperty(a) || (this.namespaces[a] = new $g(a));
            return this.namespaces[a]
        }
    });
    var hn = function(a, b) {
        var c = a.width
          , d = a.height;
        if (c > b || d > b) {
            var e = b / Math.max(c, d)
              , f = Math.floor(c * e);
            e = Math.floor(d * e);
            console.warn("Image dimensions larger than max supported texture size of " + b + ". Resizing from " + c + ", " + d + " to " + f + ", " + e + ".");
            b = document.createElement("canvas");
            b.width = f;
            b.height = e;
            b.getContext("2d").drawImage(a, 0, 0, c, d, 0, 0, f, e);
            return b
        }
        return a
    }
      , ib = function(a, b) {
        M.call(this);
        var c;
        this.canvas = a;
        this.indexBuffer = this.shader = null;
        this.vertexBuffers = [];
        this._enableAutoInstancing = !1;
        this.autoInstancingMaxObjects = 16384;
        this.activeFramebuffer = this.transformFeedbackBuffer = this.boundVao = this.defaultFramebuffer = null;
        this.textureUnit = 0;
        this.textureUnits = [];
        this._maxPixelRatio = 1;
        this.feedback = this.renderTarget = null;
        this._tempEnableSafariTextureUnitWorkaround = !!window.safari;
        this._height = this._width = 0;
        this.updateClientRect();
        this.vertexShaderCache = {};
        this.fragmentShaderCache = {};
        this.shaders = [];
        this.buffers = [];
        this.textures = [];
        this.targets = [];
        this._vaoMap = new Map;
        this.contextLost = !1;
        this._contextLostHandler = function(q) {
            q.preventDefault();
            this.contextLost = !0;
            this.fire("devicelost")
        }
        .bind(this);
        this._contextRestoredHandler = function() {
            this.initializeContext();
            this.contextLost = !1;
            this.fire("devicerestored")
        }
        .bind(this);
        var d = b && void 0 !== b.preferWebGl2 ? b.preferWebGl2 : !0
          , e = d ? ["webgl2", "experimental-webgl2", "webgl", "experimental-webgl"] : ["webgl", "experimental-webgl"]
          , f = null;
        b = b || {};
        b.stencil = !0;
        for (c = 0; c < e.length; c++) {
            try {
                f = a.getContext(e[c], b)
            } catch (q) {}
            if (f) {
                this.webgl2 = d && 2 > c;
                break
            }
        }
        if (!f)
            throw Error("WebGL not supported");
        this.gl = f;
        window.setupVertexArrayObject(f);
        a.addEventListener("webglcontextlost", this._contextLostHandler, !1);
        a.addEventListener("webglcontextrestored", this._contextRestoredHandler, !1);
        this.initializeExtensions();
        this.initializeCapabilities();
        this.initializeRenderState();
        for (c = 0; c < this.maxCombinedTextures; c++)
            this.textureUnits.push([null, null, null]);
        this.defaultClearOptions = {
            color: [0, 0, 0, 1],
            depth: 1,
            stencil: 0,
            flags: 3
        };
        this.glAddress = [f.REPEAT, f.CLAMP_TO_EDGE, f.MIRRORED_REPEAT];
        this.glBlendEquation = [f.FUNC_ADD, f.FUNC_SUBTRACT, f.FUNC_REVERSE_SUBTRACT, this.webgl2 ? f.MIN : this.extBlendMinmax ? this.extBlendMinmax.MIN_EXT : f.FUNC_ADD, this.webgl2 ? f.MAX : this.extBlendMinmax ? this.extBlendMinmax.MAX_EXT : f.FUNC_ADD];
        this.glBlendFunction = [f.ZERO, f.ONE, f.SRC_COLOR, f.ONE_MINUS_SRC_COLOR, f.DST_COLOR, f.ONE_MINUS_DST_COLOR, f.SRC_ALPHA, f.SRC_ALPHA_SATURATE, f.ONE_MINUS_SRC_ALPHA, f.DST_ALPHA, f.ONE_MINUS_DST_ALPHA];
        this.glComparison = [f.NEVER, f.LESS, f.EQUAL, f.LEQUAL, f.GREATER, f.NOTEQUAL, f.GEQUAL, f.ALWAYS];
        this.glStencilOp = [f.KEEP, f.ZERO, f.REPLACE, f.INCR, f.INCR_WRAP, f.DECR, f.DECR_WRAP, f.INVERT];
        this.glClearFlag = [0, f.COLOR_BUFFER_BIT, f.DEPTH_BUFFER_BIT, f.COLOR_BUFFER_BIT | f.DEPTH_BUFFER_BIT, f.STENCIL_BUFFER_BIT, f.STENCIL_BUFFER_BIT | f.COLOR_BUFFER_BIT, f.STENCIL_BUFFER_BIT | f.DEPTH_BUFFER_BIT, f.STENCIL_BUFFER_BIT | f.COLOR_BUFFER_BIT | f.DEPTH_BUFFER_BIT];
        this.glCull = [0, f.BACK, f.FRONT, f.FRONT_AND_BACK];
        this.glFilter = [f.NEAREST, f.LINEAR, f.NEAREST_MIPMAP_NEAREST, f.NEAREST_MIPMAP_LINEAR, f.LINEAR_MIPMAP_NEAREST, f.LINEAR_MIPMAP_LINEAR];
        this.glPrimitive = [f.POINTS, f.LINES, f.LINE_LOOP, f.LINE_STRIP, f.TRIANGLES, f.TRIANGLE_STRIP, f.TRIANGLE_FAN];
        this.glType = [f.BYTE, f.UNSIGNED_BYTE, f.SHORT, f.UNSIGNED_SHORT, f.INT, f.UNSIGNED_INT, f.FLOAT];
        this.pcUniformType = {};
        this.pcUniformType[f.BOOL] = 0;
        this.pcUniformType[f.INT] = 1;
        this.pcUniformType[f.FLOAT] = 2;
        this.pcUniformType[f.FLOAT_VEC2] = 3;
        this.pcUniformType[f.FLOAT_VEC3] = 4;
        this.pcUniformType[f.FLOAT_VEC4] = 5;
        this.pcUniformType[f.INT_VEC2] = 6;
        this.pcUniformType[f.INT_VEC3] = 7;
        this.pcUniformType[f.INT_VEC4] = 8;
        this.pcUniformType[f.BOOL_VEC2] = 9;
        this.pcUniformType[f.BOOL_VEC3] = 10;
        this.pcUniformType[f.BOOL_VEC4] = 11;
        this.pcUniformType[f.FLOAT_MAT2] = 12;
        this.pcUniformType[f.FLOAT_MAT3] = 13;
        this.pcUniformType[f.FLOAT_MAT4] = 14;
        this.pcUniformType[f.SAMPLER_2D] = 15;
        this.pcUniformType[f.SAMPLER_CUBE] = 16;
        this.webgl2 && (this.pcUniformType[f.SAMPLER_2D_SHADOW] = 18,
        this.pcUniformType[f.SAMPLER_CUBE_SHADOW] = 19,
        this.pcUniformType[f.SAMPLER_3D] = 20);
        this.targetToSlot = {};
        this.targetToSlot[f.TEXTURE_2D] = 0;
        this.targetToSlot[f.TEXTURE_CUBE_MAP] = 1;
        this.targetToSlot[f.TEXTURE_3D] = 2;
        var g, k, h, l, n;
        this.commitFunction = [];
        this.commitFunction[0] = function(q, r) {
            q.value !== r && (f.uniform1i(q.locationId, r),
            q.value = r)
        }
        ;
        this.commitFunction[1] = this.commitFunction[0];
        this.commitFunction[2] = function(q, r) {
            q.value !== r && (f.uniform1f(q.locationId, r),
            q.value = r)
        }
        ;
        this.commitFunction[3] = function(q, r) {
            n = q.value;
            g = r[0];
            k = r[1];
            if (n[0] !== g || n[1] !== k)
                f.uniform2fv(q.locationId, r),
                n[0] = g,
                n[1] = k
        }
        ;
        this.commitFunction[4] = function(q, r) {
            n = q.value;
            g = r[0];
            k = r[1];
            h = r[2];
            if (n[0] !== g || n[1] !== k || n[2] !== h)
                f.uniform3fv(q.locationId, r),
                n[0] = g,
                n[1] = k,
                n[2] = h
        }
        ;
        this.commitFunction[5] = function(q, r) {
            n = q.value;
            g = r[0];
            k = r[1];
            h = r[2];
            l = r[3];
            if (n[0] !== g || n[1] !== k || n[2] !== h || n[3] !== l)
                f.uniform4fv(q.locationId, r),
                n[0] = g,
                n[1] = k,
                n[2] = h,
                n[3] = l
        }
        ;
        this.commitFunction[6] = function(q, r) {
            n = q.value;
            g = r[0];
            k = r[1];
            if (n[0] !== g || n[1] !== k)
                f.uniform2iv(q.locationId, r),
                n[0] = g,
                n[1] = k
        }
        ;
        this.commitFunction[9] = this.commitFunction[6];
        this.commitFunction[7] = function(q, r) {
            n = q.value;
            g = r[0];
            k = r[1];
            h = r[2];
            if (n[0] !== g || n[1] !== k || n[2] !== h)
                f.uniform3iv(q.locationId, r),
                n[0] = g,
                n[1] = k,
                n[2] = h
        }
        ;
        this.commitFunction[10] = this.commitFunction[7];
        this.commitFunction[8] = function(q, r) {
            n = q.value;
            g = r[0];
            k = r[1];
            h = r[2];
            l = r[3];
            if (n[0] !== g || n[1] !== k || n[2] !== h || n[3] !== l)
                f.uniform4iv(q.locationId, r),
                n[0] = g,
                n[1] = k,
                n[2] = h,
                n[3] = l
        }
        ;
        this.commitFunction[11] = this.commitFunction[8];
        this.commitFunction[12] = function(q, r) {
            f.uniformMatrix2fv(q.locationId, !1, r)
        }
        ;
        this.commitFunction[13] = function(q, r) {
            f.uniformMatrix3fv(q.locationId, !1, r)
        }
        ;
        this.commitFunction[14] = function(q, r) {
            f.uniformMatrix4fv(q.locationId, !1, r)
        }
        ;
        this.commitFunction[17] = function(q, r) {
            f.uniform1fv(q.locationId, r)
        }
        ;
        this.commitFunction[21] = function(q, r) {
            f.uniform2fv(q.locationId, r)
        }
        ;
        this.commitFunction[22] = function(q, r) {
            f.uniform3fv(q.locationId, r)
        }
        ;
        this.commitFunction[23] = function(q, r) {
            f.uniform4fv(q.locationId, r)
        }
        ;
        this.scope = new $g("Device");
        this.programLib = new Jb(this);
        for (var p in mh)
            this.programLib.register(p, mh[p]);
        this.supportsBoneTextures = this.extTextureFloat && 0 < this.maxVertexTextures;
        this.useTexCubeLod = this.extTextureLod && 16 > this.maxTextures;
        this.boneLimit = Math.floor((this.vertexUniformsCount - 16 - 8 - 1 - 16) / 3);
        this.boneLimit = Math.min(this.boneLimit, 128);
        "Mali-450 MP" === this.unmaskedRenderer && (this.boneLimit = 34);
        this._shaderSwitchesPerFrame = this._drawCallsPerFrame = 0;
        this._primsPerFrame = [];
        for (c = 0; 6 >= c; c++)
            this._primsPerFrame[c] = 0;
        this._renderTargetCreationTime = 0;
        this._vram = {
            tex: 0,
            vb: 0,
            ib: 0
        };
        this._shaderStats = {
            vsCompiled: 0,
            fsCompiled: 0,
            linked: 0,
            materialShaders: 0,
            compileTime: 0
        };
        this.constantTexSource = this.scope.resolve("source");
        this.textureFloatRenderable = this.extTextureFloat ? this.webgl2 ? !!this.extColorBufferFloat : Fl(f, f.FLOAT) : !1;
        this.textureHalfFloatRenderable = this.extTextureHalfFloat ? this.webgl2 ? !!this.extColorBufferFloat : Fl(f, this.extTextureHalfFloat.HALF_FLOAT_OES) : !1;
        this.supportsMorphTargetTexturesCore = "highp" === this.maxPrecision && 2 <= this.maxVertexTextures;
        this._textureHalfFloatUpdatable = this._textureFloatHighPrecision = void 0;
        this.createGrabPass();
        Na.init(this)
    };
    ib.prototype = Object.create(M.prototype);
    ib.prototype.constructor = ib;
    Object.assign(ib.prototype, {
        getPrecision: function() {
            var a = this.gl
              , b = "highp";
            if (a.getShaderPrecisionFormat) {
                var c = a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT)
                  , d = a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT)
                  , e = a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT);
                a = a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT);
                d = 0 < d.precision && 0 < a.precision;
                0 < c.precision && 0 < e.precision || (b = d ? "mediump" : "lowp")
            }
            return b
        },
        initializeExtensions: function() {
            var a = this.gl
              , b = a.getSupportedExtensions()
              , c = function() {
                for (var e = 0; e < arguments.length; e++)
                    if (-1 !== b.indexOf(arguments[e]))
                        return a.getExtension(arguments[e]);
                return null
            };
            if (this.webgl2)
                this.extVertexArrayObject = this.extUintElement = this.extTextureLod = this.extTextureHalfFloatLinear = this.extTextureHalfFloat = this.extTextureFloat = this.extStandardDerivatives = this.extInstancing = this.extDrawBuffers = this.extBlendMinmax = !0,
                this.extColorBufferFloat = c("EXT_color_buffer_float"),
                this.extDisjointTimerQuery = c("EXT_disjoint_timer_query_webgl2", "EXT_disjoint_timer_query");
            else {
                this.extBlendMinmax = c("EXT_blend_minmax");
                this.extDrawBuffers = c("EXT_draw_buffers");
                if (this.extInstancing = c("ANGLE_instanced_arrays")) {
                    var d = this.extInstancing;
                    a.drawArraysInstanced = d.drawArraysInstancedANGLE.bind(d);
                    a.drawElementsInstanced = d.drawElementsInstancedANGLE.bind(d);
                    a.vertexAttribDivisor = d.vertexAttribDivisorANGLE.bind(d)
                }
                this.extStandardDerivatives = c("OES_standard_derivatives");
                this.extTextureFloat = c("OES_texture_float");
                this.extTextureHalfFloat = c("OES_texture_half_float");
                this.extTextureHalfFloatLinear = c("OES_texture_half_float_linear");
                this.extTextureLod = c("EXT_shader_texture_lod");
                this.extUintElement = c("OES_element_index_uint");
                if (this.extVertexArrayObject = c("OES_vertex_array_object"))
                    d = this.extVertexArrayObject,
                    a.createVertexArray = d.createVertexArrayOES.bind(d),
                    a.deleteVertexArray = d.deleteVertexArrayOES.bind(d),
                    a.isVertexArray = d.isVertexArrayOES.bind(d),
                    a.bindVertexArray = d.bindVertexArrayOES.bind(d);
                this.extDisjointTimerQuery = this.extColorBufferFloat = null
            }
            this.extDebugRendererInfo = c("WEBGL_debug_renderer_info");
            this.extTextureFloatLinear = c("OES_texture_float_linear");
            this.extFloatBlend = c("EXT_float_blend");
            this.extTextureFilterAnisotropic = c("EXT_texture_filter_anisotropic", "WEBKIT_EXT_texture_filter_anisotropic");
            this.extCompressedTextureETC1 = c("WEBGL_compressed_texture_etc1");
            this.extCompressedTextureETC = c("WEBGL_compressed_texture_etc");
            this.extCompressedTexturePVRTC = c("WEBGL_compressed_texture_pvrtc", "WEBKIT_WEBGL_compressed_texture_pvrtc");
            this.extCompressedTextureS3TC = c("WEBGL_compressed_texture_s3tc", "WEBKIT_WEBGL_compressed_texture_s3tc");
            this.extCompressedTextureATC = c("WEBGL_compressed_texture_atc");
            this.extCompressedTextureASTC = c("WEBGL_compressed_texture_astc");
            this.extParallelShaderCompile = c("KHR_parallel_shader_compile");
            this.supportsInstancing = !!this.extInstancing
        },
        initializeCapabilities: function() {
            var a = this.gl;
            this.maxPrecision = this.precision = this.getPrecision();
            var b = a.getContextAttributes();
            this.supportsMsaa = b.antialias;
            this.supportsStencil = b.stencil;
            this.maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE);
            this.maxCubeMapSize = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE);
            this.maxRenderBufferSize = a.getParameter(a.MAX_RENDERBUFFER_SIZE);
            this.maxTextures = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);
            this.maxCombinedTextures = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            this.maxVertexTextures = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            this.vertexUniformsCount = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS);
            this.fragmentUniformsCount = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS);
            this.webgl2 ? (this.maxDrawBuffers = a.getParameter(a.MAX_DRAW_BUFFERS),
            this.maxColorAttachments = a.getParameter(a.MAX_COLOR_ATTACHMENTS),
            this.maxVolumeSize = a.getParameter(a.MAX_3D_TEXTURE_SIZE)) : (this.maxDrawBuffers = (b = this.extDrawBuffers) ? a.getParameter(b.MAX_DRAW_BUFFERS_EXT) : 1,
            this.maxColorAttachments = b ? a.getParameter(b.MAX_COLOR_ATTACHMENTS_EXT) : 1,
            this.maxVolumeSize = 1);
            this.unmaskedRenderer = (b = this.extDebugRendererInfo) ? a.getParameter(b.UNMASKED_RENDERER_WEBGL) : "";
            this.unmaskedVendor = b ? a.getParameter(b.UNMASKED_VENDOR_WEBGL) : "";
            this.maxAnisotropy = (b = this.extTextureFilterAnisotropic) ? a.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
            this.samples = a.getParameter(a.SAMPLES)
        },
        initializeRenderState: function() {
            var a = this.gl;
            this.blending = !1;
            a.disable(a.BLEND);
            this.blendSrc = 1;
            this.blendDst = 0;
            this.blendSrcAlpha = 1;
            this.blendDstAlpha = 0;
            this.separateAlphaBlend = !1;
            this.blendAlphaEquation = this.blendEquation = 0;
            this.separateAlphaEquation = !1;
            a.blendFunc(a.ONE, a.ZERO);
            a.blendEquation(a.FUNC_ADD);
            this.writeAlpha = this.writeBlue = this.writeGreen = this.writeRed = !0;
            a.colorMask(!0, !0, !0, !0);
            this.cullMode = 1;
            a.enable(a.CULL_FACE);
            a.cullFace(a.BACK);
            this.depthTest = !0;
            a.enable(a.DEPTH_TEST);
            this.depthFunc = 3;
            a.depthFunc(a.LEQUAL);
            this.depthWrite = !0;
            a.depthMask(!0);
            this.stencil = !1;
            a.disable(a.STENCIL_TEST);
            this.stencilFuncFront = this.stencilFuncBack = 7;
            this.stencilRefFront = this.stencilRefBack = 0;
            this.stencilMaskFront = this.stencilMaskBack = 255;
            a.stencilFunc(a.ALWAYS, 0, 255);
            this.stencilZpassFront = this.stencilZpassBack = this.stencilZfailFront = this.stencilZfailBack = this.stencilFailFront = this.stencilFailBack = 0;
            this.stencilWriteMaskBack = this.stencilWriteMaskFront = 255;
            a.stencilOp(a.KEEP, a.KEEP, a.KEEP);
            a.stencilMask(255);
            this.alphaToCoverage = !1;
            this.raster = !0;
            this.webgl2 && (a.disable(a.SAMPLE_ALPHA_TO_COVERAGE),
            a.disable(a.RASTERIZER_DISCARD));
            this.depthBiasEnabled = !1;
            a.disable(a.POLYGON_OFFSET_FILL);
            this.clearDepth = 1;
            a.clearDepth(1);
            this.clearAlpha = this.clearGreen = this.clearBlue = this.clearRed = 0;
            a.clearColor(0, 0, 0, 0);
            this.clearStencil = 0;
            a.clearStencil(0);
            this.sx = this.sy = this.sw = this.sh = this.vx = this.vy = this.vw = this.vh = 0;
            this.webgl2 ? a.hint(a.FRAGMENT_SHADER_DERIVATIVE_HINT, a.NICEST) : this.extStandardDerivatives && a.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, a.NICEST);
            a.enable(a.SCISSOR_TEST);
            a.pixelStorei(a.UNPACK_COLORSPACE_CONVERSION_WEBGL, a.NONE);
            this.unpackFlipY = !1;
            a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, !1);
            this.unpackPremultiplyAlpha = !1;
            a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1)
        },
        initializeContext: function() {
            this.initializeExtensions();
            this.initializeCapabilities();
            this.initializeRenderState();
            var a;
            var b = 0;
            for (a = this.shaders.length; b < a; b++)
                this.compileAndLinkShader(this.shaders[b]);
            this.shader = null;
            b = 0;
            for (a = this.buffers.length; b < a; b++)
                this.buffers[b].bufferId = void 0,
                this.buffers[b].unlock();
            this.indexBuffer = this.boundVao = null;
            this.vertexBuffers = [];
            b = 0;
            for (a = this.textures.length; b < a; b++) {
                var c = this.textures[b];
                this.destroyTexture(c);
                c.dirtyAll()
            }
            this.textureUnit = 0;
            for (b = this.textureUnits.length = 0; b < this.maxCombinedTextures; b++)
                this.textureUnits.push([null, null, null]);
            b = 0;
            for (a = this.targets.length; b < a; b++)
                this.targets[b]._glFrameBuffer = void 0,
                this.targets[b]._glDepthBuffer = void 0,
                this.targets[b]._glResolveFrameBuffer = void 0,
                this.targets[b]._glMsaaColorBuffer = void 0,
                this.targets[b]._glMsaaDepthBuffer = void 0;
            this.transformFeedbackBuffer = this.feedback = this.activeFramebuffer = this.renderTarget = null
        },
        createGrabPass: function() {
            if (!this.grabPassTexture) {
                var a = new V(this,{
                    format: 7,
                    minFilter: 1,
                    magFilter: 1,
                    addressU: 1,
                    addressV: 1,
                    mipmaps: !1
                });
                a.name = "texture_grabPass";
                var b = this.scope.resolve(a.name);
                b.setValue(a);
                this.grabPassRenderTarget = new ra({
                    colorBuffer: a,
                    depth: !1
                });
                this.grabPassTextureId = b;
                this.grabPassTexture = a
            }
        },
        updateGrabPass: function() {
            var a = this.gl
              , b = this.renderTarget
              , c = b && b._glResolveFrameBuffer
              , d = this.grabPassTexture
              , e = this.width
              , f = this.height;
            this.webgl2 && e === d._width && f === d._height ? (c && b.resolve(!0),
            c = b ? b._glFrameBuffer : null,
            b = b ? b._glResolveFrameBuffer || b._glFrameBuffer : null,
            this.initRenderTarget(this.grabPassRenderTarget),
            d = this.grabPassRenderTarget._glFrameBuffer,
            a.bindFramebuffer(a.READ_FRAMEBUFFER, b),
            a.bindFramebuffer(a.DRAW_FRAMEBUFFER, d),
            a.blitFramebuffer(0, 0, e, f, 0, 0, e, f, a.COLOR_BUFFER_BIT, a.NEAREST),
            a.bindFramebuffer(a.DRAW_FRAMEBUFFER, c)) : (c && (b.resolve(!0),
            a.bindFramebuffer(a.FRAMEBUFFER, b._glResolveFrameBuffer)),
            a.copyTexImage2D(a.TEXTURE_2D, 0, d._glFormat, 0, 0, e, f, 0),
            d._width = e,
            d._height = f,
            c && a.bindFramebuffer(a.FRAMEBUFFER, b._glFrameBuffer))
        },
        destroyGrabPass: function() {
            this.grabPassRenderTarget.destroy();
            this.grabPassTextureId = this.grabPassRenderTarget = null;
            this.grabPassTexture.destroy();
            this.grabPassTexture = null
        },
        updateClientRect: function() {
            this.clientRect = this.canvas.getBoundingClientRect()
        },
        setViewport: function(a, b, c, d) {
            if (this.vx !== a || this.vy !== b || this.vw !== c || this.vh !== d)
                this.gl.viewport(a, b, c, d),
                this.vx = a,
                this.vy = b,
                this.vw = c,
                this.vh = d
        },
        setScissor: function(a, b, c, d) {
            if (this.sx !== a || this.sy !== b || this.sw !== c || this.sh !== d)
                this.gl.scissor(a, b, c, d),
                this.sx = a,
                this.sy = b,
                this.sw = c,
                this.sh = d
        },
        getProgramLibrary: function() {
            return this.programLib
        },
        setProgramLibrary: function(a) {
            this.programLib = a
        },
        setFramebuffer: function(a) {
            this.activeFramebuffer !== a && (this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, a),
            this.activeFramebuffer = a)
        },
        _checkFbo: function() {
            var a = this.gl;
            switch (a.checkFramebufferStatus(a.FRAMEBUFFER)) {
            case a.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                console.error("ERROR: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                break;
            case a.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                console.error("ERROR: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                break;
            case a.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                console.error("ERROR: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                break;
            case a.FRAMEBUFFER_UNSUPPORTED:
                console.error("ERROR: FRAMEBUFFER_UNSUPPORTED")
            }
        },
        copyRenderTarget: function(a, b, c, d) {
            var e = this.gl;
            if (!this.webgl2 && d)
                return !1;
            if (c)
                if (!b) {
                    if (!a._colorBuffer)
                        return !1
                } else if (!a._colorBuffer || !b._colorBuffer || a._colorBuffer._format !== b._colorBuffer._format)
                    return !1;
            if (d && (!a._depthBuffer || !b._depthBuffer || a._depthBuffer._format !== b._depthBuffer._format))
                return !1;
            if (this.webgl2 && b) {
                var f = this.renderTarget;
                this.renderTarget = b;
                this.updateBegin();
                e.bindFramebuffer(e.READ_FRAMEBUFFER, a ? a._glFrameBuffer : null);
                e.bindFramebuffer(e.DRAW_FRAMEBUFFER, b._glFrameBuffer);
                var g = a ? a.width : b.width;
                a = a ? a.height : b.height;
                e.blitFramebuffer(0, 0, g, a, 0, 0, g, a, (c ? e.COLOR_BUFFER_BIT : 0) | (d ? e.DEPTH_BUFFER_BIT : 0), e.NEAREST);
                this.renderTarget = f;
                e.bindFramebuffer(e.FRAMEBUFFER, f ? f._glFrameBuffer : null)
            } else
                c = this.getCopyShader(),
                this.constantTexSource.setValue(a._colorBuffer),
                La(this, b, c);
            return !0
        },
        initRenderTarget: function(a) {
            if (!a._glFrameBuffer) {
                a._device = this;
                var b = this.gl;
                a._glFrameBuffer = b.createFramebuffer();
                this.setFramebuffer(a._glFrameBuffer);
                var c = a._colorBuffer;
                c && (c._glTexture || (c._width = Math.min(c.width, this.maxRenderBufferSize),
                c._height = Math.min(c.height, this.maxRenderBufferSize),
                this.setTexture(c, 0)),
                b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, c._cubemap ? b.TEXTURE_CUBE_MAP_POSITIVE_X + a._face : b.TEXTURE_2D, c._glTexture, 0));
                var d = a._depthBuffer;
                d && this.webgl2 ? (d._glTexture || (d._width = Math.min(d.width, this.maxRenderBufferSize),
                d._height = Math.min(d.height, this.maxRenderBufferSize),
                this.setTexture(d, 0)),
                a._stencil ? b.framebufferTexture2D(b.FRAMEBUFFER, b.DEPTH_STENCIL_ATTACHMENT, d._cubemap ? b.TEXTURE_CUBE_MAP_POSITIVE_X + a._face : b.TEXTURE_2D, a._depthBuffer._glTexture, 0) : b.framebufferTexture2D(b.FRAMEBUFFER, b.DEPTH_ATTACHMENT, d._cubemap ? b.TEXTURE_CUBE_MAP_POSITIVE_X + a._face : b.TEXTURE_2D, a._depthBuffer._glTexture, 0)) : !a._depth || 1 < a._samples && this.webgl2 || (a._glDepthBuffer || (a._glDepthBuffer = b.createRenderbuffer()),
                b.bindRenderbuffer(b.RENDERBUFFER, a._glDepthBuffer),
                a._stencil ? (b.renderbufferStorage(b.RENDERBUFFER, b.DEPTH_STENCIL, a.width, a.height),
                b.framebufferRenderbuffer(b.FRAMEBUFFER, b.DEPTH_STENCIL_ATTACHMENT, b.RENDERBUFFER, a._glDepthBuffer)) : (b.renderbufferStorage(b.RENDERBUFFER, b.DEPTH_COMPONENT16, a.width, a.height),
                b.framebufferRenderbuffer(b.FRAMEBUFFER, b.DEPTH_ATTACHMENT, b.RENDERBUFFER, a._glDepthBuffer)),
                b.bindRenderbuffer(b.RENDERBUFFER, null));
                this.webgl2 && 1 < a._samples && (a._glResolveFrameBuffer = a._glFrameBuffer,
                a._glFrameBuffer = b.createFramebuffer(),
                this.setFramebuffer(a._glFrameBuffer),
                c && (a._glMsaaColorBuffer || (a._glMsaaColorBuffer = b.createRenderbuffer()),
                b.bindRenderbuffer(b.RENDERBUFFER, a._glMsaaColorBuffer),
                b.renderbufferStorageMultisample(b.RENDERBUFFER, a._samples, c._glInternalFormat, a.width, a.height),
                b.framebufferRenderbuffer(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.RENDERBUFFER, a._glMsaaColorBuffer)),
                a._depth && (a._glMsaaDepthBuffer || (a._glMsaaDepthBuffer = b.createRenderbuffer()),
                b.bindRenderbuffer(b.RENDERBUFFER, a._glMsaaDepthBuffer),
                a._stencil ? (b.renderbufferStorageMultisample(b.RENDERBUFFER, a._samples, b.DEPTH24_STENCIL8, a.width, a.height),
                b.framebufferRenderbuffer(b.FRAMEBUFFER, b.DEPTH_STENCIL_ATTACHMENT, b.RENDERBUFFER, a._glMsaaDepthBuffer)) : (b.renderbufferStorageMultisample(b.RENDERBUFFER, a._samples, b.DEPTH_COMPONENT32F, a.width, a.height),
                b.framebufferRenderbuffer(b.FRAMEBUFFER, b.DEPTH_ATTACHMENT, b.RENDERBUFFER, a._glMsaaDepthBuffer))));
                this.targets.push(a)
            }
        },
        getCopyShader: function() {
            this._copyShader || (this._copyShader = Wa(this, F.fullscreenQuadVS, F.outputTex2DPS, "outputTex2D"));
            return this._copyShader
        },
        updateBegin: function() {
            this.boundVao = null;
            if (this._tempEnableSafariTextureUnitWorkaround)
                for (var a = 0; a < this.textureUnits.length; ++a)
                    for (var b = 0; 3 > b; ++b)
                        this.textureUnits[a][b] = null;
            (a = this.renderTarget) ? a._glFrameBuffer ? this.setFramebuffer(a._glFrameBuffer) : this.initRenderTarget(a) : this.setFramebuffer(this.defaultFramebuffer)
        },
        updateEnd: function() {
            var a = this.gl;
            this.boundVao = null;
            this.gl.bindVertexArray(null);
            var b = this.renderTarget;
            if (b) {
                var c = b._colorBuffer;
                c && c._glTexture && c.mipmaps && c.pot && (this.activeTexture(this.maxCombinedTextures - 1),
                this.bindTexture(c),
                a.generateMipmap(c._glTarget));
                this.webgl2 && 1 < b._samples && b.autoResolve && b.resolve()
            }
        },
        initializeTexture: function(a) {
            var b = this.gl;
            a._glTexture = b.createTexture();
            a._glTarget = a._cubemap ? b.TEXTURE_CUBE_MAP : a._volume ? b.TEXTURE_3D : b.TEXTURE_2D;
            switch (a._format) {
            case 0:
                a._glFormat = b.ALPHA;
                a._glInternalFormat = b.ALPHA;
                a._glPixelType = b.UNSIGNED_BYTE;
                break;
            case 1:
                a._glFormat = b.LUMINANCE;
                a._glInternalFormat = b.LUMINANCE;
                a._glPixelType = b.UNSIGNED_BYTE;
                break;
            case 2:
                a._glFormat = b.LUMINANCE_ALPHA;
                a._glInternalFormat = b.LUMINANCE_ALPHA;
                a._glPixelType = b.UNSIGNED_BYTE;
                break;
            case 3:
                a._glFormat = b.RGB;
                a._glInternalFormat = b.RGB;
                a._glPixelType = b.UNSIGNED_SHORT_5_6_5;
                break;
            case 4:
                a._glFormat = b.RGBA;
                a._glInternalFormat = b.RGBA;
                a._glPixelType = b.UNSIGNED_SHORT_5_5_5_1;
                break;
            case 5:
                a._glFormat = b.RGBA;
                a._glInternalFormat = b.RGBA;
                a._glPixelType = b.UNSIGNED_SHORT_4_4_4_4;
                break;
            case 6:
                a._glFormat = b.RGB;
                a._glInternalFormat = this.webgl2 ? b.RGB8 : b.RGB;
                a._glPixelType = b.UNSIGNED_BYTE;
                break;
            case 7:
                a._glFormat = b.RGBA;
                a._glInternalFormat = this.webgl2 ? b.RGBA8 : b.RGBA;
                a._glPixelType = b.UNSIGNED_BYTE;
                break;
            case 8:
                var c = this.extCompressedTextureS3TC;
                a._glFormat = b.RGB;
                a._glInternalFormat = c.COMPRESSED_RGB_S3TC_DXT1_EXT;
                break;
            case 9:
                c = this.extCompressedTextureS3TC;
                a._glFormat = b.RGBA;
                a._glInternalFormat = c.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                break;
            case 10:
                c = this.extCompressedTextureS3TC;
                a._glFormat = b.RGBA;
                a._glInternalFormat = c.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                break;
            case 21:
                c = this.extCompressedTextureETC1;
                a._glFormat = b.RGB;
                a._glInternalFormat = c.COMPRESSED_RGB_ETC1_WEBGL;
                break;
            case 24:
                c = this.extCompressedTexturePVRTC;
                a._glFormat = b.RGB;
                a._glInternalFormat = c.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                break;
            case 25:
                c = this.extCompressedTexturePVRTC;
                a._glFormat = b.RGBA;
                a._glInternalFormat = c.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                break;
            case 26:
                c = this.extCompressedTexturePVRTC;
                a._glFormat = b.RGB;
                a._glInternalFormat = c.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                break;
            case 27:
                c = this.extCompressedTexturePVRTC;
                a._glFormat = b.RGBA;
                a._glInternalFormat = c.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                break;
            case 22:
                c = this.extCompressedTextureETC;
                a._glFormat = b.RGB;
                a._glInternalFormat = c.COMPRESSED_RGB8_ETC2;
                break;
            case 23:
                c = this.extCompressedTextureETC;
                a._glFormat = b.RGBA;
                a._glInternalFormat = c.COMPRESSED_RGBA8_ETC2_EAC;
                break;
            case 28:
                c = this.extCompressedTextureASTC;
                a._glFormat = b.RGBA;
                a._glInternalFormat = c.COMPRESSED_RGBA_ASTC_4x4_KHR;
                break;
            case 29:
                c = this.extCompressedTextureATC;
                a._glFormat = b.RGB;
                a._glInternalFormat = c.COMPRESSED_RGB_ATC_WEBGL;
                break;
            case 30:
                c = this.extCompressedTextureATC;
                a._glFormat = b.RGBA;
                a._glInternalFormat = c.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
                break;
            case 11:
                c = this.extTextureHalfFloat;
                a._glFormat = b.RGB;
                this.webgl2 ? (a._glInternalFormat = b.RGB16F,
                a._glPixelType = b.HALF_FLOAT) : (a._glInternalFormat = b.RGB,
                a._glPixelType = c.HALF_FLOAT_OES);
                break;
            case 12:
                c = this.extTextureHalfFloat;
                a._glFormat = b.RGBA;
                this.webgl2 ? (a._glInternalFormat = b.RGBA16F,
                a._glPixelType = b.HALF_FLOAT) : (a._glInternalFormat = b.RGBA,
                a._glPixelType = c.HALF_FLOAT_OES);
                break;
            case 13:
                a._glFormat = b.RGB;
                a._glInternalFormat = this.webgl2 ? b.RGB32F : b.RGB;
                a._glPixelType = b.FLOAT;
                break;
            case 14:
                a._glFormat = b.RGBA;
                a._glInternalFormat = this.webgl2 ? b.RGBA32F : b.RGBA;
                a._glPixelType = b.FLOAT;
                break;
            case 15:
                a._glFormat = b.RED;
                a._glInternalFormat = b.R32F;
                a._glPixelType = b.FLOAT;
                break;
            case 16:
                this.webgl2 ? (a._glFormat = b.DEPTH_COMPONENT,
                a._glInternalFormat = b.DEPTH_COMPONENT32F,
                a._glPixelType = b.FLOAT) : (a._glFormat = b.DEPTH_COMPONENT,
                a._glInternalFormat = b.DEPTH_COMPONENT,
                a._glPixelType = b.UNSIGNED_SHORT);
                break;
            case 17:
                a._glFormat = b.DEPTH_STENCIL;
                a._glInternalFormat = b.DEPTH24_STENCIL8;
                a._glPixelType = b.UNSIGNED_INT_24_8;
                break;
            case 18:
                a._glFormat = b.RGB;
                a._glInternalFormat = b.R11F_G11F_B10F;
                a._glPixelType = b.FLOAT;
                break;
            case 19:
                a._glFormat = b.RGB;
                a._glInternalFormat = b.SRGB8;
                a._glPixelType = b.UNSIGNED_BYTE;
                break;
            case 20:
                a._glFormat = b.RGBA,
                a._glInternalFormat = b.SRGB8_ALPHA8,
                a._glPixelType = b.UNSIGNED_BYTE
            }
            this.textures.push(a)
        },
        destroyTexture: function(a) {
            if (a._glTexture) {
                var b = this.textures.indexOf(a);
                -1 !== b && this.textures.splice(b, 1);
                for (var c in this.scope.variables)
                    b = this.scope.variables[c],
                    b.value === a && (b.value = null);
                for (c = 0; c < this.textureUnits.length; c++) {
                    b = this.textureUnits[c];
                    for (var d = 0; d < b.length; d++)
                        b[d] === a._glTexture && (b[d] = null)
                }
                this.gl.deleteTexture(a._glTexture);
                delete a._glTexture;
                delete a._glTarget;
                delete a._glFormat;
                delete a._glInternalFormat;
                delete a._glPixelType;
                this._vram.tex -= a._gpuSize
            }
        },
        setUnpackFlipY: function(a) {
            if (this.unpackFlipY !== a) {
                this.unpackFlipY = a;
                var b = this.gl;
                b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, a)
            }
        },
        setUnpackPremultiplyAlpha: function(a) {
            if (this.unpackPremultiplyAlpha !== a) {
                this.unpackPremultiplyAlpha = a;
                var b = this.gl;
                b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a)
            }
        },
        _isBrowserInterface: function(a) {
            return "undefined" !== typeof HTMLCanvasElement && a instanceof HTMLCanvasElement || "undefined" !== typeof HTMLImageElement && a instanceof HTMLImageElement || "undefined" !== typeof HTMLVideoElement && a instanceof HTMLVideoElement || "undefined" !== typeof ImageBitmap && a instanceof ImageBitmap
        },
        uploadTexture: function(a) {
            var b = this.gl;
            if (a._needsUpload || !(a._needsMipmapsUpload && a._mipmapsUploaded || !a.pot)) {
                for (var c = 0, d, e, f = Math.log2(Math.max(a._width, a._height)) + 1; a._levels[c] || 0 === c; ) {
                    if (a._needsUpload || 0 !== c) {
                        if (c && (!a._needsMipmapsUpload || !a._mipmaps))
                            break;
                        d = a._levels[c];
                        1 == c && !a._compressed && a._levels.length < f && (b.generateMipmap(a._glTarget),
                        a._mipmapsUploaded = !0);
                        if (a._cubemap) {
                            var g;
                            if (this._isBrowserInterface(d[0]))
                                for (g = 0; 6 > g; g++)
                                    a._levelsUpdated[0][g] && (e = d[g],
                                    e instanceof HTMLImageElement && (e.width > this.maxCubeMapSize || e.height > this.maxCubeMapSize) && (e = hn(e, this.maxCubeMapSize),
                                    0 === c && (a._width = e.width,
                                    a._height = e.height)),
                                    this.setUnpackFlipY(!1),
                                    this.setUnpackPremultiplyAlpha(a._premultiplyAlpha),
                                    b.texImage2D(b.TEXTURE_CUBE_MAP_POSITIVE_X + g, c, a._glInternalFormat, a._glFormat, a._glPixelType, e));
                            else
                                for (e = 1 / Math.pow(2, c),
                                g = 0; 6 > g; g++)
                                    if (a._levelsUpdated[0][g]) {
                                        var k = d[g];
                                        a._compressed ? b.compressedTexImage2D(b.TEXTURE_CUBE_MAP_POSITIVE_X + g, c, a._glInternalFormat, Math.max(a._width * e, 1), Math.max(a._height * e, 1), 0, k) : (this.setUnpackFlipY(!1),
                                        this.setUnpackPremultiplyAlpha(a._premultiplyAlpha),
                                        b.texImage2D(b.TEXTURE_CUBE_MAP_POSITIVE_X + g, c, a._glInternalFormat, Math.max(a._width * e, 1), Math.max(a._height * e, 1), 0, a._glFormat, a._glPixelType, k))
                                    }
                        } else
                            a._volume ? (e = 1 / Math.pow(2, c),
                            a._compressed ? b.compressedTexImage3D(b.TEXTURE_3D, c, a._glInternalFormat, Math.max(a._width * e, 1), Math.max(a._height * e, 1), Math.max(a._depth * e, 1), 0, d) : (this.setUnpackFlipY(!1),
                            this.setUnpackPremultiplyAlpha(a._premultiplyAlpha),
                            b.texImage3D(b.TEXTURE_3D, c, a._glInternalFormat, Math.max(a._width * e, 1), Math.max(a._height * e, 1), Math.max(a._depth * e, 1), 0, a._glFormat, a._glPixelType, d))) : (this._isBrowserInterface(d) ? (d instanceof HTMLImageElement && (d.width > this.maxTextureSize || d.height > this.maxTextureSize) && (d = hn(d, this.maxTextureSize),
                            0 === c && (a._width = d.width,
                            a._height = d.height)),
                            this.setUnpackFlipY(a._flipY),
                            this.setUnpackPremultiplyAlpha(a._premultiplyAlpha),
                            b.texImage2D(b.TEXTURE_2D, c, a._glInternalFormat, a._glFormat, a._glPixelType, d)) : (e = 1 / Math.pow(2, c),
                            a._compressed ? b.compressedTexImage2D(b.TEXTURE_2D, c, a._glInternalFormat, Math.max(a._width * e, 1), Math.max(a._height * e, 1), 0, d) : (this.setUnpackFlipY(!1),
                            this.setUnpackPremultiplyAlpha(a._premultiplyAlpha),
                            b.texImage2D(b.TEXTURE_2D, c, a._glInternalFormat, Math.max(a._width * e, 1), Math.max(a._height * e, 1), 0, a._glFormat, a._glPixelType, d))),
                            a._mipmapsUploaded = 0 === c ? !1 : !0)
                    }
                    c++
                }
                if (a._needsUpload)
                    if (a._cubemap)
                        for (c = 0; 6 > c; c++)
                            a._levelsUpdated[0][c] = !1;
                    else
                        a._levelsUpdated[0] = !1;
                !a._compressed && a._mipmaps && a._needsMipmapsUpload && a.pot && 1 === a._levels.length && (b.generateMipmap(a._glTarget),
                a._mipmapsUploaded = !0);
                a._gpuSize && (this._vram.tex -= a._gpuSize);
                a._gpuSize = a.gpuSize;
                this._vram.tex += a._gpuSize
            }
        },
        activeTexture: function(a) {
            this.textureUnit !== a && (this.gl.activeTexture(this.gl.TEXTURE0 + a),
            this.textureUnit = a)
        },
        bindTexture: function(a) {
            var b = a._glTarget;
            a = a._glTexture;
            var c = this.textureUnit
              , d = this.targetToSlot[b];
            this.textureUnits[c][d] !== a && (this.gl.bindTexture(b, a),
            this.textureUnits[c][d] = a)
        },
        bindTextureOnUnit: function(a, b) {
            var c = a._glTarget;
            a = a._glTexture;
            var d = this.targetToSlot[c];
            this.textureUnits[b][d] !== a && (this.activeTexture(b),
            this.gl.bindTexture(c, a),
            this.textureUnits[b][d] = a)
        },
        setTextureParameters: function(a) {
            var b = this.gl
              , c = a._parameterFlags
              , d = a._glTarget;
            if (c & 1) {
                var e = a._minFilter;
                if (!a.pot || !a._mipmaps || a._compressed && 1 === a._levels.length)
                    if (2 === e || 3 === e)
                        e = 0;
                    else if (4 === e || 5 === e)
                        e = 1;
                b.texParameteri(d, b.TEXTURE_MIN_FILTER, this.glFilter[e])
            }
            c & 2 && b.texParameteri(d, b.TEXTURE_MAG_FILTER, this.glFilter[a._magFilter]);
            c & 4 && (this.webgl2 ? b.texParameteri(d, b.TEXTURE_WRAP_S, this.glAddress[a._addressU]) : b.texParameteri(d, b.TEXTURE_WRAP_S, this.glAddress[a.pot ? a._addressU : 1]));
            c & 8 && (this.webgl2 ? b.texParameteri(d, b.TEXTURE_WRAP_T, this.glAddress[a._addressV]) : b.texParameteri(d, b.TEXTURE_WRAP_T, this.glAddress[a.pot ? a._addressV : 1]));
            c & 16 && this.webgl2 && b.texParameteri(d, b.TEXTURE_WRAP_R, this.glAddress[a._addressW]);
            c & 32 && this.webgl2 && b.texParameteri(d, b.TEXTURE_COMPARE_MODE, a._compareOnRead ? b.COMPARE_REF_TO_TEXTURE : b.NONE);
            c & 64 && this.webgl2 && b.texParameteri(d, b.TEXTURE_COMPARE_FUNC, this.glComparison[a._compareFunc]);
            c & 128 && (c = this.extTextureFilterAnisotropic) && b.texParameterf(d, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.max(1, Math.min(Math.round(a._anisotropy), this.maxAnisotropy)))
        },
        setTexture: function(a, b) {
            a._glTexture || this.initializeTexture(a);
            if (0 < a._parameterFlags || a._needsUpload || a._needsMipmapsUpload || a === this.grabPassTexture)
                if (this.activeTexture(b),
                this.bindTexture(a),
                a._parameterFlags && (this.setTextureParameters(a),
                a._parameterFlags = 0),
                a === this.grabPassTexture)
                    this.updateGrabPass();
                else {
                    if (a._needsUpload || a._needsMipmapsUpload)
                        this.uploadTexture(a),
                        a._needsUpload = !1,
                        a._needsMipmapsUpload = !1
                }
            else
                this.bindTextureOnUnit(a, b)
        },
        createVertexArray: function(a) {
            var b, c = 1 < a.length;
            if (c) {
                var d = "";
                for (b = 0; b < a.length; b++) {
                    var e = a[b];
                    d += e.id + e.format.renderingingHash
                }
                var f = this._vaoMap.get(d)
            }
            if (!f) {
                var g = this.gl;
                f = g.createVertexArray();
                g.bindVertexArray(f);
                g.bindBuffer(g.ELEMENT_ARRAY_BUFFER, null);
                for (b = 0; b < a.length; b++) {
                    e = a[b];
                    g.bindBuffer(g.ARRAY_BUFFER, e.bufferId);
                    var k = e.format.elements;
                    for (var h = 0; h < k.length; h++) {
                        var l = k[h];
                        var n = Jj[l.name];
                        g.vertexAttribPointer(n, l.numComponents, this.glType[l.dataType], l.normalize, l.stride, l.offset);
                        g.enableVertexAttribArray(n);
                        e.instancing && g.vertexAttribDivisor(n, 1)
                    }
                }
                g.bindVertexArray(null);
                g.bindBuffer(g.ARRAY_BUFFER, null);
                c && this._vaoMap.set(d, f)
            }
            return f
        },
        setBuffers: function() {
            var a = this.gl;
            if (1 === this.vertexBuffers.length) {
                var b = this.vertexBuffers[0];
                b._vao || (b._vao = this.createVertexArray(this.vertexBuffers));
                b = b._vao
            } else
                b = this.createVertexArray(this.vertexBuffers);
            this.boundVao !== b && (this.boundVao = b,
            a.bindVertexArray(b));
            this.vertexBuffers.length = 0;
            a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer ? this.indexBuffer.bufferId : null)
        },
        draw: function(a, b, c) {
            var d = this.gl, e, f, g, k = this.shader;
            var h = k.samplers;
            k = k.uniforms;
            c || this.setBuffers();
            var l = 0;
            c = 0;
            for (f = h.length; c < f; c++) {
                var n = h[c];
                if (g = n.scopeId.value)
                    if (g instanceof V) {
                        var p = g;
                        this.setTexture(p, l);
                        n.slot !== l && (d.uniform1i(n.locationId, l),
                        n.slot = l);
                        l++
                    } else {
                        n.array.length = 0;
                        var q = g.length;
                        for (e = 0; e < q; e++)
                            p = g[e],
                            this.setTexture(p, l),
                            n.array[e] = l,
                            l++;
                        d.uniform1iv(n.locationId, n.array)
                    }
            }
            c = 0;
            for (f = k.length; c < f; c++)
                if (h = k[c],
                e = h.scopeId,
                n = h.version,
                g = e.versionObject.version,
                n.globalId !== g.globalId || n.revision !== g.revision)
                    if (n.globalId = g.globalId,
                    n.revision = g.revision,
                    null !== e.value)
                        this.commitFunction[h.dataType](h, e.value);
            this.webgl2 && this.transformFeedbackBuffer && (d.bindBufferBase(d.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.bufferId),
            d.beginTransformFeedback(d.POINTS));
            k = this.glPrimitive[a.type];
            c = a.count;
            a.indexed ? (h = this.indexBuffer,
            f = h.glFormat,
            a = a.base * h.bytesPerIndex,
            0 < b ? d.drawElementsInstanced(k, c, f, a, b) : d.drawElements(k, c, f, a)) : (a = a.base,
            0 < b ? d.drawArraysInstanced(k, a, c, b) : d.drawArrays(k, a, c));
            this.webgl2 && this.transformFeedbackBuffer && (d.endTransformFeedback(),
            d.bindBufferBase(d.TRANSFORM_FEEDBACK_BUFFER, 0, null));
            this._drawCallsPerFrame++
        },
        clear: function(a) {
            var b = this.defaultClearOptions;
            a = a || b;
            var c = void 0 == a.flags ? b.flags : a.flags;
            if (0 !== c) {
                var d = this.gl;
                if (c & 1) {
                    var e = void 0 == a.color ? b.color : a.color;
                    this.setClearColor(e[0], e[1], e[2], e[3])
                }
                c & 2 && (this.setClearDepth(void 0 == a.depth ? b.depth : a.depth),
                this.depthWrite || d.depthMask(!0));
                c & 4 && this.setClearStencil(void 0 == a.stencil ? b.stencil : a.stencil);
                d.clear(this.glClearFlag[c]);
                c & 2 && (this.depthWrite || d.depthMask(!1))
            }
        },
        readPixels: function(a, b, c, d, e) {
            var f = this.gl;
            f.readPixels(a, b, c, d, f.RGBA, f.UNSIGNED_BYTE, e)
        },
        setClearDepth: function(a) {
            a !== this.clearDepth && (this.gl.clearDepth(a),
            this.clearDepth = a)
        },
        setClearColor: function(a, b, c, d) {
            if (a !== this.clearRed || b !== this.clearGreen || c !== this.clearBlue || d !== this.clearAlpha)
                this.gl.clearColor(a, b, c, d),
                this.clearRed = a,
                this.clearGreen = b,
                this.clearBlue = c,
                this.clearAlpha = d
        },
        setClearStencil: function(a) {
            a !== this.clearStencil && (this.gl.clearStencil(a),
            this.clearStencil = a)
        },
        setRenderTarget: function(a) {
            this.renderTarget = a
        },
        getRenderTarget: function() {
            return this.renderTarget
        },
        getDepthTest: function() {
            return this.depthTest
        },
        setDepthTest: function(a) {
            if (this.depthTest !== a) {
                var b = this.gl;
                a ? b.enable(b.DEPTH_TEST) : b.disable(b.DEPTH_TEST);
                this.depthTest = a
            }
        },
        setDepthFunc: function(a) {
            this.depthFunc !== a && (this.gl.depthFunc(this.glComparison[a]),
            this.depthFunc = a)
        },
        getDepthWrite: function() {
            return this.depthWrite
        },
        setDepthWrite: function(a) {
            this.depthWrite !== a && (this.gl.depthMask(a),
            this.depthWrite = a)
        },
        setColorWrite: function(a, b, c, d) {
            if (this.writeRed !== a || this.writeGreen !== b || this.writeBlue !== c || this.writeAlpha !== d)
                this.gl.colorMask(a, b, c, d),
                this.writeRed = a,
                this.writeGreen = b,
                this.writeBlue = c,
                this.writeAlpha = d
        },
        setAlphaToCoverage: function(a) {
            this.webgl2 && this.alphaToCoverage !== a && ((this.alphaToCoverage = a) ? this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE) : this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE))
        },
        setTransformFeedbackBuffer: function(a) {
            if (this.transformFeedbackBuffer !== a && (this.transformFeedbackBuffer = a,
            this.webgl2)) {
                var b = this.gl;
                a ? (this.feedback || (this.feedback = b.createTransformFeedback()),
                b.bindTransformFeedback(b.TRANSFORM_FEEDBACK, this.feedback)) : b.bindTransformFeedback(b.TRANSFORM_FEEDBACK, null)
            }
        },
        setRaster: function(a) {
            this.raster !== a && (this.raster = a,
            this.webgl2 && (a ? this.gl.disable(this.gl.RASTERIZER_DISCARD) : this.gl.enable(this.gl.RASTERIZER_DISCARD)))
        },
        setDepthBias: function(a) {
            this.depthBiasEnabled !== a && ((this.depthBiasEnabled = a) ? this.gl.enable(this.gl.POLYGON_OFFSET_FILL) : this.gl.disable(this.gl.POLYGON_OFFSET_FILL))
        },
        setDepthBiasValues: function(a, b) {
            this.gl.polygonOffset(b, a)
        },
        getBlending: function() {
            return this.blending
        },
        setBlending: function(a) {
            if (this.blending !== a) {
                var b = this.gl;
                a ? b.enable(b.BLEND) : b.disable(b.BLEND);
                this.blending = a
            }
        },
        setStencilTest: function(a) {
            if (this.stencil !== a) {
                var b = this.gl;
                a ? b.enable(b.STENCIL_TEST) : b.disable(b.STENCIL_TEST);
                this.stencil = a
            }
        },
        setStencilFunc: function(a, b, c) {
            if (this.stencilFuncFront !== a || this.stencilRefFront !== b || this.stencilMaskFront !== c || this.stencilFuncBack !== a || this.stencilRefBack !== b || this.stencilMaskBack !== c)
                this.gl.stencilFunc(this.glComparison[a], b, c),
                this.stencilFuncFront = this.stencilFuncBack = a,
                this.stencilRefFront = this.stencilRefBack = b,
                this.stencilMaskFront = this.stencilMaskBack = c
        },
        setStencilFuncFront: function(a, b, c) {
            if (this.stencilFuncFront !== a || this.stencilRefFront !== b || this.stencilMaskFront !== c) {
                var d = this.gl;
                d.stencilFuncSeparate(d.FRONT, this.glComparison[a], b, c);
                this.stencilFuncFront = a;
                this.stencilRefFront = b;
                this.stencilMaskFront = c
            }
        },
        setStencilFuncBack: function(a, b, c) {
            if (this.stencilFuncBack !== a || this.stencilRefBack !== b || this.stencilMaskBack !== c) {
                var d = this.gl;
                d.stencilFuncSeparate(d.BACK, this.glComparison[a], b, c);
                this.stencilFuncBack = a;
                this.stencilRefBack = b;
                this.stencilMaskBack = c
            }
        },
        setStencilOperation: function(a, b, c, d) {
            if (this.stencilFailFront !== a || this.stencilZfailFront !== b || this.stencilZpassFront !== c || this.stencilFailBack !== a || this.stencilZfailBack !== b || this.stencilZpassBack !== c)
                this.gl.stencilOp(this.glStencilOp[a], this.glStencilOp[b], this.glStencilOp[c]),
                this.stencilFailFront = this.stencilFailBack = a,
                this.stencilZfailFront = this.stencilZfailBack = b,
                this.stencilZpassFront = this.stencilZpassBack = c;
            if (this.stencilWriteMaskFront !== d || this.stencilWriteMaskBack !== d)
                this.gl.stencilMask(d),
                this.stencilWriteMaskBack = this.stencilWriteMaskFront = d
        },
        setStencilOperationFront: function(a, b, c, d) {
            if (this.stencilFailFront !== a || this.stencilZfailFront !== b || this.stencilZpassFront !== c)
                this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[a], this.glStencilOp[b], this.glStencilOp[c]),
                this.stencilFailFront = a,
                this.stencilZfailFront = b,
                this.stencilZpassFront = c;
            this.stencilWriteMaskFront !== d && (this.gl.stencilMaskSeparate(this.gl.FRONT, d),
            this.stencilWriteMaskFront = d)
        },
        setStencilOperationBack: function(a, b, c, d) {
            if (this.stencilFailBack !== a || this.stencilZfailBack !== b || this.stencilZpassBack !== c)
                this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[a], this.glStencilOp[b], this.glStencilOp[c]),
                this.stencilFailBack = a,
                this.stencilZfailBack = b,
                this.stencilZpassBack = c;
            this.stencilWriteMaskBack !== d && (this.gl.stencilMaskSeparate(this.gl.BACK, d),
            this.stencilWriteMaskBack = d)
        },
        setBlendFunction: function(a, b) {
            if (this.blendSrc !== a || this.blendDst !== b || this.separateAlphaBlend)
                this.gl.blendFunc(this.glBlendFunction[a], this.glBlendFunction[b]),
                this.blendSrc = a,
                this.blendDst = b,
                this.separateAlphaBlend = !1
        },
        setBlendFunctionSeparate: function(a, b, c, d) {
            this.blendSrc === a && this.blendDst === b && this.blendSrcAlpha === c && this.blendDstAlpha === d && this.separateAlphaBlend || (this.gl.blendFuncSeparate(this.glBlendFunction[a], this.glBlendFunction[b], this.glBlendFunction[c], this.glBlendFunction[d]),
            this.blendSrc = a,
            this.blendDst = b,
            this.blendSrcAlpha = c,
            this.blendDstAlpha = d,
            this.separateAlphaBlend = !0)
        },
        setBlendEquation: function(a) {
            if (this.blendEquation !== a || this.separateAlphaEquation)
                this.gl.blendEquation(this.glBlendEquation[a]),
                this.blendEquation = a,
                this.separateAlphaEquation = !1
        },
        setBlendEquationSeparate: function(a, b) {
            this.blendEquation === a && this.blendAlphaEquation === b && this.separateAlphaEquation || (this.gl.blendEquationSeparate(this.glBlendEquation[a], this.glBlendEquation[b]),
            this.blendEquation = a,
            this.blendAlphaEquation = b,
            this.separateAlphaEquation = !0)
        },
        setCullMode: function(a) {
            if (this.cullMode !== a) {
                if (0 === a)
                    this.gl.disable(this.gl.CULL_FACE);
                else {
                    0 === this.cullMode && this.gl.enable(this.gl.CULL_FACE);
                    var b = this.glCull[a];
                    this.cullFace !== b && (this.gl.cullFace(b),
                    this.cullFace = b)
                }
                this.cullMode = a
            }
        },
        getCullMode: function() {
            return this.cullMode
        },
        setIndexBuffer: function(a) {
            this.indexBuffer = a
        },
        setVertexBuffer: function(a) {
            a && this.vertexBuffers.push(a)
        },
        compileShaderSource: function(a, b) {
            var c = this.gl
              , d = b ? this.vertexShaderCache[a] : this.fragmentShaderCache[a];
            d || (d = c.createShader(b ? c.VERTEX_SHADER : c.FRAGMENT_SHADER),
            c.shaderSource(d, a),
            c.compileShader(d),
            b ? this.vertexShaderCache[a] = d : this.fragmentShaderCache[a] = d);
            return d
        },
        compileAndLinkShader: function(a) {
            var b = this.gl, c = a.definition, d, e = c.attributes, f = this.compileShaderSource(c.vshader, !0), g = this.compileShaderSource(c.fshader, !1), k = b.createProgram();
            b.attachShader(k, f);
            b.attachShader(k, g);
            if (this.webgl2 && c.useTransformFeedback) {
                c = [];
                for (d in e)
                    e.hasOwnProperty(d) && c.push("out_" + d);
                b.transformFeedbackVaryings(k, c, b.INTERLEAVED_ATTRIBS)
            }
            c = {};
            for (d in e)
                if (e.hasOwnProperty(d)) {
                    var h = Jj[e[d]];
                    c.hasOwnProperty(h);
                    c[h] = d;
                    b.bindAttribLocation(k, h, d)
                }
            b.linkProgram(k);
            a._glVertexShader = f;
            a._glFragmentShader = g;
            a._glProgram = k
        },
        createShader: function(a) {
            this.compileAndLinkShader(a);
            this.shaders.push(a)
        },
        destroyShader: function(a) {
            var b = this.shaders.indexOf(a);
            -1 !== b && this.shaders.splice(b, 1);
            a._glProgram && (this.gl.deleteProgram(a._glProgram),
            a._glProgram = null,
            this.removeShaderFromCache(a))
        },
        _addLineNumbers: function(a) {
            a = a.split("\n");
            for (var b = 0, c = a.length; b < c; b++)
                a[b] = b + 1 + ":\t" + a[b];
            return a.join("\n")
        },
        postLink: function(a) {
            var b = this.gl
              , c = a._glVertexShader
              , d = a._glFragmentShader
              , e = a._glProgram
              , f = a.definition;
            if (!b.getShaderParameter(c, b.COMPILE_STATUS))
                return console.error("Failed to compile vertex shader:\n\n" + this._addLineNumbers(f.vshader) + "\n\n" + b.getShaderInfoLog(c)),
                !1;
            if (!b.getShaderParameter(d, b.COMPILE_STATUS))
                return console.error("Failed to compile fragment shader:\n\n" + this._addLineNumbers(f.fshader) + "\n\n" + b.getShaderInfoLog(d)),
                !1;
            if (!b.getProgramParameter(e, b.LINK_STATUS))
                return console.error("Failed to link shader program. Error: " + b.getProgramInfoLog(e)),
                !1;
            c = 0;
            for (var g = b.getProgramParameter(e, b.ACTIVE_ATTRIBUTES); c < g; ) {
                d = b.getActiveAttrib(e, c++);
                var k = b.getAttribLocation(e, d.name);
                void 0 === f.attributes[d.name] && console.error('Vertex shader attribute "' + d.name + '" is not mapped to a semantic in shader definition.');
                k = new vj(this,f.attributes[d.name],this.pcUniformType[d.type],k);
                a.attributes.push(k)
            }
            c = 0;
            for (f = b.getProgramParameter(e, b.ACTIVE_UNIFORMS); c < f; )
                d = b.getActiveUniform(e, c++),
                k = b.getUniformLocation(e, d.name),
                k = new vj(this,d.name,this.pcUniformType[d.type],k),
                d.type === b.SAMPLER_2D || d.type === b.SAMPLER_CUBE || this.webgl2 && (d.type === b.SAMPLER_2D_SHADOW || d.type === b.SAMPLER_CUBE_SHADOW || d.type === b.SAMPLER_3D) ? a.samplers.push(k) : a.uniforms.push(k);
            return a.ready = !0
        },
        setShader: function(a) {
            if (a !== this.shader) {
                if (!a.ready && !this.postLink(a))
                    return !1;
                this.shader = a;
                this.gl.useProgram(a._glProgram);
                this.attributesInvalidated = !0
            }
            return !0
        },
        getHdrFormat: function() {
            return this.textureHalfFloatRenderable ? 11 : this.textureFloatRenderable ? 13 : 7
        },
        getBoneLimit: function() {
            return this.boneLimit
        },
        setBoneLimit: function(a) {
            this.boneLimit = a
        },
        resizeCanvas: function(a, b) {
            this._width = a;
            this._height = b;
            var c = Math.min(this._maxPixelRatio, window.devicePixelRatio);
            a *= c;
            b *= c;
            if (this.canvas.width !== a || this.canvas.height !== b)
                this.canvas.width = a,
                this.canvas.height = b,
                this.fire("resizecanvas", a, b)
        },
        setResolution: function(a, b) {
            this._width = a;
            this._height = b;
            this.canvas.width = a;
            this.canvas.height = b;
            this.fire("resizecanvas", a, b)
        },
        clearShaderCache: function() {
            var a = this.gl, b;
            for (b in this.fragmentShaderCache)
                a.deleteShader(this.fragmentShaderCache[b]),
                delete this.fragmentShaderCache[b];
            for (b in this.vertexShaderCache)
                a.deleteShader(this.vertexShaderCache[b]),
                delete this.vertexShaderCache[b];
            this.programLib.clearCache()
        },
        clearVertexArrayObjectCache: function() {
            var a = this.gl;
            this._vaoMap.forEach(function(b, c, d) {
                a.deleteVertexArray(b)
            });
            this._vaoMap.clear()
        },
        removeShaderFromCache: function(a) {
            this.programLib.removeFromCache(a)
        },
        destroy: function() {
            var a = this.gl;
            this.destroyGrabPass();
            this.webgl2 && this.feedback && a.deleteTransformFeedback(this.feedback);
            this.clearShaderCache();
            this.clearVertexArrayObjectCache();
            this.canvas.removeEventListener("webglcontextlost", this._contextLostHandler, !1);
            this.canvas.removeEventListener("webglcontextrestored", this._contextRestoredHandler, !1);
            this.gl = this.canvas = this._contextRestoredHandler = this._contextLostHandler = null
        }
    });
    Object.defineProperty(ib.prototype, "width", {
        get: function() {
            return this.gl.drawingBufferWidth || this.canvas.width
        }
    });
    Object.defineProperty(ib.prototype, "height", {
        get: function() {
            return this.gl.drawingBufferHeight || this.canvas.height
        }
    });
    Object.defineProperty(ib.prototype, "fullscreen", {
        get: function() {
            return !!document.fullscreenElement
        },
        set: function(a) {
            a ? this.gl.canvas.requestFullscreen() : document.exitFullscreen()
        }
    });
    Object.defineProperty(ib.prototype, "enableAutoInstancing", {
        get: function() {
            return this._enableAutoInstancing
        },
        set: function(a) {
            this._enableAutoInstancing = a && this.extInstancing
        }
    });
    Object.defineProperty(ib.prototype, "maxPixelRatio", {
        get: function() {
            return this._maxPixelRatio
        },
        set: function(a) {
            this._maxPixelRatio = a;
            this.resizeCanvas(this._width, this._height)
        }
    });
    Object.defineProperty(ib.prototype, "textureFloatHighPrecision", {
        get: function() {
            if (void 0 === this._textureFloatHighPrecision) {
                if (this.textureFloatRenderable) {
                    var a = Wa(this, F.fullscreenQuadVS, F.precisionTestPS, "ptest1")
                      , b = Wa(this, F.fullscreenQuadVS, F.precisionTest2PS, "ptest2")
                      , c = {
                        format: 14,
                        width: 1,
                        height: 1,
                        mipmaps: !1,
                        minFilter: 0,
                        magFilter: 0
                    };
                    var d = new V(this,c);
                    d.name = "testFHP";
                    var e = new ra(this,d,{
                        depth: !1
                    });
                    La(this, e, a);
                    c.format = 7;
                    a = new V(this,c);
                    a.name = "testFHP";
                    c = new ra(this,a,{
                        depth: !1
                    });
                    this.constantTexSource.setValue(d);
                    La(this, c, b);
                    b = this.activeFramebuffer;
                    this.setFramebuffer(c._glFrameBuffer);
                    var f = new Uint8Array(4);
                    this.readPixels(0, 0, 1, 1, f);
                    this.setFramebuffer(b);
                    b = f[0] / 255 / 16777216 + f[1] / 255 / 65536 + f[2] / 255 / 256 + f[3] / 255;
                    d.destroy();
                    e.destroy();
                    a.destroy();
                    c.destroy();
                    d = 0 === b
                } else
                    d = !1;
                this._textureFloatHighPrecision = d
            }
            return this._textureFloatHighPrecision
        }
    });
    Object.defineProperties(ib.prototype, {
        textureHalfFloatUpdatable: {
            get: function() {
                if (void 0 === this._textureHalfFloatUpdatable)
                    if (this.webgl2)
                        this._textureHalfFloatUpdatable = !0;
                    else {
                        var a = this.gl
                          , b = this.extTextureHalfFloat.HALF_FLOAT_OES
                          , c = !0
                          , d = a.createTexture();
                        a.bindTexture(a.TEXTURE_2D, d);
                        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST);
                        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST);
                        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE);
                        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);
                        var e = new Uint16Array(16);
                        a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, 2, 2, 0, a.RGBA, b, e);
                        a.getError() !== a.NO_ERROR && (c = !1,
                        console.log("Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support"));
                        a.bindTexture(a.TEXTURE_2D, null);
                        a.deleteTexture(d);
                        this._textureHalfFloatUpdatable = c
                    }
                return this._textureHalfFloatUpdatable
            }
        }
    });
    var Vp = {
        depth: !0,
        face: 0
    }
      , ra = function(a, b, c) {
        a instanceof ib ? (this._colorBuffer = b,
        a = c) : this._colorBuffer = a.colorBuffer;
        this._glDepthBuffer = this._glFrameBuffer = null;
        a = void 0 !== a ? a : Vp;
        this._depthBuffer = a.depthBuffer;
        this._face = void 0 !== a.face ? a.face : 0;
        this._depthBuffer ? (b = this._depthBuffer._format,
        16 === b ? (this._depth = !0,
        this._stencil = !1) : this._stencil = 17 === b ? this._depth = !0 : this._depth = !1) : (this._depth = void 0 !== a.depth ? a.depth : !0,
        this._stencil = void 0 !== a.stencil ? a.stencil : !1);
        this._samples = void 0 !== a.samples ? a.samples : 1;
        this.autoResolve = void 0 !== a.autoResolve ? a.autoResolve : !0;
        this._glMsaaDepthBuffer = this._glMsaaColorBuffer = this._glResolveFrameBuffer = null
    };
    Object.assign(ra.prototype, {
        destroy: function() {
            if (this._device) {
                var a = this._device
                  , b = a.targets.indexOf(this);
                -1 !== b && a.targets.splice(b, 1);
                a = a.gl;
                this._glFrameBuffer && (a.deleteFramebuffer(this._glFrameBuffer),
                this._glFrameBuffer = null);
                this._glDepthBuffer && (a.deleteRenderbuffer(this._glDepthBuffer),
                this._glDepthBuffer = null);
                this._glResolveFrameBuffer && (a.deleteFramebuffer(this._glResolveFrameBuffer),
                this._glResolveFrameBuffer = null);
                this._glMsaaColorBuffer && (a.deleteRenderbuffer(this._glMsaaColorBuffer),
                this._glMsaaColorBuffer = null);
                this._glMsaaDepthBuffer && (a.deleteRenderbuffer(this._glMsaaDepthBuffer),
                this._glMsaaDepthBuffer = null)
            }
        },
        resolve: function(a, b) {
            if (this._device && this._device.webgl2) {
                var c = this._device.gl;
                void 0 === a && (a = !0);
                void 0 === b && this._depthBuffer && (b = !0);
                c.bindFramebuffer(c.READ_FRAMEBUFFER, this._glFrameBuffer);
                c.bindFramebuffer(c.DRAW_FRAMEBUFFER, this._glResolveFrameBuffer);
                c.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, (a ? c.COLOR_BUFFER_BIT : 0) | (b ? c.DEPTH_BUFFER_BIT : 0), c.NEAREST);
                c.bindFramebuffer(c.FRAMEBUFFER, this._glFrameBuffer)
            }
        },
        copy: function(a, b, c) {
            if (!this._device)
                if (a._device)
                    this._device = a._device;
                else
                    return !1;
            return this._device.copyRenderTarget(a, this, b, c)
        }
    });
    Object.defineProperty(ra.prototype, "colorBuffer", {
        get: function() {
            return this._colorBuffer
        }
    });
    Object.defineProperty(ra.prototype, "depthBuffer", {
        get: function() {
            return this._depthBuffer
        }
    });
    Object.defineProperty(ra.prototype, "face", {
        get: function() {
            return this._face
        }
    });
    Object.defineProperty(ra.prototype, "width", {
        get: function() {
            return this._colorBuffer ? this._colorBuffer.width : this._depthBuffer.width
        }
    });
    Object.defineProperty(ra.prototype, "height", {
        get: function() {
            return this._colorBuffer ? this._colorBuffer.height : this._depthBuffer.height
        }
    });
    var jn = function(a) {
        switch (a.type) {
        case "rgbm":
            return "RGBM";
        case "rgbe":
            return "RGBE";
        default:
            switch (a.format) {
            case 11:
            case 13:
            case 12:
            case 14:
                return "Linear";
            default:
                return "Gamma"
            }
        }
    }
      , Io = {
        type: 5,
        base: 0,
        count: 4,
        indexed: !1
    };
    Object.assign(wj.prototype, {
        render: function(a, b, c) {}
    });
    Kf.createShader = function(a, b, c) {
        return Wa(a, b, null, c, !0)
    }
    ;
    Object.assign(Kf.prototype, {
        destroy: function() {
            this._outputBuffer.destroy()
        },
        process: function(a, b) {
            void 0 === b && (b = !0);
            var c = this.device;
            c.setRenderTarget(null);
            c.updateBegin();
            c.setVertexBuffer(this._inputBuffer, 0);
            c.setRaster(!1);
            c.setTransformFeedbackBuffer(this._outputBuffer);
            c.setShader(a);
            c.draw({
                type: 0,
                base: 0,
                count: this._inputBuffer.numVertices,
                indexed: !1
            });
            c.setTransformFeedbackBuffer(null);
            c.setRaster(!0);
            c.updateEnd();
            b && (a = this._inputBuffer.bufferId,
            this._inputBuffer.bufferId = this._outputBuffer.bufferId,
            this._outputBuffer.bufferId = a,
            a = this._inputBuffer._vao,
            this._inputBuffer._vao = this._outputBuffer._vao,
            this._outputBuffer._vao = a)
        }
    });
    Object.defineProperty(Kf.prototype, "inputBuffer", {
        get: function() {
            return this._inputBuffer
        }
    });
    Object.defineProperty(Kf.prototype, "outputBuffer", {
        get: function() {
            return this._outputBuffer
        }
    });
    $d.prototype = Object.create(ka.prototype);
    $d.prototype.constructor = $d;
    Object.assign($d.prototype, {
        clone: function() {
            var a = new $d;
            ka.prototype._cloneInternal.call(this, a);
            return a
        },
        updateShader: function(a) {
            var b = {
                skin: !!this.meshInstances[0].skinInstance
            };
            this.shader = a.getProgramLibrary().getProgram("depth", b)
        }
    });
    pd.prototype.getSelection = function(a, b, c, d) {
        var e = this.device;
        "object" === typeof a ? (d = a,
        a = d.x,
        b = d.y,
        c = d.width,
        d = d.height) : b = this.layer.renderTarget.height - (b + (d || 1));
        c = c || 1;
        d = d || 1;
        var f = e.renderTarget;
        e.setRenderTarget(this.layer.renderTarget);
        e.updateBegin();
        var g = new Uint8Array(4 * c * d);
        e.readPixels(a, b, c, d, g);
        e.updateEnd();
        e.setRenderTarget(f);
        a = [];
        b = this.layer.instances.visibleOpaque[0].list;
        for (e = 0; e < c * d; e++) {
            f = g[4 * e];
            var k = g[4 * e + 1];
            var h = g[4 * e + 2];
            f = f << 16 | k << 8 | h;
            16777215 !== f && (f = b[f],
            -1 === a.indexOf(f) && a.push(f))
        }
        return a
    }
    ;
    pd.prototype.prepare = function(a, b, c) {
        var d = this.device
          , e = this;
        a instanceof pa && (a = a.node.camera);
        this.scene = b;
        var f = null
          , g = null;
        c instanceof ma ? f = c : g = c;
        if (!this.layer) {
            var k = d.scope.resolve("uColor");
            this.layer = new ma({
                name: "Picker",
                shaderPass: 18,
                opaqueSortMode: 0,
                onEnable: function() {
                    if (!this.renderTarget) {
                        var t = new V(d,{
                            format: 7,
                            width: e.width,
                            height: e.height
                        });
                        t.name = "pick";
                        t.minFilter = 0;
                        t.magFilter = 0;
                        t.addressU = 1;
                        t.addressV = 1;
                        this.renderTarget = new ra(d,t,{
                            depth: !0
                        })
                    }
                },
                onDisable: function() {
                    this.renderTarget && (this.renderTarget._colorBuffer.destroy(),
                    this.renderTarget.destroy(),
                    this.renderTarget = null)
                },
                onDrawCall: function(t, u) {
                    e.pickColor[0] = (u >> 16 & 255) / 255;
                    e.pickColor[1] = (u >> 8 & 255) / 255;
                    e.pickColor[2] = (u & 255) / 255;
                    k.setValue(e.pickColor);
                    d.setBlending(!1)
                }
            });
            this.layerComp = new xa;
            this.layerComp.pushOpaque(this.layer);
            this.meshInstances = this.layer.opaqueMeshInstances;
            this._instancesVersion = -1
        }
        if (!f) {
            this.layer.clearMeshInstances();
            c = b.layers.layerList;
            var h = b.layers.subLayerEnabled
              , l = b.layers.subLayerList;
            for (b = 0; b < c.length; b++)
                c[b].overrideClear && c[b]._clearDepthBuffer && (c[b]._pickerCleared = !1);
            for (b = 0; b < c.length; b++) {
                var n = c[b];
                if (n.renderTarget === g && n.enabled && h[b]) {
                    var p = n.cameras.indexOf(a);
                    if (!(0 > p)) {
                        n.overrideClear && n._clearDepthBuffer && !n._pickerCleared && (this.meshInstances.push(this.clearDepthCommand),
                        n._pickerCleared = !0);
                        p = (p = l[b]) ? n.instances.transparentMeshInstances : n.instances.opaqueMeshInstances;
                        var q = p.length;
                        for (n = 0; n < q; n++) {
                            var r = p[n];
                            r.pick && this.meshInstances.push(r)
                        }
                    }
                }
            }
        } else if (this._instancesVersion !== f._version) {
            this.layer.clearMeshInstances();
            p = f.instances.opaqueMeshInstances;
            q = p.length;
            for (n = 0; n < q; n++)
                r = p[n],
                r.pick && this.meshInstances.push(r);
            p = f.instances.transparentMeshInstances;
            q = p.length;
            for (n = 0; n < q; n++)
                r = p[n],
                r.pick && this.meshInstances.push(r);
            this._instancesVersion = f._version
        }
        this.layer.cameras[0] !== a && (this.layer.clearCameras(),
        this.layer.addCamera(a));
        this.onLayerPreRender(this.layer, f, g);
        this.app.renderer.renderComposition(this.layerComp);
        this.onLayerPostRender(this.layer)
    }
    ;
    pd.prototype.onLayerPreRender = function(a, b, c) {
        if (this.width !== a.renderTarget.width || this.height !== a.renderTarget.height)
            a.onDisable(),
            a.onEnable();
        a.oldClear = a.cameras[0].camera._clearOptions;
        a.oldAspectMode = a.cameras[0].aspectRatioMode;
        a.oldAspect = a.cameras[0].aspectRatio;
        a.cameras[0].camera._clearOptions = this.clearOptions;
        a.cameras[0].aspectRatioMode = 1;
        a.cameras[0].aspectRatio = a.cameras[0].calculateAspectRatio(c ? c : b ? b.renderTarget : null);
        this.app.renderer.updateCameraFrustum(a.cameras[0].camera)
    }
    ;
    pd.prototype.onLayerPostRender = function(a) {
        a.cameras[0].camera._clearOptions = a.oldClear;
        a.cameras[0].aspectRatioMode = a.oldAspectMode;
        a.cameras[0].aspectRatio = a.oldAspect
    }
    ;
    pd.prototype.resize = function(a, b) {
        this.width = a;
        this.height = b
    }
    ;
    Object.defineProperty(pd.prototype, "renderTarget", {
        get: function() {
            return this.layer.renderTarget
        }
    });
    Object.assign(Jl.prototype, {
        load: function(a, b, c) {
            throw Error("not implemented");
        },
        open: function(a, b, c) {
            throw Error("not implemented");
        },
        patch: function(a, b) {}
    });
    var ch = new xj
      , Wp = {
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        27: "Escape",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        46: "Delete",
        91: "Win"
    };
    jb.prototype = Object.create(M.prototype);
    jb.prototype.constructor = jb;
    jb.prototype.attach = function(a) {
        this._element && this.detach();
        this._element = a;
        this._element.addEventListener("keydown", this._keyDownHandler, !1);
        this._element.addEventListener("keypress", this._keyPressHandler, !1);
        this._element.addEventListener("keyup", this._keyUpHandler, !1)
    }
    ;
    jb.prototype.detach = function() {
        this._element.removeEventListener("keydown", this._keyDownHandler);
        this._element.removeEventListener("keypress", this._keyPressHandler);
        this._element.removeEventListener("keyup", this._keyUpHandler);
        this._element = null
    }
    ;
    jb.prototype.toKeyIdentifier = function(a) {
        a = dh(a);
        var b;
        if (b = Wp[a.toString()])
            return b;
        b = a.toString(16).toUpperCase();
        var c = b.length;
        for (a = 0; a < 4 - c; a++)
            b = "0" + b;
        return "U+" + b
    }
    ;
    jb.prototype._handleKeyDown = function(a) {
        var b = a.keyCode || a.charCode;
        void 0 !== b && (b = this.toKeyIdentifier(b),
        this._keymap[b] = !0,
        this.fire("keydown", yj(a)),
        this.preventDefault && a.preventDefault(),
        this.stopPropagation && a.stopPropagation())
    }
    ;
    jb.prototype._handleKeyUp = function(a) {
        var b = a.keyCode || a.charCode;
        void 0 !== b && (b = this.toKeyIdentifier(b),
        delete this._keymap[b],
        this.fire("keyup", yj(a)),
        this.preventDefault && a.preventDefault(),
        this.stopPropagation && a.stopPropagation())
    }
    ;
    jb.prototype._handleKeyPress = function(a) {
        this.fire("keypress", yj(a));
        this.preventDefault && a.preventDefault();
        this.stopPropagation && a.stopPropagation()
    }
    ;
    jb.prototype.update = function() {
        for (var a in this._lastmap)
            delete this._lastmap[a];
        for (a in this._keymap)
            this._keymap.hasOwnProperty(a) && (this._lastmap[a] = this._keymap[a])
    }
    ;
    jb.prototype.isPressed = function(a) {
        a = dh(a);
        a = this.toKeyIdentifier(a);
        return !!this._keymap[a]
    }
    ;
    jb.prototype.wasPressed = function(a) {
        a = dh(a);
        a = this.toKeyIdentifier(a);
        return !!this._keymap[a] && !this._lastmap[a]
    }
    ;
    jb.prototype.wasReleased = function(a) {
        a = dh(a);
        a = this.toKeyIdentifier(a);
        return !this._keymap[a] && !!this._lastmap[a]
    }
    ;
    Kb.prototype = Object.create(M.prototype);
    Kb.prototype.constructor = Kb;
    Kb.isPointerLocked = function() {
        return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement)
    }
    ;
    Object.assign(Kb.prototype, {
        attach: function(a) {
            this._target = a;
            this._attached || (this._attached = !0,
            a = Ca.passiveEvents ? {
                passive: !1
            } : !1,
            window.addEventListener("mouseup", this._upHandler, a),
            window.addEventListener("mousedown", this._downHandler, a),
            window.addEventListener("mousemove", this._moveHandler, a),
            window.addEventListener("wheel", this._wheelHandler, a))
        },
        detach: function() {
            if (this._attached) {
                this._attached = !1;
                this._target = null;
                var a = Ca.passiveEvents ? {
                    passive: !1
                } : !1;
                window.removeEventListener("mouseup", this._upHandler, a);
                window.removeEventListener("mousedown", this._downHandler, a);
                window.removeEventListener("mousemove", this._moveHandler, a);
                window.removeEventListener("wheel", this._wheelHandler, a)
            }
        },
        disableContextMenu: function() {
            this._target && this._target.addEventListener("contextmenu", this._contextMenuHandler)
        },
        enableContextMenu: function() {
            this._target && this._target.removeEventListener("contextmenu", this._contextMenuHandler)
        },
        enablePointerLock: function(a, b) {
            if (document.body.requestPointerLock) {
                var c = function() {
                    a();
                    document.removeEventListener("pointerlockchange", c)
                }
                  , d = function() {
                    b();
                    document.removeEventListener("pointerlockerror", d)
                };
                a && document.addEventListener("pointerlockchange", c, !1);
                b && document.addEventListener("pointerlockerror", d, !1);
                document.body.requestPointerLock()
            } else
                b && b()
        },
        disablePointerLock: function(a) {
            if (document.exitPointerLock) {
                var b = function() {
                    a();
                    document.removeEventListener("pointerlockchange", b)
                };
                a && document.addEventListener("pointerlockchange", b, !1);
                document.exitPointerLock()
            }
        },
        update: function() {
            this._lastbuttons[0] = this._buttons[0];
            this._lastbuttons[1] = this._buttons[1];
            this._lastbuttons[2] = this._buttons[2]
        },
        isPressed: function(a) {
            return this._buttons[a]
        },
        wasPressed: function(a) {
            return this._buttons[a] && !this._lastbuttons[a]
        },
        wasReleased: function(a) {
            return !this._buttons[a] && this._lastbuttons[a]
        },
        _handleUp: function(a) {
            this._buttons[a.button] = !1;
            a = new qd(this,a);
            a.event && this.fire("mouseup", a)
        },
        _handleDown: function(a) {
            this._buttons[a.button] = !0;
            a = new qd(this,a);
            a.event && this.fire("mousedown", a)
        },
        _handleMove: function(a) {
            a = new qd(this,a);
            a.event && (this.fire("mousemove", a),
            this._lastX = a.x,
            this._lastY = a.y)
        },
        _handleWheel: function(a) {
            a = new qd(this,a);
            a.event && this.fire("mousewheel", a)
        },
        _getTargetCoords: function(a) {
            var b = this._target.getBoundingClientRect()
              , c = Math.floor(b.left);
            b = Math.floor(b.top);
            return a.clientX < c || a.clientX >= c + this._target.clientWidth || a.clientY < b || a.clientY >= b + this._target.clientHeight ? null : {
                x: a.clientX - c,
                y: a.clientY - b
            }
        }
    });
    kb.prototype.attach = function(a) {
        this._element = a;
        this._keyboard && this._keyboard.attach(a);
        this._mouse && this._mouse.attach(a)
    }
    ;
    kb.prototype.detach = function() {
        this._keyboard && this._keyboard.detach();
        this._mouse && this._mouse.detach();
        this._element = null
    }
    ;
    kb.prototype.disableContextMenu = function() {
        this._mouse || this._enableMouse();
        this._mouse.disableContextMenu()
    }
    ;
    kb.prototype.enableContextMenu = function() {
        this._mouse || this._enableMouse();
        this._mouse.enableContextMenu()
    }
    ;
    kb.prototype.update = function(a) {
        this._keyboard && this._keyboard.update(a);
        this._mouse && this._mouse.update(a);
        this._gamepads && this._gamepads.update(a);
        this._axesValues = {};
        for (var b in this._axes)
            this._axesValues[b] = []
    }
    ;
    kb.prototype.registerKeys = function(a, b) {
        this._keyboard || this._enableKeyboard();
        if (this._actions[a])
            throw Error("Action: " + a + " already registered");
        if (void 0 === b)
            throw Error("Invalid button");
        b.length || (b = [b]);
        this._actions[a] ? this._actions[a].push({
            type: "keyboard",
            keys: b
        }) : this._actions[a] = [{
            type: "keyboard",
            keys: b
        }]
    }
    ;
    kb.prototype.registerMouse = function(a, b) {
        this._mouse || this._enableMouse();
        if (void 0 === b)
            throw Error("Invalid button");
        this._actions[a] ? this._actions[a].push({
            type: "mouse",
            button: b
        }) : this._actions[a] = [{
            type: "mouse",
            button: -b
        }]
    }
    ;
    kb.prototype.registerPadButton = function(a, b, c) {
        if (void 0 === c)
            throw Error("Invalid button");
        this._actions[a] ? this._actions[a].push({
            type: "gamepad",
            button: c,
            pad: b
        }) : this._actions[a] = [{
            type: "gamepad",
            button: c,
            pad: b
        }]
    }
    ;
    kb.prototype.registerAxis = function(a) {
        var b = a.name;
        this._axes[b] || (this._axes[b] = []);
        var c = this._axes[b].push(b);
        a = a || {};
        a.pad = a.pad || 0;
        var d = function(e, f, g, k) {
            switch (f) {
            case "mousex":
                e._mouse.on("mousemove", function(h) {
                    e._axesValues[b][c] = h.dx / 10
                });
                break;
            case "mousey":
                e._mouse.on("mousemove", function(h) {
                    e._axesValues[b][c] = h.dy / 10
                });
                break;
            case "key":
                e._axes[b].push(function() {
                    return e._keyboard.isPressed(k) ? g : 0
                });
                break;
            case "padrx":
                e._axes[b].push(function() {
                    return e._gamepads.getAxis(a.pad, 2)
                });
                break;
            case "padry":
                e._axes[b].push(function() {
                    return e._gamepads.getAxis(a.pad, 3)
                });
                break;
            case "padlx":
                e._axes[b].push(function() {
                    return e._gamepads.getAxis(a.pad, 0)
                });
                break;
            case "padly":
                e._axes[b].push(function() {
                    return e._gamepads.getAxis(a.pad, 1)
                });
                break;
            default:
                throw Error("Unknown axis");
            }
        };
        d(this, a.positive, 1, a.positiveKey);
        (a.negativeKey || a.negative !== a.positive) && d(this, a.negative, -1, a.negativeKey)
    }
    ;
    kb.prototype.isPressed = function(a) {
        if (!this._actions[a])
            return !1;
        var b, c = this._actions[a].length;
        for (b = 0; b < c; ++b) {
            var d = this._actions[a][b];
            switch (d.type) {
            case "keyboard":
                if (this._keyboard) {
                    var e, f = d.keys.length;
                    for (e = 0; e < f; e++)
                        if (this._keyboard.isPressed(d.keys[e]))
                            return !0
                }
                break;
            case "mouse":
                if (this._mouse && this._mouse.isPressed(d.button))
                    return !0;
                break;
            case "gamepad":
                if (this._gamepads && this._gamepads.isPressed(d.pad, d.button))
                    return !0
            }
        }
        return !1
    }
    ;
    kb.prototype.wasPressed = function(a) {
        if (!this._actions[a])
            return !1;
        var b, c = this._actions[a].length;
        for (b = 0; b < c; ++b) {
            var d = this._actions[a][b];
            switch (d.type) {
            case "keyboard":
                if (this._keyboard) {
                    var e, f = d.keys.length;
                    for (e = 0; e < f; e++)
                        if (this._keyboard.wasPressed(d.keys[e]))
                            return !0
                }
                break;
            case "mouse":
                if (this._mouse && this._mouse.wasPressed(d.button))
                    return !0;
                break;
            case "gamepad":
                if (this._gamepads && this._gamepads.wasPressed(d.pad, d.button))
                    return !0
            }
        }
        return !1
    }
    ;
    kb.prototype.getAxis = function(a) {
        var b = 0;
        if (this._axes[a]) {
            var c, d = this._axes[a].length;
            for (c = 0; c < d; c++)
                if ("function" === Zc(this._axes[a][c])) {
                    var e = this._axes[a][c]();
                    Math.abs(e) > Math.abs(b) && (b = e)
                } else
                    this._axesValues[a] && Math.abs(this._axesValues[a][c]) > Math.abs(b) && (b = this._axesValues[a][c])
        }
        return b
    }
    ;
    kb.prototype._enableMouse = function() {
        this._mouse = new Kb;
        if (!this._element)
            throw Error("Controller must be attached to an Element");
        this._mouse.attach(this._element)
    }
    ;
    kb.prototype._enableKeyboard = function() {
        this._keyboard = new jb;
        if (!this._element)
            throw Error("Controller must be attached to an Element");
        this._keyboard.attach(this._element)
    }
    ;
    var cc, Ad, kn = new z, ln = new z, Bd = new bd, mn = new bd, sk = new bd;
    Bd.end = new z;
    mn.end = new z;
    sk.end = new z;
    var Re = new z
      , eh = new z
      , zj = new z
      , Kl = new z
      , Aj = new z
      , fh = new z
      , Ll = new z
      , tk = new P
      , og = new z
      , Uh = new z
      , Vh = new z
      , pg = new z
      , nn = new z
      , on = new z
      , pn = new z
      , qn = new z
      , Xp = new X;
    Object.assign(rd.prototype, {
        stopPropagation: function() {
            this._stopPropagation = !0;
            this.event && (this.event.stopImmediatePropagation(),
            this.event.stopPropagation())
        }
    });
    sd.prototype = Object.create(rd.prototype);
    sd.prototype.constructor = sd;
    Oc.prototype = Object.create(rd.prototype);
    Oc.prototype.constructor = Oc;
    lc.prototype = Object.create(rd.prototype);
    lc.prototype.constructor = lc;
    Object.assign(Lf.prototype, {
        attach: function(a) {
            this._attached && (this._attached = !1,
            this.detach());
            this._target = a;
            this._attached = !0;
            a = Ca.passiveEvents ? {
                passive: !0
            } : !1;
            this._useMouse && (window.addEventListener("mouseup", this._upHandler, a),
            window.addEventListener("mousedown", this._downHandler, a),
            window.addEventListener("mousemove", this._moveHandler, a),
            window.addEventListener("wheel", this._wheelHandler, a));
            this._useTouch && Ca.touch && (this._target.addEventListener("touchstart", this._touchstartHandler, a),
            this._target.addEventListener("touchend", this._touchendHandler, !1),
            this._target.addEventListener("touchmove", this._touchmoveHandler, !1),
            this._target.addEventListener("touchcancel", this._touchcancelHandler, !1));
            this.attachSelectEvents()
        },
        attachSelectEvents: function() {
            !this._selectEventsAttached && this._useXr && this.app && this.app.xr && this.app.xr.supported && (this._clickedEntities || (this._clickedEntities = {}),
            this._selectEventsAttached = !0,
            this.app.xr.on("start", this._onXrStart, this))
        },
        detach: function() {
            if (this._attached) {
                this._attached = !1;
                var a = Ca.passiveEvents ? {
                    passive: !0
                } : !1;
                this._useMouse && (window.removeEventListener("mouseup", this._upHandler, a),
                window.removeEventListener("mousedown", this._downHandler, a),
                window.removeEventListener("mousemove", this._moveHandler, a),
                window.removeEventListener("wheel", this._wheelHandler, a));
                this._useTouch && (this._target.removeEventListener("touchstart", this._touchstartHandler, a),
                this._target.removeEventListener("touchend", this._touchendHandler, !1),
                this._target.removeEventListener("touchmove", this._touchmoveHandler, !1),
                this._target.removeEventListener("touchcancel", this._touchcancelHandler, !1));
                this._selectEventsAttached && (this._selectEventsAttached = !1,
                this.app.xr.off("start", this._onXrStart, this),
                this.app.xr.off("end", this._onXrEnd, this),
                this.app.xr.off("update", this._onXrUpdate, this),
                this.app.xr.input.off("selectstart", this._onSelectStart, this),
                this.app.xr.input.off("selectend", this._onSelectEnd, this),
                this.app.xr.input.off("remove", this._onXrInputRemove, this));
                this._target = null
            }
        },
        addElement: function(a) {
            -1 === this._elements.indexOf(a) && this._elements.push(a)
        },
        removeElement: function(a) {
            a = this._elements.indexOf(a);
            -1 !== a && this._elements.splice(a, 1)
        },
        _handleUp: function(a) {
            this._enabled && !Kb.isPointerLocked() && (this._calcMouseCoords(a),
            null !== cc && this._onElementMouseEvent("mouseup", a))
        },
        _handleDown: function(a) {
            this._enabled && !Kb.isPointerLocked() && (this._calcMouseCoords(a),
            null !== cc && this._onElementMouseEvent("mousedown", a))
        },
        _handleMove: function(a) {
            this._enabled && (this._calcMouseCoords(a),
            null !== cc && (this._onElementMouseEvent("mousemove", a),
            this._lastX = cc,
            this._lastY = Ad))
        },
        _handleWheel: function(a) {
            this._enabled && (this._calcMouseCoords(a),
            null !== cc && this._onElementMouseEvent("mousewheel", a))
        },
        _determineTouchedElements: function(a) {
            var b = {}, c = this.app.systems.camera.cameras, d, e;
            for (d = c.length - 1; 0 <= d; d--) {
                var f = c[d]
                  , g = 0;
                var k = 0;
                for (e = a.changedTouches.length; k < e; k++)
                    if (b[a.changedTouches[k].identifier])
                        g++;
                    else {
                        var h = this._calcTouchCoords(a.changedTouches[k])
                          , l = this._getTargetElement(f, h.x, h.y);
                        l && (g++,
                        b[a.changedTouches[k].identifier] = {
                            element: l,
                            camera: f,
                            x: h.x,
                            y: h.y
                        })
                    }
                if (g === e)
                    break
            }
            return b
        },
        _handleTouchStart: function(a) {
            if (this._enabled) {
                for (var b = this._determineTouchedElements(a), c = 0, d = a.changedTouches.length; c < d; c++) {
                    var e = a.changedTouches[c]
                      , f = b[e.identifier]
                      , g = this._touchedElements[e.identifier];
                    !f || g && f.element === g.element || (this._fireEvent(a.type, new Oc(a,f.element,f.camera,f.x,f.y,e)),
                    this._touchesForWhichTouchLeaveHasFired[e.identifier] = !1)
                }
                for (var k in b)
                    this._touchedElements[k] = b[k]
            }
        },
        _handleTouchEnd: function(a) {
            if (this._enabled) {
                var b = this.app.systems.camera.cameras;
                for (c in this._clickedEntities)
                    delete this._clickedEntities[c];
                var c = 0;
                for (var d = a.changedTouches.length; c < d; c++) {
                    var e = a.changedTouches[c]
                      , f = this._touchedElements[e.identifier];
                    if (f) {
                        var g = f.element
                          , k = f.camera
                          , h = f.x;
                        f = f.y;
                        delete this._touchedElements[e.identifier];
                        delete this._touchesForWhichTouchLeaveHasFired[e.identifier];
                        this._fireEvent(a.type, new Oc(a,g,k,h,f,e));
                        if (0 === a.touches.length)
                            for (var l = this._calcTouchCoords(e), n = b.length - 1; 0 <= n; n--)
                                this._getTargetElement(b[n], l.x, l.y) !== g || this._clickedEntities[g.entity.getGuid()] || (this._fireEvent("click", new Oc(a,g,k,h,f,e)),
                                this._clickedEntities[g.entity.getGuid()] = !0)
                    }
                }
            }
        },
        _handleTouchMove: function(a) {
            a.preventDefault();
            if (this._enabled)
                for (var b = this._determineTouchedElements(a), c = 0, d = a.changedTouches.length; c < d; c++) {
                    var e = a.changedTouches[c]
                      , f = b[e.identifier]
                      , g = this._touchedElements[e.identifier];
                    if (g) {
                        var k = this._calcTouchCoords(e);
                        f && f.element === g.element || this._touchesForWhichTouchLeaveHasFired[e.identifier] || (this._fireEvent("touchleave", new Oc(a,g.element,g.camera,k.x,k.y,e)),
                        this._touchesForWhichTouchLeaveHasFired[e.identifier] = !0);
                        this._fireEvent("touchmove", new Oc(a,g.element,g.camera,k.x,k.y,e))
                    }
                }
        },
        _onElementMouseEvent: function(a, b) {
            var c, d = this._hoveredElement;
            this._hoveredElement = null;
            for (var e = this.app.systems.camera.cameras, f, g = e.length - 1; 0 <= g && !(f = e[g],
            c = this._getTargetElement(f, cc, Ad)); g--)
                ;
            c && (this._fireEvent(a, new sd(b,c,f,cc,Ad,this._lastX,this._lastY)),
            this._hoveredElement = c,
            "mousedown" === a && (this._pressedElement = c));
            d !== this._hoveredElement && (d && this._fireEvent("mouseleave", new sd(b,d,f,cc,Ad,this._lastX,this._lastY)),
            this._hoveredElement && this._fireEvent("mouseenter", new sd(b,this._hoveredElement,f,cc,Ad,this._lastX,this._lastY)));
            "mouseup" === a && this._pressedElement && (this._pressedElement === this._hoveredElement ? (this._pressedElement = null,
            this._clickedEntities && this._clickedEntities[this._hoveredElement.entity.getGuid()] || this._fireEvent("click", new sd(b,this._hoveredElement,f,cc,Ad,this._lastX,this._lastY))) : this._pressedElement = null)
        },
        _onXrStart: function() {
            this.app.xr.on("end", this._onXrEnd, this);
            this.app.xr.on("update", this._onXrUpdate, this);
            this.app.xr.input.on("selectstart", this._onSelectStart, this);
            this.app.xr.input.on("selectend", this._onSelectEnd, this);
            this.app.xr.input.on("remove", this._onXrInputRemove, this)
        },
        _onXrEnd: function() {
            this.app.xr.off("update", this._onXrUpdate, this);
            this.app.xr.input.off("selectstart", this._onSelectStart, this);
            this.app.xr.input.off("selectend", this._onSelectEnd, this);
            this.app.xr.input.off("remove", this._onXrInputRemove, this)
        },
        _onXrUpdate: function() {
            if (this._enabled)
                for (var a = this.app.xr.input.inputSources, b = 0; b < a.length; b++)
                    this._onElementSelectEvent("selectmove", a[b], null)
        },
        _onXrInputRemove: function(a) {
            var b = this._selectedElements[a.id];
            b && (a._elementEntity = null,
            this._fireEvent("selectleave", new lc(null,b,null,a)));
            delete this._selectedElements[a.id];
            delete this._selectedPressedElements[a.id]
        },
        _onSelectStart: function(a, b) {
            this._enabled && this._onElementSelectEvent("selectstart", a, b)
        },
        _onSelectEnd: function(a, b) {
            this._enabled && this._onElementSelectEvent("selectend", a, b)
        },
        _onElementSelectEvent: function(a, b, c) {
            var d, e = this._selectedElements[b.id], f = this.app.systems.camera.cameras;
            if (b.elementInput) {
                sk.set(b.getOrigin(), b.getDirection());
                for (var g = f.length - 1; 0 <= g; g--) {
                    var k = f[g];
                    if (d = this._getTargetElementByRay(sk, k))
                        break
                }
            }
            b._elementEntity = d || null;
            if (d)
                var h = this._selectedElements[b.id] = d;
            else
                delete this._selectedElements[b.id];
            e !== h && (e && this._fireEvent("selectleave", new lc(c,e,k,b)),
            h && this._fireEvent("selectenter", new lc(c,h,k,b)));
            "selectstart" === a && (this._selectedPressedElements[b.id] = h) && this._fireEvent("selectstart", new lc(c,h,k,b));
            d = this._selectedPressedElements[b.id];
            !b.elementInput && d && (delete this._selectedPressedElements[b.id],
            e && this._fireEvent("selectend", new lc(c,e,k,b)));
            "selectend" === a && b.elementInput && (delete this._selectedPressedElements[b.id],
            e && this._fireEvent("selectend", new lc(c,e,k,b)),
            d && d === e && this._fireEvent("click", new lc(c,d,k,b)))
        },
        _fireEvent: function(a, b) {
            for (var c = b.element; ; ) {
                c.fire(a, b);
                if (b._stopPropagation)
                    break;
                if (!c.entity.parent)
                    break;
                c = c.entity.parent.element;
                if (!c)
                    break
            }
        },
        _calcMouseCoords: function(a) {
            var b = this._target.getBoundingClientRect()
              , c = Math.floor(b.left);
            b = Math.floor(b.top);
            a.clientX < c || a.clientX >= c + this._target.clientWidth || a.clientY < b || a.clientY >= b + this._target.clientHeight ? Ad = cc = null : (cc = a.clientX - c,
            Ad = a.clientY - b)
        },
        _calcTouchCoords: function(a) {
            for (var b = 0, c = 0, d = a.target; !(d instanceof HTMLElement); )
                d = d.parentNode;
            do
                b += d.offsetLeft - d.scrollLeft,
                c += d.offsetTop - d.scrollTop,
                d = d.offsetParent;
            while (d);return {
                x: a.pageX - b,
                y: a.pageY - c
            }
        },
        _sortElements: function(a, b) {
            var c = this.app.scene.layers.sortTransparentLayers(a.layers, b.layers);
            return 0 !== c ? c : a.screen && !b.screen ? -1 : !a.screen && b.screen ? 1 : a.screen || b.screen ? a.screen.screen.screenSpace && !b.screen.screen.screenSpace ? -1 : b.screen.screen.screenSpace && !a.screen.screen.screenSpace ? 1 : b.drawOrder - a.drawOrder : 0
        },
        _getTargetElement: function(a, b, c) {
            var d = null;
            this._elements.sort(this._sortHandler);
            for (var e, f, g = 0, k = this._elements.length; g < k; g++) {
                var h = this._elements[g]
                  , l = !1;
                if (h.screen && h.screen.screen.screenSpace) {
                    void 0 === e && (e = Bd,
                    !1 === this._calculateRayScreen(b, c, a, e) && (e = null));
                    var n = e;
                    l = !0
                } else
                    void 0 === f && (f = mn,
                    !1 === this._calculateRay3d(b, c, a, f) && (f = null)),
                    n = f;
                if (n && this._checkElement(n, h, l)) {
                    d = h;
                    break
                }
            }
            return d
        },
        _getTargetElementByRay: function(a, b) {
            var c = null;
            Bd.origin.copy(a.origin);
            Bd.direction.copy(a.direction);
            Bd.end.copy(Bd.direction).scale(2 * b.farClip).add(Bd.origin);
            this._elements.sort(this._sortHandler);
            a = 0;
            for (b = this._elements.length; a < b; a++) {
                var d = this._elements[a];
                if ((!d.screen || !d.screen.screen.screenSpace) && this._checkElement(Bd, d, !1)) {
                    c = d;
                    break
                }
            }
            return c
        },
        _buildHitCorners: function(a, b, c, d) {
            if (a.entity && a.entity.button) {
                var e = a.entity.button.hitPadding || Xp;
                og.copy(a.entity.up);
                Uh.copy(og).scale(-1);
                pg.copy(a.entity.right);
                Vh.copy(pg).scale(-1);
                og.scale(e.w * d);
                Uh.scale(e.y * d);
                pg.scale(e.z * c);
                Vh.scale(e.x * c);
                nn.copy(b[0]).add(Uh).add(Vh);
                on.copy(b[1]).add(Uh).add(pg);
                pn.copy(b[2]).add(og).add(pg);
                qn.copy(b[3]).add(og).add(Vh);
                b = [nn, on, pn, qn]
            }
            return b
        },
        _calculateScaleToScreen: function(a) {
            var b = a.entity;
            a = a.screen.screen.scale;
            for (tk.set(a, a); b && !b.screen; )
                tk.mul(b.getLocalScale()),
                b = b.parent;
            return tk
        },
        _calculateRayScreen: function(a, b, c, d) {
            var e = this.app.graphicsDevice.width
              , f = this.app.graphicsDevice.height
              , g = c.rect.z * e
              , k = c.rect.w * f
              , h = c.rect.x * e;
            c = (1 - c.rect.y) * f;
            var l = c - k;
            a = a * e / this._target.clientWidth;
            b = b * f / this._target.clientHeight;
            return a >= h && a <= h + g && b <= c && b >= l ? (d.origin.set(e * (a - h) / g, f - f * (b - l) / k, 1),
            d.direction.set(0, 0, -1),
            d.end.copy(d.direction).scale(2).add(d.origin),
            !0) : !1
        },
        _calculateRay3d: function(a, b, c, d) {
            var e = this._target.clientWidth
              , f = this._target.clientHeight
              , g = c.rect.z * e
              , k = c.rect.w * f
              , h = c.rect.x * e
              , l = (1 - c.rect.y) * f
              , n = l - k
              , p = b;
            return a >= h && a <= h + g && b <= l && p >= n ? (a = e * (a - h) / g,
            p = f * (p - n) / k,
            c.screenToWorld(a, p, c.nearClip, kn),
            c.screenToWorld(a, p, c.farClip, ln),
            d.origin.copy(kn),
            d.direction.set(0, 0, -1),
            d.end.copy(ln),
            !0) : !1
        },
        _checkElement: function(a, b, c) {
            if (b.maskedBy && !this._checkElement(a, b.maskedBy.element, c))
                return !1;
            var d = c ? this._calculateScaleToScreen(b) : b.entity.getWorldTransform().getScale();
            b = this._buildHitCorners(b, c ? b.screenCorners : b.worldCorners, d.x, d.y);
            return Jo(a.origin, a.end, b) ? !0 : !1
        }
    });
    Object.defineProperty(Lf.prototype, "enabled", {
        get: function() {
            return this._enabled
        },
        set: function(a) {
            this._enabled = a
        }
    });
    Object.defineProperty(Lf.prototype, "app", {
        get: function() {
            return this._app || ea.getApplication()
        },
        set: function(a) {
            this._app = a
        }
    });
    var rn = {
        DEFAULT: {
            buttons: "PAD_FACE_1 PAD_FACE_2 PAD_FACE_3 PAD_FACE_4 PAD_L_SHOULDER_1 PAD_R_SHOULDER_1 PAD_L_SHOULDER_2 PAD_R_SHOULDER_2 PAD_SELECT PAD_START PAD_L_STICK_BUTTON PAD_R_STICK_BUTTON PAD_UP PAD_DOWN PAD_LEFT PAD_RIGHT PAD_VENDOR".split(" "),
            axes: ["PAD_L_STICK_X", "PAD_L_STICK_Y", "PAD_R_STICK_X", "PAD_R_STICK_Y"]
        },
        PS3: {
            buttons: "PAD_FACE_1 PAD_FACE_2 PAD_FACE_4 PAD_FACE_3 PAD_L_SHOULDER_1 PAD_R_SHOULDER_1 PAD_L_SHOULDER_2 PAD_R_SHOULDER_2 PAD_SELECT PAD_START PAD_L_STICK_BUTTON PAD_R_STICK_BUTTON PAD_UP PAD_DOWN PAD_LEFT PAD_RIGHT PAD_VENDOR".split(" "),
            axes: ["PAD_L_STICK_X", "PAD_L_STICK_Y", "PAD_R_STICK_X", "PAD_R_STICK_Y"]
        }
    }
      , sn = {
        "Product: 0268": "PS3"
    };
    Object.assign(Bj.prototype, {
        update: function() {
            var a, b;
            var c = 0;
            for (b = this.current.length; c < b; c++) {
                var d = this.current[c].pad.buttons;
                var e = d.length;
                for (a = 0; a < e; a++)
                    void 0 === this.previous[c] && (this.previous[c] = []),
                    this.previous[c][a] = d[a].pressed
            }
            a = this.poll();
            c = 0;
            for (b = a.length; c < b; c++)
                this.current[c] = a[c]
        },
        poll: function() {
            var a = [];
            if (this.gamepadsSupported) {
                var b = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads(), c, d = b.length;
                for (c = 0; c < d; c++)
                    b[c] && a.push({
                        map: this.getMap(b[c]),
                        pad: b[c]
                    })
            }
            return a
        },
        getMap: function(a) {
            for (var b in sn)
                if (0 <= a.id.indexOf(b))
                    return rn[sn[b]];
            return rn.DEFAULT
        },
        isPressed: function(a, b) {
            return this.current[a] ? this.current[a].pad.buttons[pc[this.current[a].map.buttons[b]]].pressed : !1
        },
        wasPressed: function(a, b) {
            if (!this.current[a])
                return !1;
            b = pc[this.current[a].map.buttons[b]];
            return this.current[a].pad.buttons[b].pressed && !this.previous[a][b]
        },
        getAxis: function(a, b) {
            if (!this.current[a])
                return !1;
            a = this.current[a].pad.axes[pc[this.current[a].map.axes[b]]];
            Math.abs(a) < this.deadZone && (a = 0);
            return a
        }
    });
    Object.assign(ae.prototype, {
        getTouchById: function(a, b) {
            var c, d = b.length;
            for (c = 0; c < d; c++)
                if (b[c].id === a)
                    return b[c];
            return null
        }
    });
    Se.prototype = Object.create(M.prototype);
    Se.prototype.constructor = Se;
    Object.assign(Se.prototype, {
        attach: function(a) {
            this._element && this.detach();
            this._element = a;
            this._element.addEventListener("touchstart", this._startHandler, !1);
            this._element.addEventListener("touchend", this._endHandler, !1);
            this._element.addEventListener("touchmove", this._moveHandler, !1);
            this._element.addEventListener("touchcancel", this._cancelHandler, !1)
        },
        detach: function() {
            this._element && (this._element.removeEventListener("touchstart", this._startHandler, !1),
            this._element.removeEventListener("touchend", this._endHandler, !1),
            this._element.removeEventListener("touchmove", this._moveHandler, !1),
            this._element.removeEventListener("touchcancel", this._cancelHandler, !1));
            this._element = null
        },
        _handleTouchStart: function(a) {
            this.fire("touchstart", new ae(this,a))
        },
        _handleTouchEnd: function(a) {
            this.fire("touchend", new ae(this,a))
        },
        _handleTouchMove: function(a) {
            a.preventDefault();
            this.fire("touchmove", new ae(this,a))
        },
        _handleTouchCancel: function(a) {
            this.fire("touchcancel", new ae(this,a))
        }
    });
    wb.prototype = Object.create(M.prototype);
    wb.prototype.constructor = wb;
    wb.prototype.createTextures = function(a) {
        a = this._normalizeCharsSet(a);
        if (a.length !== this.chars.length)
            this._renderAtlas(a);
        else
            for (var b = 0; b < a.length; b++)
                if (a[b] !== this.chars[b]) {
                    this._renderAtlas(a);
                    break
                }
    }
    ;
    wb.prototype.updateTextures = function(a) {
        a = this._normalizeCharsSet(a);
        for (var b = [], c = 0; c < a.length; c++) {
            var d = a[c];
            this.data.chars[d] || b.push(d)
        }
        0 < b.length && this._renderAtlas(this.chars.concat(b))
    }
    ;
    wb.prototype.destroy = function() {
        for (var a = 0; a < this.textures.length; a++)
            this.textures[a].destroy();
        this.fontWeight = this.type = this.textures = this.intensity = this.glyphSize = this.fontSize = this.fontName = this.data = this.color = this.chars = null
    }
    ;
    wb.prototype._getAndClearContext = function(a, b) {
        var c = a.width
          , d = a.height;
        a = a.getContext("2d", {
            alpha: !0
        });
        a.clearRect(0, 0, c, d);
        a.fillStyle = b;
        a.fillRect(0, 0, c, d);
        return a
    }
    ;
    wb.prototype._colorToRgbString = function(a, b) {
        var c = Math.round(255 * a.r)
          , d = Math.round(255 * a.g)
          , e = Math.round(255 * a.b);
        return b ? "rgba(" + c + ", " + d + ", " + e + ", " + a.a + ")" : "rgb(" + c + ", " + d + ", " + e + ")"
    }
    ;
    wb.prototype.renderCharacter = function(a, b, c, d, e) {
        a.fillStyle = e;
        a.fillText(b, c, d)
    }
    ;
    wb.prototype._renderAtlas = function(a) {
        this.chars = a;
        a = 1;
        var b = this.textures[a - 1].getSource()
          , c = b.width
          , d = b.height
          , e = this._colorToRgbString(this.color, !1)
          , f = this.color.a;
        this.color.a = 1 / 255;
        var g = this._colorToRgbString(this.color, !0);
        this.color.a = f;
        f = this._getAndClearContext(b, g);
        f.font = this.fontWeight + " " + this.fontSize.toString() + "px " + this.fontName;
        f.textAlign = "center";
        f.textBaseline = "alphabetic";
        this.data = this._createJson(this.chars, this.fontName, c, d);
        var k = vc.getSymbols(this.chars.join("")), h = this.textures.length, l = 0, n = 0, p = {}, q;
        for (q = 0; q < k.length; q++)
            b = k[q],
            p[b] = this._getTextMetrics(b),
            l = Math.max(l, p[b].height),
            n = Math.max(n, p[b].descent);
        this.glyphSize = Math.max(this.glyphSize, l);
        l = this.glyphSize + 2 * this.padding;
        var r = this.glyphSize + 2 * this.padding
          , t = this.glyphSize / 2 + this.padding
          , u = r - n - this.padding
          , x = 0
          , v = 0;
        for (q = 0; q < k.length; q++) {
            b = k[q];
            var w = vc.getCodePoint(k[q])
              , y = this.fontSize;
            f.font = this.fontWeight + " " + y.toString() + "px " + this.fontName;
            f.textAlign = "center";
            f.textBaseline = "alphabetic";
            var A = f.measureText(b).width;
            A > y && (y = this.fontSize * this.fontSize / A,
            f.font = this.fontWeight + " " + y.toString() + "px " + this.fontName,
            A = this.fontSize);
            this.renderCharacter(f, b, x + t, v + u, e);
            this._addChar(this.data, b, w, x, v, l, r, this.padding + (this.glyphSize - A) / 2, -this.padding + p[b].descent - n, A, a - 1, c, d);
            x += l;
            x + l > c && (x = 0,
            v += r,
            v + r > d && (this.textures[a - 1].upload(),
            a++,
            v = 0,
            a > h ? (b = document.createElement("canvas"),
            b.height = d,
            b.width = c,
            f = this._getAndClearContext(b, g),
            w = new V(this.app.graphicsDevice,{
                format: 7,
                autoMipmap: !0
            }),
            w.name = "font-atlas",
            w.setSource(b),
            w.minFilter = 5,
            w.magFilter = 1,
            w.addressU = 1,
            w.addressV = 1,
            this.textures.push(w)) : (b = this.textures[a - 1].getSource(),
            f = this._getAndClearContext(b, g))))
        }
        this.textures[a - 1].upload();
        if (a < h) {
            for (q = a; q < h; q++)
                this.textures[q].destroy();
            this.textures.splice(a)
        }
        this.fire("render")
    }
    ;
    wb.prototype._createJson = function(a, b, c, d) {
        return {
            version: 3,
            intensity: this.intensity,
            info: {
                face: b,
                width: c,
                height: d,
                maps: [{
                    width: c,
                    height: d
                }]
            },
            chars: {}
        }
    }
    ;
    wb.prototype._addChar = function(a, b, c, d, e, f, g, k, h, l, n, p, q) {
        a.info.maps.length < n + 1 && a.info.maps.push({
            width: p,
            height: q
        });
        p = this.fontSize / 32;
        a.chars[b] = {
            id: c,
            letter: b,
            x: d,
            y: e,
            width: f,
            height: g,
            xadvance: l / p,
            xoffset: k / p,
            yoffset: (h + this.padding) / p,
            scale: p,
            range: 1,
            map: n,
            bounds: [0, 0, f / p, g / p]
        }
    }
    ;
    wb.prototype._normalizeCharsSet = function(a) {
        var b = this.app.systems.element.getUnicodeConverter();
        b && (a = b(a));
        b = {};
        a = vc.getSymbols(a);
        var c;
        for (c = 0; c < a.length; c++) {
            var d = a[c];
            b[d] || (b[d] = d)
        }
        return Object.keys(b).sort()
    }
    ;
    wb.prototype._getTextMetrics = function(a) {
        var b = document.createElement("span");
        b.id = "content-span";
        b.innerHTML = a;
        a = document.createElement("div");
        a.id = "content-block";
        a.style.display = "inline-block";
        a.style.width = "1px";
        a.style.height = "0px";
        var c = document.createElement("div");
        c.appendChild(b);
        c.appendChild(a);
        c.style.font = this.fontName;
        c.style.fontSize = this.fontSize + "px";
        document.body.appendChild(c);
        var d = -1
          , e = -1
          , f = -1;
        try {
            a.style["vertical-align"] = "baseline",
            d = a.offsetTop - b.offsetTop,
            a.style["vertical-align"] = "bottom",
            f = a.offsetTop - b.offsetTop,
            e = f - d
        } finally {
            document.body.removeChild(c)
        }
        return {
            ascent: d,
            descent: e,
            height: f
        }
    }
    ;
    var Ka = [null, null], Dj = null, Pl, Ab = new X, Mf = new Float32Array(4), mc = [], Nf = !1, Fj = !1, Ej = !1, Ko = /uniform[ \t\n\r]+\S+[ \t\n\r]+\S+[ \t\n\r]*;/g, Lo = /\S+[ \t\n\r]*;/, Mo = /[ \t\n\r]*;/, Vo = /(float|int|bool|vec2|vec3|vec4|struct)([ \t\n\r]+[^;]+[ \t\n\r]*,*)+;/g, Wo = /(float|int|bool|vec2|vec3|vec4|struct|,|;|\{|\})/g, Xo = /(uniform|varying|in|out)[ \t\n\r]+(float|int|bool|vec2|vec3|vec4|struct)([ \t\n\r]+[^;]+[ \t\n\r]*,*)+;/g, Yo = /(float|int|bool|vec2|vec3|vec4|struct|uniform|varying|in|out|,|;|\{|\})/g, No = /#version/g, Oo = /out highp vec4 pc_fragColor;/g, Po = /#define gl_FragColor/g, Qo = /gl_FragColor/g, Ro = /uniform[ \t\n\r]+sampler2D[ \t\n\r]+uColorBuffer;/g, So = /(varying|in)[ \t\n\r]+vec2[ \t\n\r]+vUv0;/g, To = /(texture2D|texture)[ \t\n\r]*\([ \t\n\r]*uColorBuffer/g, Uo = /void[ \t\n\r]+main/g;
    Ol.prototype.addToComposition = function(a) {
        this.app.scene.layers.insertTransparent(this.layer, a)
    }
    ;
    var Wh = {
        write: function(a) {
            console.log(a)
        },
        open: function() {
            Wh.write("Powered by PlayCanvas 1.35.1 3317bcf")
        },
        info: function(a) {
            console.info("INFO:\t" + a)
        },
        debug: function(a) {
            console.debug("DEBUG:   " + a)
        },
        error: function(a) {
            console.error("ERROR:   " + a)
        },
        warning: function(a) {
            console.warn("WARNING: " + a)
        },
        alert: function(a) {
            Wh.write("ALERT:   " + a);
            alert(a)
        },
        assert: function(a, b) {
            !1 === a && Wh.write("ASSERT:  " + b)
        }
    };
    vc.endsWith = function(a, b) {
        return a.endsWith(b)
    }
    ;
    vc.startsWith = function(a, b) {
        return a.startsWith(b)
    }
    ;
    var Yp = {
        now: Lb,
        Timer: $h
    };
    Object.defineProperty(L.prototype, "data", {
        get: function() {
            this._data || (this._data = new Float32Array(4));
            this._data[0] = this.r;
            this._data[1] = this.g;
            this._data[2] = this.b;
            this._data[3] = this.a;
            return this._data
        }
    });
    Object.defineProperty(L.prototype, "data3", {
        get: function() {
            this._data3 || (this._data3 = new Float32Array(3));
            this._data3[0] = this.r;
            this._data3[1] = this.g;
            this._data3[2] = this.b;
            return this._data3
        }
    });
    N.INV_LOG2 = Math.LOG2E;
    N.intToBytes = N.intToBytes32;
    N.bytesToInt = N.bytesToInt32;
    Object.defineProperty(P.prototype, "data", {
        get: function() {
            this._data || (this._data = new Float32Array(2));
            this._data[0] = this.x;
            this._data[1] = this.y;
            return this._data
        }
    });
    Object.defineProperty(z.prototype, "data", {
        get: function() {
            this._data || (this._data = new Float32Array(3));
            this._data[0] = this.x;
            this._data[1] = this.y;
            this._data[2] = this.z;
            return this._data
        }
    });
    Object.defineProperty(X.prototype, "data", {
        get: function() {
            this._data || (this._data = new Float32Array(4));
            this._data[0] = this.x;
            this._data[1] = this.y;
            this._data[2] = this.z;
            this._data[3] = this.w;
            return this._data
        }
    });
    var Zp = {
        Aabb: oa,
        Sphere: Cd,
        Plane: ci
    };
    Cd.prototype.intersectRay = Cd.prototype.intersectsRay;
    rg.prototype.update = function(a, b) {
        var c = new K;
        c.mul2(a, b);
        this.setFromMat4(c)
    }
    ;
    Gj.prototype = Error.prototype;
    Hj.prototype = Error.prototype;
    var $p = {
        ADDRESS_CLAMP_TO_EDGE: 1,
        ADDRESS_MIRRORED_REPEAT: 2,
        ADDRESS_REPEAT: 0,
        BLENDMODE_ZERO: 0,
        BLENDMODE_ONE: 1,
        BLENDMODE_SRC_COLOR: 2,
        BLENDMODE_ONE_MINUS_SRC_COLOR: 3,
        BLENDMODE_DST_COLOR: 4,
        BLENDMODE_ONE_MINUS_DST_COLOR: 5,
        BLENDMODE_SRC_ALPHA: 6,
        BLENDMODE_SRC_ALPHA_SATURATE: 7,
        BLENDMODE_ONE_MINUS_SRC_ALPHA: 8,
        BLENDMODE_DST_ALPHA: 9,
        BLENDMODE_ONE_MINUS_DST_ALPHA: 10,
        BUFFER_STATIC: 0,
        BUFFER_DYNAMIC: 1,
        BUFFER_STREAM: 2,
        CULLFACE_NONE: 0,
        CULLFACE_BACK: 1,
        CULLFACE_FRONT: 2,
        CULLFACE_FRONTANDBACK: 3,
        ELEMENTTYPE_INT8: 0,
        ELEMENTTYPE_UINT8: 1,
        ELEMENTTYPE_INT16: 2,
        ELEMENTTYPE_UINT16: 3,
        ELEMENTTYPE_INT32: 4,
        ELEMENTTYPE_UINT32: 5,
        ELEMENTTYPE_FLOAT32: 6,
        FILTER_NEAREST: 0,
        FILTER_LINEAR: 1,
        FILTER_NEAREST_MIPMAP_NEAREST: 2,
        FILTER_NEAREST_MIPMAP_LINEAR: 3,
        FILTER_LINEAR_MIPMAP_NEAREST: 4,
        FILTER_LINEAR_MIPMAP_LINEAR: 5,
        INDEXFORMAT_UINT8: 0,
        INDEXFORMAT_UINT16: 1,
        INDEXFORMAT_UINT32: 2,
        PIXELFORMAT_R5_G6_B5: 3,
        PIXELFORMAT_R8_G8_B8: 6,
        PIXELFORMAT_R8_G8_B8_A8: 7,
        PRIMITIVE_POINTS: 0,
        PRIMITIVE_LINES: 1,
        PRIMITIVE_LINELOOP: 2,
        PRIMITIVE_LINESTRIP: 3,
        PRIMITIVE_TRIANGLES: 4,
        PRIMITIVE_TRISTRIP: 5,
        PRIMITIVE_TRIFAN: 6,
        SEMANTIC_POSITION: "POSITION",
        SEMANTIC_NORMAL: "NORMAL",
        SEMANTIC_COLOR: "COLOR",
        SEMANTIC_TEXCOORD: "TEXCOORD",
        SEMANTIC_TEXCOORD0: "TEXCOORD0",
        SEMANTIC_TEXCOORD1: "TEXCOORD1",
        SEMANTIC_ATTR0: "ATTR0",
        SEMANTIC_ATTR1: "ATTR1",
        SEMANTIC_ATTR2: "ATTR2",
        SEMANTIC_ATTR3: "ATTR3",
        TEXTURELOCK_READ: 1,
        TEXTURELOCK_WRITE: 2,
        drawQuadWithShader: La,
        programlib: mh,
        shaderChunks: F,
        ContextCreationError: Hj,
        Device: ib,
        IndexBuffer: dc,
        ProgramLibrary: Jb,
        RenderTarget: ra,
        ScopeId: Zg,
        Shader: re,
        ShaderInput: vj,
        Texture: V,
        UnsupportedBrowserError: Gj,
        VertexBuffer: ab,
        VertexFormat: Na,
        VertexIterator: Pb
    }
      , aq = {
        createFullscreenQuad: Hl,
        drawFullscreenQuad: Il,
        PostEffect: wj,
        PostEffectQueue: Ug
    };
    Object.defineProperty(F, "transformSkinnedVS", {
        get: function() {
            return "#define SKIN\n" + F.transformVS
        }
    });
    Object.defineProperties(V.prototype, {
        rgbm: {
            get: function() {
                return "rgbm" === this.type
            },
            set: function(a) {
                this.type = a ? "rgbm" : "default"
            }
        },
        swizzleGGGR: {
            get: function() {
                return "swizzleGGGR" === this.type
            },
            set: function(a) {
                this.type = a ? "swizzleGGGR" : "default"
            }
        }
    });
    var bq = la
      , cq = {
        partitionSkin: Wk,
        procedural: {
            calculateTangents: Nk,
            createMesh: Qb,
            createTorus: Ok,
            createCylinder: mi,
            createCapsule: ni,
            createCone: oi,
            createSphere: pi,
            createPlane: qi,
            createBox: Eg
        },
        BasicMaterial: dd,
        Command: vg,
        DepthMaterial: $d,
        ForwardRenderer: xg,
        GraphNode: Z,
        Material: ka,
        Mesh: rb,
        MeshInstance: va,
        Model: sb,
        ParticleEmitter: $b,
        PhongMaterial: la,
        Picker: pd,
        Projection: {
            ORTHOGRAPHIC: 1,
            PERSPECTIVE: 0
        },
        Scene: sa,
        Skin: Hg,
        SkinInstance: Hc
    };
    Z.prototype._dirtify = function(a) {
        a ? this._dirtifyLocal() : this._dirtifyWorld()
    }
    ;
    Z.prototype.addLabel = function(a) {
        this._labels[a] = !0
    }
    ;
    Z.prototype.getLabels = function() {
        return Object.keys(this._labels)
    }
    ;
    Z.prototype.hasLabel = function(a) {
        return !!this._labels[a]
    }
    ;
    Z.prototype.removeLabel = function(a) {
        delete this._labels[a]
    }
    ;
    Z.prototype.findByLabel = function(a, b) {
        var c, d = this._children.length;
        b = b || [];
        this.hasLabel(a) && b.push(this);
        for (c = 0; c < d; ++c)
            b = this._children[c].findByLabel(a, b);
        return b
    }
    ;
    Z.prototype.getChildren = function() {
        return this.children
    }
    ;
    Z.prototype.getName = function() {
        return this.name
    }
    ;
    Z.prototype.getPath = function() {
        return this.path
    }
    ;
    Z.prototype.getRoot = function() {
        return this.root
    }
    ;
    Z.prototype.getParent = function() {
        return this.parent
    }
    ;
    Z.prototype.setName = function(a) {
        this.name = a
    }
    ;
    ka.prototype.getName = function() {
        return this.name
    }
    ;
    ka.prototype.setName = function(a) {
        this.name = a
    }
    ;
    ka.prototype.getShader = function() {
        return this.shader
    }
    ;
    ka.prototype.setShader = function(a) {
        this.shader = a
    }
    ;
    var dq = {
        Animation: Rb,
        Key: Fg,
        Node: Gg,
        Skeleton: Ta
    }
      , eq = {
        AudioManager: ec,
        Channel: ac,
        Channel3d: $a,
        Listener: ri,
        Sound: Kg
    };
    ec.prototype.getListener = function() {
        return this.listener
    }
    ;
    ec.prototype.getVolume = function() {
        return this.volume
    }
    ;
    ec.prototype.setVolume = function(a) {
        this.volume = a
    }
    ;
    Ld.prototype.getAssetById = function(a) {
        return this.get(a)
    }
    ;
    Object.defineProperty(ta.prototype, "ray", {
        get: function() {
            return this._rayLocal
        }
    });
    Object.defineProperty(ta.prototype, "position", {
        get: function() {
            return this._localPosition
        }
    });
    Object.defineProperty(ta.prototype, "rotation", {
        get: function() {
            return this._localRotation
        }
    });
    var fq = {
        getTouchTargetCoords: Cj,
        Controller: kb,
        GamePads: Bj,
        Keyboard: jb,
        KeyboardEvent: xj,
        Mouse: Kb,
        MouseEvent: qd,
        Touch: gh,
        TouchDevice: Se,
        TouchEvent: ae
    };
    Object.defineProperty(Lf.prototype, "wheel", {
        get: function() {
            return -2 * this.wheelDelta
        }
    });
    Object.defineProperty(qd.prototype, "wheel", {
        get: function() {
            return -2 * this.wheelDelta
        }
    });
    var gq = He
      , hq = {
        Application: ea,
        Component: O,
        ComponentData: Ml,
        ComponentSystem: H,
        Entity: fa,
        FillMode: {
            NONE: "NONE",
            FILL_WINDOW: "FILL_WINDOW",
            KEEP_ASPECT: Yg
        },
        ResolutionMode: {
            AUTO: "AUTO",
            FIXED: tj
        }
    };
    ea.prototype.isFullscreen = function() {
        return !!document.fullscreenElement
    }
    ;
    ea.prototype.enableFullscreen = function(a, b, c) {
        a = a || this.graphicsDevice.canvas;
        var d = function() {
            b();
            document.removeEventListener("fullscreenchange", d)
        }
          , e = function() {
            c();
            document.removeEventListener("fullscreenerror", e)
        };
        b && document.addEventListener("fullscreenchange", d, !1);
        c && document.addEventListener("fullscreenerror", e, !1);
        a.requestFullscreen ? a.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT) : c()
    }
    ;
    ea.prototype.disableFullscreen = function(a) {
        var b = function() {
            a();
            document.removeEventListener("fullscreenchange", b)
        };
        a && document.addEventListener("fullscreenchange", b, !1);
        document.exitFullscreen()
    }
    ;
    Object.defineProperty(Ob.prototype, "node", {
        get: function() {
            return this.entity
        }
    });
    Object.defineProperty(kd.prototype, "enable", {
        get: function() {
            return this.enabled
        },
        set: function(a) {
            this.enabled = a
        }
    });
    Ha.prototype.setVisible = function(a) {
        this.enabled = a
    }
    ;
    Object.defineProperty(hc.prototype, "bodyType", {
        get: function() {
            return this.type
        },
        set: function(a) {
            this.type = a
        }
    });
    hc.prototype.syncBodyToEntity = function() {
        this._updateDynamic()
    }
    ;
    Ud.prototype.setGravity = function() {
        1 === arguments.length ? this.gravity.copy(arguments[0]) : this.gravity.set(arguments[0], arguments[1], arguments[2])
    }
    ;
    m.ABSOLUTE_URL = ff;
    m.ACTION_GAMEPAD = "gamepad";
    m.ACTION_KEYBOARD = "keyboard";
    m.ACTION_MOUSE = "mouse";
    m.ADDRESS_CLAMP_TO_EDGE = 1;
    m.ADDRESS_MIRRORED_REPEAT = 2;
    m.ADDRESS_REPEAT = 0;
    m.ANIM_EQUAL_TO = "EQUAL_TO";
    m.ANIM_GREATER_THAN = "GREATER_THAN";
    m.ANIM_GREATER_THAN_EQUAL_TO = "GREATER_THAN_EQUAL_TO";
    m.ANIM_INTERRUPTION_NEXT = "NEXT_STATE";
    m.ANIM_INTERRUPTION_NEXT_PREV = "NEXT_STATE_PREV_STATE";
    m.ANIM_INTERRUPTION_NONE = "NONE";
    m.ANIM_INTERRUPTION_PREV = "PREV_STATE";
    m.ANIM_INTERRUPTION_PREV_NEXT = "PREV_STATE_NEXT_STATE";
    m.ANIM_LESS_THAN = "LESS_THAN";
    m.ANIM_LESS_THAN_EQUAL_TO = "LESS_THAN_EQUAL_TO";
    m.ANIM_NOT_EQUAL_TO = "NOT_EQUAL_TO";
    m.ANIM_PARAMETER_BOOLEAN = "BOOLEAN";
    m.ANIM_PARAMETER_FLOAT = "FLOAT";
    m.ANIM_PARAMETER_INTEGER = "INTEGER";
    m.ANIM_PARAMETER_TRIGGER = "TRIGGER";
    m.ANIM_STATE_ANY = "ANY";
    m.ANIM_STATE_END = "END";
    m.ANIM_STATE_START = "START";
    m.ASPECT_AUTO = 0;
    m.ASPECT_MANUAL = 1;
    m.ASSET_ANIMATION = "animation";
    m.ASSET_AUDIO = "audio";
    m.ASSET_CONTAINER = "container";
    m.ASSET_CSS = "css";
    m.ASSET_CUBEMAP = "cubemap";
    m.ASSET_HTML = "html";
    m.ASSET_IMAGE = "image";
    m.ASSET_JSON = "json";
    m.ASSET_MATERIAL = "material";
    m.ASSET_MODEL = "model";
    m.ASSET_SCRIPT = "script";
    m.ASSET_SHADER = "shader";
    m.ASSET_TEXT = "text";
    m.ASSET_TEXTURE = "texture";
    m.AXIS_KEY = "key";
    m.AXIS_MOUSE_X = "mousex";
    m.AXIS_MOUSE_Y = "mousey";
    m.AXIS_PAD_L_X = "padlx";
    m.AXIS_PAD_L_Y = "padly";
    m.AXIS_PAD_R_X = "padrx";
    m.AXIS_PAD_R_Y = "padry";
    m.AnimBinder = uc;
    m.AnimClip = wf;
    m.AnimClipHandler = vi;
    m.AnimComponent = id;
    m.AnimComponentLayer = Rg;
    m.AnimComponentSystem = xe;
    m.AnimController = Sg;
    m.AnimCurve = Ig;
    m.AnimData = vf;
    m.AnimEvaluator = Ja;
    m.AnimPropertyLocator = uf;
    m.AnimSnapshot = Rk;
    m.AnimStateGraph = yf;
    m.AnimStateGraphHandler = wi;
    m.AnimTarget = Ic;
    m.AnimTrack = Kd;
    m.Animation = Rb;
    m.AnimationComponent = hd;
    m.AnimationComponentSystem = we;
    m.AnimationHandler = ui;
    m.Application = ea;
    m.Asset = aa;
    m.AssetListLoader = Eb;
    m.AssetReference = wc;
    m.AssetRegistry = Ld;
    m.AudioHandler = zf;
    m.AudioListenerComponent = Od;
    m.AudioListenerComponentSystem = ye;
    m.AudioSourceComponent = Pd;
    m.AudioSourceComponentSystem = ze;
    m.BAKE_COLOR = 0;
    m.BAKE_COLORDIR = 1;
    m.BLENDEQUATION_ADD = 0;
    m.BLENDEQUATION_MAX = 4;
    m.BLENDEQUATION_MIN = 3;
    m.BLENDEQUATION_REVERSE_SUBTRACT = 2;
    m.BLENDEQUATION_SUBTRACT = 1;
    m.BLENDMODE_DST_ALPHA = 9;
    m.BLENDMODE_DST_COLOR = 4;
    m.BLENDMODE_ONE = 1;
    m.BLENDMODE_ONE_MINUS_DST_ALPHA = 10;
    m.BLENDMODE_ONE_MINUS_DST_COLOR = 5;
    m.BLENDMODE_ONE_MINUS_SRC_ALPHA = 8;
    m.BLENDMODE_ONE_MINUS_SRC_COLOR = 3;
    m.BLENDMODE_SRC_ALPHA = 6;
    m.BLENDMODE_SRC_ALPHA_SATURATE = 7;
    m.BLENDMODE_SRC_COLOR = 2;
    m.BLENDMODE_ZERO = 0;
    m.BLEND_ADDITIVE = 1;
    m.BLEND_ADDITIVEALPHA = 6;
    m.BLEND_MAX = 10;
    m.BLEND_MIN = 9;
    m.BLEND_MULTIPLICATIVE = 5;
    m.BLEND_MULTIPLICATIVE2X = 7;
    m.BLEND_NONE = 3;
    m.BLEND_NORMAL = 2;
    m.BLEND_PREMULTIPLIED = 4;
    m.BLEND_SCREEN = 8;
    m.BLEND_SUBTRACTIVE = 0;
    m.BLUR_BOX = 0;
    m.BLUR_GAUSSIAN = 1;
    m.BODYFLAG_KINEMATIC_OBJECT = 2;
    m.BODYFLAG_NORESPONSE_OBJECT = 4;
    m.BODYFLAG_STATIC_OBJECT = 1;
    m.BODYGROUP_DEFAULT = 1;
    m.BODYGROUP_DYNAMIC = 1;
    m.BODYGROUP_ENGINE_1 = 8;
    m.BODYGROUP_ENGINE_2 = 32;
    m.BODYGROUP_ENGINE_3 = 64;
    m.BODYGROUP_KINEMATIC = 4;
    m.BODYGROUP_NONE = 0;
    m.BODYGROUP_STATIC = qj;
    m.BODYGROUP_TRIGGER = 16;
    m.BODYGROUP_USER_1 = 128;
    m.BODYGROUP_USER_2 = 256;
    m.BODYGROUP_USER_3 = 512;
    m.BODYGROUP_USER_4 = 1024;
    m.BODYGROUP_USER_5 = 2048;
    m.BODYGROUP_USER_6 = 4096;
    m.BODYGROUP_USER_7 = 8192;
    m.BODYGROUP_USER_8 = 16384;
    m.BODYMASK_ALL = 65535;
    m.BODYMASK_NONE = 0;
    m.BODYMASK_NOT_STATIC = Wg;
    m.BODYMASK_NOT_STATIC_KINEMATIC = 65529;
    m.BODYMASK_STATIC = 2;
    m.BODYSTATE_ACTIVE_TAG = 1;
    m.BODYSTATE_DISABLE_DEACTIVATION = 4;
    m.BODYSTATE_DISABLE_SIMULATION = 5;
    m.BODYSTATE_ISLAND_SLEEPING = 2;
    m.BODYSTATE_WANTS_DEACTIVATION = 3;
    m.BODYTYPE_DYNAMIC = "dynamic";
    m.BODYTYPE_KINEMATIC = "kinematic";
    m.BODYTYPE_STATIC = He;
    m.BUFFER_DYNAMIC = 1;
    m.BUFFER_GPUDYNAMIC = 3;
    m.BUFFER_STATIC = 0;
    m.BUFFER_STREAM = 2;
    m.BUTTON_TRANSITION_MODE_SPRITE_CHANGE = 1;
    m.BUTTON_TRANSITION_MODE_TINT = Tg;
    m.BasicMaterial = dd;
    m.BasisParser = bj;
    m.Batch = fi;
    m.BatchGroup = bb;
    m.BatchManager = Ia;
    m.BinaryHandler = xi;
    m.BoundingBox = oa;
    m.BoundingSphere = Cd;
    m.Bundle = Af;
    m.BundleHandler = zi;
    m.BundleRegistry = fj;
    m.ButtonComponent = Qd;
    m.ButtonComponentSystem = Ae;
    m.CLEARFLAG_COLOR = 1;
    m.CLEARFLAG_DEPTH = 2;
    m.CLEARFLAG_STENCIL = 4;
    m.COMPUPDATED_BLEND = 8;
    m.COMPUPDATED_CAMERAS = 4;
    m.COMPUPDATED_INSTANCES = 1;
    m.COMPUPDATED_LIGHTS = 2;
    m.CUBEFACE_NEGX = 1;
    m.CUBEFACE_NEGY = 3;
    m.CUBEFACE_NEGZ = 5;
    m.CUBEFACE_POSX = 0;
    m.CUBEFACE_POSY = 2;
    m.CUBEFACE_POSZ = 4;
    m.CUBEPROJ_BOX = 1;
    m.CUBEPROJ_NONE = 0;
    m.CULLFACE_BACK = 1;
    m.CULLFACE_FRONT = 2;
    m.CULLFACE_FRONTANDBACK = 3;
    m.CULLFACE_NONE = 0;
    m.CURVE_CARDINAL = 3;
    m.CURVE_CATMULL = 2;
    m.CURVE_LINEAR = 0;
    m.CURVE_SMOOTHSTEP = 1;
    m.CURVE_SPLINE = 4;
    m.CURVE_STEP = 5;
    m.Camera = pa;
    m.CameraComponent = Ob;
    m.CameraComponentSystem = Me;
    m.CanvasFont = wb;
    m.CollisionComponent = le;
    m.CollisionComponentSystem = Le;
    m.Color = L;
    m.Command = vg;
    m.Component = O;
    m.ComponentData = Ml;
    m.ComponentSystem = H;
    m.ComponentSystemRegistry = kj;
    m.ContactPoint = vl;
    m.ContactResult = wl;
    m.ContainerHandler = Bi;
    m.ContainerResource = Ai;
    m.ContextCreationError = Hj;
    m.Controller = kb;
    m.CssHandler = Ci;
    m.CubemapHandler = Di;
    m.Curve = gb;
    m.CurveSet = Cb;
    m.DETAILMODE_ADD = "add";
    m.DETAILMODE_MAX = "max";
    m.DETAILMODE_MIN = "min";
    m.DETAILMODE_MUL = "mul";
    m.DETAILMODE_OVERLAY = "overlay";
    m.DETAILMODE_SCREEN = "screen";
    m.DISTANCE_EXPONENTIAL = "exponential";
    m.DISTANCE_INVERSE = Hf;
    m.DISTANCE_LINEAR = "linear";
    m.DefaultAnimBinder = xf;
    m.DepthMaterial = $d;
    m.ELEMENTTYPE_FLOAT32 = 6;
    m.ELEMENTTYPE_GROUP = nl;
    m.ELEMENTTYPE_IMAGE = "image";
    m.ELEMENTTYPE_INT16 = 2;
    m.ELEMENTTYPE_INT32 = 4;
    m.ELEMENTTYPE_INT8 = 0;
    m.ELEMENTTYPE_TEXT = "text";
    m.ELEMENTTYPE_UINT16 = 3;
    m.ELEMENTTYPE_UINT32 = 5;
    m.ELEMENTTYPE_UINT8 = 1;
    m.EMITTERSHAPE_BOX = 0;
    m.EMITTERSHAPE_SPHERE = 1;
    m.EVENT_KEYDOWN = "keydown";
    m.EVENT_KEYUP = "keyup";
    m.EVENT_MOUSEDOWN = "mousedown";
    m.EVENT_MOUSEMOVE = "mousemove";
    m.EVENT_MOUSEUP = "mouseup";
    m.EVENT_MOUSEWHEEL = "mousewheel";
    m.EVENT_SELECT = "select";
    m.EVENT_SELECTEND = "selectend";
    m.EVENT_SELECTSTART = "selectstart";
    m.EVENT_TOUCHCANCEL = "touchcancel";
    m.EVENT_TOUCHEND = "touchend";
    m.EVENT_TOUCHMOVE = "touchmove";
    m.EVENT_TOUCHSTART = "touchstart";
    m.ElementComponent = ia;
    m.ElementComponentSystem = Ce;
    m.ElementDragHelper = Nc;
    m.ElementInput = Lf;
    m.ElementInputEvent = rd;
    m.ElementMouseEvent = sd;
    m.ElementSelectEvent = lc;
    m.ElementTouchEvent = Oc;
    m.Entity = fa;
    m.EntityReference = Kc;
    m.EventHandler = M;
    m.FILLMODE_FILL_WINDOW = "FILL_WINDOW";
    m.FILLMODE_KEEP_ASPECT = Yg;
    m.FILLMODE_NONE = "NONE";
    m.FILTER_LINEAR = 1;
    m.FILTER_LINEAR_MIPMAP_LINEAR = 5;
    m.FILTER_LINEAR_MIPMAP_NEAREST = 4;
    m.FILTER_NEAREST = 0;
    m.FILTER_NEAREST_MIPMAP_LINEAR = 3;
    m.FILTER_NEAREST_MIPMAP_NEAREST = 2;
    m.FITTING_BOTH = 3;
    m.FITTING_NONE = mj;
    m.FITTING_SHRINK = 2;
    m.FITTING_STRETCH = 1;
    m.FOG_EXP = "exp";
    m.FOG_EXP2 = "exp2";
    m.FOG_LINEAR = "linear";
    m.FOG_NONE = "none";
    m.FONT_BITMAP = "bitmap";
    m.FONT_MSDF = "msdf";
    m.FRESNEL_NONE = 0;
    m.FRESNEL_SCHLICK = 2;
    m.FUNC_ALWAYS = 7;
    m.FUNC_EQUAL = 2;
    m.FUNC_GREATER = 4;
    m.FUNC_GREATEREQUAL = 6;
    m.FUNC_LESS = 1;
    m.FUNC_LESSEQUAL = 3;
    m.FUNC_NEVER = 0;
    m.FUNC_NOTEQUAL = 5;
    m.FolderHandler = Ei;
    m.Font = Lg;
    m.FontHandler = Gi;
    m.ForwardRenderer = xg;
    m.Frustum = rg;
    m.GAMMA_NONE = 0;
    m.GAMMA_SRGB = 1;
    m.GAMMA_SRGBFAST = 2;
    m.GAMMA_SRGBHDR = 3;
    m.GamePads = Bj;
    m.GraphNode = Z;
    m.GraphicsDevice = ib;
    m.HierarchyHandler = Hi;
    m.HtmlHandler = Ii;
    m.Http = da;
    m.I18n = Oa;
    m.INDEXFORMAT_UINT16 = 1;
    m.INDEXFORMAT_UINT32 = 2;
    m.INDEXFORMAT_UINT8 = 0;
    m.INTERPOLATION_CUBIC = 2;
    m.INTERPOLATION_LINEAR = 1;
    m.INTERPOLATION_STEP = 0;
    m.ImageElement = cb;
    m.ImgParser = cj;
    m.IndexBuffer = dc;
    m.IndexedList = Zh;
    m.JsonHandler = Ji;
    m.JsonStandardMaterialParser = ve;
    m.KEY_0 = 48;
    m.KEY_1 = 49;
    m.KEY_2 = 50;
    m.KEY_3 = 51;
    m.KEY_4 = 52;
    m.KEY_5 = 53;
    m.KEY_6 = 54;
    m.KEY_7 = 55;
    m.KEY_8 = 56;
    m.KEY_9 = 57;
    m.KEY_A = 65;
    m.KEY_ADD = 107;
    m.KEY_ALT = 18;
    m.KEY_B = 66;
    m.KEY_BACKSPACE = 8;
    m.KEY_BACK_SLASH = 220;
    m.KEY_C = 67;
    m.KEY_CAPS_LOCK = 20;
    m.KEY_CLOSE_BRACKET = 221;
    m.KEY_COMMA = 188;
    m.KEY_CONTEXT_MENU = 93;
    m.KEY_CONTROL = 17;
    m.KEY_D = 68;
    m.KEY_DECIMAL = 110;
    m.KEY_DELETE = 46;
    m.KEY_DIVIDE = 111;
    m.KEY_DOWN = 40;
    m.KEY_E = 69;
    m.KEY_END = 35;
    m.KEY_ENTER = 13;
    m.KEY_EQUAL = 61;
    m.KEY_ESCAPE = 27;
    m.KEY_F = 70;
    m.KEY_F1 = 112;
    m.KEY_F10 = 121;
    m.KEY_F11 = 122;
    m.KEY_F12 = 123;
    m.KEY_F2 = 113;
    m.KEY_F3 = 114;
    m.KEY_F4 = 115;
    m.KEY_F5 = 116;
    m.KEY_F6 = 117;
    m.KEY_F7 = 118;
    m.KEY_F8 = 119;
    m.KEY_F9 = 120;
    m.KEY_G = 71;
    m.KEY_H = 72;
    m.KEY_HOME = 36;
    m.KEY_I = 73;
    m.KEY_INSERT = 45;
    m.KEY_J = 74;
    m.KEY_K = 75;
    m.KEY_L = 76;
    m.KEY_LEFT = 37;
    m.KEY_M = 77;
    m.KEY_META = 224;
    m.KEY_MULTIPLY = 106;
    m.KEY_N = 78;
    m.KEY_NUMPAD_0 = 96;
    m.KEY_NUMPAD_1 = 97;
    m.KEY_NUMPAD_2 = 98;
    m.KEY_NUMPAD_3 = 99;
    m.KEY_NUMPAD_4 = 100;
    m.KEY_NUMPAD_5 = 101;
    m.KEY_NUMPAD_6 = 102;
    m.KEY_NUMPAD_7 = 103;
    m.KEY_NUMPAD_8 = 104;
    m.KEY_NUMPAD_9 = 105;
    m.KEY_O = 79;
    m.KEY_OPEN_BRACKET = 219;
    m.KEY_P = 80;
    m.KEY_PAGE_DOWN = 34;
    m.KEY_PAGE_UP = 33;
    m.KEY_PAUSE = 19;
    m.KEY_PERIOD = 190;
    m.KEY_PRINT_SCREEN = 44;
    m.KEY_Q = 81;
    m.KEY_R = 82;
    m.KEY_RETURN = 13;
    m.KEY_RIGHT = 39;
    m.KEY_S = 83;
    m.KEY_SEMICOLON = 59;
    m.KEY_SEPARATOR = 108;
    m.KEY_SHIFT = 16;
    m.KEY_SLASH = 191;
    m.KEY_SPACE = 32;
    m.KEY_SUBTRACT = 109;
    m.KEY_T = 84;
    m.KEY_TAB = 9;
    m.KEY_U = 85;
    m.KEY_UP = 38;
    m.KEY_V = 86;
    m.KEY_W = 87;
    m.KEY_WINDOWS = 91;
    m.KEY_X = 88;
    m.KEY_Y = 89;
    m.KEY_Z = 90;
    m.Key = Fg;
    m.Keyboard = jb;
    m.KeyboardEvent = xj;
    m.KtxParser = dj;
    m.LAYERID_DEPTH = 1;
    m.LAYERID_IMMEDIATE = 3;
    m.LAYERID_SKYBOX = 2;
    m.LAYERID_UI = 4;
    m.LAYERID_WORLD = 0;
    m.LAYER_FX = 2;
    m.LAYER_GIZMO = 1;
    m.LAYER_HUD = 0;
    m.LAYER_WORLD = 15;
    m.LIGHTFALLOFF_INVERSESQUARED = 1;
    m.LIGHTFALLOFF_LINEAR = 0;
    m.LIGHTTYPE_DIRECTIONAL = 0;
    m.LIGHTTYPE_POINT = 1;
    m.LIGHTTYPE_SPOT = 2;
    m.LINEBATCH_GIZMO = 2;
    m.LINEBATCH_OVERLAY = 1;
    m.LINEBATCH_WORLD = 0;
    m.Layer = ma;
    m.LayerComposition = xa;
    m.LayoutCalculator = lj;
    m.LayoutChildComponent = Sd;
    m.LayoutChildComponentSystem = Pe;
    m.LayoutGroupComponent = jd;
    m.LayoutGroupComponentSystem = De;
    m.LegacyDdsParser = ej;
    m.Light = Va;
    m.LightComponent = kd;
    m.LightComponentSystem = Ee;
    m.Lightmapper = ii;
    m.LocalizedAsset = Ga;
    m.MASK_BAKED = 2;
    m.MASK_DYNAMIC = 1;
    m.MASK_LIGHTMAP = 4;
    m.MOUSEBUTTON_LEFT = 0;
    m.MOUSEBUTTON_MIDDLE = 1;
    m.MOUSEBUTTON_NONE = -1;
    m.MOUSEBUTTON_RIGHT = 2;
    m.Mat3 = xb;
    m.Mat4 = K;
    m.Material = ka;
    m.MaterialHandler = Ki;
    m.Mesh = rb;
    m.MeshInstance = va;
    m.Model = sb;
    m.ModelComponent = Ha;
    m.ModelComponentSystem = Fe;
    m.ModelHandler = Li;
    m.Morph = Db;
    m.MorphInstance = sf;
    m.MorphTarget = tf;
    m.Mouse = Kb;
    m.MouseEvent = qd;
    m.Node = Gg;
    m.ORIENTATION_HORIZONTAL = 0;
    m.ORIENTATION_VERTICAL = 1;
    m.OrientedBox = bi;
    m.PAD_1 = 0;
    m.PAD_2 = 1;
    m.PAD_3 = 2;
    m.PAD_4 = 3;
    m.PAD_DOWN = 13;
    m.PAD_FACE_1 = 0;
    m.PAD_FACE_2 = 1;
    m.PAD_FACE_3 = 2;
    m.PAD_FACE_4 = 3;
    m.PAD_LEFT = 14;
    m.PAD_L_SHOULDER_1 = 4;
    m.PAD_L_SHOULDER_2 = 6;
    m.PAD_L_STICK_BUTTON = 10;
    m.PAD_L_STICK_X = 0;
    m.PAD_L_STICK_Y = 1;
    m.PAD_RIGHT = 15;
    m.PAD_R_SHOULDER_1 = 5;
    m.PAD_R_SHOULDER_2 = 7;
    m.PAD_R_STICK_BUTTON = 11;
    m.PAD_R_STICK_X = 2;
    m.PAD_R_STICK_Y = 3;
    m.PAD_SELECT = 8;
    m.PAD_START = 9;
    m.PAD_UP = 12;
    m.PAD_VENDOR = 16;
    m.PARTICLEMODE_CPU = 1;
    m.PARTICLEMODE_GPU = 0;
    m.PARTICLEORIENTATION_EMITTER = 2;
    m.PARTICLEORIENTATION_SCREEN = 0;
    m.PARTICLEORIENTATION_WORLD = 1;
    m.PARTICLESORT_DISTANCE = 1;
    m.PARTICLESORT_NEWER_FIRST = 2;
    m.PARTICLESORT_NONE = 0;
    m.PARTICLESORT_OLDER_FIRST = 3;
    m.PIXELFORMAT_111110F = 18;
    m.PIXELFORMAT_A8 = 0;
    m.PIXELFORMAT_ASTC_4x4 = 28;
    m.PIXELFORMAT_ATC_RGB = 29;
    m.PIXELFORMAT_ATC_RGBA = 30;
    m.PIXELFORMAT_DEPTH = 16;
    m.PIXELFORMAT_DEPTHSTENCIL = 17;
    m.PIXELFORMAT_DXT1 = 8;
    m.PIXELFORMAT_DXT3 = 9;
    m.PIXELFORMAT_DXT5 = 10;
    m.PIXELFORMAT_ETC1 = 21;
    m.PIXELFORMAT_ETC2_RGB = 22;
    m.PIXELFORMAT_ETC2_RGBA = 23;
    m.PIXELFORMAT_L8 = 1;
    m.PIXELFORMAT_L8_A8 = 2;
    m.PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;
    m.PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;
    m.PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;
    m.PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;
    m.PIXELFORMAT_R32F = 15;
    m.PIXELFORMAT_R4_G4_B4_A4 = 5;
    m.PIXELFORMAT_R5_G5_B5_A1 = 4;
    m.PIXELFORMAT_R5_G6_B5 = 3;
    m.PIXELFORMAT_R8_G8_B8 = 6;
    m.PIXELFORMAT_R8_G8_B8_A8 = 7;
    m.PIXELFORMAT_RGB16F = 11;
    m.PIXELFORMAT_RGB32F = 13;
    m.PIXELFORMAT_RGBA16F = 12;
    m.PIXELFORMAT_RGBA32F = 14;
    m.PIXELFORMAT_SRGB = 19;
    m.PIXELFORMAT_SRGBA = 20;
    m.PRIMITIVE_LINELOOP = 2;
    m.PRIMITIVE_LINES = 1;
    m.PRIMITIVE_LINESTRIP = 3;
    m.PRIMITIVE_POINTS = 0;
    m.PRIMITIVE_TRIANGLES = 4;
    m.PRIMITIVE_TRIFAN = 6;
    m.PRIMITIVE_TRISTRIP = 5;
    m.PROJECTION_ORTHOGRAPHIC = 1;
    m.PROJECTION_PERSPECTIVE = 0;
    m.ParticleEmitter = $b;
    m.ParticleSystemComponent = ld;
    m.ParticleSystemComponentSystem = Ge;
    m.PhongMaterial = bq;
    m.Picker = pd;
    m.Plane = ci;
    m.PostEffect = wj;
    m.PostEffectPass = Ol;
    m.PostEffectQueue = Ug;
    m.ProgramLibrary = Jb;
    m.Quat = Y;
    m.RENDERSTYLE_POINTS = 2;
    m.RENDERSTYLE_SOLID = 0;
    m.RENDERSTYLE_WIREFRAME = 1;
    m.RESOLUTION_AUTO = "AUTO";
    m.RESOLUTION_FIXED = tj;
    m.RIGIDBODY_ACTIVE_TAG = 1;
    m.RIGIDBODY_CF_KINEMATIC_OBJECT = 2;
    m.RIGIDBODY_CF_NORESPONSE_OBJECT = 4;
    m.RIGIDBODY_CF_STATIC_OBJECT = 1;
    m.RIGIDBODY_DISABLE_DEACTIVATION = 4;
    m.RIGIDBODY_DISABLE_SIMULATION = 5;
    m.RIGIDBODY_ISLAND_SLEEPING = 2;
    m.RIGIDBODY_TYPE_DYNAMIC = "dynamic";
    m.RIGIDBODY_TYPE_KINEMATIC = "kinematic";
    m.RIGIDBODY_TYPE_STATIC = gq;
    m.RIGIDBODY_WANTS_DEACTIVATION = 3;
    m.Ray = bd;
    m.RaycastResult = rj;
    m.RenderTarget = ra;
    m.ResourceHandler = Jl;
    m.ResourceLoader = Mi;
    m.RigidBodyComponent = hc;
    m.RigidBodyComponentSystem = Ud;
    m.SCALEMODE_BLEND = "blend";
    m.SCALEMODE_NONE = Vd;
    m.SCROLLBAR_VISIBILITY_SHOW_ALWAYS = 0;
    m.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = 1;
    m.SCROLL_MODE_BOUNCE = 1;
    m.SCROLL_MODE_CLAMP = 0;
    m.SCROLL_MODE_INFINITE = 2;
    m.SEMANTIC_ATTR = "ATTR";
    m.SEMANTIC_ATTR0 = "ATTR0";
    m.SEMANTIC_ATTR1 = "ATTR1";
    m.SEMANTIC_ATTR10 = "ATTR10";
    m.SEMANTIC_ATTR11 = "ATTR11";
    m.SEMANTIC_ATTR12 = "ATTR12";
    m.SEMANTIC_ATTR13 = "ATTR13";
    m.SEMANTIC_ATTR14 = "ATTR14";
    m.SEMANTIC_ATTR15 = "ATTR15";
    m.SEMANTIC_ATTR2 = "ATTR2";
    m.SEMANTIC_ATTR3 = "ATTR3";
    m.SEMANTIC_ATTR4 = "ATTR4";
    m.SEMANTIC_ATTR5 = "ATTR5";
    m.SEMANTIC_ATTR6 = "ATTR6";
    m.SEMANTIC_ATTR7 = "ATTR7";
    m.SEMANTIC_ATTR8 = "ATTR8";
    m.SEMANTIC_ATTR9 = "ATTR9";
    m.SEMANTIC_BLENDINDICES = "BLENDINDICES";
    m.SEMANTIC_BLENDWEIGHT = "BLENDWEIGHT";
    m.SEMANTIC_COLOR = "COLOR";
    m.SEMANTIC_NORMAL = "NORMAL";
    m.SEMANTIC_POSITION = "POSITION";
    m.SEMANTIC_TANGENT = "TANGENT";
    m.SEMANTIC_TEXCOORD = "TEXCOORD";
    m.SEMANTIC_TEXCOORD0 = "TEXCOORD0";
    m.SEMANTIC_TEXCOORD1 = "TEXCOORD1";
    m.SEMANTIC_TEXCOORD2 = "TEXCOORD2";
    m.SEMANTIC_TEXCOORD3 = "TEXCOORD3";
    m.SEMANTIC_TEXCOORD4 = "TEXCOORD4";
    m.SEMANTIC_TEXCOORD5 = "TEXCOORD5";
    m.SEMANTIC_TEXCOORD6 = "TEXCOORD6";
    m.SEMANTIC_TEXCOORD7 = "TEXCOORD7";
    m.SHADERDEF_DIRLM = 128;
    m.SHADERDEF_INSTANCING = 32;
    m.SHADERDEF_LM = 64;
    m.SHADERDEF_MORPH_NORMAL = 2048;
    m.SHADERDEF_MORPH_POSITION = 1024;
    m.SHADERDEF_MORPH_TEXTURE_BASED = 4096;
    m.SHADERDEF_NOSHADOW = 1;
    m.SHADERDEF_SCREENSPACE = 256;
    m.SHADERDEF_SKIN = 2;
    m.SHADERDEF_TANGENTS = 512;
    m.SHADERDEF_UV0 = 4;
    m.SHADERDEF_UV1 = 8;
    m.SHADERDEF_VCOLOR = 16;
    m.SHADERTAG_MATERIAL = 1;
    m.SHADER_DEPTH = 2;
    m.SHADER_FORWARD = 0;
    m.SHADER_FORWARDHDR = 1;
    m.SHADER_PICK = 18;
    m.SHADER_SHADOW = 3;
    m.SHADOWUPDATE_NONE = 0;
    m.SHADOWUPDATE_REALTIME = 2;
    m.SHADOWUPDATE_THISFRAME = 1;
    m.SHADOW_DEPTH = 0;
    m.SHADOW_PCF3 = 0;
    m.SHADOW_PCF5 = 4;
    m.SHADOW_VSM16 = 2;
    m.SHADOW_VSM32 = 3;
    m.SHADOW_VSM8 = 1;
    m.SORTKEY_DEPTH = 1;
    m.SORTKEY_FORWARD = 0;
    m.SORTMODE_BACK2FRONT = 3;
    m.SORTMODE_CUSTOM = 5;
    m.SORTMODE_FRONT2BACK = 4;
    m.SORTMODE_MANUAL = 1;
    m.SORTMODE_MATERIALMESH = 2;
    m.SORTMODE_NONE = 0;
    m.SPECOCC_AO = 1;
    m.SPECOCC_GLOSSDEPENDENT = 2;
    m.SPECOCC_NONE = 0;
    m.SPECULAR_BLINN = 1;
    m.SPECULAR_PHONG = 0;
    m.SPRITETYPE_ANIMATED = "animated";
    m.SPRITETYPE_SIMPLE = "simple";
    m.SPRITE_RENDERMODE_SIMPLE = 0;
    m.SPRITE_RENDERMODE_SLICED = 1;
    m.SPRITE_RENDERMODE_TILED = 2;
    m.STENCILOP_DECREMENT = 5;
    m.STENCILOP_DECREMENTWRAP = 6;
    m.STENCILOP_INCREMENT = 3;
    m.STENCILOP_INCREMENTWRAP = 4;
    m.STENCILOP_INVERT = 7;
    m.STENCILOP_KEEP = 0;
    m.STENCILOP_REPLACE = 2;
    m.STENCILOP_ZERO = 1;
    m.Scene = sa;
    m.SceneHandler = Ni;
    m.SceneRegistry = kc;
    m.SceneRegistryItem = Cl;
    m.SceneSettingsHandler = Oi;
    m.ScopeId = Zg;
    m.ScopeSpace = $g;
    m.ScreenComponent = Hb;
    m.ScreenComponentSystem = Ie;
    m.ScriptAttributes = Wd;
    m.ScriptComponent = Xa;
    m.ScriptComponentSystem = Je;
    m.ScriptHandler = tb;
    m.ScriptLegacyComponent = Xd;
    m.ScriptLegacyComponentSystem = Ne;
    m.ScriptRegistry = fc;
    m.ScriptType = db;
    m.ScrollViewComponent = md;
    m.ScrollViewComponentSystem = Oe;
    m.ScrollbarComponent = Yd;
    m.ScrollbarComponentSystem = Ke;
    m.Shader = re;
    m.ShaderHandler = Pi;
    m.SingleContactResult = ul;
    m.Skeleton = Ta;
    m.Skin = Hg;
    m.SkinInstance = Hc;
    m.SortedLoopArray = ic;
    m.Sound = Kg;
    m.SoundComponent = jc;
    m.SoundComponentSystem = od;
    m.SoundManager = ec;
    m.SoundSlot = Qa;
    m.Sprite = Sa;
    m.SpriteAnimationClip = vb;
    m.SpriteComponent = Ba;
    m.SpriteComponentSystem = Zd;
    m.SpriteHandler = Qi;
    m.StandardMaterial = la;
    m.StencilParameters = Rd;
    m.TEXHINT_ASSET = 2;
    m.TEXHINT_LIGHTMAP = 3;
    m.TEXHINT_NONE = 0;
    m.TEXHINT_SHADOWMAP = 1;
    m.TEXTURELOCK_READ = 1;
    m.TEXTURELOCK_WRITE = 2;
    m.TEXTURETYPE_DEFAULT = "default";
    m.TEXTURETYPE_RGBE = "rgbe";
    m.TEXTURETYPE_RGBM = "rgbm";
    m.TEXTURETYPE_SWIZZLEGGGR = "swizzleGGGR";
    m.TONEMAP_ACES = 3;
    m.TONEMAP_ACES2 = 4;
    m.TONEMAP_FILMIC = 1;
    m.TONEMAP_HEJL = 2;
    m.TONEMAP_LINEAR = 0;
    m.TYPE_FLOAT32 = 6;
    m.TYPE_INT16 = 2;
    m.TYPE_INT32 = 4;
    m.TYPE_INT8 = 0;
    m.TYPE_UINT16 = 3;
    m.TYPE_UINT32 = 5;
    m.TYPE_UINT8 = 1;
    m.Tags = ad;
    m.Template = Og;
    m.TemplateHandler = Ti;
    m.TemplateUtils = Yc;
    m.TextElement = na;
    m.TextHandler = Ui;
    m.Texture = V;
    m.TextureAtlas = xc;
    m.TextureAtlasHandler = Vi;
    m.TextureHandler = Pg;
    m.TextureParser = al;
    m.Timer = $h;
    m.Touch = gh;
    m.TouchDevice = Se;
    m.TouchEvent = ae;
    m.TransformFeedback = Kf;
    m.UNIFORMTYPE_BOOL = 0;
    m.UNIFORMTYPE_BVEC2 = 9;
    m.UNIFORMTYPE_BVEC3 = 10;
    m.UNIFORMTYPE_BVEC4 = 11;
    m.UNIFORMTYPE_FLOAT = 2;
    m.UNIFORMTYPE_FLOATARRAY = 17;
    m.UNIFORMTYPE_INT = 1;
    m.UNIFORMTYPE_IVEC2 = 6;
    m.UNIFORMTYPE_IVEC3 = 7;
    m.UNIFORMTYPE_IVEC4 = 8;
    m.UNIFORMTYPE_MAT2 = 12;
    m.UNIFORMTYPE_MAT3 = 13;
    m.UNIFORMTYPE_MAT4 = 14;
    m.UNIFORMTYPE_TEXTURE2D = 15;
    m.UNIFORMTYPE_TEXTURE2D_SHADOW = 18;
    m.UNIFORMTYPE_TEXTURE3D = 20;
    m.UNIFORMTYPE_TEXTURECUBE = 16;
    m.UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;
    m.UNIFORMTYPE_VEC2 = 3;
    m.UNIFORMTYPE_VEC2ARRAY = 21;
    m.UNIFORMTYPE_VEC3 = 4;
    m.UNIFORMTYPE_VEC3ARRAY = 22;
    m.UNIFORMTYPE_VEC4 = 5;
    m.UNIFORMTYPE_VEC4ARRAY = 23;
    m.URI = qg;
    m.UnsupportedBrowserError = Gj;
    m.VIEW_CENTER = 0;
    m.VIEW_LEFT = 1;
    m.VIEW_RIGHT = 2;
    m.Vec2 = P;
    m.Vec3 = z;
    m.Vec4 = X;
    m.VertexBuffer = ab;
    m.VertexFormat = Na;
    m.VertexIterator = Pb;
    m.VrDisplay = Md;
    m.VrManager = gd;
    m.XRHAND_LEFT = "left";
    m.XRHAND_NONE = "none";
    m.XRHAND_RIGHT = "right";
    m.XRSPACE_BOUNDEDFLOOR = "bounded-floor";
    m.XRSPACE_LOCAL = "local";
    m.XRSPACE_LOCALFLOOR = "local-floor";
    m.XRSPACE_UNBOUNDED = "unbounded";
    m.XRSPACE_VIEWER = "viewer";
    m.XRTARGETRAY_GAZE = "gaze";
    m.XRTARGETRAY_POINTER = "tracked-pointer";
    m.XRTARGETRAY_SCREEN = "screen";
    m.XRTRACKABLE_MESH = "mesh";
    m.XRTRACKABLE_PLANE = "plane";
    m.XRTRACKABLE_POINT = "point";
    m.XRTYPE_AR = Nd;
    m.XRTYPE_INLINE = cl;
    m.XRTYPE_VR = gj;
    m.XrHitTest = Sb;
    m.XrHitTestSource = Jc;
    m.XrInput = Fb;
    m.XrInputSource = ta;
    m.XrLightEstimation = hb;
    m.XrManager = Pa;
    m.ZoneComponent = nd;
    m.ZoneComponentSystem = Qe;
    m.anim = dq;
    m.apps = {};
    m.asset = {
        ASSET_ANIMATION: "animation",
        ASSET_AUDIO: "audio",
        ASSET_IMAGE: "image",
        ASSET_JSON: "json",
        ASSET_MODEL: "model",
        ASSET_MATERIAL: "material",
        ASSET_TEXT: "text",
        ASSET_TEXTURE: "texture",
        ASSET_CUBEMAP: "cubemap",
        ASSET_SCRIPT: "script"
    };
    m.audio = eq;
    m.basisDownload = $i;
    m.basisDownloadFromConfig = Zk;
    m.basisInitialize = Yi;
    m.basisSetDownloadConfig = function(a, b, c) {
        Ff = {
            glueUrl: a,
            wasmUrl: b,
            fallbackUrl: c
        }
    }
    ;
    m.basisTargetFormat = Wi;
    m.basisTranscode = $k;
    m.calculateNormals = Mk;
    m.calculateTangents = Nk;
    m.common = {};
    m.config = {};
    m.createBox = Eg;
    m.createCapsule = ni;
    m.createCone = oi;
    m.createCylinder = mi;
    m.createMesh = Qb;
    m.createPlane = qi;
    m.createScript = Ib;
    m.createSphere = pi;
    m.createStyle = function(a) {
        var b = document.createElement("style");
        b.type = "text/css";
        b.styleSheet ? b.styleSheet.cssText = a : b.appendChild(document.createTextNode(a));
        return b
    }
    ;
    m.createTorus = Ok;
    m.createURI = function(a) {
        var b = "";
        if ((a.authority || a.scheme) && (a.host || a.hostpath))
            throw Error("Can't have 'scheme' or 'authority' and 'host' or 'hostpath' option");
        if (a.host && a.hostpath)
            throw Error("Can't have 'host' and 'hostpath' option");
        if (a.path && a.hostpath)
            throw Error("Can't have 'path' and 'hostpath' option");
        a.scheme && (b += a.scheme + ":");
        a.authority && (b += "//" + a.authority);
        a.host && (b += a.host);
        a.path && (b += a.path);
        a.hostpath && (b += a.hostpath);
        a.query && (b += "?" + a.query);
        a.fragment && (b += "#" + a.fragment);
        return b
    }
    ;
    m.data = {};
    m.debug = Zo;
    m.drawFullscreenQuad = Il;
    m.drawQuadWithShader = La;
    m.drawTexture = function(a, b, c, d, e, f, g) {
        d = d || a.getCopyShader();
        a.constantTexSource.setValue(b);
        La(a, c, d, e, f, g)
    }
    ;
    m.events = Of;
    m.extend = Gc;
    m.fw = hq;
    m.getTouchTargetCoords = Cj;
    m.gfx = $p;
    m.guid = Ql;
    m.http = wa;
    m.inherits = function(a, b) {
        var c = function() {}
          , d = function(e, f, g, k, h, l, n, p) {
            b.call(this, e, f, g, k, h, l, n, p);
            a.call(this, e, f, g, k, h, l, n, p)
        };
        d._super = b.prototype;
        c.prototype = b.prototype;
        d.prototype = new c;
        return d
    }
    ;
    m.input = fq;
    m.isDefined = Xh;
    m.log = Wh;
    m.makeArray = function(a) {
        return Array.prototype.slice.call(a)
    }
    ;
    m.math = N;
    m.now = Lb;
    m.path = ca;
    m.platform = Ca;
    m.posteffect = aq;
    m.prefilterCubemap = function(a) {
        var b = a.device
          , c = a.sourceCubemap
          , d = a.method
          , e = a.samples
          , f = a.cpuSync;
        if (f && !c._levels[0])
            console.error("ERROR: prefilter: cubemap must have _levels");
        else {
            var g = c.type
              , k = "rgbm" === g
              , h = Wa(b, F.fullscreenQuadVS, F.rgbmPS + F.prefilterCubemapPS.replace(/\$METHOD/g, 0 === d ? "cos" : "phong").replace(/\$NUMSAMPLES/g, e).replace(/\$textureCube/g, k ? "textureCubeRGBM" : "textureCube"), "prefilter" + d + e + k)
              , l = Wa(b, F.fullscreenQuadVS, F.outputCubemapPS, "outputCubemap")
              , n = b.scope.resolve("source")
              , p = b.scope.resolve("params")
              , q = new X
              , r = c.width;
            e = c.format;
            var t = [[], a.filteredFixed, a.filteredRgbm, a.filteredFixedRgbm], u = 0 === d ? [.9, .85, .7, .4, .25, .15, .1] : [512, 128, 32, 8, 2, 1, 1], x = [64, 32, 16, 8, 4, 2, 1], v;
            var w = !1;
            f && (w = c._levels[0][0]instanceof HTMLImageElement);
            if ((6 === e || w) && f) {
                e = 7;
                var y = new V(b,{
                    cubemap: !0,
                    type: g,
                    format: e,
                    width: r,
                    height: r,
                    mipmaps: !1
                });
                y.name = "prefiltered-cube";
                for (v = 0; 6 > v; v++) {
                    var A = new ra(b,y,{
                        face: v,
                        depth: !1
                    });
                    q.x = v;
                    q.y = 0;
                    n.setValue(c);
                    p.setValue(q.data);
                    La(b, A, l);
                    ah(b, A, v)
                }
                c = y
            }
            if (128 < r) {
                var B = Math.round(Math.log2(r)) - Math.round(Math.log2(128));
                for (w = 0; w < B; w++) {
                    r = .5 * c.width;
                    var E = 0 === d ? 1 : Math.pow(2, Math.round(Math.log2(u[0]) + 2 * (B - w)));
                    y = new V(b,{
                        cubemap: !0,
                        type: g,
                        format: e,
                        width: r,
                        height: r,
                        mipmaps: !1
                    });
                    y.name = "prefiltered-cube";
                    for (v = 0; 6 > v; v++)
                        A = new ra(b,y,{
                            face: v,
                            depth: !1
                        }),
                        q.x = v,
                        q.y = E,
                        q.z = r,
                        q.w = k ? 3 : 0,
                        n.setValue(c),
                        p.setValue(q.data),
                        La(b, A, l),
                        w === B - 1 && f && ah(b, A, v);
                    c = y
                }
            }
            a.sourceCubemap = c;
            y = null;
            if (!k && a.filteredFixedRgbm)
                for (y = new V(b,{
                    cubemap: !0,
                    type: "rgbm",
                    format: 7,
                    width: r,
                    height: r,
                    mipmaps: !1
                }),
                y.name = "prefiltered-cube",
                v = 0; 6 > v; v++)
                    A = new ra(b,y,{
                        face: v,
                        depth: !1
                    }),
                    q.x = v,
                    q.w = 2,
                    n.setValue(c),
                    p.setValue(q.data),
                    La(b, A, l),
                    ah(b, A, v);
            r = 0 === d ? 1 : 2048;
            A = 0 === d ? 0 : -1;
            t[A] = [];
            for (w = 0; 7 > w; w++)
                for (l = A; l < t.length; l++)
                    null != t[l] && (t[l][w] = new V(b,{
                        cubemap: !0,
                        type: 2 > l ? g : "rgbm",
                        format: 2 > l ? e : 7,
                        fixCubemapSeams: 1 === l || 3 === l,
                        width: x[w],
                        height: x[w],
                        mipmaps: !1
                    }),
                    t[l][w].name = "prefiltered-cube");
            for (l = A; l < t.length; l++)
                if (null != t[l])
                    if (1 < l && k)
                        t[l] = t[l - 2];
                    else
                        for (w = 0; 7 > w; w++)
                            for (v = 0; 6 > v; v++)
                                A = new ra(b,t[l][w],{
                                    face: v,
                                    depth: !1
                                }),
                                q.x = v,
                                q.y = 0 > l ? r : u[w],
                                q.z = x[w],
                                q.w = k ? 3 : l,
                                n.setValue(0 === w ? c : 0 === d ? t[0][w - 1] : t[-1][w - 1]),
                                p.setValue(q.data),
                                La(b, A, h),
                                f && ah(b, A, v);
            a.filtered = t[0];
            if (f && a.singleFilteredFixed) {
                c = [c].concat(a.filteredFixed);
                g = new V(b,{
                    cubemap: !0,
                    type: g,
                    fixCubemapSeams: !0,
                    format: e,
                    width: 128,
                    height: 128,
                    addressU: 1,
                    addressV: 1
                });
                g.name = "prefiltered-cube";
                for (w = 0; w < c.length; w++)
                    g._levels[w] = c[w]._levels[0];
                g.upload();
                g._prefilteredMips = !0;
                a.singleFilteredFixed = g
            }
            if (f && a.singleFilteredFixedRgbm && a.filteredFixedRgbm) {
                c = [y].concat(a.filteredFixedRgbm);
                g = new V(b,{
                    cubemap: !0,
                    type: "rgbm",
                    fixCubemapSeams: !0,
                    format: 7,
                    width: 128,
                    height: 128,
                    addressU: 1,
                    addressV: 1
                });
                g.name = "prefiltered-cube";
                for (w = 0; w < c.length; w++)
                    g._levels[w] = c[w]._levels[0];
                g.upload();
                g._prefilteredMips = !0;
                a.singleFilteredFixedRgbm = g
            }
        }
    }
    ;
    m.programlib = mh;
    m.registerScript = zl;
    m.reprojectTexture = function(a, b, c, d) {
        var e = "decode" + jn(b)
          , f = "encode" + jn(c)
          , g = b.cubemap ? "sampleCubemap" : "sampleEquirect"
          , k = c.cubemap ? "getDirectionCubemap" : "getDirectionEquirect";
        e = Wa(a, F.fullscreenQuadVS, "#define DECODE_FUNC " + e + "\n#define ENCODE_FUNC " + f + "\n#define SOURCE_FUNC " + g + "\n#define TARGET_FUNC " + k + "\n#define NUM_SAMPLES 1024\n\n" + F.reprojectPS, "reproject" + e + f + g + k, null, a.webgl2 ? "" : "#extension GL_OES_standard_derivatives: enable\n");
        a.scope.resolve(b.cubemap ? "sourceCube" : "sourceTex").setValue(b);
        b = a.scope.resolve("params");
        f = new X;
        f.y = void 0 !== d ? d : 1;
        f.z = void 0 !== d ? 1 : 0;
        for (d = 0; d < (c.cubemap ? 6 : 1); d++)
            g = new ra(a,c,{
                face: d,
                depth: !1
            }),
            f.x = d,
            b.setValue(f.data),
            La(a, g, e)
    }
    ;
    m.revision = "3317bcf";
    m.scene = cq;
    m.script = ub;
    m.semanticToLocation = Jj;
    m.shFromCubemap = Gl;
    m.shaderChunks = F;
    m.shape = Zp;
    m.string = vc;
    m.time = Yp;
    m.type = Zc;
    m.typedArrayIndexFormats = Ul;
    m.typedArrayIndexFormatsByteSize = [1, 2, 4];
    m.typedArrayToType = {
        Int8Array: 0,
        Uint8Array: 1,
        Int16Array: 2,
        Uint16Array: 3,
        Int32Array: 4,
        Uint32Array: 5,
        Float32Array: 6
    };
    m.typedArrayTypes = Dd;
    m.typedArrayTypesByteSize = qf;
    m.version = "1.35.1";
    Object.defineProperty(m, "__esModule", {
        value: !0
    })
});
